"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/big.js";
exports.ids = ["vendor-chunks/big.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/big.js/big.mjs":
/*!*************************************!*\
  !*** ./node_modules/big.js/big.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Big: () => (/* binding */ Big),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *  big.js v6.2.2\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2024 Michael Mclaughlin\r\n *  https://github.com/MikeMcl/big.js/LICENCE.md\r\n */ /************************************** EDITABLE DEFAULTS *****************************************/ // The default values below must be integers within the stated ranges.\n/*\r\n   * The maximum number of decimal places (DP) of the results of operations involving division:\r\n   * div and sqrt, and pow with negative exponents.\r\n   */ var DP = 20, /*\r\n   * The rounding mode (RM) used when rounding to the above decimal places.\r\n   *\r\n   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n   *  3  Away from zero.                                  (ROUND_UP)\r\n   */ RM = 1, // The maximum value of DP and Big.DP.\nMAX_DP = 1E6, // The maximum magnitude of the exponent argument to the pow method.\nMAX_POWER = 1E6, /*\r\n   * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n   * (JavaScript numbers: -7)\r\n   * -1000000 is the minimum recommended exponent value of a Big.\r\n   */ NE = -7, /*\r\n   * The positive exponent (PE) at and above which toString returns exponential notation.\r\n   * (JavaScript numbers: 21)\r\n   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\r\n   */ PE = 21, /*\r\n   * When true, an error will be thrown if a primitive number is passed to the Big constructor,\r\n   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\r\n   * primitive number without a loss of precision.\r\n   */ STRICT = false, /**************************************************************************************************/ // Error messages.\nNAME = \"[big.js] \", INVALID = NAME + \"Invalid \", INVALID_DP = INVALID + \"decimal places\", INVALID_RM = INVALID + \"rounding mode\", DIV_BY_ZERO = NAME + \"Division by zero\", // The shared prototype object.\nP = {}, UNDEFINED = void 0, NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n/*\r\n * Create and return a Big constructor.\r\n */ function _Big_() {\n    /*\r\n   * The Big constructor and exported function.\r\n   * Create and return a new instance of a Big number object.\r\n   *\r\n   * n {number|string|Big} A numeric value.\r\n   */ function Big(n) {\n        var x = this;\n        // Enable constructor usage without new.\n        if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\n        // Duplicate.\n        if (n instanceof Big) {\n            x.s = n.s;\n            x.e = n.e;\n            x.c = n.c.slice();\n        } else {\n            if (typeof n !== \"string\") {\n                if (Big.strict === true && typeof n !== \"bigint\") {\n                    throw TypeError(INVALID + \"value\");\n                }\n                // Minus zero?\n                n = n === 0 && 1 / n < 0 ? \"-0\" : String(n);\n            }\n            parse(x, n);\n        }\n        // Retain a reference to this Big constructor.\n        // Shadow Big.prototype.constructor which points to Object.\n        x.constructor = Big;\n    }\n    Big.prototype = P;\n    Big.DP = DP;\n    Big.RM = RM;\n    Big.NE = NE;\n    Big.PE = PE;\n    Big.strict = STRICT;\n    Big.roundDown = 0;\n    Big.roundHalfUp = 1;\n    Big.roundHalfEven = 2;\n    Big.roundUp = 3;\n    return Big;\n}\n/*\r\n * Parse the number or string value passed to a Big constructor.\r\n *\r\n * x {Big} A Big number instance.\r\n * n {number|string} A numeric value.\r\n */ function parse(x, n) {\n    var e, i, nl;\n    if (!NUMERIC.test(n)) {\n        throw Error(INVALID + \"number\");\n    }\n    // Determine sign.\n    x.s = n.charAt(0) == \"-\" ? (n = n.slice(1), -1) : 1;\n    // Decimal point?\n    if ((e = n.indexOf(\".\")) > -1) n = n.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = n.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +n.slice(i + 1);\n        n = n.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = n.length;\n    }\n    nl = n.length;\n    // Determine leading zeros.\n    for(i = 0; i < nl && n.charAt(i) == \"0\";)++i;\n    if (i == nl) {\n        // Zero.\n        x.c = [\n            x.e = 0\n        ];\n    } else {\n        // Determine trailing zeros.\n        for(; nl > 0 && n.charAt(--nl) == \"0\";);\n        x.e = e - i - 1;\n        x.c = [];\n        // Convert string to array of digits without leading/trailing zeros.\n        for(e = 0; i <= nl;)x.c[e++] = +n.charAt(i++);\n    }\n    return x;\n}\n/*\r\n * Round Big x to a maximum of sd significant digits using rounding mode rm.\r\n *\r\n * x {Big} The Big to round.\r\n * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\r\n * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n * [more] {boolean} Whether the result of division was truncated.\r\n */ function round(x, sd, rm, more) {\n    var xc = x.c;\n    if (rm === UNDEFINED) rm = x.constructor.RM;\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\n        throw Error(INVALID_RM);\n    }\n    if (sd < 1) {\n        more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));\n        xc.length = 1;\n        if (more) {\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n            x.e = x.e - sd + 1;\n            xc[0] = 1;\n        } else {\n            // Zero.\n            xc[0] = x.e = 0;\n        }\n    } else if (sd < xc.length) {\n        // xc[sd] is the digit after the digit that may be rounded up.\n        more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);\n        // Remove any digits after the required precision.\n        xc.length = sd;\n        // Round up?\n        if (more) {\n            // Rounding up may mean the previous digit has to be rounded up.\n            for(; ++xc[--sd] > 9;){\n                xc[sd] = 0;\n                if (sd === 0) {\n                    ++x.e;\n                    xc.unshift(1);\n                    break;\n                }\n            }\n        }\n        // Remove trailing zeros.\n        for(sd = xc.length; !xc[--sd];)xc.pop();\n    }\n    return x;\n}\n/*\r\n * Return a string representing the value of Big x in normal or exponential notation.\r\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n */ function stringify(x, doExponential, isNonzero) {\n    var e = x.e, s = x.c.join(\"\"), n = s.length;\n    // Exponential notation?\n    if (doExponential) {\n        s = s.charAt(0) + (n > 1 ? \".\" + s.slice(1) : \"\") + (e < 0 ? \"e\" : \"e+\") + e;\n    // Normal notation.\n    } else if (e < 0) {\n        for(; ++e;)s = \"0\" + s;\n        s = \"0.\" + s;\n    } else if (e > 0) {\n        if (++e > n) {\n            for(e -= n; e--;)s += \"0\";\n        } else if (e < n) {\n            s = s.slice(0, e) + \".\" + s.slice(e);\n        }\n    } else if (n > 1) {\n        s = s.charAt(0) + \".\" + s.slice(1);\n    }\n    return x.s < 0 && isNonzero ? \"-\" + s : s;\n}\n// Prototype/instance methods\n/*\r\n * Return a new Big whose value is the absolute value of this Big.\r\n */ P.abs = function() {\n    var x = new this.constructor(this);\n    x.s = 1;\n    return x;\n};\n/*\r\n * Return 1 if the value of this Big is greater than the value of Big y,\r\n *       -1 if the value of this Big is less than the value of Big y, or\r\n *        0 if they have the same value.\r\n */ P.cmp = function(y) {\n    var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\n    // Signs differ?\n    if (i != j) return i;\n    isneg = i < 0;\n    // Compare exponents.\n    if (k != l) return k > l ^ isneg ? 1 : -1;\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n    // Compare digit by digit.\n    for(i = -1; ++i < j;){\n        if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n    }\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.div = function(y) {\n    var x = this, Big = x.constructor, a = x.c, b = (y = new Big(y)).c, k = x.s == y.s ? 1 : -1, dp = Big.DP;\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n    }\n    // Divisor is zero?\n    if (!b[0]) {\n        throw Error(DIV_BY_ZERO);\n    }\n    // Dividend is 0? Return +-0.\n    if (!a[0]) {\n        y.s = k;\n        y.c = [\n            y.e = 0\n        ];\n        return y;\n    }\n    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1; // precision of the result\n    q.s = k;\n    k = p < 0 ? 0 : p;\n    // Create version of divisor with leading zero.\n    bz.unshift(0);\n    // Add zeros to make remainder as long as divisor.\n    for(; rl++ < bl;)r.push(0);\n    do {\n        // n is how many times the divisor goes into current remainder.\n        for(n = 0; n < 10; n++){\n            // Compare divisor and remainder.\n            if (bl != (rl = r.length)) {\n                cmp = bl > rl ? 1 : -1;\n            } else {\n                for(ri = -1, cmp = 0; ++ri < bl;){\n                    if (b[ri] != r[ri]) {\n                        cmp = b[ri] > r[ri] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            // If divisor < remainder, subtract divisor from remainder.\n            if (cmp < 0) {\n                // Remainder can't be more than 1 digit longer than divisor.\n                // Equalise lengths using divisor with extra leading zero?\n                for(bt = rl == bl ? b : bz; rl;){\n                    if (r[--rl] < bt[rl]) {\n                        ri = rl;\n                        for(; ri && !r[--ri];)r[ri] = 9;\n                        --r[ri];\n                        r[rl] += 10;\n                    }\n                    r[rl] -= bt[rl];\n                }\n                for(; !r[0];)r.shift();\n            } else {\n                break;\n            }\n        }\n        // Add the digit n to the result array.\n        qc[qi++] = cmp ? n : ++n;\n        // Update the remainder.\n        if (r[0] && cmp) r[rl] = a[ai] || 0;\n        else r = [\n            a[ai]\n        ];\n    }while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if (!qc[0] && qi != 1) {\n        // There can't be more than one zero.\n        qc.shift();\n        q.e--;\n        p--;\n    }\n    // Round?\n    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\n    return q;\n};\n/*\r\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n */ P.eq = function(y) {\n    return this.cmp(y) === 0;\n};\n/*\r\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n * false.\r\n */ P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.gte = function(y) {\n    return this.cmp(y) > -1;\n};\n/*\r\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n */ P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n */ P.minus = P.sub = function(y) {\n    var i, j, t, xlty, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.plus(y);\n    }\n    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        if (yc[0]) {\n            y.s = -b;\n        } else if (xc[0]) {\n            y = new Big(x);\n        } else {\n            y.s = 1;\n        }\n        return y;\n    }\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\n    if (a = xe - ye) {\n        if (xlty = a < 0) {\n            a = -a;\n            t = xc;\n        } else {\n            ye = xe;\n            t = yc;\n        }\n        t.reverse();\n        for(b = a; b--;)t.push(0);\n        t.reverse();\n    } else {\n        // Exponents equal. Check digit by digit.\n        j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n        for(a = b = 0; b < j; b++){\n            if (xc[b] != yc[b]) {\n                xlty = xc[b] < yc[b];\n                break;\n            }\n        }\n    }\n    // x < y? Point xc to the array of the bigger number.\n    if (xlty) {\n        t = xc;\n        xc = yc;\n        yc = t;\n        y.s = -y.s;\n    }\n    /*\r\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n   * needs to start at yc.length.\r\n   */ if ((b = (j = yc.length) - (i = xc.length)) > 0) for(; b--;)xc[i++] = 0;\n    // Subtract yc from xc.\n    for(b = i; j > a;){\n        if (xc[--j] < yc[j]) {\n            for(i = j; i && !xc[--i];)xc[i] = 9;\n            --xc[i];\n            xc[j] += 10;\n        }\n        xc[j] -= yc[j];\n    }\n    // Remove trailing zeros.\n    for(; xc[--b] === 0;)xc.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xc[0] === 0;){\n        xc.shift();\n        --ye;\n    }\n    if (!xc[0]) {\n        // n - n = +0\n        y.s = 1;\n        // Result must be zero.\n        xc = [\n            ye = 0\n        ];\n    }\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n */ P.mod = function(y) {\n    var ygtx, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    if (!y.c[0]) {\n        throw Error(DIV_BY_ZERO);\n    }\n    x.s = y.s = 1;\n    ygtx = y.cmp(x) == 1;\n    x.s = a;\n    y.s = b;\n    if (ygtx) return new Big(x);\n    a = Big.DP;\n    b = Big.RM;\n    Big.DP = Big.RM = 0;\n    x = x.div(y);\n    Big.DP = a;\n    Big.RM = b;\n    return this.minus(x.times(y));\n};\n/*\r\n * Return a new Big whose value is the value of this Big negated.\r\n */ P.neg = function() {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return x;\n};\n/*\r\n * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n */ P.plus = P.add = function(y) {\n    var e, k, t, x = this, Big = x.constructor;\n    y = new Big(y);\n    // Signs differ?\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n    }\n    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        if (!yc[0]) {\n            if (xc[0]) {\n                y = new Big(x);\n            } else {\n                y.s = x.s;\n            }\n        }\n        return y;\n    }\n    xc = xc.slice();\n    // Prepend zeros to equalise exponents.\n    // Note: reverse faster than unshifts.\n    if (e = xe - ye) {\n        if (e > 0) {\n            ye = xe;\n            t = yc;\n        } else {\n            e = -e;\n            t = xc;\n        }\n        t.reverse();\n        for(; e--;)t.push(0);\n        t.reverse();\n    }\n    // Point xc to the longer array.\n    if (xc.length - yc.length < 0) {\n        t = yc;\n        yc = xc;\n        xc = t;\n    }\n    e = yc.length;\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n    for(k = 0; e; xc[e] %= 10)k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    if (k) {\n        xc.unshift(k);\n        ++ye;\n    }\n    // Remove trailing zeros.\n    for(e = xc.length; xc[--e] === 0;)xc.pop();\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a Big whose value is the value of this Big raised to the power n.\r\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n * mode Big.RM.\r\n *\r\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n */ P.pow = function(n) {\n    var x = this, one = new x.constructor(\"1\"), y = one, isneg = n < 0;\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\n        throw Error(INVALID + \"exponent\");\n    }\n    if (isneg) n = -n;\n    for(;;){\n        if (n & 1) y = y.times(x);\n        n >>= 1;\n        if (!n) break;\n        x = x.times(x);\n    }\n    return isneg ? one.div(y) : y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\r\n * significant digits using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.prec = function(sd, rm) {\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n        throw Error(INVALID + \"precision\");\n    }\n    return round(new this.constructor(this), sd, rm);\n};\n/*\r\n * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\r\n * using rounding mode rm, or Big.RM if rm is not specified.\r\n * If dp is negative, round to an integer which is a multiple of 10**-dp.\r\n * If dp is not specified, round to 0 decimal places.\r\n *\r\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.round = function(dp, rm) {\n    if (dp === UNDEFINED) dp = 0;\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n    }\n    return round(new this.constructor(this), dp + this.e + 1, rm);\n};\n/*\r\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.sqrt = function() {\n    var r, c, t, x = this, Big = x.constructor, s = x.s, e = x.e, half = new Big(\"0.5\");\n    // Zero?\n    if (!x.c[0]) return new Big(x);\n    // Negative?\n    if (s < 0) {\n        throw Error(NAME + \"No square root\");\n    }\n    // Estimate.\n    s = Math.sqrt(+stringify(x, true, true));\n    // Math.sqrt underflow/overflow?\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n    if (s === 0 || s === 1 / 0) {\n        c = x.c.join(\"\");\n        if (!(c.length + e & 1)) c += \"0\";\n        s = Math.sqrt(c);\n        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n        r = new Big((s == 1 / 0 ? \"5e\" : (s = s.toExponential()).slice(0, s.indexOf(\"e\") + 1)) + e);\n    } else {\n        r = new Big(s + \"\");\n    }\n    e = r.e + (Big.DP += 4);\n    // Newton-Raphson iteration.\n    do {\n        t = r;\n        r = half.times(t.plus(x.div(t)));\n    }while (t.c.slice(0, e).join(\"\") !== r.c.slice(0, e).join(\"\"));\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\n};\n/*\r\n * Return a new Big whose value is the value of this Big times the value of Big y.\r\n */ P.times = P.mul = function(y) {\n    var c, x = this, Big = x.constructor, xc = x.c, yc = (y = new Big(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;\n    // Determine sign of result.\n    y.s = x.s == y.s ? 1 : -1;\n    // Return signed 0 if either 0.\n    if (!xc[0] || !yc[0]) {\n        y.c = [\n            y.e = 0\n        ];\n        return y;\n    }\n    // Initialise exponent of result as x.e + y.e.\n    y.e = i + j;\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n    if (a < b) {\n        c = xc;\n        xc = yc;\n        yc = c;\n        j = a;\n        a = b;\n        b = j;\n    }\n    // Initialise coefficient array of result with zeros.\n    for(c = new Array(j = a + b); j--;)c[j] = 0;\n    // Multiply.\n    // i is initially xc.length.\n    for(i = b; i--;){\n        b = 0;\n        // a is yc.length.\n        for(j = a + i; j > i;){\n            // Current sum of products at this digit position, plus carry.\n            b = c[j] + yc[i] * xc[j - i - 1] + b;\n            c[j--] = b % 10;\n            // carry\n            b = b / 10 | 0;\n        }\n        c[j] = b;\n    }\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\n    if (b) ++y.e;\n    else c.shift();\n    // Remove trailing zeros.\n    for(i = c.length; !c[--i];)c.pop();\n    y.c = c;\n    return y;\n};\n/*\r\n * Return a string representing the value of this Big in exponential notation rounded to dp fixed\r\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.toExponential = function(dp, rm) {\n    var x = this, n = x.c[0];\n    if (dp !== UNDEFINED) {\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n            throw Error(INVALID_DP);\n        }\n        x = round(new x.constructor(x), ++dp, rm);\n        for(; x.c.length < dp;)x.c.push(0);\n    }\n    return stringify(x, true, !!n);\n};\n/*\r\n * Return a string representing the value of this Big in normal notation rounded to dp fixed\r\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n */ P.toFixed = function(dp, rm) {\n    var x = this, n = x.c[0];\n    if (dp !== UNDEFINED) {\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n            throw Error(INVALID_DP);\n        }\n        x = round(new x.constructor(x), dp + x.e + 1, rm);\n        // x.e may have changed if the value is rounded up.\n        for(dp = dp + x.e + 1; x.c.length < dp;)x.c.push(0);\n    }\n    return stringify(x, false, !!n);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Omit the sign for negative zero.\r\n */ P[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toJSON = P.toString = function() {\n    var x = this, Big = x.constructor;\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\n};\n/*\r\n * Return the value of this Big as a primitve number.\r\n */ P.toNumber = function() {\n    var n = +stringify(this, true, true);\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\n        throw Error(NAME + \"Imprecise conversion\");\n    }\n    return n;\n};\n/*\r\n * Return a string representing the value of this Big rounded to sd significant digits using\r\n * rounding mode rm, or Big.RM if rm is not specified.\r\n * Use exponential notation if sd is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.toPrecision = function(sd, rm) {\n    var x = this, Big = x.constructor, n = x.c[0];\n    if (sd !== UNDEFINED) {\n        if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n            throw Error(INVALID + \"precision\");\n        }\n        x = round(new Big(x), sd, rm);\n        for(; x.c.length < sd;)x.c.push(0);\n    }\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Include the sign for negative zero.\r\n */ P.valueOf = function() {\n    var x = this, Big = x.constructor;\n    if (Big.strict === true) {\n        throw Error(NAME + \"valueOf disallowed\");\n    }\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\n};\n// Export\nvar Big = _Big_();\n/// <reference types=\"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts\" />\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNETCxFQUFFc0csT0FBTyxHQUFHO0lBQ1YsSUFBSWhHLElBQUksSUFBSSxFQUNWRixNQUFNRSxFQUFFUyxXQUFXO0lBQ3JCLElBQUlYLElBQUlPLE1BQU0sS0FBSyxNQUFNO1FBQ3ZCLE1BQU1hLE1BQU03QixPQUFPO0lBQ3JCO0lBQ0EsT0FBTzJDLFVBQVVoQyxHQUFHQSxFQUFFRSxDQUFDLElBQUlKLElBQUlaLEVBQUUsSUFBSWMsRUFBRUUsQ0FBQyxJQUFJSixJQUFJWCxFQUFFLEVBQUU7QUFDdEQ7QUFHQSxTQUFTO0FBR0YsSUFBSVcsTUFBTUQsUUFBUTtBQUV6QiwwSEFBMEg7QUFDMUgsaUVBQWVDLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYmlnLmpzL2JpZy5tanM/ZWI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiAgYmlnLmpzIHY2LjIuMlxyXG4gKiAgQSBzbWFsbCwgZmFzdCwgZWFzeS10by11c2UgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBkZWNpbWFsIGFyaXRobWV0aWMuXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMjQgTWljaGFlbCBNY2xhdWdobGluXHJcbiAqICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvTElDRU5DRS5tZFxyXG4gKi9cclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRURJVEFCTEUgREVGQVVMVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIHN0YXRlZCByYW5nZXMuXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIChEUCkgb2YgdGhlIHJlc3VsdHMgb2Ygb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb246XHJcbiAgICogZGl2IGFuZCBzcXJ0LCBhbmQgcG93IHdpdGggbmVnYXRpdmUgZXhwb25lbnRzLlxyXG4gICAqL1xyXG52YXIgRFAgPSAyMCwgICAgICAgICAgLy8gMCB0byBNQVhfRFBcclxuXHJcbiAgLypcclxuICAgKiBUaGUgcm91bmRpbmcgbW9kZSAoUk0pIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICpcclxuICAgKiAgMCAgVG93YXJkcyB6ZXJvIChpLmUuIHRydW5jYXRlLCBubyByb3VuZGluZykuICAgICAgIChST1VORF9ET1dOKVxyXG4gICAqICAxICBUbyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHJvdW5kIHVwLiAgKFJPVU5EX0hBTEZfVVApXHJcbiAgICogIDIgIFRvIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG8gZXZlbi4gICAoUk9VTkRfSEFMRl9FVkVOKVxyXG4gICAqICAzICBBd2F5IGZyb20gemVyby4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFJPVU5EX1VQKVxyXG4gICAqL1xyXG4gIFJNID0gMSwgICAgICAgICAgICAgLy8gMCwgMSwgMiBvciAzXHJcblxyXG4gIC8vIFRoZSBtYXhpbXVtIHZhbHVlIG9mIERQIGFuZCBCaWcuRFAuXHJcbiAgTUFYX0RQID0gMUU2LCAgICAgICAvLyAwIHRvIDEwMDAwMDBcclxuXHJcbiAgLy8gVGhlIG1heGltdW0gbWFnbml0dWRlIG9mIHRoZSBleHBvbmVudCBhcmd1bWVudCB0byB0aGUgcG93IG1ldGhvZC5cclxuICBNQVhfUE9XRVIgPSAxRTYsICAgIC8vIDEgdG8gMTAwMDAwMFxyXG5cclxuICAvKlxyXG4gICAqIFRoZSBuZWdhdGl2ZSBleHBvbmVudCAoTkUpIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICogKEphdmFTY3JpcHQgbnVtYmVyczogLTcpXHJcbiAgICogLTEwMDAwMDAgaXMgdGhlIG1pbmltdW0gcmVjb21tZW5kZWQgZXhwb25lbnQgdmFsdWUgb2YgYSBCaWcuXHJcbiAgICovXHJcbiAgTkUgPSAtNywgICAgICAgICAgICAvLyAwIHRvIC0xMDAwMDAwXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIHBvc2l0aXZlIGV4cG9uZW50IChQRSkgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICogKEphdmFTY3JpcHQgbnVtYmVyczogMjEpXHJcbiAgICogMTAwMDAwMCBpcyB0aGUgbWF4aW11bSByZWNvbW1lbmRlZCBleHBvbmVudCB2YWx1ZSBvZiBhIEJpZywgYnV0IHRoaXMgbGltaXQgaXMgbm90IGVuZm9yY2VkLlxyXG4gICAqL1xyXG4gIFBFID0gMjEsICAgICAgICAgICAgLy8gMCB0byAxMDAwMDAwXHJcblxyXG4gIC8qXHJcbiAgICogV2hlbiB0cnVlLCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiBhIHByaW1pdGl2ZSBudW1iZXIgaXMgcGFzc2VkIHRvIHRoZSBCaWcgY29uc3RydWN0b3IsXHJcbiAgICogb3IgaWYgdmFsdWVPZiBpcyBjYWxsZWQsIG9yIGlmIHRvTnVtYmVyIGlzIGNhbGxlZCBvbiBhIEJpZyB3aGljaCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGFcclxuICAgKiBwcmltaXRpdmUgbnVtYmVyIHdpdGhvdXQgYSBsb3NzIG9mIHByZWNpc2lvbi5cclxuICAgKi9cclxuICBTVFJJQ1QgPSBmYWxzZSwgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuICAvLyBFcnJvciBtZXNzYWdlcy5cclxuICBOQU1FID0gJ1tiaWcuanNdICcsXHJcbiAgSU5WQUxJRCA9IE5BTUUgKyAnSW52YWxpZCAnLFxyXG4gIElOVkFMSURfRFAgPSBJTlZBTElEICsgJ2RlY2ltYWwgcGxhY2VzJyxcclxuICBJTlZBTElEX1JNID0gSU5WQUxJRCArICdyb3VuZGluZyBtb2RlJyxcclxuICBESVZfQllfWkVSTyA9IE5BTUUgKyAnRGl2aXNpb24gYnkgemVybycsXHJcblxyXG4gIC8vIFRoZSBzaGFyZWQgcHJvdG90eXBlIG9iamVjdC5cclxuICBQID0ge30sXHJcbiAgVU5ERUZJTkVEID0gdm9pZCAwLFxyXG4gIE5VTUVSSUMgPSAvXi0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaTtcclxuXHJcblxyXG4vKlxyXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZyBjb25zdHJ1Y3Rvci5cclxuICovXHJcbmZ1bmN0aW9uIF9CaWdfKCkge1xyXG5cclxuICAvKlxyXG4gICAqIFRoZSBCaWcgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnIG51bWJlciBvYmplY3QuXHJcbiAgICpcclxuICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ30gQSBudW1lcmljIHZhbHVlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEJpZyhuKSB7XHJcbiAgICB2YXIgeCA9IHRoaXM7XHJcblxyXG4gICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIHVzYWdlIHdpdGhvdXQgbmV3LlxyXG4gICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZykpIHJldHVybiBuID09PSBVTkRFRklORUQgPyBfQmlnXygpIDogbmV3IEJpZyhuKTtcclxuXHJcbiAgICAvLyBEdXBsaWNhdGUuXHJcbiAgICBpZiAobiBpbnN0YW5jZW9mIEJpZykge1xyXG4gICAgICB4LnMgPSBuLnM7XHJcbiAgICAgIHguZSA9IG4uZTtcclxuICAgICAgeC5jID0gbi5jLnNsaWNlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodHlwZW9mIG4gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKEJpZy5zdHJpY3QgPT09IHRydWUgJiYgdHlwZW9mIG4gIT09ICdiaWdpbnQnKSB7XHJcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoSU5WQUxJRCArICd2YWx1ZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTWludXMgemVybz9cclxuICAgICAgICBuID0gbiA9PT0gMCAmJiAxIC8gbiA8IDAgPyAnLTAnIDogU3RyaW5nKG4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwYXJzZSh4LCBuKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXRhaW4gYSByZWZlcmVuY2UgdG8gdGhpcyBCaWcgY29uc3RydWN0b3IuXHJcbiAgICAvLyBTaGFkb3cgQmlnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciB3aGljaCBwb2ludHMgdG8gT2JqZWN0LlxyXG4gICAgeC5jb25zdHJ1Y3RvciA9IEJpZztcclxuICB9XHJcblxyXG4gIEJpZy5wcm90b3R5cGUgPSBQO1xyXG4gIEJpZy5EUCA9IERQO1xyXG4gIEJpZy5STSA9IFJNO1xyXG4gIEJpZy5ORSA9IE5FO1xyXG4gIEJpZy5QRSA9IFBFO1xyXG4gIEJpZy5zdHJpY3QgPSBTVFJJQ1Q7XHJcbiAgQmlnLnJvdW5kRG93biA9IDA7XHJcbiAgQmlnLnJvdW5kSGFsZlVwID0gMTtcclxuICBCaWcucm91bmRIYWxmRXZlbiA9IDI7XHJcbiAgQmlnLnJvdW5kVXAgPSAzO1xyXG5cclxuICByZXR1cm4gQmlnO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUGFyc2UgdGhlIG51bWJlciBvciBzdHJpbmcgdmFsdWUgcGFzc2VkIHRvIGEgQmlnIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiB4IHtCaWd9IEEgQmlnIG51bWJlciBpbnN0YW5jZS5cclxuICogbiB7bnVtYmVyfHN0cmluZ30gQSBudW1lcmljIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2UoeCwgbikge1xyXG4gIHZhciBlLCBpLCBubDtcclxuXHJcbiAgaWYgKCFOVU1FUklDLnRlc3QobikpIHtcclxuICAgIHRocm93IEVycm9yKElOVkFMSUQgKyAnbnVtYmVyJyk7XHJcbiAgfVxyXG5cclxuICAvLyBEZXRlcm1pbmUgc2lnbi5cclxuICB4LnMgPSBuLmNoYXJBdCgwKSA9PSAnLScgPyAobiA9IG4uc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgaWYgKChlID0gbi5pbmRleE9mKCcuJykpID4gLTEpIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgaWYgKChpID0gbi5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICBlICs9ICtuLnNsaWNlKGkgKyAxKTtcclxuICAgIG4gPSBuLnN1YnN0cmluZygwLCBpKTtcclxuICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgLy8gSW50ZWdlci5cclxuICAgIGUgPSBuLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIG5sID0gbi5sZW5ndGg7XHJcblxyXG4gIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gIGZvciAoaSA9IDA7IGkgPCBubCAmJiBuLmNoYXJBdChpKSA9PSAnMCc7KSArK2k7XHJcblxyXG4gIGlmIChpID09IG5sKSB7XHJcblxyXG4gICAgLy8gWmVyby5cclxuICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyBubCA+IDAgJiYgbi5jaGFyQXQoLS1ubCkgPT0gJzAnOyk7XHJcbiAgICB4LmUgPSBlIC0gaSAtIDE7XHJcbiAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgd2l0aG91dCBsZWFkaW5nL3RyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChlID0gMDsgaSA8PSBubDspIHguY1tlKytdID0gK24uY2hhckF0KGkrKyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJvdW5kIEJpZyB4IHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS5cclxuICpcclxuICogeCB7QmlnfSBUaGUgQmlnIHRvIHJvdW5kLlxyXG4gKiBzZCB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICogcm0ge251bWJlcn0gUm91bmRpbmcgbW9kZTogMCAoZG93biksIDEgKGhhbGYtdXApLCAyIChoYWxmLWV2ZW4pIG9yIDMgKHVwKS5cclxuICogW21vcmVdIHtib29sZWFufSBXaGV0aGVyIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gd2FzIHRydW5jYXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgbW9yZSkge1xyXG4gIHZhciB4YyA9IHguYztcclxuXHJcbiAgaWYgKHJtID09PSBVTkRFRklORUQpIHJtID0geC5jb25zdHJ1Y3Rvci5STTtcclxuICBpZiAocm0gIT09IDAgJiYgcm0gIT09IDEgJiYgcm0gIT09IDIgJiYgcm0gIT09IDMpIHtcclxuICAgIHRocm93IEVycm9yKElOVkFMSURfUk0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKHNkIDwgMSkge1xyXG4gICAgbW9yZSA9XHJcbiAgICAgIHJtID09PSAzICYmIChtb3JlIHx8ICEheGNbMF0pIHx8IHNkID09PSAwICYmIChcclxuICAgICAgcm0gPT09IDEgJiYgeGNbMF0gPj0gNSB8fFxyXG4gICAgICBybSA9PT0gMiAmJiAoeGNbMF0gPiA1IHx8IHhjWzBdID09PSA1ICYmIChtb3JlIHx8IHhjWzFdICE9PSBVTkRFRklORUQpKVxyXG4gICAgKTtcclxuXHJcbiAgICB4Yy5sZW5ndGggPSAxO1xyXG5cclxuICAgIGlmIChtb3JlKSB7XHJcblxyXG4gICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICB4LmUgPSB4LmUgLSBzZCArIDE7XHJcbiAgICAgIHhjWzBdID0gMTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChzZCA8IHhjLmxlbmd0aCkge1xyXG5cclxuICAgIC8vIHhjW3NkXSBpcyB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICBtb3JlID1cclxuICAgICAgcm0gPT09IDEgJiYgeGNbc2RdID49IDUgfHxcclxuICAgICAgcm0gPT09IDIgJiYgKHhjW3NkXSA+IDUgfHwgeGNbc2RdID09PSA1ICYmXHJcbiAgICAgICAgKG1vcmUgfHwgeGNbc2QgKyAxXSAhPT0gVU5ERUZJTkVEIHx8IHhjW3NkIC0gMV0gJiAxKSkgfHxcclxuICAgICAgcm0gPT09IDMgJiYgKG1vcmUgfHwgISF4Y1swXSk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGFueSBkaWdpdHMgYWZ0ZXIgdGhlIHJlcXVpcmVkIHByZWNpc2lvbi5cclxuICAgIHhjLmxlbmd0aCA9IHNkO1xyXG5cclxuICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgaWYgKG1vcmUpIHtcclxuXHJcbiAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cC5cclxuICAgICAgZm9yICg7ICsreGNbLS1zZF0gPiA5Oykge1xyXG4gICAgICAgIHhjW3NkXSA9IDA7XHJcbiAgICAgICAgaWYgKHNkID09PSAwKSB7XHJcbiAgICAgICAgICArK3guZTtcclxuICAgICAgICAgIHhjLnVuc2hpZnQoMSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKHNkID0geGMubGVuZ3RoOyAheGNbLS1zZF07KSB4Yy5wb3AoKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnIHggaW4gbm9ybWFsIG9yIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gKiBIYW5kbGVzIFAudG9FeHBvbmVudGlhbCwgUC50b0ZpeGVkLCBQLnRvSlNPTiwgUC50b1ByZWNpc2lvbiwgUC50b1N0cmluZyBhbmQgUC52YWx1ZU9mLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5KHgsIGRvRXhwb25lbnRpYWwsIGlzTm9uemVybykge1xyXG4gIHZhciBlID0geC5lLFxyXG4gICAgcyA9IHguYy5qb2luKCcnKSxcclxuICAgIG4gPSBzLmxlbmd0aDtcclxuXHJcbiAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24/XHJcbiAgaWYgKGRvRXhwb25lbnRpYWwpIHtcclxuICAgIHMgPSBzLmNoYXJBdCgwKSArIChuID4gMSA/ICcuJyArIHMuc2xpY2UoMSkgOiAnJykgKyAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcblxyXG4gIC8vIE5vcm1hbCBub3RhdGlvbi5cclxuICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcbiAgICBmb3IgKDsgKytlOykgcyA9ICcwJyArIHM7XHJcbiAgICBzID0gJzAuJyArIHM7XHJcbiAgfSBlbHNlIGlmIChlID4gMCkge1xyXG4gICAgaWYgKCsrZSA+IG4pIHtcclxuICAgICAgZm9yIChlIC09IG47IGUtLTspIHMgKz0gJzAnO1xyXG4gICAgfSBlbHNlIGlmIChlIDwgbikge1xyXG4gICAgICBzID0gcy5zbGljZSgwLCBlKSArICcuJyArIHMuc2xpY2UoZSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChuID4gMSkge1xyXG4gICAgcyA9IHMuY2hhckF0KDApICsgJy4nICsgcy5zbGljZSgxKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4LnMgPCAwICYmIGlzTm9uemVybyA/ICctJyArIHMgOiBzO1xyXG59XHJcblxyXG5cclxuLy8gUHJvdG90eXBlL2luc3RhbmNlIG1ldGhvZHNcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZy5cclxuICovXHJcblAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgeC5zID0gMTtcclxuICByZXR1cm4geDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSxcclxuICogICAgICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksIG9yXHJcbiAqICAgICAgICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZS5cclxuICovXHJcblAuY21wID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgaXNuZWcsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIHhjID0geC5jLFxyXG4gICAgeWMgPSAoeSA9IG5ldyB4LmNvbnN0cnVjdG9yKHkpKS5jLFxyXG4gICAgaSA9IHgucyxcclxuICAgIGogPSB5LnMsXHJcbiAgICBrID0geC5lLFxyXG4gICAgbCA9IHkuZTtcclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiAheGNbMF0gPyAheWNbMF0gPyAwIDogLWogOiBpO1xyXG5cclxuICAvLyBTaWducyBkaWZmZXI/XHJcbiAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gIGlzbmVnID0gaSA8IDA7XHJcblxyXG4gIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gIGlmIChrICE9IGwpIHJldHVybiBrID4gbCBeIGlzbmVnID8gMSA6IC0xO1xyXG5cclxuICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgZm9yIChpID0gLTE7ICsraSA8IGo7KSB7XHJcbiAgICBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gaXNuZWcgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGlzbmVnID8gMSA6IC0xO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mIEJpZyB5LCByb3VuZGVkLFxyXG4gKiBpZiBuZWNlc3NhcnksIHRvIGEgbWF4aW11bSBvZiBCaWcuRFAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBCaWcuUk0uXHJcbiAqL1xyXG5QLmRpdiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIGEgPSB4LmMsICAgICAgICAgICAgICAgICAgLy8gZGl2aWRlbmRcclxuICAgIGIgPSAoeSA9IG5ldyBCaWcoeSkpLmMsICAgLy8gZGl2aXNvclxyXG4gICAgayA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICBkcCA9IEJpZy5EUDtcclxuXHJcbiAgaWYgKGRwICE9PSB+fmRwIHx8IGRwIDwgMCB8fCBkcCA+IE1BWF9EUCkge1xyXG4gICAgdGhyb3cgRXJyb3IoSU5WQUxJRF9EUCk7XHJcbiAgfVxyXG5cclxuICAvLyBEaXZpc29yIGlzIHplcm8/XHJcbiAgaWYgKCFiWzBdKSB7XHJcbiAgICB0aHJvdyBFcnJvcihESVZfQllfWkVSTyk7XHJcbiAgfVxyXG5cclxuICAvLyBEaXZpZGVuZCBpcyAwPyBSZXR1cm4gKy0wLlxyXG4gIGlmICghYVswXSkge1xyXG4gICAgeS5zID0gaztcclxuICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgIHJldHVybiB5O1xyXG4gIH1cclxuXHJcbiAgdmFyIGJsLCBidCwgbiwgY21wLCByaSxcclxuICAgIGJ6ID0gYi5zbGljZSgpLFxyXG4gICAgYWkgPSBibCA9IGIubGVuZ3RoLFxyXG4gICAgYWwgPSBhLmxlbmd0aCxcclxuICAgIHIgPSBhLnNsaWNlKDAsIGJsKSwgICAvLyByZW1haW5kZXJcclxuICAgIHJsID0gci5sZW5ndGgsXHJcbiAgICBxID0geSwgICAgICAgICAgICAgICAgLy8gcXVvdGllbnRcclxuICAgIHFjID0gcS5jID0gW10sXHJcbiAgICBxaSA9IDAsXHJcbiAgICBwID0gZHAgKyAocS5lID0geC5lIC0geS5lKSArIDE7ICAgIC8vIHByZWNpc2lvbiBvZiB0aGUgcmVzdWx0XHJcblxyXG4gIHEucyA9IGs7XHJcbiAgayA9IHAgPCAwID8gMCA6IHA7XHJcblxyXG4gIC8vIENyZWF0ZSB2ZXJzaW9uIG9mIGRpdmlzb3Igd2l0aCBsZWFkaW5nIHplcm8uXHJcbiAgYnoudW5zaGlmdCgwKTtcclxuXHJcbiAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICBmb3IgKDsgcmwrKyA8IGJsOykgci5wdXNoKDApO1xyXG5cclxuICBkbyB7XHJcblxyXG4gICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gY3VycmVudCByZW1haW5kZXIuXHJcbiAgICBmb3IgKG4gPSAwOyBuIDwgMTA7IG4rKykge1xyXG5cclxuICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgIGlmIChibCAhPSAocmwgPSByLmxlbmd0aCkpIHtcclxuICAgICAgICBjbXAgPSBibCA+IHJsID8gMSA6IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAocmkgPSAtMSwgY21wID0gMDsgKytyaSA8IGJsOykge1xyXG4gICAgICAgICAgaWYgKGJbcmldICE9IHJbcmldKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IGJbcmldID4gcltyaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgLy8gUmVtYWluZGVyIGNhbid0IGJlIG1vcmUgdGhhbiAxIGRpZ2l0IGxvbmdlciB0aGFuIGRpdmlzb3IuXHJcbiAgICAgICAgLy8gRXF1YWxpc2UgbGVuZ3RocyB1c2luZyBkaXZpc29yIHdpdGggZXh0cmEgbGVhZGluZyB6ZXJvP1xyXG4gICAgICAgIGZvciAoYnQgPSBybCA9PSBibCA/IGIgOiBiejsgcmw7KSB7XHJcbiAgICAgICAgICBpZiAoclstLXJsXSA8IGJ0W3JsXSkge1xyXG4gICAgICAgICAgICByaSA9IHJsO1xyXG4gICAgICAgICAgICBmb3IgKDsgcmkgJiYgIXJbLS1yaV07KSByW3JpXSA9IDk7XHJcbiAgICAgICAgICAgIC0tcltyaV07XHJcbiAgICAgICAgICAgIHJbcmxdICs9IDEwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcltybF0gLT0gYnRbcmxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICg7ICFyWzBdOykgci5zaGlmdCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHRoZSBkaWdpdCBuIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICBxY1txaSsrXSA9IGNtcCA/IG4gOiArK247XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICBpZiAoclswXSAmJiBjbXApIHJbcmxdID0gYVthaV0gfHwgMDtcclxuICAgIGVsc2UgciA9IFthW2FpXV07XHJcblxyXG4gIH0gd2hpbGUgKChhaSsrIDwgYWwgfHwgclswXSAhPT0gVU5ERUZJTkVEKSAmJiBrLS0pO1xyXG5cclxuICAvLyBMZWFkaW5nIHplcm8/IERvIG5vdCByZW1vdmUgaWYgcmVzdWx0IGlzIHNpbXBseSB6ZXJvIChxaSA9PSAxKS5cclxuICBpZiAoIXFjWzBdICYmIHFpICE9IDEpIHtcclxuXHJcbiAgICAvLyBUaGVyZSBjYW4ndCBiZSBtb3JlIHRoYW4gb25lIHplcm8uXHJcbiAgICBxYy5zaGlmdCgpO1xyXG4gICAgcS5lLS07XHJcbiAgICBwLS07XHJcbiAgfVxyXG5cclxuICAvLyBSb3VuZD9cclxuICBpZiAocWkgPiBwKSByb3VuZChxLCBwLCBCaWcuUk0sIHJbMF0gIT09IFVOREVGSU5FRCk7XHJcblxyXG4gIHJldHVybiBxO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5QLmVxID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPT09IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZSByZXR1cm5cclxuICogZmFsc2UuXHJcbiAqL1xyXG5QLmd0ID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPiAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2VcclxuICogcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuUC5ndGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA+IC0xO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuUC5sdCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3RoZXJ3aXNlXHJcbiAqIHJldHVybiBmYWxzZS5cclxuICovXHJcblAubHRlID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPCAxO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIG1pbnVzIHRoZSB2YWx1ZSBvZiBCaWcgeS5cclxuICovXHJcblAubWludXMgPSBQLnN1YiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGksIGosIHQsIHhsdHksXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICBhID0geC5zLFxyXG4gICAgYiA9ICh5ID0gbmV3IEJpZyh5KSkucztcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmIChhICE9IGIpIHtcclxuICAgIHkucyA9IC1iO1xyXG4gICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICB9XHJcblxyXG4gIHZhciB4YyA9IHguYy5zbGljZSgpLFxyXG4gICAgeGUgPSB4LmUsXHJcbiAgICB5YyA9IHkuYyxcclxuICAgIHllID0geS5lO1xyXG5cclxuICAvLyBFaXRoZXIgemVybz9cclxuICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG4gICAgaWYgKHljWzBdKSB7XHJcbiAgICAgIHkucyA9IC1iO1xyXG4gICAgfSBlbHNlIGlmICh4Y1swXSkge1xyXG4gICAgICB5ID0gbmV3IEJpZyh4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHkucyA9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geTtcclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci4gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgaWYgKHhsdHkgPSBhIDwgMCkge1xyXG4gICAgICBhID0gLWE7XHJcbiAgICAgIHQgPSB4YztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHllID0geGU7XHJcbiAgICAgIHQgPSB5YztcclxuICAgIH1cclxuXHJcbiAgICB0LnJldmVyc2UoKTtcclxuICAgIGZvciAoYiA9IGE7IGItLTspIHQucHVzaCgwKTtcclxuICAgIHQucmV2ZXJzZSgpO1xyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgIGogPSAoKHhsdHkgPSB4Yy5sZW5ndGggPCB5Yy5sZW5ndGgpID8geGMgOiB5YykubGVuZ3RoO1xyXG5cclxuICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcbiAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgIHhsdHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gIGlmICh4bHR5KSB7XHJcbiAgICB0ID0geGM7XHJcbiAgICB4YyA9IHljO1xyXG4gICAgeWMgPSB0O1xyXG4gICAgeS5zID0gLXkucztcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Rpb24gb25seVxyXG4gICAqIG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgKi9cclxuICBpZiAoKGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCkpID4gMCkgZm9yICg7IGItLTspIHhjW2krK10gPSAwO1xyXG5cclxuICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gIGZvciAoYiA9IGk7IGogPiBhOykge1xyXG4gICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOykgeGNbaV0gPSA5O1xyXG4gICAgICAtLXhjW2ldO1xyXG4gICAgICB4Y1tqXSArPSAxMDtcclxuICAgIH1cclxuXHJcbiAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKDsgeGNbLS1iXSA9PT0gMDspIHhjLnBvcCgpO1xyXG5cclxuICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gIGZvciAoOyB4Y1swXSA9PT0gMDspIHtcclxuICAgIHhjLnNoaWZ0KCk7XHJcbiAgICAtLXllO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgIC8vIG4gLSBuID0gKzBcclxuICAgIHkucyA9IDE7XHJcblxyXG4gICAgLy8gUmVzdWx0IG11c3QgYmUgemVyby5cclxuICAgIHhjID0gW3llID0gMF07XHJcbiAgfVxyXG5cclxuICB5LmMgPSB4YztcclxuICB5LmUgPSB5ZTtcclxuXHJcbiAgcmV0dXJuIHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgbW9kdWxvIHRoZSB2YWx1ZSBvZiBCaWcgeS5cclxuICovXHJcblAubW9kID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgeWd0eCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIGEgPSB4LnMsXHJcbiAgICBiID0gKHkgPSBuZXcgQmlnKHkpKS5zO1xyXG5cclxuICBpZiAoIXkuY1swXSkge1xyXG4gICAgdGhyb3cgRXJyb3IoRElWX0JZX1pFUk8pO1xyXG4gIH1cclxuXHJcbiAgeC5zID0geS5zID0gMTtcclxuICB5Z3R4ID0geS5jbXAoeCkgPT0gMTtcclxuICB4LnMgPSBhO1xyXG4gIHkucyA9IGI7XHJcblxyXG4gIGlmICh5Z3R4KSByZXR1cm4gbmV3IEJpZyh4KTtcclxuXHJcbiAgYSA9IEJpZy5EUDtcclxuICBiID0gQmlnLlJNO1xyXG4gIEJpZy5EUCA9IEJpZy5STSA9IDA7XHJcbiAgeCA9IHguZGl2KHkpO1xyXG4gIEJpZy5EUCA9IGE7XHJcbiAgQmlnLlJNID0gYjtcclxuXHJcbiAgcmV0dXJuIHRoaXMubWludXMoeC50aW1lcyh5KSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgbmVnYXRlZC5cclxuICovXHJcblAubmVnID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgeC5zID0gLXgucztcclxuICByZXR1cm4geDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBwbHVzIHRoZSB2YWx1ZSBvZiBCaWcgeS5cclxuICovXHJcblAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgZSwgaywgdCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgeSA9IG5ldyBCaWcoeSk7XHJcblxyXG4gIC8vIFNpZ25zIGRpZmZlcj9cclxuICBpZiAoeC5zICE9IHkucykge1xyXG4gICAgeS5zID0gLXkucztcclxuICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHhlID0geC5lLFxyXG4gICAgeGMgPSB4LmMsXHJcbiAgICB5ZSA9IHkuZSxcclxuICAgIHljID0geS5jO1xyXG5cclxuICAvLyBFaXRoZXIgemVybz9cclxuICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG4gICAgaWYgKCF5Y1swXSkge1xyXG4gICAgICBpZiAoeGNbMF0pIHtcclxuICAgICAgICB5ID0gbmV3IEJpZyh4KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5LnMgPSB4LnM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB5O1xyXG4gIH1cclxuXHJcbiAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAvLyBOb3RlOiByZXZlcnNlIGZhc3RlciB0aGFuIHVuc2hpZnRzLlxyXG4gIGlmIChlID0geGUgLSB5ZSkge1xyXG4gICAgaWYgKGUgPiAwKSB7XHJcbiAgICAgIHllID0geGU7XHJcbiAgICAgIHQgPSB5YztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGUgPSAtZTtcclxuICAgICAgdCA9IHhjO1xyXG4gICAgfVxyXG5cclxuICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgZm9yICg7IGUtLTspIHQucHVzaCgwKTtcclxuICAgIHQucmV2ZXJzZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheS5cclxuICBpZiAoeGMubGVuZ3RoIC0geWMubGVuZ3RoIDwgMCkge1xyXG4gICAgdCA9IHljO1xyXG4gICAgeWMgPSB4YztcclxuICAgIHhjID0gdDtcclxuICB9XHJcblxyXG4gIGUgPSB5Yy5sZW5ndGg7XHJcblxyXG4gIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBsZWZ0IGFzIHRoZXkgYXJlLlxyXG4gIGZvciAoayA9IDA7IGU7IHhjW2VdICU9IDEwKSBrID0gKHhjWy0tZV0gPSB4Y1tlXSArIHljW2VdICsgaykgLyAxMCB8IDA7XHJcblxyXG4gIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuXHJcbiAgaWYgKGspIHtcclxuICAgIHhjLnVuc2hpZnQoayk7XHJcbiAgICArK3llO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoZSA9IHhjLmxlbmd0aDsgeGNbLS1lXSA9PT0gMDspIHhjLnBvcCgpO1xyXG5cclxuICB5LmMgPSB4YztcclxuICB5LmUgPSB5ZTtcclxuXHJcbiAgcmV0dXJuIHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyByYWlzZWQgdG8gdGhlIHBvd2VyIG4uXHJcbiAqIElmIG4gaXMgbmVnYXRpdmUsIHJvdW5kIHRvIGEgbWF4aW11bSBvZiBCaWcuRFAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmdcclxuICogbW9kZSBCaWcuUk0uXHJcbiAqXHJcbiAqIG4ge251bWJlcn0gSW50ZWdlciwgLU1BWF9QT1dFUiB0byBNQVhfUE9XRVIgaW5jbHVzaXZlLlxyXG4gKi9cclxuUC5wb3cgPSBmdW5jdGlvbiAobikge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIG9uZSA9IG5ldyB4LmNvbnN0cnVjdG9yKCcxJyksXHJcbiAgICB5ID0gb25lLFxyXG4gICAgaXNuZWcgPSBuIDwgMDtcclxuXHJcbiAgaWYgKG4gIT09IH5+biB8fCBuIDwgLU1BWF9QT1dFUiB8fCBuID4gTUFYX1BPV0VSKSB7XHJcbiAgICB0aHJvdyBFcnJvcihJTlZBTElEICsgJ2V4cG9uZW50Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNuZWcpIG4gPSAtbjtcclxuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgaWYgKG4gJiAxKSB5ID0geS50aW1lcyh4KTtcclxuICAgIG4gPj49IDE7XHJcbiAgICBpZiAoIW4pIGJyZWFrO1xyXG4gICAgeCA9IHgudGltZXMoeCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNuZWcgPyBvbmUuZGl2KHkpIDogeTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyByb3VuZGVkIHRvIGEgbWF4aW11bSBwcmVjaXNpb24gb2Ygc2RcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIEJpZy5STSBpZiBybSBpcyBub3Qgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBzZCB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICogcm0/IHtudW1iZXJ9IFJvdW5kaW5nIG1vZGU6IDAgKGRvd24pLCAxIChoYWxmLXVwKSwgMiAoaGFsZi1ldmVuKSBvciAzICh1cCkuXHJcbiAqL1xyXG5QLnByZWMgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgaWYgKHNkICE9PSB+fnNkIHx8IHNkIDwgMSB8fCBzZCA+IE1BWF9EUCkge1xyXG4gICAgdGhyb3cgRXJyb3IoSU5WQUxJRCArICdwcmVjaXNpb24nKTtcclxuICB9XHJcbiAgcmV0dXJuIHJvdW5kKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCBzZCwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzXHJcbiAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIEJpZy5STSBpZiBybSBpcyBub3Qgc3BlY2lmaWVkLlxyXG4gKiBJZiBkcCBpcyBuZWdhdGl2ZSwgcm91bmQgdG8gYW4gaW50ZWdlciB3aGljaCBpcyBhIG11bHRpcGxlIG9mIDEwKiotZHAuXHJcbiAqIElmIGRwIGlzIG5vdCBzcGVjaWZpZWQsIHJvdW5kIHRvIDAgZGVjaW1hbCBwbGFjZXMuXHJcbiAqXHJcbiAqIGRwPyB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX0RQIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAqIHJtPyB7bnVtYmVyfSBSb3VuZGluZyBtb2RlOiAwIChkb3duKSwgMSAoaGFsZi11cCksIDIgKGhhbGYtZXZlbikgb3IgMyAodXApLlxyXG4gKi9cclxuUC5yb3VuZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICBpZiAoZHAgPT09IFVOREVGSU5FRCkgZHAgPSAwO1xyXG4gIGVsc2UgaWYgKGRwICE9PSB+fmRwIHx8IGRwIDwgLU1BWF9EUCB8fCBkcCA+IE1BWF9EUCkge1xyXG4gICAgdGhyb3cgRXJyb3IoSU5WQUxJRF9EUCk7XHJcbiAgfVxyXG4gIHJldHVybiByb3VuZChuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgZHAgKyB0aGlzLmUgKyAxLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnLCByb3VuZGVkLCBpZlxyXG4gKiBuZWNlc3NhcnksIHRvIGEgbWF4aW11bSBvZiBCaWcuRFAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBCaWcuUk0uXHJcbiAqL1xyXG5QLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHIsIGMsIHQsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICBzID0geC5zLFxyXG4gICAgZSA9IHguZSxcclxuICAgIGhhbGYgPSBuZXcgQmlnKCcwLjUnKTtcclxuXHJcbiAgLy8gWmVybz9cclxuICBpZiAoIXguY1swXSkgcmV0dXJuIG5ldyBCaWcoeCk7XHJcblxyXG4gIC8vIE5lZ2F0aXZlP1xyXG4gIGlmIChzIDwgMCkge1xyXG4gICAgdGhyb3cgRXJyb3IoTkFNRSArICdObyBzcXVhcmUgcm9vdCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gRXN0aW1hdGUuXHJcbiAgcyA9IE1hdGguc3FydCgrc3RyaW5naWZ5KHgsIHRydWUsIHRydWUpKTtcclxuXHJcbiAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAvLyBSZS1lc3RpbWF0ZTogcGFzcyB4IGNvZWZmaWNpZW50IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gIGlmIChzID09PSAwIHx8IHMgPT09IDEgLyAwKSB7XHJcbiAgICBjID0geC5jLmpvaW4oJycpO1xyXG4gICAgaWYgKCEoYy5sZW5ndGggKyBlICYgMSkpIGMgKz0gJzAnO1xyXG4gICAgcyA9IE1hdGguc3FydChjKTtcclxuICAgIGUgPSAoKGUgKyAxKSAvIDIgfCAwKSAtIChlIDwgMCB8fCBlICYgMSk7XHJcbiAgICByID0gbmV3IEJpZygocyA9PSAxIC8gMCA/ICc1ZScgOiAocyA9IHMudG9FeHBvbmVudGlhbCgpKS5zbGljZSgwLCBzLmluZGV4T2YoJ2UnKSArIDEpKSArIGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByID0gbmV3IEJpZyhzICsgJycpO1xyXG4gIH1cclxuXHJcbiAgZSA9IHIuZSArIChCaWcuRFAgKz0gNCk7XHJcblxyXG4gIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICBkbyB7XHJcbiAgICB0ID0gcjtcclxuICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyh4LmRpdih0KSkpO1xyXG4gIH0gd2hpbGUgKHQuYy5zbGljZSgwLCBlKS5qb2luKCcnKSAhPT0gci5jLnNsaWNlKDAsIGUpLmpvaW4oJycpKTtcclxuXHJcbiAgcmV0dXJuIHJvdW5kKHIsIChCaWcuRFAgLT0gNCkgKyByLmUgKyAxLCBCaWcuUk0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHRpbWVzIHRoZSB2YWx1ZSBvZiBCaWcgeS5cclxuICovXHJcblAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGMsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICB4YyA9IHguYyxcclxuICAgIHljID0gKHkgPSBuZXcgQmlnKHkpKS5jLFxyXG4gICAgYSA9IHhjLmxlbmd0aCxcclxuICAgIGIgPSB5Yy5sZW5ndGgsXHJcbiAgICBpID0geC5lLFxyXG4gICAgaiA9IHkuZTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHNpZ24gb2YgcmVzdWx0LlxyXG4gIHkucyA9IHgucyA9PSB5LnMgPyAxIDogLTE7XHJcblxyXG4gIC8vIFJldHVybiBzaWduZWQgMCBpZiBlaXRoZXIgMC5cclxuICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG4gICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgcmV0dXJuIHk7XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXNlIGV4cG9uZW50IG9mIHJlc3VsdCBhcyB4LmUgKyB5LmUuXHJcbiAgeS5lID0gaSArIGo7XHJcblxyXG4gIC8vIElmIGFycmF5IHhjIGhhcyBmZXdlciBkaWdpdHMgdGhhbiB5Yywgc3dhcCB4YyBhbmQgeWMsIGFuZCBsZW5ndGhzLlxyXG4gIGlmIChhIDwgYikge1xyXG4gICAgYyA9IHhjO1xyXG4gICAgeGMgPSB5YztcclxuICAgIHljID0gYztcclxuICAgIGogPSBhO1xyXG4gICAgYSA9IGI7XHJcbiAgICBiID0gajtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpc2UgY29lZmZpY2llbnQgYXJyYXkgb2YgcmVzdWx0IHdpdGggemVyb3MuXHJcbiAgZm9yIChjID0gbmV3IEFycmF5KGogPSBhICsgYik7IGotLTspIGNbal0gPSAwO1xyXG5cclxuICAvLyBNdWx0aXBseS5cclxuXHJcbiAgLy8gaSBpcyBpbml0aWFsbHkgeGMubGVuZ3RoLlxyXG4gIGZvciAoaSA9IGI7IGktLTspIHtcclxuICAgIGIgPSAwO1xyXG5cclxuICAgIC8vIGEgaXMgeWMubGVuZ3RoLlxyXG4gICAgZm9yIChqID0gYSArIGk7IGogPiBpOykge1xyXG5cclxuICAgICAgLy8gQ3VycmVudCBzdW0gb2YgcHJvZHVjdHMgYXQgdGhpcyBkaWdpdCBwb3NpdGlvbiwgcGx1cyBjYXJyeS5cclxuICAgICAgYiA9IGNbal0gKyB5Y1tpXSAqIHhjW2ogLSBpIC0gMV0gKyBiO1xyXG4gICAgICBjW2otLV0gPSBiICUgMTA7XHJcblxyXG4gICAgICAvLyBjYXJyeVxyXG4gICAgICBiID0gYiAvIDEwIHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBjW2pdID0gYjtcclxuICB9XHJcblxyXG4gIC8vIEluY3JlbWVudCByZXN1bHQgZXhwb25lbnQgaWYgdGhlcmUgaXMgYSBmaW5hbCBjYXJyeSwgb3RoZXJ3aXNlIHJlbW92ZSBsZWFkaW5nIHplcm8uXHJcbiAgaWYgKGIpICsreS5lO1xyXG4gIGVsc2UgYy5zaGlmdCgpO1xyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChpID0gYy5sZW5ndGg7ICFjWy0taV07KSBjLnBvcCgpO1xyXG4gIHkuYyA9IGM7XHJcblxyXG4gIHJldHVybiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIHJvdW5kZWQgdG8gZHAgZml4ZWRcclxuICogZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgQmlnLlJNIGlmIHJtIGlzIG5vdCBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIGRwPyB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybT8ge251bWJlcn0gUm91bmRpbmcgbW9kZTogMCAoZG93biksIDEgKGhhbGYtdXApLCAyIChoYWxmLWV2ZW4pIG9yIDMgKHVwKS5cclxuICovXHJcblAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBuID0geC5jWzBdO1xyXG5cclxuICBpZiAoZHAgIT09IFVOREVGSU5FRCkge1xyXG4gICAgaWYgKGRwICE9PSB+fmRwIHx8IGRwIDwgMCB8fCBkcCA+IE1BWF9EUCkge1xyXG4gICAgICB0aHJvdyBFcnJvcihJTlZBTElEX0RQKTtcclxuICAgIH1cclxuICAgIHggPSByb3VuZChuZXcgeC5jb25zdHJ1Y3Rvcih4KSwgKytkcCwgcm0pO1xyXG4gICAgZm9yICg7IHguYy5sZW5ndGggPCBkcDspIHguYy5wdXNoKDApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh4LCB0cnVlLCAhIW4pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGluIG5vcm1hbCBub3RhdGlvbiByb3VuZGVkIHRvIGRwIGZpeGVkXHJcbiAqIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIEJpZy5STSBpZiBybSBpcyBub3Qgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBkcD8ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICogcm0/IHtudW1iZXJ9IFJvdW5kaW5nIG1vZGU6IDAgKGRvd24pLCAxIChoYWxmLXVwKSwgMiAoaGFsZi1ldmVuKSBvciAzICh1cCkuXHJcbiAqXHJcbiAqICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsIGJ1dCAoLTAuMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gKiAoLTApLnRvRml4ZWQoMSkgaXMgJzAuMCcsIGJ1dCAoLTAuMDEpLnRvRml4ZWQoMSkgaXMgJy0wLjAnLlxyXG4gKi9cclxuUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIG4gPSB4LmNbMF07XHJcblxyXG4gIGlmIChkcCAhPT0gVU5ERUZJTkVEKSB7XHJcbiAgICBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAwIHx8IGRwID4gTUFYX0RQKSB7XHJcbiAgICAgIHRocm93IEVycm9yKElOVkFMSURfRFApO1xyXG4gICAgfVxyXG4gICAgeCA9IHJvdW5kKG5ldyB4LmNvbnN0cnVjdG9yKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuXHJcbiAgICAvLyB4LmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgaXMgcm91bmRlZCB1cC5cclxuICAgIGZvciAoZHAgPSBkcCArIHguZSArIDE7IHguYy5sZW5ndGggPCBkcDspIHguYy5wdXNoKDApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh4LCBmYWxzZSwgISFuKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZy5cclxuICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoaXMgQmlnIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhblxyXG4gKiBCaWcuUEUsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIEJpZy5ORS5cclxuICogT21pdCB0aGUgc2lnbiBmb3IgbmVnYXRpdmUgemVyby5cclxuICovXHJcblBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnRvSlNPTiA9IFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcjtcclxuICByZXR1cm4gc3RyaW5naWZ5KHgsIHguZSA8PSBCaWcuTkUgfHwgeC5lID49IEJpZy5QRSwgISF4LmNbMF0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgYXMgYSBwcmltaXR2ZSBudW1iZXIuXHJcbiAqL1xyXG5QLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBuID0gK3N0cmluZ2lmeSh0aGlzLCB0cnVlLCB0cnVlKTtcclxuICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5zdHJpY3QgPT09IHRydWUgJiYgIXRoaXMuZXEobi50b1N0cmluZygpKSkge1xyXG4gICAgdGhyb3cgRXJyb3IoTkFNRSArICdJbXByZWNpc2UgY29udmVyc2lvbicpO1xyXG4gIH1cclxuICByZXR1cm4gbjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZ1xyXG4gKiByb3VuZGluZyBtb2RlIHJtLCBvciBCaWcuUk0gaWYgcm0gaXMgbm90IHNwZWNpZmllZC5cclxuICogVXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50XHJcbiAqIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIG5vcm1hbCBub3RhdGlvbi5cclxuICpcclxuICogc2Qge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAqIHJtPyB7bnVtYmVyfSBSb3VuZGluZyBtb2RlOiAwIChkb3duKSwgMSAoaGFsZi11cCksIDIgKGhhbGYtZXZlbikgb3IgMyAodXApLlxyXG4gKi9cclxuUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgbiA9IHguY1swXTtcclxuXHJcbiAgaWYgKHNkICE9PSBVTkRFRklORUQpIHtcclxuICAgIGlmIChzZCAhPT0gfn5zZCB8fCBzZCA8IDEgfHwgc2QgPiBNQVhfRFApIHtcclxuICAgICAgdGhyb3cgRXJyb3IoSU5WQUxJRCArICdwcmVjaXNpb24nKTtcclxuICAgIH1cclxuICAgIHggPSByb3VuZChuZXcgQmlnKHgpLCBzZCwgcm0pO1xyXG4gICAgZm9yICg7IHguYy5sZW5ndGggPCBzZDspIHguYy5wdXNoKDApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh4LCBzZCA8PSB4LmUgfHwgeC5lIDw9IEJpZy5ORSB8fCB4LmUgPj0gQmlnLlBFLCAhIW4pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnLlxyXG4gKiBSZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhpcyBCaWcgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXHJcbiAqIEJpZy5QRSwgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW4gQmlnLk5FLlxyXG4gKiBJbmNsdWRlIHRoZSBzaWduIGZvciBuZWdhdGl2ZSB6ZXJvLlxyXG4gKi9cclxuUC52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3I7XHJcbiAgaWYgKEJpZy5zdHJpY3QgPT09IHRydWUpIHtcclxuICAgIHRocm93IEVycm9yKE5BTUUgKyAndmFsdWVPZiBkaXNhbGxvd2VkJyk7XHJcbiAgfVxyXG4gIHJldHVybiBzdHJpbmdpZnkoeCwgeC5lIDw9IEJpZy5ORSB8fCB4LmUgPj0gQmlnLlBFLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vLyBFeHBvcnRcclxuXHJcblxyXG5leHBvcnQgdmFyIEJpZyA9IF9CaWdfKCk7XHJcblxyXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL21hc3Rlci90eXBlcy9iaWcuanMvaW5kZXguZC50c1wiIC8+XHJcbmV4cG9ydCBkZWZhdWx0IEJpZztcclxuIl0sIm5hbWVzIjpbIkRQIiwiUk0iLCJNQVhfRFAiLCJNQVhfUE9XRVIiLCJORSIsIlBFIiwiU1RSSUNUIiwiTkFNRSIsIklOVkFMSUQiLCJJTlZBTElEX0RQIiwiSU5WQUxJRF9STSIsIkRJVl9CWV9aRVJPIiwiUCIsIlVOREVGSU5FRCIsIk5VTUVSSUMiLCJfQmlnXyIsIkJpZyIsIm4iLCJ4IiwicyIsImUiLCJjIiwic2xpY2UiLCJzdHJpY3QiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJwYXJzZSIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwicm91bmREb3duIiwicm91bmRIYWxmVXAiLCJyb3VuZEhhbGZFdmVuIiwicm91bmRVcCIsImkiLCJubCIsInRlc3QiLCJFcnJvciIsImNoYXJBdCIsImluZGV4T2YiLCJyZXBsYWNlIiwic2VhcmNoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicm91bmQiLCJzZCIsInJtIiwibW9yZSIsInhjIiwidW5zaGlmdCIsInBvcCIsInN0cmluZ2lmeSIsImRvRXhwb25lbnRpYWwiLCJpc05vbnplcm8iLCJqb2luIiwiYWJzIiwiY21wIiwieSIsImlzbmVnIiwieWMiLCJqIiwiayIsImwiLCJkaXYiLCJhIiwiYiIsImRwIiwiYmwiLCJidCIsInJpIiwiYnoiLCJhaSIsImFsIiwiciIsInJsIiwicSIsInFjIiwicWkiLCJwIiwicHVzaCIsInNoaWZ0IiwiZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwibWludXMiLCJzdWIiLCJ0IiwieGx0eSIsInBsdXMiLCJ4ZSIsInllIiwicmV2ZXJzZSIsIm1vZCIsInlndHgiLCJ0aW1lcyIsIm5lZyIsImFkZCIsInBvdyIsIm9uZSIsInByZWMiLCJzcXJ0IiwiaGFsZiIsIk1hdGgiLCJ0b0V4cG9uZW50aWFsIiwibXVsIiwiQXJyYXkiLCJ0b0ZpeGVkIiwiU3ltYm9sIiwiZm9yIiwidG9KU09OIiwidG9TdHJpbmciLCJ0b051bWJlciIsInRvUHJlY2lzaW9uIiwidmFsdWVPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/big.js/big.mjs\n");

/***/ })

};
;