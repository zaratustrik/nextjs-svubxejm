"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana";
exports.ids = ["vendor-chunks/@solana"];
exports.modules = {

/***/ "(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/buffer-layout/lib/Layout.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ /**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */ function checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError(\"b must be a Uint8Array\");\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */ function uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */ class Layout {\n    constructor(span, property){\n        if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */ makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */ getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */ replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */ fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */ function nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + \"[\" + lo.property + \"]\";\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */ // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if (\"function\" !== typeof Class) {\n        throw new TypeError(\"Class must be constructor\");\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, \"layout_\")) {\n        throw new Error(\"Class is already bound to a layout\");\n    }\n    if (!(layout && layout instanceof Layout)) {\n        throw new TypeError(\"layout must be a Layout\");\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, \"boundConstructor_\")) {\n        throw new Error(\"layout is already bound to a constructor\");\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = ()=>new Class();\n    Object.defineProperty(Class.prototype, \"encode\", {\n        value (b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true\n    });\n    Object.defineProperty(Class, \"decode\", {\n        value (b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */ class ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */ isCount() {\n        throw new Error(\"ExternalLayout is abstract\");\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */ class GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property){\n        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */ this.elementSpan = elementSpan;\n    }\n    /** @override */ isCount() {\n        return true;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */ encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */ class OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property){\n        if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */ this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */ this.offset = offset;\n    }\n    /** @override */ isCount() {\n        return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */ decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UInt extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UIntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Int extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class IntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */ function divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - hi32 * V2E32;\n    return {\n        hi32,\n        lo32\n    };\n}\n/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Float extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class FloatBE extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Double extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class DoubleBE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Sequence extends Layout {\n    constructor(elementLayout, count, property){\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n        }\n        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        } else {\n            let idx = 0;\n            while(idx < count){\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while(i < count){\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v)=>{\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */ class Structure extends Layout {\n    constructor(fields, property, decodePrefixes){\n        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n        }\n        if (\"boolean\" === typeof property && undefined === decodePrefixes) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){\n            if (0 > fd.span && undefined === fd.property) {\n                throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);\n        } catch (e) {\n        // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */ this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd)=>{\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes && b.length === offset) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */ encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields){\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */ span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */ return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */ fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property && 0 < values.length) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */ layoutFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */ offsetOf(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        let offset = 0;\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            } else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */ class UnionDiscriminator {\n    constructor(property){\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */ this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */ decode(b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */ encode(src, b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */ class UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property){\n        if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n        }\n        super(property || layout.property || \"variant\");\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */ this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Union extends Layout {\n    constructor(discr, defaultLayout, property){\n        let discriminator;\n        if (discr instanceof UInt || discr instanceof UIntBE) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator \" + \"or an unsigned integer layout\");\n        } else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate(\"content\");\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */ let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */ this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */ this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */ this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */ this.registry = {};\n        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */ this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */ const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */ defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n                return vlo;\n            }\n        } else {\n            for(const tag in this.registry){\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */ decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        } else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */ encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */ addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */ getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        } else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */ class VariantLayout extends Layout {\n    constructor(union, variant, layout, property){\n        if (!(union instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n        }\n        if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n        }\n        if (\"string\" === typeof layout && undefined === property) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n                throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n                throw new TypeError(\"variant must have a String property\");\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */ this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */ this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */ this.layout = layout || null;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */ return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */ let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error(\"variant mismatch\");\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        } else if (this.property) {\n            dest[this.property] = true;\n        } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n                throw new Error(\"encoded variant overruns containing union\");\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */ fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */ function fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class BitStructure extends Layout {\n    constructor(word, msb, property){\n        if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n        }\n        if (\"string\" === typeof msb && undefined === property) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */ this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */ this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/ this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */ let value = 0;\n        this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function() {\n            return value;\n        };\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */ addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */ // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */ fieldFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */ class BitField {\n    constructor(container, bits, property){\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n        }\n        if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);\n        if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */ this.container = container;\n        /** The span of this value in bits. */ this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;\n        if (32 === bits) {\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */ this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */ decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {\n        if (\"number\" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */ /* eslint-disable no-extend-native */ class Boolean extends BitField {\n    constructor(container, property){\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */ decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */ encode(value) {\n        if (\"boolean\" === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */ /**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Blob extends Layout {\n    constructor(length, property){\n        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */ this.length = length;\n    }\n    /** @override */ getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Uint8Array as src\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Uint8Array\");\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString(\"hex\"), offset, span, \"hex\");\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class CString extends Layout {\n    constructor(property){\n        super(-1, property);\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while(idx < b.length && 0 !== b[idx]){\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UTF8 extends Layout {\n    constructor(maxSpan, property){\n        if (\"string\" === typeof maxSpan && undefined === property) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */ this.maxSpan = maxSpan;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Constant extends Layout {\n    constructor(value, property){\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */ this.value = value;\n    }\n    /** @override */ decode(b, offset) {\n        return this.value;\n    }\n    /** @override */ encode(src, b, offset) {\n        /* Constants take no space */ return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */ exports.u8 = (property)=>new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */ exports.s8 = (property)=>new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);\n/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);\n/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);\n/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */ exports.constant = (value, property)=>new Constant(value, property); //# sourceMappingURL=Layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9idWZmZXItbGF5b3V0L2xpYi9MYXlvdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJHQyxHQUNEO0FBQ0FBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLFVBQVUsR0FBR0EsY0FBYyxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsWUFBWSxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsVUFBVSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsZ0JBQWdCLEdBQUdBLFlBQVksR0FBR0EsZUFBZSxHQUFHQSxZQUFZLEdBQUdBLGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxnQ0FBZ0MsR0FBR0EsMEJBQTBCLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHQSxhQUFhLEdBQUdBLG1CQUFtQixHQUFHQSxpQkFBaUIsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSxhQUFhLEdBQUdBLFdBQVcsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBR0EsY0FBYyxHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUN0N0JBLGdCQUFnQixH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QUFDekQseUNBQXlDLEdBQ3pDeEYsZ0JBQWdCLEdBQUksQ0FBQ0MsT0FBT3VGLFdBQWEsSUFBSXJFLFNBQVNsQixPQUFPdUYsV0FDN0Qsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvYnVmZmVyLWxheW91dC9saWIvTGF5b3V0LmpzPzY3ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBQZXRlciBBLiBCaWdvdFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogU3VwcG9ydCBmb3IgdHJhbnNsYXRpbmcgYmV0d2VlbiBVaW50OEFycmF5IGluc3RhbmNlcyBhbmQgSmF2YVNjcmlwdFxuICogbmF0aXZlIHR5cGVzLlxuICpcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9IGlzIHRoZSBiYXNpcyBvZiBhIGNsYXNzXG4gKiBoaWVyYXJjaHkgdGhhdCBhc3NvY2lhdGVzIHByb3BlcnR5IG5hbWVzIHdpdGggc2VxdWVuY2VzIG9mIGVuY29kZWRcbiAqIGJ5dGVzLlxuICpcbiAqIExheW91dHMgYXJlIHN1cHBvcnRlZCBmb3IgdGhlc2Ugc2NhbGFyIChudW1lcmljKSB0eXBlczpcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+VUludHxVbnNpZ25lZCBpbnRlZ2VycyBpbiBsaXR0bGUtZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC51OHw4LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnUxNnwxNi1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8MjQtYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyfDMyLWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnU0MHw0MC1iaXR9LCBhbmQge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQ4fDQ4LWJpdH1cbiAqICAgcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5VSW50QkV8VW5zaWduZWQgaW50ZWdlcnMgaW4gYmlnLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQudTE2YmV8MTYtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTI0YmV8MjQtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyYmV8MzItYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwYmV8NDAtYml0fSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnU0OGJlfDQ4LWJpdH0gcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5JbnR8U2lnbmVkIGludGVnZXJzIGluIGxpdHRsZS1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fDgtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczE2fDE2LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMyNHwyNC1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJ8MzItYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczQwfDQwLWJpdH0sIGFuZCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDh8NDgtYml0fVxuICogICByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkludEJFfFNpZ25lZCBpbnRlZ2VycyBpbiBiaWctZW5kaWFuIGZvcm1hdH1cbiAqICAgd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMTZiZXwxNi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zMjRiZXwyNC1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJiZXwzMi1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDBiZXw0MC1iaXR9LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczQ4YmV8NDgtYml0fSByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIDY0LWJpdCBpbnRlZ3JhbCB2YWx1ZXMgdGhhdCBkZWNvZGUgdG8gYW4gZXhhY3QgKGlmIG1hZ25pdHVkZSBpc1xuICogICBsZXNzIHRoYW4gMl41Mykgb3IgbmVhcmJ5IGludGVncmFsIE51bWJlciBpbiB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5udTY0fHVuc2lnbmVkIGxpdHRsZS1lbmRpYW59LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5udTY0YmV8dW5zaWduZWQgYmlnLWVuZGlhbn0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm5zNjR8c2lnbmVkIGxpdHRsZS1lbmRpYW59LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnM2NGJlfHVuc2lnbmVkIGJpZy1lbmRpYW59IGVuY29kaW5ncztcbiAqICogMzItYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmYzMnxsaXR0bGUtZW5kaWFufSBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjMyYmV8YmlnLWVuZGlhbn0gcmVwcmVzZW50YXRpb25zO1xuICogKiA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGgge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjY0fGxpdHRsZS1lbmRpYW59IGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mNjRiZXxiaWctZW5kaWFufSByZXByZXNlbnRhdGlvbnM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmNvbnN0fENvbnN0YW50c30gdGhhdCB0YWtlIG5vIHNwYWNlIGluIHRoZVxuICogICBlbmNvZGVkIGV4cHJlc3Npb24uXG4gKlxuICogYW5kIGZvciB0aGVzZSBhZ2dyZWdhdGUgdHlwZXM6XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnNlcXxTZXF1ZW5jZX1zIG9mIGluc3RhbmNlcyBvZiBhIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9LCB3aXRoIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gYXNcbiAqICAgYW4gQXJyYXkgYW5kIGNvbnN0YW50IG9yIGRhdGEtZGVwZW5kZW50IHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0flNlcXVlbmNlI2NvdW50fGxlbmd0aH07XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxTdHJ1Y3R1cmV9cyB0aGF0IGFnZ3JlZ2F0ZSBhXG4gKiAgIGhldGVyb2dlbmVvdXMgc2VxdWVuY2Ugb2Yge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH1cbiAqICAgaW5zdGFuY2VzLCB3aXRoIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gYXMgYW4gT2JqZWN0O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC51bmlvbnxVbmlvbn1zIHRoYXQgc3VwcG9ydCBtdWx0aXBsZSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5WYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0c30gb3ZlciBhIGZpeGVkXG4gKiAgIChwYWRkZWQpIG9yIHZhcmlhYmxlIChub3QgcGFkZGVkKSBzcGFuIG9mIGJ5dGVzLCB1c2luZyBhblxuICogICB1bnNpZ25lZCBpbnRlZ2VyIGF0IHRoZSBzdGFydCBvZiB0aGUgZGF0YSBvciBhIHNlcGFyYXRlIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcnxsYXlvdXQgZWxlbWVudH0gdG9cbiAqICAgZGV0ZXJtaW5lIHdoaWNoIGxheW91dCB0byB1c2Ugd2hlbiBpbnRlcnByZXRpbmcgdGhlIGJ1ZmZlclxuICogICBjb250ZW50cztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYml0c3xCaXRTdHJ1Y3R1cmV9cyB0aGF0IGNvbnRhaW4gYSBzZXF1ZW5jZVxuICogICBvZiBpbmRpdmlkdWFsIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkJpdFN0cnVjdHVyZSNhZGRGaWVsZHxCaXRGaWVsZH1zIHBhY2tlZCBpbnRvIGFuIDgsXG4gKiAgIDE2LCAyNCwgb3IgMzItYml0IHVuc2lnbmVkIGludGVnZXIgc3RhcnRpbmcgYXQgdGhlIGxlYXN0LSBvclxuICogICBtb3N0LXNpZ25pZmljYW50IGJpdDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY3N0cnxDIHN0cmluZ3N9IG9mIHZhcnlpbmcgbGVuZ3RoO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5ibG9ifEJsb2JzfSBvZiBmaXhlZC0gb3IgdmFyaWFibGUte0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+QmxvYiNsZW5ndGh8bGVuZ3RofSByYXcgZGF0YS5cbiAqXG4gKiBBbGwge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0gaW5zdGFuY2VzIGFyZSBpbW11dGFibGVcbiAqIGFmdGVyIGNvbnN0cnVjdGlvbiwgdG8gcHJldmVudCBpbnRlcm5hbCBzdGF0ZSBmcm9tIGJlY29taW5nXG4gKiBpbmNvbnNpc3RlbnQuXG4gKlxuICogQGxvY2FsIExheW91dFxuICogQGxvY2FsIEV4dGVybmFsTGF5b3V0XG4gKiBAbG9jYWwgR3JlZWR5Q291bnRcbiAqIEBsb2NhbCBPZmZzZXRMYXlvdXRcbiAqIEBsb2NhbCBVSW50XG4gKiBAbG9jYWwgVUludEJFXG4gKiBAbG9jYWwgSW50XG4gKiBAbG9jYWwgSW50QkVcbiAqIEBsb2NhbCBOZWFyVUludDY0XG4gKiBAbG9jYWwgTmVhclVJbnQ2NEJFXG4gKiBAbG9jYWwgTmVhckludDY0XG4gKiBAbG9jYWwgTmVhckludDY0QkVcbiAqIEBsb2NhbCBGbG9hdFxuICogQGxvY2FsIEZsb2F0QkVcbiAqIEBsb2NhbCBEb3VibGVcbiAqIEBsb2NhbCBEb3VibGVCRVxuICogQGxvY2FsIFNlcXVlbmNlXG4gKiBAbG9jYWwgU3RydWN0dXJlXG4gKiBAbG9jYWwgVW5pb25EaXNjcmltaW5hdG9yXG4gKiBAbG9jYWwgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yXG4gKiBAbG9jYWwgVW5pb25cbiAqIEBsb2NhbCBWYXJpYW50TGF5b3V0XG4gKiBAbG9jYWwgQml0U3RydWN0dXJlXG4gKiBAbG9jYWwgQml0RmllbGRcbiAqIEBsb2NhbCBCb29sZWFuXG4gKiBAbG9jYWwgQmxvYlxuICogQGxvY2FsIENTdHJpbmdcbiAqIEBsb2NhbCBDb25zdGFudFxuICogQGxvY2FsIGJpbmRDb25zdHJ1Y3RvckxheW91dFxuICogQG1vZHVsZSBMYXlvdXRcbiAqIEBsaWNlbnNlIE1JVFxuICogQGF1dGhvciBQZXRlciBBLiBCaWdvdFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BhYmlnb3QvYnVmZmVyLWxheW91dHxidWZmZXItbGF5b3V0IG9uIEdpdEh1Yn1cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zMTYgPSBleHBvcnRzLnM4ID0gZXhwb3J0cy5udTY0YmUgPSBleHBvcnRzLnU0OGJlID0gZXhwb3J0cy51NDBiZSA9IGV4cG9ydHMudTMyYmUgPSBleHBvcnRzLnUyNGJlID0gZXhwb3J0cy51MTZiZSA9IGV4cG9ydHMubnU2NCA9IGV4cG9ydHMudTQ4ID0gZXhwb3J0cy51NDAgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTI0ID0gZXhwb3J0cy51MTYgPSBleHBvcnRzLnU4ID0gZXhwb3J0cy5vZmZzZXQgPSBleHBvcnRzLmdyZWVkeSA9IGV4cG9ydHMuQ29uc3RhbnQgPSBleHBvcnRzLlVURjggPSBleHBvcnRzLkNTdHJpbmcgPSBleHBvcnRzLkJsb2IgPSBleHBvcnRzLkJvb2xlYW4gPSBleHBvcnRzLkJpdEZpZWxkID0gZXhwb3J0cy5CaXRTdHJ1Y3R1cmUgPSBleHBvcnRzLlZhcmlhbnRMYXlvdXQgPSBleHBvcnRzLlVuaW9uID0gZXhwb3J0cy5VbmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSBleHBvcnRzLlVuaW9uRGlzY3JpbWluYXRvciA9IGV4cG9ydHMuU3RydWN0dXJlID0gZXhwb3J0cy5TZXF1ZW5jZSA9IGV4cG9ydHMuRG91YmxlQkUgPSBleHBvcnRzLkRvdWJsZSA9IGV4cG9ydHMuRmxvYXRCRSA9IGV4cG9ydHMuRmxvYXQgPSBleHBvcnRzLk5lYXJJbnQ2NEJFID0gZXhwb3J0cy5OZWFySW50NjQgPSBleHBvcnRzLk5lYXJVSW50NjRCRSA9IGV4cG9ydHMuTmVhclVJbnQ2NCA9IGV4cG9ydHMuSW50QkUgPSBleHBvcnRzLkludCA9IGV4cG9ydHMuVUludEJFID0gZXhwb3J0cy5VSW50ID0gZXhwb3J0cy5PZmZzZXRMYXlvdXQgPSBleHBvcnRzLkdyZWVkeUNvdW50ID0gZXhwb3J0cy5FeHRlcm5hbExheW91dCA9IGV4cG9ydHMuYmluZENvbnN0cnVjdG9yTGF5b3V0ID0gZXhwb3J0cy5uYW1lV2l0aFByb3BlcnR5ID0gZXhwb3J0cy5MYXlvdXQgPSBleHBvcnRzLnVpbnQ4QXJyYXlUb0J1ZmZlciA9IGV4cG9ydHMuY2hlY2tVaW50OEFycmF5ID0gdm9pZCAwO1xuZXhwb3J0cy5jb25zdGFudCA9IGV4cG9ydHMudXRmOCA9IGV4cG9ydHMuY3N0ciA9IGV4cG9ydHMuYmxvYiA9IGV4cG9ydHMudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gZXhwb3J0cy51bmlvbiA9IGV4cG9ydHMuc2VxID0gZXhwb3J0cy5iaXRzID0gZXhwb3J0cy5zdHJ1Y3QgPSBleHBvcnRzLmY2NGJlID0gZXhwb3J0cy5mNjQgPSBleHBvcnRzLmYzMmJlID0gZXhwb3J0cy5mMzIgPSBleHBvcnRzLm5zNjRiZSA9IGV4cG9ydHMuczQ4YmUgPSBleHBvcnRzLnM0MGJlID0gZXhwb3J0cy5zMzJiZSA9IGV4cG9ydHMuczI0YmUgPSBleHBvcnRzLnMxNmJlID0gZXhwb3J0cy5uczY0ID0gZXhwb3J0cy5zNDggPSBleHBvcnRzLnM0MCA9IGV4cG9ydHMuczMyID0gZXhwb3J0cy5zMjQgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4vKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgVWludDhBcnJheS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiBjaGVja1VpbnQ4QXJyYXkoYikge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiIG11c3QgYmUgYSBVaW50OEFycmF5Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1VpbnQ4QXJyYXkgPSBjaGVja1VpbnQ4QXJyYXk7XG4vKiBDcmVhdGUgYSBCdWZmZXIgaW5zdGFuY2UgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gdWludDhBcnJheVRvQnVmZmVyKGIpIHtcbiAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIubGVuZ3RoKTtcbn1cbmV4cG9ydHMudWludDhBcnJheVRvQnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXlvdXQgb2JqZWN0cy5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnRlZ2VyOyBhIG5lZ2F0aXZlIHZhbHVlIHNpZ25pZmllcyB0aGF0IHRoZVxuICogc3BhbiBpcyB7QGxpbmsgTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBvc2l0aXZlIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IGV4cGVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBaZXJvIHdpbGwgb25seSBhcHBlYXIgaW4ge0BsaW5rIENvbnN0YW50fXMgYW5kIGluIHtAbGlua1xuICAgICAgICAgKiBTZXF1ZW5jZX1zIHdoZXJlIHRoZSB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IGlzIHplcm8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIHNwYW4gaXMgdmFsdWUtc3BlY2lmaWMsIGFuZFxuICAgICAgICAgKiBtdXN0IGJlIG9idGFpbmVkIHVzaW5nIHtAbGluayBMYXlvdXQjZ2V0U3BhbnxnZXRTcGFufS4gKi9cbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIHVzZWQgd2hlbiB0aGlzIGxheW91dCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAgICAgKiBPYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICAgICAqIGluc3RhbmNlcy4gIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBzcGFuIG9mIHRoZSB1bm5hbWVkIGxheW91dCB3aWxsXG4gICAgICAgICAqIGJlIHRyZWF0ZWQgYXMgcGFkZGluZzogaXQgd2lsbCBub3QgYmUgbXV0YXRlZCBieSB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG5vciByZXByZXNlbnRlZCBhcyBhIHByb3BlcnR5IGluIHRoZVxuICAgICAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICAvKiogRnVuY3Rpb24gdG8gY3JlYXRlIGFuIE9iamVjdCBpbnRvIHdoaWNoIGRlY29kZWQgcHJvcGVydGllcyB3aWxsXG4gICAgICogYmUgd3JpdHRlbi5cbiAgICAgKlxuICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICogaW5zdGFuY2VzLCB3aGljaCBtZWFuczpcbiAgICAgKiAqIHtAbGluayBTdHJ1Y3R1cmV9XG4gICAgICogKiB7QGxpbmsgVW5pb259XG4gICAgICogKiB7QGxpbmsgVmFyaWFudExheW91dH1cbiAgICAgKiAqIHtAbGluayBCaXRTdHJ1Y3R1cmV9XG4gICAgICpcbiAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGVzZSBsYXlvdXRzXG4gICAgICogd2lsbCBiZSBPYmplY3QgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBiaW5kQ29uc3RydWN0b3JMYXlvdXR9LlxuICAgICAqL1xuICAgIG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNwYW4gb2YgYSBzcGVjaWZpYyBpbnN0YW5jZSBvZiBhIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYiAtIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyBhbiBlbmNvZGVkIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBpbnN0YW5jZVxuICAgICAqIHN0YXJ0cy4gIElmIGFic2VudCBhIHplcm8gb2Zmc2V0IGlzIGluZmVycmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgY292ZXJlZCBieSB0aGUgbGF5b3V0XG4gICAgICogaW5zdGFuY2UuICBJZiB0aGlzIG1ldGhvZCBpcyBub3Qgb3ZlcnJpZGRlbiBpbiBhIHN1YmNsYXNzIHRoZVxuICAgICAqIGRlZmluaXRpb24tdGltZSBjb25zdGFudCB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gLSBpZiB0aGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZSBjYW5ub3QgYmVcbiAgICAgKiBkZXRlcm1pbmVkLlxuICAgICAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICgwID4gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXRlcm1pbmF0ZSBzcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGljYXRlIHRoZSBsYXlvdXQgdXNpbmcgYSBuZXcgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBnZXQgYSBzdHJ1Y3R1cmFsbHktZXF1aXZhbGVudCBsYXlvdXRcbiAgICAgKiB3aXRoIGEgZGlmZmVyZW50IG5hbWUgc2luY2UgYWxsIHtAbGluayBMYXlvdXR9IGluc3RhbmNlcyBhcmVcbiAgICAgKiBpbW11dGFibGUuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGlzIGEgc2hhbGxvdyBjb3B5LiAgQWxsIGZpZWxkcyBleGNlcHQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSBhcmUgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIG9yaWdpbiBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgdmFsdWUgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gaW4gdGhlIHJlcGxpY2EuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TGF5b3V0fSAtIHRoZSBjb3B5IHdpdGgge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX1cbiAgICAgKiBzZXQgdG8gYHByb3BlcnR5YC5cbiAgICAgKi9cbiAgICByZXBsaWNhdGUocHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihydiwgdGhpcyk7XG4gICAgICAgIHJ2LnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9iamVjdCBmcm9tIGxheW91dCBwcm9wZXJ0aWVzIGFuZCBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgaW52b2tlZCBvbiBhIGxheW91dFxuICAgICAqIHRoYXQgZG9lcyBub3QgcmV0dXJuIGl0cyB2YWx1ZSBhcyBhbiBPYmplY3QuICBPYmplY3RzIGFyZVxuICAgICAqIHJldHVybmVkIGZvciB0aGluZ3MgdGhhdCBhcmUgYSB7QGxpbmsgU3RydWN0dXJlfSwgd2hpY2ggaW5jbHVkZXNcbiAgICAgKiB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IGlmIHRoZXkgYXJlIHN0cnVjdHVyZXMsIGFuZFxuICAgICAqIGV4Y2x1ZGVzIHtAbGluayBVbmlvbn1zLiAgSWYgeW91IHdhbnQgdGhpcyBmZWF0dXJlIGZvciBhIHVuaW9uXG4gICAgICogeW91IG11c3QgdXNlIHtAbGluayBVbmlvbi5nZXRWYXJpYW50fGdldFZhcmlhbnR9IHRvIHNlbGVjdCB0aGVcbiAgICAgKiBkZXNpcmVkIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIGFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gICAgICogZGVmYXVsdCBvcmRlciBmb3IgcHJvcGVydGllcy4gIEFzIHdpdGgge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfVxuICAgICAqIGxheW91dCBlbGVtZW50cyB0aGF0IGhhdmUgbm8gcHJvcGVydHkgbmFtZSBhcmUgc2tpcHBlZCB3aGVuXG4gICAgICogaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IHZhbHVlcy4gIE9ubHkgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIGFzc2lnbmVkOyBhcmd1bWVudHMgYXJlIG5vdCBhc3NpZ25lZCB0byBwcm9wZXJ0aWVzIG9mIGNvbnRhaW5lZFxuICAgICAqIGxheW91dHMuICBBbnkgdW51c2VkIHZhbHVlcyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyhPYmplY3R8dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5MYXlvdXQgPSBMYXlvdXQ7XG4vKiBQcm92aWRlIHRleHQgdGhhdCBjYXJyaWVzIGEgbmFtZSAoc3VjaCBhcyBmb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAqIGJlIHRocm93aW5nIGFuIGVycm9yKSBhbm5vdGF0ZWQgd2l0aCB0aGUgcHJvcGVydHkgb2YgYSBnaXZlbiBsYXlvdXRcbiAqIChzdWNoIGFzIG9uZSBmb3Igd2hpY2ggdGhlIHZhbHVlIHdhcyB1bmFjY2VwdGFibGUpLlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIG5hbWVXaXRoUHJvcGVydHkobmFtZSwgbG8pIHtcbiAgICBpZiAobG8ucHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAnWycgKyBsby5wcm9wZXJ0eSArICddJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnRzLm5hbWVXaXRoUHJvcGVydHkgPSBuYW1lV2l0aFByb3BlcnR5O1xuLyoqXG4gKiBBdWdtZW50IGEgY2xhc3Mgc28gdGhhdCBpbnN0YW5jZXMgY2FuIGJlIGVuY29kZWQvZGVjb2RlZCB1c2luZyBhXG4gKiBnaXZlbiBsYXlvdXQuXG4gKlxuICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGNvdXBsZXMgYENsYXNzYCB3aXRoIGBsYXlvdXRgIGluIHNldmVyYWwgd2F5czpcbiAqXG4gKiAqIGBDbGFzcy5sYXlvdXRfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbCB0byBgbGF5b3V0YDtcbiAqICogYGxheW91dC5ib3VuZENvbnN0cnVjdG9yX2AgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgcHJvcGVydHkgZXF1YWxcbiAqICAgIHRvIGBDbGFzc2A7XG4gKiAqIFRoZSB7QGxpbmsgTGF5b3V0I21ha2VEZXN0aW5hdGlvbk9iamVjdHxtYWtlRGVzdGluYXRpb25PYmplY3QoKX1cbiAqICAgcHJvcGVydHkgb2YgYGxheW91dGAgaXMgc2V0IHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYG5ld1xuICogICBDbGFzcygpYDtcbiAqICogYENsYXNzLmRlY29kZShiLCBvZmZzZXQpYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBmdW5jdGlvbiB0aGF0XG4gKiAgIGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxsYXlvdXQuZGVjb2RlfS4gIFRoZVxuICogICBzeW50aGVzaXplZCBmdW5jdGlvbiBtYXkgYmUgY2FwdHVyZWQgYW5kIGV4dGVuZGVkLlxuICogKiBgQ2xhc3MucHJvdG90eXBlLmVuY29kZShiLCBvZmZzZXQpYCBwcm92aWRlcyBhbiBpbnN0YW5jZSBtZW1iZXJcbiAqICAgZnVuY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgdG8ge0BsaW5rIExheW91dCNlbmNvZGV8bGF5b3V0LmVuY29kZX1cbiAqICAgd2l0aCBgc3JjYCBzZXQgdG8gYHRoaXNgLiAgVGhlIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZVxuICogICBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQsIGJ1dCB3aGVuIHRoZSBleHRlbnNpb24gaXMgaW52b2tlZCBgdGhpc2BcbiAqICAgbXVzdCBiZSBleHBsaWNpdGx5IGJvdW5kIHRvIHRoZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2NsYXNzfSBDbGFzcyAtIGEgSmF2YVNjcmlwdCBjbGFzcyB3aXRoIGEgbnVsbGFyeVxuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIHRoZSB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSB1c2VkIHRvIGVuY29kZVxuICogaW5zdGFuY2VzIG9mIGBDbGFzc2AuXG4gKi9cbi8vIGBDbGFzc2AgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIEZ1bmN0aW9uLCBidXQgdGhlIGFzc2lnbm1lbnQgb2YgYSBgbGF5b3V0X2AgcHJvcGVydHkgdG8gaXQgbWFrZXMgaXQgZGlmZmljdWx0IHRvIHR5cGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBiaW5kQ29uc3RydWN0b3JMYXlvdXQoQ2xhc3MsIGxheW91dCkge1xuICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgQ2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2xhc3MgbXVzdCBiZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKENsYXNzLCAnbGF5b3V0XycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3MgaXMgYWxyZWFkeSBib3VuZCB0byBhIGxheW91dCcpO1xuICAgIH1cbiAgICBpZiAoIShsYXlvdXQgJiYgKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGF5b3V0LCAnYm91bmRDb25zdHJ1Y3Rvcl8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheW91dCBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgQ2xhc3MubGF5b3V0XyA9IGxheW91dDtcbiAgICBsYXlvdXQuYm91bmRDb25zdHJ1Y3Rvcl8gPSBDbGFzcztcbiAgICBsYXlvdXQubWFrZURlc3RpbmF0aW9uT2JqZWN0ID0gKCgpID0+IG5ldyBDbGFzcygpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCAnZW5jb2RlJywge1xuICAgICAgICB2YWx1ZShiLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXQuZW5jb2RlKHRoaXMsIGIsIG9mZnNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgJ2RlY29kZScsIHtcbiAgICAgICAgdmFsdWUoYiwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuYmluZENvbnN0cnVjdG9yTGF5b3V0ID0gYmluZENvbnN0cnVjdG9yTGF5b3V0O1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBiZWhhdmVzIGxpa2UgYSBsYXlvdXQgYnV0IGRvZXMgbm90IGNvbnN1bWUgc3BhY2VcbiAqIHdpdGhpbiBpdHMgY29udGFpbmluZyBsYXlvdXQuXG4gKlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byBvYnRhaW4gbWV0YWRhdGEgYWJvdXQgYSBtZW1iZXIsIHN1Y2ggYXMgYVxuICoge0BsaW5rIE9mZnNldExheW91dH0gdGhhdCBjYW4gcHJvdmlkZSBkYXRhIGFib3V0IGEge0BsaW5rXG4gKiBMYXlvdXQjZ2V0U3Bhbnx2YWx1ZS1zcGVjaWZpYyBzcGFufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB7QGxpbmtcbiAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudH0gb3Igb3RoZXIge0BsaW5rIExheW91dH0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEV4dGVybmFsTGF5b3V0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmZiB0aGUgZXh0ZXJuYWwgbGF5b3V0IGRlY29kZXMgdG8gYW4gdW5zaWduZWRcbiAgICAgKiBpbnRlZ2VyIGxheW91dC5cbiAgICAgKlxuICAgICAqIEluIHRoYXQgY2FzZSBpdCBjYW4gYmUgdXNlZCBhcyB0aGUgc291cmNlIG9mIHtAbGlua1xuICAgICAqIFNlcXVlbmNlI2NvdW50fFNlcXVlbmNlIGNvdW50c30sIHtAbGluayBCbG9iI2xlbmd0aHxCbG9iIGxlbmd0aHN9LFxuICAgICAqIG9yIGFzIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGV4dGVybmFsIHVuaW9uXG4gICAgICogZGlzY3JpbWluYXRvcnN9LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlcm5hbExheW91dCBpcyBhYnN0cmFjdCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZXJuYWxMYXlvdXQgPSBFeHRlcm5hbExheW91dDtcbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IGRldGVybWluZXMgaXRzIHtAbGlua1xuICogTGF5b3V0I2RlY29kZXx2YWx1ZX0gYmFzZWQgb24gb2Zmc2V0IGludG8gYW5kIGxlbmd0aCBvZiB0aGUgYnVmZmVyXG4gKiBvbiB3aGljaCBpdCBpcyBpbnZva2VkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZ3JlZWR5fGdyZWVkeX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2VsZW1lbnRTcGFuXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEdyZWVkeUNvdW50I2VsZW1lbnRTcGFufGVsZW1lbnRTcGFufS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtFeHRlcm5hbExheW91dH1cbiAqL1xuY2xhc3MgR3JlZWR5Q291bnQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFNwYW4gPSAxLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKGVsZW1lbnRTcGFuKSkgfHwgKDAgPj0gZWxlbWVudFNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50U3BhbiBtdXN0IGJlIGEgKHBvc2l0aXZlKSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIHNlcXVlbmNlLiAgVGhlIHZhbHVlXG4gICAgICAgICAqIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiAgSWYgbm90IHByb3ZpZGVkLCB0aGUgdmFsdWUgd2lsbCBiZVxuICAgICAgICAgKiAxLiAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRTcGFuID0gZWxlbWVudFNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgY29uc3QgcmVtID0gYi5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJlbSAvIHRoaXMuZWxlbWVudFNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JlZWR5Q291bnQgPSBHcmVlZHlDb3VudDtcbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IHN1cHBvcnRzIGFjY2Vzc2luZyBhIHtAbGluayBMYXlvdXR9XG4gKiBhdCBhIGZpeGVkIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBhbm90aGVyIExheW91dC4gIFRoZSBvZmZzZXQgbWF5XG4gKiBiZSBiZWZvcmUsIHdpdGhpbiwgb3IgYWZ0ZXIgdGhlIGJhc2UgbGF5b3V0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQub2Zmc2V0fG9mZnNldH1cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I2xheW91dHxsYXlvdXR9LCBtb2R1bG8gYHByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF0gLSBJbml0aWFsaXplcyB7QGxpbmtcbiAqIE9mZnNldExheW91dCNvZmZzZXR8b2Zmc2V0fS4gIERlZmF1bHRzIHRvIHplcm8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBPcHRpb25hbCBuZXcgcHJvcGVydHkgbmFtZSBmb3IgYVxuICoge0BsaW5rIExheW91dCNyZXBsaWNhdGV8IHJlcGxpY2F9IG9mIGBsYXlvdXRgIHRvIGJlIHVzZWQgYXMge0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjbGF5b3V0fGxheW91dH0uICBJZiBub3QgcHJvdmlkZWQgdGhlIGBsYXlvdXRgIGlzIHVzZWRcbiAqIHVuY2hhbmdlZC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgT2Zmc2V0TGF5b3V0IGV4dGVuZHMgRXh0ZXJuYWxMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgb2Zmc2V0ID0gMCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgaW50ZWdlciBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihsYXlvdXQuc3BhbiwgcHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBzdWJvcmRpbmF0ZWQgbGF5b3V0LiAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgLyoqIFRoZSBsb2NhdGlvbiBvZiB7QGxpbmsgT2Zmc2V0TGF5b3V0I2xheW91dH0gcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIHN0YXJ0IG9mIGFub3RoZXIgbGF5b3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdmFsdWUgbWF5IGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCBidXQgYW4gZXJyb3Igd2lsbCB0aHJvd25cbiAgICAgICAgICogaWYgYXQgdGhlIHBvaW50IG9mIHVzZSBpdCBnb2VzIG91dHNpZGUgdGhlIHNwYW4gb2YgdGhlIFVpbnQ4QXJyYXlcbiAgICAgICAgICogYmVpbmcgYWNjZXNzZWQuICAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGlzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMubGF5b3V0IGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8ICh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnRCRSkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUoc3JjLCBiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0cy5PZmZzZXRMYXlvdXQgPSBPZmZzZXRMYXlvdXQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8dTh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUxNnx1MTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8dTI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MzJ8dTMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwfHU0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTQ4fHU0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkVUludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlVUludExFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuVUludCA9IFVJbnQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudThiZXx1OGJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnUxNmJlfHUxNmJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0YmV8dTI0YmV9LFxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyYmV8dTMyYmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQudTQwYmV8dTQwYmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDhiZXx1NDhiZX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRVSW50QkUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVVSW50QkUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5VSW50QkUgPSBVSW50QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczh8czh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnMxNnxzMTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjR8czI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMzJ8czMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQwfHM0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczQ4fHM0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUludExFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ID0gSW50O1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4YmV8czhiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC5zMTZiZXxzMTZiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMyNGJlfHMyNGJlfSxcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMmJlfHMzMmJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnM0MGJlfHM0MGJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQ4YmV8czQ4YmV9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRJbnRCRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50QkUgPSBJbnRCRTtcbmNvbnN0IFYyRTMyID0gTWF0aC5wb3coMiwgMzIpO1xuLyogVHJ1ZSBtb2R1bHVzIGhpZ2ggYW5kIGxvdyAzMi1iaXQgd29yZHMsIHdoZXJlIGxvdyB3b3JkIGlzIGFsd2F5c1xuICogbm9uLW5lZ2F0aXZlLiAqL1xuZnVuY3Rpb24gZGl2bW9kSW50NjQoc3JjKSB7XG4gICAgY29uc3QgaGkzMiA9IE1hdGguZmxvb3Ioc3JjIC8gVjJFMzIpO1xuICAgIGNvbnN0IGxvMzIgPSBzcmMgLSAoaGkzMiAqIFYyRTMyKTtcbiAgICByZXR1cm4geyBoaTMyLCBsbzMyIH07XG59XG4vKiBSZWNvbnN0cnVjdCBOdW1iZXIgZnJvbSBxdW90aWVudCBhbmQgbm9uLW5lZ2F0aXZlIHJlbWFpbmRlciAqL1xuZnVuY3Rpb24gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpIHtcbiAgICByZXR1cm4gaGkzMiAqIFYyRTMyICsgbG8zMjtcbn1cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0fG51NjR9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJVSW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5sbzMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5oaTMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFyVUludDY0ID0gTmVhclVJbnQ2NDtcbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0YmV8bnU2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFyVUludDY0QkUgPSBOZWFyVUludDY0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NHxuczY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhckludDY0ID0gTmVhckludDY0O1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjRiZXxuczY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZEludDMyQkUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJJbnQ2NEJFID0gTmVhckludDY0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJ8ZjMyfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRmxvYXQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEZsb2F0TEUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRmxvYXRMRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbmV4cG9ydHMuRmxvYXQgPSBGbG9hdDtcbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMmJlfGYzMmJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRmxvYXRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRmxvYXRCRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVGbG9hdEJFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxufVxuZXhwb3J0cy5GbG9hdEJFID0gRmxvYXRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmY2NHxmNjR9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBEb3VibGUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZERvdWJsZUxFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZURvdWJsZUxFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3VibGUgPSBEb3VibGU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mNjRiZXxmNjRiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIERvdWJsZUJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWREb3VibGVCRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVEb3VibGVCRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuRG91YmxlQkUgPSBEb3VibGVCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgY29udGlndW91cyBzZXF1ZW5jZSBvZiBhIHNwZWNpZmljIGxheW91dCBhcyBhbiBBcnJheS5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnNlcXxzZXF9XG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGVsZW1lbnRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTZXF1ZW5jZSNlbGVtZW50TGF5b3V0fGVsZW1lbnRMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7KE51bWJlcnxFeHRlcm5hbExheW91dCl9IGNvdW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjY291bnR8Y291bnR9LiAgVGhlIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBhIHBvc2l0aXZlXG4gKiBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mIHtAbGluayBFeHRlcm5hbExheW91dH0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBTZXF1ZW5jZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKGVsZW1lbnRMYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50TGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpICYmIGNvdW50LmlzQ291bnQoKSlcbiAgICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGNvdW50KSAmJiAoMCA8PSBjb3VudCkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY291bnQgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmICgoIShjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSlcbiAgICAgICAgICAgICYmICgwIDwgZWxlbWVudExheW91dC5zcGFuKSkge1xuICAgICAgICAgICAgc3BhbiA9IGNvdW50ICogZWxlbWVudExheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIHNlcXVlbmNlLiAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRMYXlvdXQgPSBlbGVtZW50TGF5b3V0O1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSBlaXRoZXIgYSBub24tbmVnYXRpdmUgaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZlxuICAgICAgICAgKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IGZvciB3aGljaCB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9IGlzIGB0cnVlYC4gKi9cbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwIDwgdGhpcy5lbGVtZW50TGF5b3V0LnNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSBjb3VudCAqIHRoaXMuZWxlbWVudExheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IHRoaXMuZWxlbWVudExheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIHNwYW4pO1xuICAgICAgICAgICAgICAgICsraWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgcnYgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICBydi5wdXNoKHRoaXMuZWxlbWVudExheW91dC5kZWNvZGUoYiwgb2Zmc2V0KSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFNlcXVlbmNlfS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIGBzcmNgIGlzIHNob3J0ZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZW5cbiAgICAgKiB0aGUgdW51c2VkIHNwYWNlIGluIHRoZSBidWZmZXIgaXMgbGVmdCB1bmNoYW5nZWQuICBJZiBgc3JjYCBpc1xuICAgICAqIGxvbmdlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlIHVubmVlZGVkIGVsZW1lbnRzIGFyZVxuICAgICAqIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZWxvID0gdGhpcy5lbGVtZW50TGF5b3V0O1xuICAgICAgICBjb25zdCBzcGFuID0gc3JjLnJlZHVjZSgoc3BhbiwgdikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNwYW4gKyBlbG8uZW5jb2RlKHYsIGIsIG9mZnNldCArIHNwYW4pO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudC5lbmNvZGUoc3JjLmxlbmd0aCwgYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlNlcXVlbmNlID0gU2VxdWVuY2U7XG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYXJiaXRyYXJ5IGxheW91dCBlbGVtZW50cyBhcyBhblxuICogT2JqZWN0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc3RydWN0fHN0cnVjdH1cbiAqXG4gKiAqKk5PVEUqKiBUaGUge0BsaW5rIExheW91dCNzcGFufHNwYW59IG9mIHRoZSBzdHJ1Y3R1cmUgaXMgdmFyaWFibGVcbiAqIGlmIGFueSBsYXlvdXQgaW4ge0BsaW5rIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfSBoYXMgYSB2YXJpYWJsZVxuICogc3Bhbi4gIFdoZW4ge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2Rpbmd9IHdlIG11c3QgaGF2ZSBhIHZhbHVlIGZvclxuICogYWxsIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMsIG9yIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gZmlndXJlIG91dFxuICogaG93IG11Y2ggc3BhY2UgdG8gdXNlIGZvciBzdG9yYWdlLiAgV2UgY2FuIG9ubHkgaWRlbnRpZnkgdGhlIHZhbHVlXG4gKiBmb3IgYSBmaWVsZCB3aGVuIGl0IGhhcyBhIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LiAgQXNcbiAqIHN1Y2gsIGFsdGhvdWdoIGEgc3RydWN0dXJlIG1heSBjb250YWluIGJvdGggdW5uYW1lZCBmaWVsZHMgYW5kXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBpdCBjYW5ub3QgY29udGFpbiBhbiB1bm5hbWVkXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGQuXG4gKlxuICogQHBhcmFtIHtMYXlvdXRbXX0gZmllbGRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU3RydWN0dXJlI2ZpZWxkc3xmaWVsZHN9LiAgQW4gZXJyb3IgaXMgcmFpc2VkIGlmIHRoaXMgY29udGFpbnMgYVxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkIGZvciB3aGljaCBhIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gKiBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZGVjb2RlUHJlZml4ZXNdIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU3RydWN0dXJlI2RlY29kZVByZWZpeGVzfHByb3BlcnR5fS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgZmllbGRzYCBjb250YWlucyBhbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aFxuICogbGF5b3V0LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBTdHJ1Y3R1cmUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSB7XG4gICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoZmllbGRzKVxuICAgICAgICAgICAgJiYgZmllbGRzLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgJiYgKHYgaW5zdGFuY2VvZiBMYXlvdXQpLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpZWxkcyBtdXN0IGJlIGFycmF5IG9mIExheW91dCBpbnN0YW5jZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdib29sZWFuJyA9PT0gdHlwZW9mIHByb3BlcnR5KVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZGVjb2RlUHJlZml4ZXMpKSB7XG4gICAgICAgICAgICBkZWNvZGVQcmVmaXhlcyA9IHByb3BlcnR5O1xuICAgICAgICAgICAgcHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogVmVyaWZ5IGFic2VuY2Ugb2YgdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKCgwID4gZmQuc3BhbilcbiAgICAgICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBmZC5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkcyBjYW5ub3QgY29udGFpbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBsYXlvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BhbiA9IGZpZWxkcy5yZWR1Y2UoKHNwYW4sIGZkKSA9PiBzcGFuICsgZmQuZ2V0U3BhbigpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBMYXlvdXR9IHZhbHVlcyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAgICAgKiBzdHJ1Y3R1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIG5lZWQgbm90IGJlIHRoZSBzYW1lIHR5cGUsIGFuZCBtYXkgYmVcbiAgICAgICAgICogZWl0aGVyIHNjYWxhciBvciBhZ2dyZWdhdGUgbGF5b3V0cy4gIElmIGEgbWVtYmVyIGxheW91dCBsZWF2ZXNcbiAgICAgICAgICogaXRzIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHVuZGVmaW5lZCB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgICAgICogd2lsbCBub3QgYmUgbXV0YXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0xheW91dFtdfSAqL1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgLyoqIENvbnRyb2wgYmVoYXZpb3Igb2Yge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlKCl9IGdpdmVuIHNob3J0XG4gICAgICAgICAqIGJ1ZmZlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIHNvbWUgc2l0dWF0aW9ucyBhIHN0cnVjdHVyZSBtYW55IGJlIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbFxuICAgICAgICAgKiBmaWVsZHMgb3ZlciB0aW1lLCB3aXRoIG9sZGVyIGluc3RhbGxhdGlvbnMgcHJvdmlkaW5nIG9ubHkgYVxuICAgICAgICAgKiBwcmVmaXggb2YgdGhlIGZ1bGwgc3RydWN0dXJlLiAgSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWBcbiAgICAgICAgICogZGVjb2Rpbmcgd2lsbCBhY2NlcHQgdGhvc2UgYnVmZmVycyBhbmQgbGVhdmUgc3Vic2VxdWVudCBmaWVsZHNcbiAgICAgICAgICogdW5kZWZpbmVkLCBhcyBsb25nIGFzIHRoZSBidWZmZXIgZW5kcyBhdCBhIGZpZWxkIGJvdW5kYXJ5LlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiAqL1xuICAgICAgICB0aGlzLmRlY29kZVByZWZpeGVzID0gISFkZWNvZGVQcmVmaXhlcztcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMuZmllbGRzLnJlZHVjZSgoc3BhbiwgZmQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmc3AgPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZzcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhbiArIGZzcDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXRlcm1pbmF0ZSBzcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gZmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlUHJlZml4ZXNcbiAgICAgICAgICAgICAgICAmJiAoYi5sZW5ndGggPT09IG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU3RydWN0dXJlfS5cbiAgICAgKlxuICAgICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUgY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBpc1xuICAgICAqIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBsYXN0V3JvdGUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGZkLnNwYW47XG4gICAgICAgICAgICBsYXN0V3JvdGUgPSAoMCA8IHNwYW4pID8gc3BhbiA6IDA7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ2ID0gc3JjW2ZkLnByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0V3JvdGUgPSBmZC5lbmNvZGUoZnYsIGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVhZCB0aGUgYXMtZW5jb2RlZCBzcGFuLCB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzYW1lIGFzIHdoYXQgd2Ugd3JvdGUuICovXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuID0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCArPSBzcGFuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFVzZSAobGFzdE9mZnNldCArIGxhc3RXcm90ZSkgaW5zdGVhZCBvZiBvZmZzZXQgYmVjYXVzZSB0aGUgbGFzdFxuICAgICAgICAgKiBpdGVtIG1heSBoYXZlIGhhZCBhIGR5bmFtaWMgbGVuZ3RoIGFuZCB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgICAgICAgICogdGhlIHBhZGRpbmcgYmV0d2VlbiBpdCBhbmQgdGhlIGVuZCBvZiB0aGUgc3BhY2UgcmVzZXJ2ZWQgZm9yXG4gICAgICAgICAqIGl0LiAqL1xuICAgICAgICByZXR1cm4gKGxhc3RPZmZzZXQgKyBsYXN0V3JvdGUpIC0gZmlyc3RPZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpXG4gICAgICAgICAgICAgICAgJiYgKDAgPCB2YWx1ZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gdmFsdWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2Nlc3MgdG8gdGhlIGxheW91dCBvZiBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtMYXlvdXR9IC0gdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBsYXlvdXRGb3IocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG9mZnNldCBvZiBhIHN0cnVjdHVyZSBtZW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgc3RydWN0dXJlIG1lbWJlciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgb2Zmc2V0IGluIGJ5dGVzIHRvIHRoZSBzdGFydCBvZiBgcHJvcGVydHlgXG4gICAgICogd2l0aGluIHRoZSBzdHJ1Y3R1cmUsIG9yIHVuZGVmaW5lZCBpZiBgcHJvcGVydHlgIGlzIG5vdCBhIGZpZWxkXG4gICAgICogd2l0aGluIHRoZSBzdHJ1Y3R1cmUuICBJZiB0aGUgcHJvcGVydHkgaXMgYSBtZW1iZXIgYnV0IGZvbGxvd3MgYVxuICAgICAqIHZhcmlhYmxlLWxlbmd0aCBzdHJ1Y3R1cmUgbWVtYmVyIGEgbmVnYXRpdmUgbnVtYmVyIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBvZmZzZXRPZihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCA+IGZkLnNwYW4pIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKDAgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZkLnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlN0cnVjdHVyZSA9IFN0cnVjdHVyZTtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHByb3ZpZGUgYSB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gQVBJIGZvciB7QGxpbmsgVW5pb259LlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHRoZSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNlbmNvZGV8ZW5jb2RlfSBvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBEZWZhdWx0IGZvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0byBiZSB1c2VkIHdoZW4gdGhlXG4gICAgICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgcmVmZXJlbmNlZCBpbiBpc29sYXRpb24gKGdlbmVyYWxseSB3aGVuIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWNvZGV8VW5pb24gZGVjb2RlfSBjYW5ub3QgZGVsZWdhdGUgdG8gYSBzcGVjaWZpY1xuICAgICAgICAgKiB2YXJpYW50KS4gKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBkZWNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCByZWZlcmVuY2UgdGhlIGJ1ZmZlciBpZlxuICAgICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdCcpO1xuICAgIH1cbiAgICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBlbmNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCBzdG9yZSB0aGUgdmFsdWUgaWZcbiAgICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIG1haW50YWluZWQgdGhyb3VnaCBvdGhlciBtZWFucy4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uRGlzY3JpbWluYXRvciA9IFVuaW9uRGlzY3JpbWluYXRvcjtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHByb3ZpZGUgYSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yIEFQSX0gZm9yIHtAbGluayBVbmlvbn0gdXNpbmcgYW5cbiAqIHVuc2lnbmVkIGludGVncmFsIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIGxvY2F0ZWQgZWl0aGVyIGluc2lkZSBvclxuICogb3V0c2lkZSB0aGUgdW5pb24uXG4gKlxuICogQHBhcmFtIHtFeHRlcm5hbExheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICBNdXN0IHNhdGlzZnkge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBEZWZhdWx0IGZvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0sIHN1cGVyc2VkaW5nIHRoZSBwcm9wZXJ0eVxuICogZnJvbSBgbGF5b3V0YCwgYnV0IGRlZmF1bHRpbmcgdG8gYHZhcmlhbnRgIGlmIG5laXRoZXIgYHByb3BlcnR5YFxuICogbm9yIGxheW91dCBwcm92aWRlIGEgcHJvcGVydHkgbmFtZS5cbiAqXG4gKiBAYXVnbWVudHMge1VuaW9uRGlzY3JpbWluYXRvcn1cbiAqL1xuY2xhc3MgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yIGV4dGVuZHMgVW5pb25EaXNjcmltaW5hdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKChsYXlvdXQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICYmIGxheW91dC5pc0NvdW50KCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5IHx8ICd2YXJpYW50Jyk7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB1c2VkIHRvIGFjY2VzcyB0aGUgZGlzY3JpbWluYXRvclxuICAgICAgICAgKiB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSBkZWNvZGluZyB0byB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUgZW5jb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSBVbmlvbkxheW91dERpc2NyaW1pbmF0b3I7XG4vKipcbiAqIFJlcHJlc2VudCBhbnkgbnVtYmVyIG9mIHNwYW4tY29tcGF0aWJsZSBsYXlvdXRzLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudW5pb258dW5pb259XG4gKlxuICogSWYgdGhlIHVuaW9uIGhhcyBhIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSB0aGF0XG4gKiBsYXlvdXQgbXVzdCBoYXZlIGEgbm9uLW5lZ2F0aXZlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS4gIFRoZSBzcGFuXG4gKiBvZiBhIGZpeGVkLXNwYW4gdW5pb24gaW5jbHVkZXMgaXRzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBpZiB0aGUgdmFyaWFudCBpcyBhIHtAbGlua1xuICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8cHJlZml4IG9mIHRoZSB1bmlvbn0sIHBsdXMgdGhlIHNwYW5cbiAqIG9mIGl0cyB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uXG4gKlxuICogSWYgdGhlIHVuaW9uIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IGxheW91dCB0aGVuIHRoZSBlbmNvZGVkIHNwYW5cbiAqIG9mIHRoZSB1bmlvbiBkZXBlbmRzIG9uIHRoZSBlbmNvZGVkIHNwYW4gb2YgaXRzIHZhcmlhbnQgKHdoaWNoIG1heVxuICogYmUgZml4ZWQgb3IgdmFyaWFibGUpLlxuICpcbiAqIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxWYXJpYW50IGxheW91dH1zIGFyZSBhZGRlZCB0aHJvdWdoXG4gKiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fS4gIElmIHRoZSB1bmlvbiBoYXMgYSBkZWZhdWx0XG4gKiBsYXlvdXQsIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0XG4gKiBjb250YWluZWQgYnkgdGhlIHZhcmlhbnR9IG11c3Qgbm90IGV4Y2VlZCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSAobWludXMgdGhlIHNwYW4gb2YgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBkaXNyaW1pbmF0b3J9LCBpZiB1c2VkKS4gIFRoZVxuICogc3BhbiBvZiB0aGUgdmFyaWFudCB3aWxsIGVxdWFsIHRoZSBzcGFuIG9mIHRoZSB1bmlvbiBpdHNlbGYuXG4gKlxuICogVGhlIHZhcmlhbnQgZm9yIGEgYnVmZmVyIGNhbiBvbmx5IGJlIGlkZW50aWZpZWQgZnJvbSB0aGUge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI3Byb3BlcnR5fHByb3BlcnR5fSAoaW4gdGhlIGNhc2Ugb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0pLCBvciBieSB1c2luZyB7QGxpbmtcbiAqIFVuaW9uI2dldFZhcmlhbnR8Z2V0VmFyaWFudH0gYW5kIGV4YW1pbmluZyB0aGUgcmVzdWx0aW5nIHtAbGlua1xuICogVmFyaWFudExheW91dH0gaW5zdGFuY2UuXG4gKlxuICogQSB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBhIEphdmFTY3JpcHQgb2JqZWN0IGNhbiBiZSBpZGVudGlmaWVkXG4gKiB1c2luZyB7QGxpbmsgVW5pb24jZ2V0U291cmNlVmFyaWFudHxnZXRTb3VyY2VWYXJpYW50fS5cbiAqXG4gKiBAcGFyYW0geyhVbmlvbkRpc2NyaW1pbmF0b3J8RXh0ZXJuYWxMYXlvdXR8TGF5b3V0KX0gZGlzY3IgLSBIb3cgdG9cbiAqIGlkZW50aWZ5IHRoZSBsYXlvdXQgdXNlZCB0byBpbnRlcnByZXQgdGhlIHVuaW9uIGNvbnRlbnRzLiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSwgYW5cbiAqIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBzYXRpc2ZpZXMge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0sIG9yIHtAbGluayBVSW50fSAob3Ige0BsaW5rXG4gKiBVSW50QkV9KS4gIFdoZW4gYSBub24tZXh0ZXJuYWwgbGF5b3V0IGVsZW1lbnQgaXMgcGFzc2VkIHRoZSBsYXlvdXRcbiAqIGFwcGVhcnMgYXQgdGhlIHN0YXJ0IG9mIHRoZSB1bmlvbi4gIEluIGFsbCBjYXNlcyB0aGUgKHN5bnRoZXNpemVkKVxuICoge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0gaW5zdGFuY2UgaXMgcmVjb3JkZWQgYXMge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LlxuICpcbiAqIEBwYXJhbSB7KExheW91dHxudWxsKX0gZGVmYXVsdExheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdExheW91dH0uICBJZiBhYnNlbnQgZGVmYXVsdHMgdG8gYG51bGxgLlxuICogSWYgYG51bGxgIHRoZXJlIGlzIG5vIGRlZmF1bHQgbGF5b3V0OiB0aGUgdW5pb24gaGFzIGRhdGEtZGVwZW5kZW50XG4gKiBsZW5ndGggYW5kIGF0dGVtcHRzIHRvIGRlY29kZSBvciBlbmNvZGUgdW5yZWNvZ25pemVkIHZhcmlhbnRzIHdpbGxcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gIEEge0BsaW5rIExheW91dH0gaW5zdGFuY2UgbXVzdCBoYXZlIGFcbiAqIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0sIGFuZCBpZiBpdCBsYWNrcyBhIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9IHdpbGwgYmUgYSB7QGxpbmtcbiAqIExheW91dCNyZXBsaWNhdGV8cmVwbGljYX0gd2l0aCBwcm9wZXJ0eSBgY29udGVudGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVbmlvbiBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZGlzY3IsIGRlZmF1bHRMYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGxldCBkaXNjcmltaW5hdG9yO1xuICAgICAgICBpZiAoKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKG5ldyBPZmZzZXRMYXlvdXQoZGlzY3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGlzY3IgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICYmIGRpc2NyLmlzQ291bnQoKSkge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvciA9IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IoZGlzY3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZGlzY3IgaW5zdGFuY2VvZiBVbmlvbkRpc2NyaW1pbmF0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaXNjciBtdXN0IGJlIGEgVW5pb25EaXNjcmltaW5hdG9yICdcbiAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIGxheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvciA9IGRpc2NyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRMYXlvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKChudWxsID09PSBkZWZhdWx0TGF5b3V0KVxuICAgICAgICAgICAgfHwgKGRlZmF1bHRMYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVmYXVsdExheW91dCBtdXN0IGJlIG51bGwgb3IgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPT0gZGVmYXVsdExheW91dCkge1xuICAgICAgICAgICAgaWYgKDAgPiBkZWZhdWx0TGF5b3V0LnNwYW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBoYXZlIGNvbnN0YW50IHNwYW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGF5b3V0ID0gZGVmYXVsdExheW91dC5yZXBsaWNhdGUoJ2NvbnRlbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBUaGUgdW5pb24gc3BhbiBjYW4gYmUgZXN0aW1hdGVkIG9ubHkgaWYgdGhlcmUncyBhIGRlZmF1bHRcbiAgICAgICAgICogbGF5b3V0LiAgVGhlIHVuaW9uIHNwYW5zIGl0cyBkZWZhdWx0IGxheW91dCwgcGx1cyBhbnkgcHJlZml4XG4gICAgICAgICAqIHZhcmlhbnQgbGF5b3V0LiAgQnkgY29uc3RydWN0aW9uIGJvdGggbGF5b3V0cywgaWYgcHJlc2VudCwgaGF2ZVxuICAgICAgICAgKiBub24tbmVnYXRpdmUgc3Bhbi4gKi9cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgaWYgKGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIHNwYW4gPSBkZWZhdWx0TGF5b3V0LnNwYW47XG4gICAgICAgICAgICBpZiAoKDAgPD0gc3BhbikgJiYgKChkaXNjciBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKSkpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IGRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGludGVyZmFjZSBmb3IgdGhlIGRpc2NyaW1pbmF0b3IgdmFsdWUgaW4gaXNvbGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGEge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0gZWl0aGVyIHBhc3NlZCB0byB0aGVcbiAgICAgICAgICogY29uc3RydWN0b3Igb3Igc3ludGhlc2l6ZWQgZnJvbSB0aGUgYGRpc2NyYCBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBhcmd1bWVudC4gIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnx1c2VzUHJlZml4RGlzY3JpbWluYXRvcn0gd2lsbCBiZVxuICAgICAgICAgKiBgdHJ1ZWAgaWZmIHRoZSBgZGlzY3JgIHBhcmFtZXRlciB3YXMgYSBub24tb2Zmc2V0IHtAbGlua1xuICAgICAgICAgKiBMYXlvdXR9IGluc3RhbmNlLiAqL1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3IgPSBkaXNjcmltaW5hdG9yO1xuICAgICAgICAvKiogYHRydWVgIGlmIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBpcyB0aGVcbiAgICAgICAgICogZmlyc3QgZmllbGQgaW4gdGhlIHVuaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZmFsc2VgIHRoZSBkaXNjcmltaW5hdG9yIGlzIG9idGFpbmVkIGZyb20gc29tZXdoZXJlXG4gICAgICAgICAqIGVsc2UuICovXG4gICAgICAgIHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgPSAoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIG5vbi1kaXNjcmltaW5hdG9yIGNvbnRlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgbm90IHJlY29nbml6ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuICBJdCBpc1xuICAgICAgICAgKiBzdHJ1Y3R1cmFsbHkgZXF1aXZhbGVudCB0byB0aGUgc2Vjb25kIGNvbXBvbmVudCBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jbGF5b3V0fGxheW91dH0gYnV0IG1heSBoYXZlIGEgZGlmZmVyZW50IHByb3BlcnR5XG4gICAgICAgICAqIG5hbWUuICovXG4gICAgICAgIHRoaXMuZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQ7XG4gICAgICAgIC8qKiBBIHJlZ2lzdHJ5IG9mIGFsbG93ZWQgdmFyaWFudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBrZXlzIGFyZSB1bnNpZ25lZCBpbnRlZ2VycyB3aGljaCBzaG91bGQgYmUgY29tcGF0aWJsZSB3aXRoXG4gICAgICAgICAqIHtAbGluayBVbmlvbi5kaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LiAgVGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAqIGlzIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBWYXJpYW50TGF5b3V0fSBpbnN0YW5jZXMgYXNzaWduZWRcbiAgICAgICAgICogdG8gdGhpcyB1bmlvbiBieSB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogVGhlIHJlZ2lzdHJ5IHJlbWFpbnMgbXV0YWJsZSBzbyB0aGF0IHZhcmlhbnRzIGNhbiBiZVxuICAgICAgICAgKiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRlZH0gYXQgYW55IHRpbWUuICBVc2VycyBzaG91bGQgbm90XG4gICAgICAgICAqIG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4gKi9cbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgICAgICAvKiBQcml2YXRlIHZhcmlhYmxlIHVzZWQgd2hlbiBpbnZva2luZyBnZXRTb3VyY2VWYXJpYW50ICovXG4gICAgICAgIGxldCBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSB0aGlzLmRlZmF1bHRHZXRTb3VyY2VWYXJpYW50LmJpbmQodGhpcyk7XG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byBpbmZlciB0aGUgdmFyaWFudCBzZWxlY3RlZCBieSBhIHNvdXJjZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0gYnV0IG1heVxuICAgICAgICAgKiBiZSBvdmVycmlkZGVuIHVzaW5nIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNjb25maWdHZXRTb3VyY2VWYXJpYW50fGNvbmZpZ0dldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYXMgd2l0aCB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gVGhlIGRlZmF1bHQgdmFyaWFudFxuICAgICAgICAgKiAoYHVuZGVmaW5lZGApIG9yIGZpcnN0IHJlZ2lzdGVyZWQgdmFyaWFudCB0aGF0IHVzZXMgYSBwcm9wZXJ0eVxuICAgICAgICAgKiBhdmFpbGFibGUgaW4gYHNyY2AuICovXG4gICAgICAgIHRoaXMuZ2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHJldHVybiBib3VuZEdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEZ1bmN0aW9uIHRvIG92ZXJyaWRlIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZ2V0U291cmNlVmFyaWFudHxnZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIHRoaXMgaWYgdGhlIGRlc2lyZWQgdmFyaWFudCBjYW5ub3QgYmUgaWRlbnRpZmllZCB1c2luZyB0aGVcbiAgICAgICAgICogYWxnb3JpdGhtIG9mIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYm91bmQgdG8gdGhpc1xuICAgICAgICAgKiBVbmlvbiBpbnN0YW5jZSwgcHJvdmlkaW5nIGxvY2FsIGFjY2VzcyB0byB7QGxpbmtcbiAgICAgICAgICogVW5pb24jcmVnaXN0cnl8cmVnaXN0cnl9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnc3YgLSBhIGZ1bmN0aW9uIHRoYXQgZm9sbG93cyB0aGUgQVBJIG9mXG4gICAgICAgICAqIHtAbGluayBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uICovXG4gICAgICAgIHRoaXMuY29uZmlnR2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uIChnc3YpIHtcbiAgICAgICAgICAgIGJvdW5kR2V0U291cmNlVmFyaWFudCA9IGdzdi5iaW5kKHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBEZWZhdWx0IGxheW91dHMgYWx3YXlzIGhhdmUgbm9uLW5lZ2F0aXZlIHNwYW4sIHNvIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICogb25lIGFuZCB3ZSBoYXZlIHRvIHJlY29nbml6ZSB0aGUgdmFyaWFudCB3aGljaCB3aWxsIGluIHR1cm5cbiAgICAgICAgICogZGV0ZXJtaW5lIHRoZSBzcGFuLiAqL1xuICAgICAgICBjb25zdCB2bG8gPSB0aGlzLmdldFZhcmlhbnQoYiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCF2bG8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRldGVybWluZSBzcGFuIGZvciB1bnJlY29nbml6ZWQgdmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bG8uZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gaW5mZXIgYSByZWdpc3RlcmVkIFVuaW9uIHZhcmlhbnQgY29tcGF0aWJsZSB3aXRoIGBzcmNgLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHNhdGlzZmllZCBydWxlIGluIHRoZSBmb2xsb3dpbmcgc2VxdWVuY2UgZGVmaW5lcyB0aGVcbiAgICAgKiByZXR1cm4gdmFsdWU6XG4gICAgICogKiBJZiBgc3JjYCBoYXMgcHJvcGVydGllcyBtYXRjaGluZyB0aGUgVW5pb24gZGlzY3JpbWluYXRvciBhbmRcbiAgICAgKiAgIHRoZSBkZWZhdWx0IGxheW91dCwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5ICh0aGlzIGVuc3VyZXMgdGhlIGRlZmF1bHRcbiAgICAgKiAgIGxheW91dCB3aWxsIGJlIHVzZWQpO1xuICAgICAqICogSWYgYHNyY2AgaGFzIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IsIHRoZVxuICAgICAqICAgdmFsdWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgaWRlbnRpZmllcyBhIHJlZ2lzdGVyZWQgdmFyaWFudCwgYW5kXG4gICAgICogICBlaXRoZXIgKGEpIHRoZSB2YXJpYW50IGhhcyBubyBsYXlvdXQsIG9yIChiKSBgc3JjYCBoYXMgdGhlXG4gICAgICogICB2YXJpYW50J3MgcHJvcGVydHksIHRoZW4gdGhlIHZhcmlhbnQgaXMgcmV0dXJuZWQgKGJlY2F1c2UgdGhlXG4gICAgICogICBzb3VyY2Ugc2F0aXNmaWVzIHRoZSBjb25zdHJhaW50cyBvZiB0aGUgdmFyaWFudCBpdCBpZGVudGlmaWVzKTtcbiAgICAgKiAqIElmIGBzcmNgIGRvZXMgbm90IGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgVW5pb25cbiAgICAgKiAgIGRpc2NyaW1pbmF0b3IsIGJ1dCBkb2VzIGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyBhIHJlZ2lzdGVyZWRcbiAgICAgKiAgIHZhcmlhbnQsIHRoZW4gdGhlIHZhcmlhbnQgaXMgcmV0dXJuZWQgKGJlY2F1c2UgdGhlIHNvdXJjZVxuICAgICAqICAgbWF0Y2hlcyBhIHZhcmlhbnQgd2l0aG91dCBhbiBleHBsaWNpdCBjb25mbGljdCk7XG4gICAgICogKiBBbiBlcnJvciBpcyB0aHJvd24gKGJlY2F1c2Ugd2UgZWl0aGVyIGNhbid0IGlkZW50aWZ5IGEgdmFyaWFudCxcbiAgICAgKiAgIG9yIHdlIHdlcmUgZXhwbGljaXRseSB0b2xkIHRoZSB2YXJpYW50IGJ1dCBjYW4ndCBzYXRpc2Z5IGl0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgLSBhbiBvYmplY3QgcHJlc3VtZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gICAgICogdGhlIGNvbnRlbnQgb2YgdGhlIFVuaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gLSBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgc3JjYCBjYW5ub3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgZGVmYXVsdCBvclxuICAgICAqIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICAgKi9cbiAgICBkZWZhdWx0R2V0U291cmNlVmFyaWFudChzcmMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMuZGlzY3JpbWluYXRvci5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRMYXlvdXQgJiYgdGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5XG4gICAgICAgICAgICAgICAgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2bG8gPSB0aGlzLnJlZ2lzdHJ5W3NyY1t0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHldXTtcbiAgICAgICAgICAgIGlmICh2bG9cbiAgICAgICAgICAgICAgICAmJiAoKCF2bG8ubGF5b3V0KVxuICAgICAgICAgICAgICAgICAgICB8fCAodmxvLnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHZsby5wcm9wZXJ0eSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2bG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZyBpbiB0aGlzLnJlZ2lzdHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVt0YWddO1xuICAgICAgICAgICAgICAgIGlmICh2bG8ucHJvcGVydHkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdmxvLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBpbmZlciBzcmMgdmFyaWFudCcpO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBpcyB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxyZWdpc3RlcmVkfSB0aGUgcmV0dXJuXG4gICAgICogdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB2YXJpYW50LCB3aXRoIG5vIGV4cGxpY2l0XG4gICAgICogZGlzY3JpbWluYXRvci4gIE90aGVyd2lzZSB0aGUge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdFxuICAgICAqIGxheW91dH0gaXMgdXNlZCB0byBkZWNvZGUgdGhlIGNvbnRlbnQuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGRlc3Q7XG4gICAgICAgIGNvbnN0IGRsbyA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3IgPSBkbG8uZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNsbyA9IHRoaXMucmVnaXN0cnlbZGlzY3JdO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjbG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRMYXlvdXQgPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgICAgIGRlc3RbZGxvLnByb3BlcnR5XSA9IGRpc2NyO1xuICAgICAgICAgICAgLy8gZGVmYXVsdExheW91dC5wcm9wZXJ0eSBjYW4gYmUgdW5kZWZpbmVkLCBidXQgdGhpcyBpcyBhbGxvd2VkIGJ5IGJ1ZmZlci1sYXlvdXRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBkZXN0W2RlZmF1bHRMYXlvdXQucHJvcGVydHldID0gZGVmYXVsdExheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0ID0gY2xvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAgICpcbiAgICAgKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBgc3JjYCBvYmplY3QgaXMgY29uc2lzdGVudCB3aXRoIHRoZSB1bmlvbidzXG4gICAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LiAgVG8gZW5jb2RlIHZhcmlhbnRzXG4gICAgICogdXNlIHRoZSBhcHByb3ByaWF0ZSB2YXJpYW50LXNwZWNpZmljIHtAbGluayBWYXJpYW50TGF5b3V0I2VuY29kZX1cbiAgICAgKiBtZXRob2QuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCB2bG8gPSB0aGlzLmdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdmxvKSB7XG4gICAgICAgICAgICBjb25zdCBkbG8gPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgICAgICAvLyB0aGlzLmRlZmF1bHRMYXlvdXQgaXMgbm90IHVuZGVmaW5lZCB3aGVuIHZsbyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBjb25zdCBjbG8gPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbG8uZW5jb2RlKHNyY1tkbG8ucHJvcGVydHldLCBiLCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gY2xvLnByb3BlcnR5IGlzIG5vdCB1bmRlZmluZWQgd2hlbiB2bG8gaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBjbG8uZW5jb2RlKHNyY1tjbG8ucHJvcGVydHldLCBiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmxvLmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIG5ldyB2YXJpYW50IHN0cnVjdHVyZSB3aXRoaW4gYSB1bmlvbi4gIFRoZSBuZXdseVxuICAgICAqIGNyZWF0ZWQgdmFyaWFudCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjdmFyaWFudHx2YXJpYW50fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7VmFyaWFudExheW91dH0gKi9cbiAgICBhZGRWYXJpYW50KHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgcnYgPSBuZXcgVmFyaWFudExheW91dCh0aGlzLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeVt2YXJpYW50XSA9IHJ2O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBhIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICAgKlxuICAgICAqIElmIGB2YmAgZG9lcyBub3QgcHJvZHVjZSBhIHJlZ2lzdGVyZWQgdmFyaWFudCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoTnVtYmVyfFVpbnQ4QXJyYXkpfSB2YiAtIGVpdGhlciB0aGUgdmFyaWFudCBudW1iZXIsIG9yIGFcbiAgICAgKiBidWZmZXIgZnJvbSB3aGljaCB0aGUgZGlzY3JpbWluYXRvciBpcyB0byBiZSByZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIG9mZnNldCBpbnRvIGB2YmAgZm9yIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiB1bmlvbi4gIFVzZWQgb25seSB3aGVuIGB2YmAgaXMgYW4gaW5zdGFuY2Ugb2Yge1VpbnQ4QXJyYXl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KHtWYXJpYW50TGF5b3V0fXx1bmRlZmluZWQpfVxuICAgICAqL1xuICAgIGdldFZhcmlhbnQodmIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IHZhcmlhbnQ7XG4gICAgICAgIGlmICh2YiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHZhcmlhbnQgPSB0aGlzLmRpc2NyaW1pbmF0b3IuZGVjb2RlKHZiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyaWFudCA9IHZiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5W3ZhcmlhbnRdO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pb24gPSBVbmlvbjtcbi8qKlxuICogUmVwcmVzZW50IGEgc3BlY2lmaWMgdmFyaWFudCB3aXRoaW4gYSBjb250YWluaW5nIHVuaW9uLlxuICpcbiAqICoqTk9URSoqIFRoZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gb2YgdGhlIHZhcmlhbnQgbWF5IGluY2x1ZGVcbiAqIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB1c2VkIHRvXG4gKiBpZGVudGlmeSBpdCwgYnV0IHZhbHVlcyByZWFkIGFuZCB3cml0dGVuIHVzaW5nIHRoZSB2YXJpYW50IHN0cmljdGx5XG4gKiBjb25mb3JtIHRvIHRoZSBjb250ZW50IG9mIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiAgVXNlXG4gKiB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0gaGVscGVyIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge1VuaW9ufSB1bmlvbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBbbGF5b3V0XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICBJZiBhYnNlbnQgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uICBVbmxpa2UgbWFueSBvdGhlciBsYXlvdXRzLCB2YXJpYW50XG4gKiBsYXlvdXRzIG5vcm1hbGx5IGluY2x1ZGUgYSBwcm9wZXJ0eSBuYW1lIHNvIHRoZXkgY2FuIGJlIGlkZW50aWZpZWRcbiAqIHdpdGhpbiB0aGVpciBjb250YWluaW5nIHtAbGluayBVbmlvbn0uICBUaGUgcHJvcGVydHkgaWRlbnRpZmllciBtYXlcbiAqIGJlIGFic2VudCBvbmx5IGlmIGBsYXlvdXRgIGlzIGlzIGFic2VudC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVmFyaWFudExheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IodW5pb24sIHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEodW5pb24gaW5zdGFuY2VvZiBVbmlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuaW9uIG11c3QgYmUgYSBVbmlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIodmFyaWFudCkpIHx8ICgwID4gdmFyaWFudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbXVzdCBiZSBhIChub24tbmVnYXRpdmUpIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbGF5b3V0KVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IGxheW91dDtcbiAgICAgICAgICAgIGxheW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheW91dCkge1xuICAgICAgICAgICAgaWYgKCEobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG51bGwgIT09IHVuaW9uLmRlZmF1bHRMYXlvdXQpXG4gICAgICAgICAgICAgICAgJiYgKDAgPD0gbGF5b3V0LnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKGxheW91dC5zcGFuID4gdW5pb24uZGVmYXVsdExheW91dC5zcGFuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFudCBzcGFuIGV4Y2VlZHMgc3BhbiBvZiBjb250YWluaW5nIHVuaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbXVzdCBoYXZlIGEgU3RyaW5nIHByb3BlcnR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSB1bmlvbi5zcGFuO1xuICAgICAgICBpZiAoMCA+IHVuaW9uLnNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSBsYXlvdXQgPyBsYXlvdXQuc3BhbiA6IDA7XG4gICAgICAgICAgICBpZiAoKDAgPD0gc3BhbikgJiYgdW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IHVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHtAbGluayBVbmlvbn0gdG8gd2hpY2ggdGhpcyB2YXJpYW50IGJlbG9uZ3MuICovXG4gICAgICAgIHRoaXMudW5pb24gPSB1bmlvbjtcbiAgICAgICAgLyoqIFRoZSB1bnNpZ25lZCBpbnRlZ3JhbCB2YWx1ZSBpZGVudGlmeWluZyB0aGlzIHZhcmlhbnQgd2l0aGluXG4gICAgICAgICAqIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAgICAgKiB1bmlvbi4gKi9cbiAgICAgICAgdGhpcy52YXJpYW50ID0gdmFyaWFudDtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0fSB0byBiZSB1c2VkIHdoZW4gcmVhZGluZy93cml0aW5nIHRoZVxuICAgICAgICAgKiBub24tZGlzY3JpbWluYXRvciBwYXJ0IG9mIHRoZSB7QGxpbmtcbiAgICAgICAgICogVmFyaWFudExheW91dCN1bmlvbnx1bmlvbn0uICBJZiBgbnVsbGAgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICAgICAgICAgKiBkYXRhLiAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dCB8fCBudWxsO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgLyogV2lsbCBiZSBlcXVhbCB0byB0aGUgY29udGFpbmluZyB1bmlvbiBzcGFuIGlmIHRoYXQgaXMgbm90XG4gICAgICAgICAgICAgKiB2YXJpYWJsZS4gKi9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBTcGFuIGlzIGRlZmluZWQgc29sZWx5IGJ5IHRoZSB2YXJpYW50IChhbmQgcHJlZml4IGRpc2NyaW1pbmF0b3IpICovXG4gICAgICAgIGxldCBzcGFuID0gMDtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudE9mZnNldCArIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMudW5pb24uZ2V0VmFyaWFudChiLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BlcnR5KSB7XG4gICAgICAgICAgICBkZXN0W3RoaXMucHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBkZXN0W3RoaXMudW5pb24uZGlzY3JpbWluYXRvci5wcm9wZXJ0eV0gPSB0aGlzLnZhcmlhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0XG4gICAgICAgICAgICAmJiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMucHJvcGVydHkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBsYWNrcyBwcm9wZXJ0eSAnICsgdGhpcy5wcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmVuY29kZSh0aGlzLnZhcmlhbnQsIGIsIG9mZnNldCk7XG4gICAgICAgIGxldCBzcGFuID0gY29udGVudE9mZnNldDtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5lbmNvZGUoc3JjW3RoaXMucHJvcGVydHldLCBiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIHNwYW4gKz0gdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICgoMCA8PSB0aGlzLnVuaW9uLnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKHNwYW4gPiB0aGlzLnVuaW9uLnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNvZGVkIHZhcmlhbnQgb3ZlcnJ1bnMgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUge0BsaW5rIExheW91dCNmcm9tQXJyYXl8ZnJvbUFycmF5fSB0byB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZnJvbUFycmF5KHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhbnRMYXlvdXQgPSBWYXJpYW50TGF5b3V0O1xuLyoqIEphdmFTY3JpcHQgY2hvc2UgdG8gZGVmaW5lIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcyBvcGVyYXRpbmcgb25cbiAqIHNpZ25lZCAzMi1iaXQgdmFsdWVzIGluIDIncyBjb21wbGVtZW50IGZvcm0sIG1lYW5pbmcgYW55IGludGVnZXJcbiAqIHdpdGggYml0IDMxIHNldCBpcyBnb2luZyB0byBsb29rIG5lZ2F0aXZlLiAgRm9yIHJpZ2h0IHNoaWZ0cyB0aGF0J3NcbiAqIG5vdCBhIHByb2JsZW0sIGJlY2F1c2UgYD4+PmAgaXMgYSBsb2dpY2FsIHNoaWZ0LCBidXQgZm9yIGV2ZXJ5XG4gKiBvdGhlciBiaXR3aXNlIG9wZXJhdG9yIHdlIGhhdmUgdG8gY29tcGVuc2F0ZSBmb3IgcG9zc2libGUgbmVnYXRpdmVcbiAqIHJlc3VsdHMuICovXG5mdW5jdGlvbiBmaXhCaXR3aXNlUmVzdWx0KHYpIHtcbiAgICBpZiAoMCA+IHYpIHtcbiAgICAgICAgdiArPSAweDEwMDAwMDAwMDtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG4vKipcbiAqIENvbnRhaW4gYSBzZXF1ZW5jZSBvZiBiaXQgZmllbGRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5iaXRzfGJpdHN9XG4gKlxuICogVGhpcyBpcyBhIGNvbnRhaW5lciBlbGVtZW50OyB3aXRoaW4gaXQgdGhlcmUgYXJlIHtAbGluayBCaXRGaWVsZH1cbiAqIGluc3RhbmNlcyB0aGF0IHByb3ZpZGUgdGhlIGV4dHJhY3RlZCBwcm9wZXJ0aWVzLiAgVGhlIGNvbnRhaW5lclxuICogc2ltcGx5IGRlZmluZXMgdGhlIGFnZ3JlZ2F0ZSByZXByZXNlbnRhdGlvbiBhbmQgaXRzIGJpdCBvcmRlcmluZy5cbiAqIFRoZSByZXByZXNlbnRhdGlvbiBpcyBhbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHdpdGggbnVtZXJpY1xuICogb3Ige0BsaW5rIEJvb2xlYW59IHZhbHVlcy5cbiAqXG4gKiB7QGxpbmsgQml0RmllbGR9cyBhcmUgYWRkZWQgd2l0aCB0aGUge0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGFuZCB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IG1ldGhvZHMuXG5cbiAqIEBwYXJhbSB7TGF5b3V0fSB3b3JkIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0U3RydWN0dXJlI3dvcmR8d29yZH0uICBUaGUgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2ZcbiAqIHtAbGluayBVSW50fSAob3Ige0BsaW5rIFVJbnRCRX0pIHRoYXQgaXMgbm8gbW9yZSB0aGFuIDQgYnl0ZXMgd2lkZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2x9IFttc2JdIC0gYHRydWVgIGlmIHRoZSBiaXQgbnVtYmVyaW5nIHN0YXJ0cyBhdCB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBjb250YWluaW5nIHdvcmQ7IGBmYWxzZWAgKGRlZmF1bHQpIGlmXG4gKiBpdCBzdGFydHMgYXQgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgY29udGFpbmluZyB3b3JkLiAgSWZcbiAqIHRoZSBwYXJhbWV0ZXIgYXQgdGhpcyBwb3NpdGlvbiBpcyBhIHN0cmluZyBhbmQgYHByb3BlcnR5YCBpc1xuICogYHVuZGVmaW5lZGAgdGhlIHZhbHVlIG9mIHRoaXMgYXJndW1lbnQgd2lsbCBpbnN0ZWFkIGJlIHVzZWQgYXMgdGhlXG4gKiB2YWx1ZSBvZiBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQml0U3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih3b3JkLCBtc2IsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKCh3b3JkIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8ICh3b3JkIGluc3RhbmNlb2YgVUludEJFKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dvcmQgbXVzdCBiZSBhIFVJbnQgb3IgVUludEJFIGxheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBtc2IpXG4gICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbXNiO1xuICAgICAgICAgICAgbXNiID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgPCB3b3JkLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3b3JkIGNhbm5vdCBleGNlZWQgMzIgYml0cycpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHdvcmQuc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGxheW91dCB1c2VkIGZvciB0aGUgcGFja2VkIHZhbHVlLiAge0BsaW5rIEJpdEZpZWxkfVxuICAgICAgICAgKiBpbnN0YW5jZXMgYXJlIHBhY2tlZCBzZXF1ZW50aWFsbHkgZGVwZW5kaW5nIG9uIHtAbGlua1xuICAgICAgICAgKiBCaXRTdHJ1Y3R1cmUjbXNifG1zYn0uICovXG4gICAgICAgIHRoaXMud29yZCA9IHdvcmQ7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBiaXQgc2VxdWVuY2VzIGFyZSBwYWNrZWQgc3RhcnRpbmcgYXQgdGhlIG1vc3RcbiAgICAgICAgICogc2lnbmlmaWNhbnQgYml0IGdyb3dpbmcgZG93biAoYHRydWVgKSwgb3IgdGhlIGxlYXN0IHNpZ25pZmljYW50XG4gICAgICAgICAqIGJpdCBncm93aW5nIHVwIChgZmFsc2VgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogUmVnYXJkbGVzcyBvZiB0aGlzIHZhbHVlLCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mXG4gICAgICAgICAqIGFueSB7QGxpbmsgQml0RmllbGR9IHZhbHVlIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgc2VjdGlvbiBvZiB0aGUgcGFja2VkIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLm1zYiA9ICEhbXNiO1xuICAgICAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBCaXRGaWVsZH0gbGF5b3V0cyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAgICAgKiBwYWNrZWQgc3RydWN0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBUaGUgYXJyYXkgcmVtYWlucyBtdXRhYmxlIHRvIGFsbG93IGZpZWxkcyB0byBiZSB7QGxpbmtcbiAgICAgICAgICogQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZGVkfSBhZnRlciBjb25zdHJ1Y3Rpb24uICBVc2VycyBzaG91bGRcbiAgICAgICAgICogbm90IG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4qL1xuICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xuICAgICAgICAvKiBTdG9yYWdlIGZvciB0aGUgdmFsdWUuICBDYXB0dXJlIGEgdmFyaWFibGUgaW5zdGVhZCBvZiB1c2luZyBhblxuICAgICAgICAgKiBpbnN0YW5jZSBwcm9wZXJ0eSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYW55dGhpbmcgdG8gY2hhbmdlIHRoZVxuICAgICAgICAgKiB2YWx1ZSB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlIG11dGF0b3IuICovXG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh2KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYWNrZWRHZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMud29yZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUodmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gZmQuZGVjb2RlKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICAgICAqXG4gICAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgcGFja2VkXG4gICAgICogdmFsdWUgaXMgbGVmdCB1bm1vZGlmaWVkLiAgVW51c2VkIGJpdHMgYXJlIGFsc28gbGVmdCB1bm1vZGlmaWVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdiA9IHNyY1tmZC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnYpIHtcbiAgICAgICAgICAgICAgICAgICAgZmQuZW5jb2RlKGZ2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud29yZC5lbmNvZGUodGhpcy5fcGFja2VkR2V0VmFsdWUoKSwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGEgbmV3IGJpdGZpZWxkIHdpdGggYSBjb250YWluaW5nIGJpdCBzdHJ1Y3R1cmUuICBUaGVcbiAgICAgKiByZXN1bHRpbmcgYml0ZmllbGQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYml0cyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qml0RmllbGR9ICovXG4gICAgYWRkRmllbGQoYml0cywgcHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgYmYgPSBuZXcgQml0RmllbGQodGhpcywgYml0cywgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAvKiogQXMgd2l0aCB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBmb3Igc2luZ2xlLWJpdFxuICAgICAqIGZpZWxkcyB3aXRoIGBib29sZWFuYCB2YWx1ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gKi9cbiAgICAvLyBgQm9vbGVhbmAgY29uZmxpY3RzIHdpdGggdGhlIG5hdGl2ZSBwcmltaXRpdmUgdHlwZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgYWRkQm9vbGVhbihwcm9wZXJ0eSkge1xuICAgICAgICAvLyBUaGlzIGlzIG15IEJvb2xlYW4sIG5vdCB0aGUgSmF2YXNjcmlwdCBvbmUuXG4gICAgICAgIGNvbnN0IGJmID0gbmV3IEJvb2xlYW4odGhpcywgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWNjZXNzIHRvIHRoZSBiaXQgZmllbGQgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgYml0IGZpZWxkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qml0RmllbGR9IC0gdGhlIGZpZWxkIGFzc29jaWF0ZWQgd2l0aCBgcHJvcGVydHlgLCBvclxuICAgICAqIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzdWNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZpZWxkRm9yKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLkJpdFN0cnVjdHVyZSA9IEJpdFN0cnVjdHVyZTtcbi8qKlxuICogUmVwcmVzZW50IGEgc2VxdWVuY2Ugb2YgYml0cyB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAqXG4gKiBBbGwgYml0IGZpZWxkIHZhbHVlcyBhcmUgcmVwcmVzZW50ZWQgYXMgdW5zaWduZWQgaW50ZWdlcnMuXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBoZWxwZXJcbiAqIG1ldGhvZC5cbiAqXG4gKiAqKk5PVEUqKiBCaXRGaWVsZCBpbnN0YW5jZXMgYXJlIG5vdCBpbnN0YW5jZXMgb2Yge0BsaW5rIExheW91dH1cbiAqIHNpbmNlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBtZWFzdXJlcyA4LWJpdCB1bml0cy5cbiAqXG4gKiBAcGFyYW0ge0JpdFN0cnVjdHVyZX0gY29udGFpbmVyIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0RmllbGQjY29udGFpbmVyfGNvbnRhaW5lcn0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICovXG5jbGFzcyBCaXRGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBiaXRzLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBCaXRTdHJ1Y3R1cmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250YWluZXIgbXVzdCBiZSBhIEJpdFN0cnVjdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoYml0cykpIHx8ICgwID49IGJpdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiaXRzIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsQml0cyA9IDggKiBjb250YWluZXIuc3BhbjtcbiAgICAgICAgY29uc3QgdXNlZEJpdHMgPSBjb250YWluZXIuZmllbGRzLnJlZHVjZSgoc3VtLCBmZCkgPT4gc3VtICsgZmQuYml0cywgMCk7XG4gICAgICAgIGlmICgoYml0cyArIHVzZWRCaXRzKSA+IHRvdGFsQml0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaXRzIHRvbyBsb25nIGZvciBzcGFuIHJlbWFpbmRlciAoJ1xuICAgICAgICAgICAgICAgICsgKHRvdGFsQml0cyAtIHVzZWRCaXRzKSArICcgb2YgJ1xuICAgICAgICAgICAgICAgICsgdG90YWxCaXRzICsgJyByZW1haW4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgQml0U3RydWN0dXJlfSBpbnN0YW5jZSB0byB3aGljaCB0aGlzIGJpdCBmaWVsZFxuICAgICAgICAgKiBiZWxvbmdzLiAqL1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgLyoqIFRoZSBzcGFuIG9mIHRoaXMgdmFsdWUgaW4gYml0cy4gKi9cbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgLyoqIEEgbWFzayBvZiB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfSBiaXRzIGlzb2xhdGluZyB2YWx1ZSBiaXRzXG4gICAgICAgICAqIHRoYXQgZml0IHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoYXQgaXMsIGl0IG1hc2tzIGEgdmFsdWUgdGhhdCBoYXMgbm90IHlldCBiZWVuIHNoaWZ0ZWQgaW50b1xuICAgICAgICAgKiBwb3NpdGlvbiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgcGFja2VkIGludGVnZXIuICovXG4gICAgICAgIHRoaXMudmFsdWVNYXNrID0gKDEgPDwgYml0cykgLSAxO1xuICAgICAgICBpZiAoMzIgPT09IGJpdHMpIHsgLy8gc2hpZnRlZCB2YWx1ZSBvdXQgb2YgcmFuZ2VcbiAgICAgICAgICAgIHRoaXMudmFsdWVNYXNrID0gMHhGRkZGRkZGRjtcbiAgICAgICAgfVxuICAgICAgICAvKiogVGhlIG9mZnNldCBvZiB0aGUgdmFsdWUgd2l0aGluIHRoZSBjb250YWluaW5nIHBhY2tlZCB1bnNpZ25lZFxuICAgICAgICAgKiBpbnRlZ2VyLiAgVGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgcGFja2VkIHZhbHVlIGlzIGF0XG4gICAgICAgICAqIG9mZnNldCB6ZXJvLCByZWdhcmRsZXNzIG9mIGJpdCBvcmRlcmluZyB1c2VkLiAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdXNlZEJpdHM7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5tc2IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0b3RhbEJpdHMgLSB1c2VkQml0cyAtIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEEgbWFzayBvZiB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfSBpc29sYXRpbmcgdGhlIGZpZWxkIHZhbHVlXG4gICAgICAgICAqIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWQgaW50ZWdlci4gKi9cbiAgICAgICAgdGhpcy53b3JkTWFzayA9IGZpeEJpdHdpc2VSZXN1bHQodGhpcy52YWx1ZU1hc2sgPDwgdGhpcy5zdGFydCk7XG4gICAgICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBiaXRmaWVsZCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAgICAgKiBPYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEludGVuZGVkIHRvIGJlIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIHtAbGlua1xuICAgICAgICAgKiBMYXlvdXQjcHJvcGVydHl9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgY29ycmVzcG9uZGluZyBzcGFuIG9mIGJpdHMgd2lsbCBiZVxuICAgICAgICAgKiB0cmVhdGVkIGFzIHBhZGRpbmc6IGl0IHdpbGwgbm90IGJlIG11dGF0ZWQgYnkge0BsaW5rXG4gICAgICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgICAgICogZGVjb2RlZCBPYmplY3QuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAqIGJpdCBmaWVsZC4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh3b3JkICYgdGhpcy53b3JkTWFzayk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gd29yZFZhbHVlID4+PiB0aGlzLnN0YXJ0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiBiaXQgZmllbGQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGlzIG5vdCBhIHNwZWNpYWxpemF0aW9uIG9mIHtAbGlua1xuICAgICAqIExheW91dCNlbmNvZGV8TGF5b3V0LmVuY29kZX0gYW5kIHRoZXJlIGlzIG5vIHJldHVybiB2YWx1ZS4gKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICAgIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKVxuICAgICAgICAgICAgfHwgKHZhbHVlICE9PSBmaXhCaXR3aXNlUmVzdWx0KHZhbHVlICYgdGhpcy52YWx1ZU1hc2spKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lV2l0aFByb3BlcnR5KCdCaXRGaWVsZC5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICsgJyB2YWx1ZSBtdXN0IGJlIGludGVnZXIgbm90IGV4Y2VlZGluZyAnICsgdGhpcy52YWx1ZU1hc2spO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSA8PCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuX3BhY2tlZFNldFZhbHVlKGZpeEJpdHdpc2VSZXN1bHQod29yZCAmIH50aGlzLndvcmRNYXNrKVxuICAgICAgICAgICAgfCB3b3JkVmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0RmllbGQgPSBCaXRGaWVsZDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2luZ2xlIGJpdCB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfSBhcyBhXG4gKiBKYXZhU2NyaXB0IGJvb2xlYW4uXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEJvb2xlYW58YWRkQm9vbGVhbn0gaGVscGVyXG4gKiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtCaXRTdHJ1Y3R1cmV9IGNvbnRhaW5lciAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdEZpZWxkI2NvbnRhaW5lcnxjb250YWluZXJ9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0JpdEZpZWxkfVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5jbGFzcyBCb29sZWFuIGV4dGVuZHMgQml0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyLCAxLCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBPdmVycmlkZSB7QGxpbmsgQml0RmllbGQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBCb29sZWFufEJvb2xlYW59LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gISFzdXBlci5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJpdEZpZWxkIHJlcXVpcmVzIGludGVnZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5lbmNvZGUodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQm9vbGVhbiA9IEJvb2xlYW47XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cbi8qKlxuICogQ29udGFpbiBhIGZpeGVkLWxlbmd0aCBibG9jayBvZiBhcmJpdHJhcnkgZGF0YSwgcmVwcmVzZW50ZWQgYXMgYVxuICogVWludDhBcnJheS5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmJsb2J8YmxvYn1cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBsZW5ndGggLSBpbml0aWFsaXplcyB7QGxpbmtcbiAqIEJsb2IjbGVuZ3RofGxlbmd0aH0uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBCbG9iIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKCgobGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpICYmIGxlbmd0aC5pc0NvdW50KCkpXG4gICAgICAgICAgICB8fCAoTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpICYmICgwIDw9IGxlbmd0aCkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGVuZ3RoIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmICghKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSkge1xuICAgICAgICAgICAgc3BhbiA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBibG9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1heSBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICAgICAgICAgKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0uICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgQmxvYn0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICBsZXQgc3BhbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgc3BhbiA9IHNyYy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3JjIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBzcGFuID09PSBzcmMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lV2l0aFByb3BlcnR5KCdCbG9iLmVuY29kZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgKyAnIHJlcXVpcmVzIChsZW5ndGggJyArIHNwYW4gKyAnKSBVaW50OEFycmF5IGFzIHNyYycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmNCdWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoc3JjKTtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlKHNyY0J1ZmZlci50b1N0cmluZygnaGV4JyksIG9mZnNldCwgc3BhbiwgJ2hleCcpO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGguZW5jb2RlKHNwYW4sIGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iID0gQmxvYjtcbi8qKlxuICogQ29udGFpbiBhIGBOVUxgLXRlcm1pbmF0ZWQgVVRGOCBzdHJpbmcuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5jc3RyfGNzdHJ9XG4gKlxuICogKipOT1RFKiogQW55IFVURjggc3RyaW5nIHRoYXQgaW5jb3Jwb3JhdGVzIGEgemVyby12YWx1ZWQgYnl0ZSB3aWxsXG4gKiBub3QgYmUgY29ycmVjdGx5IGRlY29kZWQgYnkgdGhpcyBsYXlvdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBDU3RyaW5nIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgbGV0IGlkeCA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKChpZHggPCBiLmxlbmd0aCkgJiYgKDAgIT09IGJbaWR4XSkpIHtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxICsgaWR4IC0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbiAtIDEpLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAgICAgKiBcInV0ZjgtZW5jb2RpbmdcIiBiZWxvdyBhY3R1YWxseSBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBsZW5ndGhcbiAgICAgICAgICogc3JjICovXG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgICAgICAgc3JjID0gU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjYiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHNyYywgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIHNyY2IuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzcGFuXSA9IDA7XG4gICAgICAgIHJldHVybiBzcGFuICsgMTtcbiAgICB9XG59XG5leHBvcnRzLkNTdHJpbmcgPSBDU3RyaW5nO1xuLyoqXG4gKiBDb250YWluIGEgVVRGOCBzdHJpbmcgd2l0aCBpbXBsaWNpdCBsZW5ndGguXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51dGY4fHV0Zjh9XG4gKlxuICogKipOT1RFKiogQmVjYXVzZSB0aGUgbGVuZ3RoIGlzIGltcGxpY2l0IGluIHRoZSBzaXplIG9mIHRoZSBidWZmZXJcbiAqIHRoaXMgbGF5b3V0IHNob3VsZCBiZSB1c2VkIG9ubHkgaW4gaXNvbGF0aW9uLCBvciBpbiBhIHNpdHVhdGlvblxuICogd2hlcmUgdGhlIGxlbmd0aCBjYW4gYmUgZXhwcmVzc2VkIGJ5IG9wZXJhdGluZyBvbiBhIHNsaWNlIG9mIHRoZVxuICogY29udGFpbmluZyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTcGFuXSAtIHRoZSBtYXhpbXVtIGxlbmd0aCBhbGxvd2VkIGZvciBlbmNvZGVkXG4gKiBzdHJpbmcgY29udGVudC4gIElmIG5vdCBwcm92aWRlZCB0aGVyZSBpcyBubyBib3VuZCBvbiB0aGUgYWxsb3dlZFxuICogY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVURjggZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKG1heFNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBtYXhTcGFuKSAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbWF4U3BhbjtcbiAgICAgICAgICAgIG1heFNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbWF4U3Bhbikge1xuICAgICAgICAgICAgbWF4U3BhbiA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTcGFuIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbWF4aW11bSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBvc2l0aXZlIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IGV4cGVjdGVkLiAgWmVybyBpcyBhYm5vcm1hbC5cbiAgICAgICAgICogQXR0ZW1wdHMgdG8gZW5jb2RlIG9yIGRlY29kZSBhIHZhbHVlIHRoYXQgZXhjZWVkcyB0aGlzIGxlbmd0aFxuICAgICAgICAgKiB3aWxsIHRocm93IGEgYFJhbmdlRXJyb3JgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBsZW5ndGhcbiAgICAgICAgICogb2YgdGhlIGNvbnRlbnQuICovXG4gICAgICAgIHRoaXMubWF4U3BhbiA9IG1heFNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICAgICAmJiAodGhpcy5tYXhTcGFuIDwgc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbikudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIC8qIE11c3QgZm9yY2UgdGhpcyB0byBhIHN0cmluZywgbGVzdCBpdCBiZSBhIG51bWJlciBhbmQgdGhlXG4gICAgICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAgICAgKiBzcmMgKi9cbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3JjKSB7XG4gICAgICAgICAgICBzcmMgPSBTdHJpbmcoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmNiID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oc3JjLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBzcGFuID0gc3JjYi5sZW5ndGg7XG4gICAgICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICAgICAmJiAodGhpcy5tYXhTcGFuIDwgc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzcmNiLmNvcHkodWludDhBcnJheVRvQnVmZmVyKGIpLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlVURjggPSBVVEY4O1xuLyoqXG4gKiBDb250YWluIGEgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogVGhpcyBsYXlvdXQgbWF5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBKYXZhU2NyaXB0IHZhbHVlIGNhbiBiZVxuICogaW5mZXJyZWQgd2l0aG91dCBhbiBleHByZXNzaW9uIGluIHRoZSBiaW5hcnkgZW5jb2RpbmcuICBBbiBleGFtcGxlXG4gKiB3b3VsZCBiZSBhIHtAbGluayBWYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0fSB3aGVyZSB0aGUgY29udGVudFxuICogaXMgaW1wbGllZCBieSB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gdmFsdWUgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBDb25zdGFudCN2YWx1ZXx2YWx1ZX0uICBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChvciBhcnJheSkgYW5kXG4gKiB0aGUgYXBwbGljYXRpb24gaW50ZW5kcyB0aGUgb2JqZWN0IHRvIHJlbWFpbiB1bmNoYW5nZWQgcmVnYXJkbGVzc1xuICogb2Ygd2hhdCBpcyBkb25lIHRvIHZhbHVlcyBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LCB0aGUgdmFsdWUgc2hvdWxkXG4gKiBiZSBmcm96ZW4gcHJpb3IgcGFzc2luZyBpdCB0byB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ29uc3RhbnQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcigwLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgdmFsdWUgcHJvZHVjZWQgYnkgdGhpcyBjb25zdGFudCB3aGVuIHRoZSBsYXlvdXQgaXMge0BsaW5rXG4gICAgICAgICAqIENvbnN0YW50I2RlY29kZXxkZWNvZGVkfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQW55IEphdmFTY3JpcHQgdmFsdWUgaW5jbHVkaW5nIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgaXNcbiAgICAgICAgICogcGVybWl0dGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKldBUk5JTkcqKiBJZiBgdmFsdWVgIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdFxuICAgICAgICAgKiBmcm96ZW4sIGl0IGlzIHBvc3NpYmxlIGZvciB1c2VycyBvZiBkZWNvZGVkIHZhbHVlcyB0byBjaGFuZ2VcbiAgICAgICAgICogdGhlIGNvbnRlbnQgb2YgdGhlIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIC8qIENvbnN0YW50cyB0YWtlIG5vIHNwYWNlICovXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3RhbnQgPSBDb25zdGFudDtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgR3JlZWR5Q291bnR9LiAqL1xuZXhwb3J0cy5ncmVlZHkgPSAoKGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkgPT4gbmV3IEdyZWVkeUNvdW50KGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBPZmZzZXRMYXlvdXR9LiAqL1xuZXhwb3J0cy5vZmZzZXQgPSAoKGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkgPT4gbmV3IE9mZnNldExheW91dChsYXlvdXQsIG9mZnNldCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHx1bnNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xuZXhwb3J0cy51OCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDEsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMudTE2ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnUyNCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMiA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnU0MCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMudTQ4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludFxuICogbGF5b3V0c30gaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnU2NCA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFyVUludDY0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMudTE2YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMudTMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnU0MGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFyVUludDY0QkV8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFyVUludDY0QkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fHNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xuZXhwb3J0cy5zOCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoMSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMTYgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMiA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMuczQwID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnM0OCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnM2NCA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFySW50NjQocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMTZiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMuczMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMuczQwYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDhiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFySW50NjRCRXxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFySW50NjRCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBGbG9hdHxsaXR0bGUtZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mMzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgRmxvYXQocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXRCRXxiaWctZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mMzJiZSA9ICgocHJvcGVydHkpID0+IG5ldyBGbG9hdEJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZXxsaXR0bGUtZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgRG91YmxlKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZUJFfGJpZy1lbmRpYW4gNjQtYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmY2NGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IERvdWJsZUJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5zdHJ1Y3QgPSAoKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSA9PiBuZXcgU3RydWN0dXJlKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJpdFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5iaXRzID0gKCh3b3JkLCBtc2IsIHByb3BlcnR5KSA9PiBuZXcgQml0U3RydWN0dXJlKHdvcmQsIG1zYiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgU2VxdWVuY2V9IHZhbHVlcy4gKi9cbmV4cG9ydHMuc2VxID0gKChlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpID0+IG5ldyBTZXF1ZW5jZShlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVW5pb259IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb24gPSAoKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkgPT4gbmV3IFVuaW9uKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3J9IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gKChsYXlvdXQsIHByb3BlcnR5KSA9PiBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGxheW91dCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQmxvYn0gdmFsdWVzLiAqL1xuZXhwb3J0cy5ibG9iID0gKChsZW5ndGgsIHByb3BlcnR5KSA9PiBuZXcgQmxvYihsZW5ndGgsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENTdHJpbmd9IHZhbHVlcy4gKi9cbmV4cG9ydHMuY3N0ciA9ICgocHJvcGVydHkpID0+IG5ldyBDU3RyaW5nKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVURjh9IHZhbHVlcy4gKi9cbmV4cG9ydHMudXRmOCA9ICgobWF4U3BhbiwgcHJvcGVydHkpID0+IG5ldyBVVEY4KG1heFNwYW4sIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENvbnN0YW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmNvbnN0YW50ID0gKCh2YWx1ZSwgcHJvcGVydHkpID0+IG5ldyBDb25zdGFudCh2YWx1ZSwgcHJvcGVydHkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheW91dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzMTYiLCJzOCIsIm51NjRiZSIsInU0OGJlIiwidTQwYmUiLCJ1MzJiZSIsInUyNGJlIiwidTE2YmUiLCJudTY0IiwidTQ4IiwidTQwIiwidTMyIiwidTI0IiwidTE2IiwidTgiLCJvZmZzZXQiLCJncmVlZHkiLCJDb25zdGFudCIsIlVURjgiLCJDU3RyaW5nIiwiQmxvYiIsIkJvb2xlYW4iLCJCaXRGaWVsZCIsIkJpdFN0cnVjdHVyZSIsIlZhcmlhbnRMYXlvdXQiLCJVbmlvbiIsIlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciIsIlVuaW9uRGlzY3JpbWluYXRvciIsIlN0cnVjdHVyZSIsIlNlcXVlbmNlIiwiRG91YmxlQkUiLCJEb3VibGUiLCJGbG9hdEJFIiwiRmxvYXQiLCJOZWFySW50NjRCRSIsIk5lYXJJbnQ2NCIsIk5lYXJVSW50NjRCRSIsIk5lYXJVSW50NjQiLCJJbnRCRSIsIkludCIsIlVJbnRCRSIsIlVJbnQiLCJPZmZzZXRMYXlvdXQiLCJHcmVlZHlDb3VudCIsIkV4dGVybmFsTGF5b3V0IiwiYmluZENvbnN0cnVjdG9yTGF5b3V0IiwibmFtZVdpdGhQcm9wZXJ0eSIsIkxheW91dCIsInVpbnQ4QXJyYXlUb0J1ZmZlciIsImNoZWNrVWludDhBcnJheSIsImNvbnN0YW50IiwidXRmOCIsImNzdHIiLCJibG9iIiwidW5pb25MYXlvdXREaXNjcmltaW5hdG9yIiwidW5pb24iLCJzZXEiLCJiaXRzIiwic3RydWN0IiwiZjY0YmUiLCJmNjQiLCJmMzJiZSIsImYzMiIsIm5zNjRiZSIsInM0OGJlIiwiczQwYmUiLCJzMzJiZSIsInMyNGJlIiwiczE2YmUiLCJuczY0IiwiczQ4IiwiczQwIiwiczMyIiwiczI0IiwiYnVmZmVyXzEiLCJyZXF1aXJlIiwiYiIsIlVpbnQ4QXJyYXkiLCJUeXBlRXJyb3IiLCJCdWZmZXIiLCJmcm9tIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImxlbmd0aCIsImNvbnN0cnVjdG9yIiwic3BhbiIsInByb3BlcnR5IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibWFrZURlc3RpbmF0aW9uT2JqZWN0IiwiZ2V0U3BhbiIsIlJhbmdlRXJyb3IiLCJyZXBsaWNhdGUiLCJydiIsImNyZWF0ZSIsInByb3RvdHlwZSIsImFzc2lnbiIsImZyb21BcnJheSIsInZhbHVlcyIsInVuZGVmaW5lZCIsIm5hbWUiLCJsbyIsIkNsYXNzIiwibGF5b3V0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRXJyb3IiLCJsYXlvdXRfIiwiYm91bmRDb25zdHJ1Y3Rvcl8iLCJlbmNvZGUiLCJ3cml0YWJsZSIsImRlY29kZSIsImlzQ291bnQiLCJlbGVtZW50U3BhbiIsInJlbSIsIk1hdGgiLCJmbG9vciIsInNyYyIsInJlYWRVSW50TEUiLCJ3cml0ZVVJbnRMRSIsInJlYWRVSW50QkUiLCJ3cml0ZVVJbnRCRSIsInJlYWRJbnRMRSIsIndyaXRlSW50TEUiLCJyZWFkSW50QkUiLCJ3cml0ZUludEJFIiwiVjJFMzIiLCJwb3ciLCJkaXZtb2RJbnQ2NCIsImhpMzIiLCJsbzMyIiwicm91bmRlZEludDY0IiwicmVhZFVJbnQzMkxFIiwic3BsaXQiLCJ3cml0ZVVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwid3JpdGVVSW50MzJCRSIsInJlYWRJbnQzMkxFIiwid3JpdGVJbnQzMkxFIiwicmVhZEludDMyQkUiLCJ3cml0ZUludDMyQkUiLCJyZWFkRmxvYXRMRSIsIndyaXRlRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwid3JpdGVGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwid3JpdGVEb3VibGVMRSIsInJlYWREb3VibGVCRSIsIndyaXRlRG91YmxlQkUiLCJlbGVtZW50TGF5b3V0IiwiY291bnQiLCJpZHgiLCJpIiwicHVzaCIsImVsbyIsInJlZHVjZSIsInYiLCJmaWVsZHMiLCJkZWNvZGVQcmVmaXhlcyIsIkFycmF5IiwiaXNBcnJheSIsImFjYyIsImZkIiwiZSIsImZzcCIsImRlc3QiLCJmaXJzdE9mZnNldCIsImxhc3RPZmZzZXQiLCJsYXN0V3JvdGUiLCJmdiIsInNoaWZ0IiwibGF5b3V0Rm9yIiwib2Zmc2V0T2YiLCJkaXNjciIsImRlZmF1bHRMYXlvdXQiLCJkaXNjcmltaW5hdG9yIiwidXNlc1ByZWZpeERpc2NyaW1pbmF0b3IiLCJyZWdpc3RyeSIsImJvdW5kR2V0U291cmNlVmFyaWFudCIsImRlZmF1bHRHZXRTb3VyY2VWYXJpYW50IiwiYmluZCIsImdldFNvdXJjZVZhcmlhbnQiLCJjb25maWdHZXRTb3VyY2VWYXJpYW50IiwiZ3N2IiwidmxvIiwiZ2V0VmFyaWFudCIsInRhZyIsImRsbyIsImNsbyIsImNvbnRlbnRPZmZzZXQiLCJhZGRWYXJpYW50IiwidmFyaWFudCIsInZiIiwiZml4Qml0d2lzZVJlc3VsdCIsIndvcmQiLCJtc2IiLCJfcGFja2VkU2V0VmFsdWUiLCJfcGFja2VkR2V0VmFsdWUiLCJhZGRGaWVsZCIsImJmIiwiYWRkQm9vbGVhbiIsImZpZWxkRm9yIiwiY29udGFpbmVyIiwidG90YWxCaXRzIiwidXNlZEJpdHMiLCJzdW0iLCJ2YWx1ZU1hc2siLCJzdGFydCIsIndvcmRNYXNrIiwid29yZFZhbHVlIiwic2xpY2UiLCJzcmNCdWZmZXIiLCJ3cml0ZSIsInRvU3RyaW5nIiwiU3RyaW5nIiwic3JjYiIsImNvcHkiLCJtYXhTcGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/@solana/web3.js/lib/index.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),\n/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),\n/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),\n/* harmony export */   Authorized: () => (/* binding */ Authorized),\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),\n/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),\n/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),\n/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),\n/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),\n/* harmony export */   Enum: () => (/* binding */ Enum),\n/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),\n/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),\n/* harmony export */   Keypair: () => (/* binding */ Keypair),\n/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Lockup: () => (/* binding */ Lockup),\n/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),\n/* harmony export */   MessageV0: () => (/* binding */ MessageV0),\n/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),\n/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),\n/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),\n/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),\n/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),\n/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),\n/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),\n/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),\n/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),\n/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),\n/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),\n/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),\n/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),\n/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),\n/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),\n/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),\n/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),\n/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),\n/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),\n/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),\n/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),\n/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),\n/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),\n/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),\n/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),\n/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),\n/* harmony export */   VoteInit: () => (/* binding */ VoteInit),\n/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),\n/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),\n/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),\n/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),\n/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/./node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(ssr)/./node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.mjs\");\n/* harmony import */ var rpc_websockets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rpc-websockets */ \"(ssr)/./node_modules/rpc-websockets/dist/index.mjs\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n            } else {\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__.sha256)(buffer);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n                buffer,\n                toBuffer(seed)\n            ]);\n        });\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            buffer,\n            programId.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__.sha256)(buffer);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"length\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"lengthPadding\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"unixTimestamp\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, \"dataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numRequiredSignatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlySignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlyUnsignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, \"keyCount\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n        };\n        let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"prefix\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numRequiredSignatures\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlySignedAccounts\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, \"serializedInstructions\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, \"encodedDataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                publicKey(\"accountKey\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, \"signatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\nclass SendTransactionError extends Error {\n    constructor({ action, signature, transactionMessage, logs }){\n        const maybeLogsOutput = logs ? `Logs: \\n${JSON.stringify(logs.slice(-10), null, 2)}. ` : \"\";\n        const guideText = \"\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.\";\n        let message;\n        switch(action){\n            case \"send\":\n                message = `Transaction ${signature} resulted in an error. \\n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;\n                break;\n            case \"simulate\":\n                message = `Simulation failed. \\nMessage: ${transactionMessage}. \\n` + maybeLogsOutput + guideText;\n                break;\n            default:\n                {\n                    message = `Unknown action '${((a)=>a)(action)}'`;\n                }\n        }\n        super(message);\n        this.signature = void 0;\n        this.transactionMessage = void 0;\n        this.transactionLogs = void 0;\n        this.signature = signature;\n        this.transactionMessage = transactionMessage;\n        this.transactionLogs = logs ? logs : undefined;\n    }\n    get transactionError() {\n        return {\n            message: this.transactionMessage,\n            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined\n        };\n    }\n    /* @deprecated Use `await getLogs()` instead */ get logs() {\n        const cachedLogs = this.transactionLogs;\n        if (cachedLogs != null && typeof cachedLogs === \"object\" && \"then\" in cachedLogs) {\n            return undefined;\n        }\n        return cachedLogs;\n    }\n    async getLogs(connection) {\n        if (!Array.isArray(this.transactionLogs)) {\n            this.transactionLogs = new Promise((resolve, reject)=>{\n                connection.getTransaction(this.signature).then((tx)=>{\n                    if (tx && tx.meta && tx.meta.logMessages) {\n                        const logs = tx.meta.logMessages;\n                        this.transactionLogs = logs;\n                        resolve(logs);\n                    } else {\n                        reject(new Error(\"Log messages not found\"));\n                    }\n                }).catch(reject);\n            });\n        }\n        return await this.transactionLogs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: \"send\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"version\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nfunction u64(property) {\n    const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(8 /* bytes */ , property);\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    const bigIntLayout = layout;\n    const codec = (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__.getU64Codec)();\n    bigIntLayout.decode = (buffer, offset)=>{\n        const src = decode(buffer, offset);\n        return codec.decode(src);\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset)=>{\n        const src = codec.encode(bigInt);\n        return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n}\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (!params.basePubkey.equals(params.fromPubkey)) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"offset\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLengthPadding\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"byte\"), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n            ]);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var ms;\nvar hasRequiredMs;\nfunction requireMs() {\n    if (hasRequiredMs) return ms;\n    hasRequiredMs = 1;\n    var s = 1000;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    /**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} [options]\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */ ms = function(val, options) {\n        options = options || {};\n        var type = typeof val;\n        if (type === \"string\" && val.length > 0) {\n            return parse(val);\n        } else if (type === \"number\" && isFinite(val)) {\n            return options.long ? fmtLong(val) : fmtShort(val);\n        }\n        throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n    };\n    /**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */ function parse(str) {\n        str = String(str);\n        if (str.length > 100) {\n            return;\n        }\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n        if (!match) {\n            return;\n        }\n        var n = parseFloat(match[1]);\n        var type = (match[2] || \"ms\").toLowerCase();\n        switch(type){\n            case \"years\":\n            case \"year\":\n            case \"yrs\":\n            case \"yr\":\n            case \"y\":\n                return n * y;\n            case \"weeks\":\n            case \"week\":\n            case \"w\":\n                return n * w;\n            case \"days\":\n            case \"day\":\n            case \"d\":\n                return n * d;\n            case \"hours\":\n            case \"hour\":\n            case \"hrs\":\n            case \"hr\":\n            case \"h\":\n                return n * h;\n            case \"minutes\":\n            case \"minute\":\n            case \"mins\":\n            case \"min\":\n            case \"m\":\n                return n * m;\n            case \"seconds\":\n            case \"second\":\n            case \"secs\":\n            case \"sec\":\n            case \"s\":\n                return n * s;\n            case \"milliseconds\":\n            case \"millisecond\":\n            case \"msecs\":\n            case \"msec\":\n            case \"ms\":\n                return n;\n            default:\n                return undefined;\n        }\n    }\n    /**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return Math.round(ms / d) + \"d\";\n        }\n        if (msAbs >= h) {\n            return Math.round(ms / h) + \"h\";\n        }\n        if (msAbs >= m) {\n            return Math.round(ms / m) + \"m\";\n        }\n        if (msAbs >= s) {\n            return Math.round(ms / s) + \"s\";\n        }\n        return ms + \"ms\";\n    }\n    /**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return plural(ms, msAbs, d, \"day\");\n        }\n        if (msAbs >= h) {\n            return plural(ms, msAbs, h, \"hour\");\n        }\n        if (msAbs >= m) {\n            return plural(ms, msAbs, m, \"minute\");\n        }\n        if (msAbs >= s) {\n            return plural(ms, msAbs, s, \"second\");\n        }\n        return ms + \" ms\";\n    }\n    /**\n\t * Pluralization helper.\n\t */ function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n    return ms;\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ var humanizeMs;\nvar hasRequiredHumanizeMs;\nfunction requireHumanizeMs() {\n    if (hasRequiredHumanizeMs) return humanizeMs;\n    hasRequiredHumanizeMs = 1;\n    /**\n\t * Module dependencies.\n\t */ var util = (util__WEBPACK_IMPORTED_MODULE_5___default());\n    var ms = /*@__PURE__*/ requireMs();\n    humanizeMs = function(t) {\n        if (typeof t === \"number\") return t;\n        var r = ms(t);\n        if (r === undefined) {\n            var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n            console.warn(err.stack);\n        }\n        return r;\n    };\n    return humanizeMs;\n}\nvar constants;\nvar hasRequiredConstants;\nfunction requireConstants() {\n    if (hasRequiredConstants) return constants;\n    hasRequiredConstants = 1;\n    constants = {\n        // agent\n        CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n        CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n        INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n        CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n        // socket\n        SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n        SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n        SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n        SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n    };\n    return constants;\n}\nvar agent;\nvar hasRequiredAgent;\nfunction requireAgent() {\n    if (hasRequiredAgent) return agent;\n    hasRequiredAgent = 1;\n    const OriginalAgent = (http__WEBPACK_IMPORTED_MODULE_6___default().Agent);\n    const ms = /*@__PURE__*/ requireHumanizeMs();\n    const debug = util__WEBPACK_IMPORTED_MODULE_5___default().debuglog(\"agentkeepalive\");\n    const { INIT_SOCKET, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = /*@__PURE__*/ requireConstants();\n    // OriginalAgent come from\n    // - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n    // - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n    // node <= 10\n    let defaultTimeoutListenerCount = 1;\n    const majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\n    if (majorVersion >= 11 && majorVersion <= 12) {\n        defaultTimeoutListenerCount = 2;\n    } else if (majorVersion >= 13) {\n        defaultTimeoutListenerCount = 3;\n    }\n    function deprecate(message) {\n        console.log(\"[agentkeepalive:deprecated] %s\", message);\n    }\n    class Agent extends OriginalAgent {\n        constructor(options){\n            options = options || {};\n            options.keepAlive = options.keepAlive !== false;\n            // default is keep-alive and 4s free socket timeout\n            // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n            if (options.freeSocketTimeout === undefined) {\n                options.freeSocketTimeout = 4000;\n            }\n            // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.keepAliveTimeout) {\n                deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.keepAliveTimeout;\n                delete options.keepAliveTimeout;\n            }\n            // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.freeSocketKeepAliveTimeout) {\n                deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n                delete options.freeSocketKeepAliveTimeout;\n            }\n            // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n            // By default is double free socket timeout.\n            if (options.timeout === undefined) {\n                // make sure socket default inactivity timeout >= 8s\n                options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n            }\n            // support humanize format\n            options.timeout = ms(options.timeout);\n            options.freeSocketTimeout = ms(options.freeSocketTimeout);\n            options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n            super(options);\n            this[CURRENT_ID] = 0;\n            // create socket success counter\n            this.createSocketCount = 0;\n            this.createSocketCountLastCheck = 0;\n            this.createSocketErrorCount = 0;\n            this.createSocketErrorCountLastCheck = 0;\n            this.closeSocketCount = 0;\n            this.closeSocketCountLastCheck = 0;\n            // socket error event count\n            this.errorSocketCount = 0;\n            this.errorSocketCountLastCheck = 0;\n            // request finished counter\n            this.requestCount = 0;\n            this.requestCountLastCheck = 0;\n            // including free socket timeout counter\n            this.timeoutSocketCount = 0;\n            this.timeoutSocketCountLastCheck = 0;\n            this.on(\"free\", (socket)=>{\n                // https://github.com/nodejs/node/pull/32000\n                // Node.js native agent will check socket timeout eqs agent.options.timeout.\n                // Use the ttl or freeSocketTimeout to overwrite.\n                const timeout = this.calcSocketTimeout(socket);\n                if (timeout > 0 && socket.timeout !== timeout) {\n                    socket.setTimeout(timeout);\n                }\n            });\n        }\n        get freeSocketKeepAliveTimeout() {\n            deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n            return this.options.freeSocketTimeout;\n        }\n        get timeout() {\n            deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n            return this.options.timeout;\n        }\n        get socketActiveTTL() {\n            deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n            return this.options.socketActiveTTL;\n        }\n        calcSocketTimeout(socket) {\n            /**\n\t     * return <= 0: should free socket\n\t     * return > 0: should update socket timeout\n\t     * return undefined: not find custom timeout\n\t     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n            const socketActiveTTL = this.options.socketActiveTTL;\n            if (socketActiveTTL) {\n                // check socketActiveTTL\n                const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n                const diff = socketActiveTTL - aliveTime;\n                if (diff <= 0) {\n                    return diff;\n                }\n                if (freeSocketTimeout && diff < freeSocketTimeout) {\n                    freeSocketTimeout = diff;\n                }\n            }\n            // set freeSocketTimeout\n            if (freeSocketTimeout) {\n                // set free keepalive timer\n                // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n                // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n                const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n                return customFreeSocketTimeout || freeSocketTimeout;\n            }\n        }\n        keepSocketAlive(socket) {\n            const result = super.keepSocketAlive(socket);\n            // should not keepAlive, do nothing\n            if (!result) return result;\n            const customTimeout = this.calcSocketTimeout(socket);\n            if (typeof customTimeout === \"undefined\") {\n                return true;\n            }\n            if (customTimeout <= 0) {\n                debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n                return false;\n            }\n            if (socket.timeout !== customTimeout) {\n                socket.setTimeout(customTimeout);\n            }\n            return true;\n        }\n        // only call on addRequest\n        reuseSocket(...args) {\n            // reuseSocket(socket, req)\n            super.reuseSocket(...args);\n            const socket = args[0];\n            const req = args[1];\n            req.reusedSocket = true;\n            const agentTimeout = this.options.timeout;\n            if (getSocketTimeout(socket) !== agentTimeout) {\n                // reset timeout before use\n                socket.setTimeout(agentTimeout);\n                debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n            }\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n        }\n        [CREATE_ID]() {\n            const id = this[CURRENT_ID]++;\n            if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n            return id;\n        }\n        [INIT_SOCKET](socket, options) {\n            // bugfix here.\n            // https on node 8, 10 won't set agent.options.timeout by default\n            // TODO: need to fix on node itself\n            if (options.timeout) {\n                const timeout = getSocketTimeout(socket);\n                if (!timeout) {\n                    socket.setTimeout(options.timeout);\n                }\n            }\n            if (this.options.keepAlive) {\n                // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n                // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n                socket.setNoDelay(true);\n            }\n            this.createSocketCount++;\n            if (this.options.socketActiveTTL) {\n                socket[SOCKET_CREATED_TIME] = Date.now();\n            }\n            // don't show the hole '-----BEGIN CERTIFICATE----' key string\n            socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n            socket[SOCKET_REQUEST_COUNT] = 1;\n            socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n            installListeners(this, socket, options);\n        }\n        createConnection(options, oncreate) {\n            let called = false;\n            const onNewCreate = (err, socket)=>{\n                if (called) return;\n                called = true;\n                if (err) {\n                    this.createSocketErrorCount++;\n                    return oncreate(err);\n                }\n                this[INIT_SOCKET](socket, options);\n                oncreate(err, socket);\n            };\n            const newSocket = super.createConnection(options, onNewCreate);\n            if (newSocket) onNewCreate(null, newSocket);\n            return newSocket;\n        }\n        get statusChanged() {\n            const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n            if (changed) {\n                this.createSocketCountLastCheck = this.createSocketCount;\n                this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n                this.closeSocketCountLastCheck = this.closeSocketCount;\n                this.errorSocketCountLastCheck = this.errorSocketCount;\n                this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n                this.requestCountLastCheck = this.requestCount;\n            }\n            return changed;\n        }\n        getCurrentStatus() {\n            return {\n                createSocketCount: this.createSocketCount,\n                createSocketErrorCount: this.createSocketErrorCount,\n                closeSocketCount: this.closeSocketCount,\n                errorSocketCount: this.errorSocketCount,\n                timeoutSocketCount: this.timeoutSocketCount,\n                requestCount: this.requestCount,\n                freeSockets: inspect(this.freeSockets),\n                sockets: inspect(this.sockets),\n                requests: inspect(this.requests)\n            };\n        }\n    }\n    // node 8 don't has timeout attribute on socket\n    // https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\n    function getSocketTimeout(socket) {\n        return socket.timeout || socket._idleTimeout;\n    }\n    function installListeners(agent, socket, options) {\n        debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n        // listener socket events: close, timeout, error, free\n        function onFree() {\n            // create and socket.emit('free') logic\n            // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n            // no req on the socket, it should be the new socket\n            if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n            socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n            agent.requestCount++;\n            debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // should reuse on pedding requests?\n            const name = agent.getName(options);\n            if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n                // will be reuse on agent free listener\n                socket[SOCKET_REQUEST_COUNT]++;\n                debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            }\n        }\n        socket.on(\"free\", onFree);\n        function onClose(isError) {\n            debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n            agent.closeSocketCount++;\n        }\n        socket.on(\"close\", onClose);\n        // start socket timeout handler\n        function onTimeout() {\n            // onTimeout and emitRequestTimeout(_http_client.js)\n            // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n            const listenerCount = socket.listeners(\"timeout\").length;\n            // node <= 10, default listenerCount is 1, onTimeout\n            // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n            // node >= 13, default listenerCount is 3, onTimeout,\n            //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n            //   and emitRequestTimeout\n            const timeout = getSocketTimeout(socket);\n            const req = socket._httpMessage;\n            const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n            debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n            if (debug.enabled) {\n                debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n            }\n            agent.timeoutSocketCount++;\n            const name = agent.getName(options);\n            if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n                // free socket timeout, destroy quietly\n                socket.destroy();\n                // Remove it from freeSockets list immediately to prevent new requests\n                // from being sent through this socket.\n                agent.removeSocket(socket, options);\n                debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n            } else {\n                // if there is no any request socket timeout handler,\n                // agent need to handle socket timeout itself.\n                //\n                // custom request socket timeout handle logic must follow these rules:\n                //  1. Destroy socket first\n                //  2. Must emit socket 'agentRemove' event tell agent remove socket\n                //     from freeSockets list immediately.\n                //     Otherise you may be get 'socket hang up' error when reuse\n                //     free socket and timeout happen in the same time.\n                if (reqTimeoutListenerCount === 0) {\n                    const error = new Error(\"Socket timeout\");\n                    error.code = \"ERR_SOCKET_TIMEOUT\";\n                    error.timeout = timeout;\n                    // must manually call socket.end() or socket.destroy() to end the connection.\n                    // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                    socket.destroy(error);\n                    agent.removeSocket(socket, options);\n                    debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n                }\n            }\n        }\n        socket.on(\"timeout\", onTimeout);\n        function onError(err) {\n            const listenerCount = socket.listeners(\"error\").length;\n            debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n            agent.errorSocketCount++;\n            if (listenerCount === 1) {\n                // if socket don't contain error event handler, don't catch it, emit it again\n                debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n                socket.removeListener(\"error\", onError);\n                socket.emit(\"error\", err);\n            }\n        }\n        socket.on(\"error\", onError);\n        function onRemove() {\n            debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // We need this function for cases like HTTP 'upgrade'\n            // (defined by WebSockets) where we need to remove a socket from the\n            // pool because it'll be locked up indefinitely\n            socket.removeListener(\"close\", onClose);\n            socket.removeListener(\"error\", onError);\n            socket.removeListener(\"free\", onFree);\n            socket.removeListener(\"timeout\", onTimeout);\n            socket.removeListener(\"agentRemove\", onRemove);\n        }\n        socket.on(\"agentRemove\", onRemove);\n    }\n    agent = Agent;\n    function inspect(obj) {\n        const res = {};\n        for(const key in obj){\n            res[key] = obj[key].length;\n        }\n        return res;\n    }\n    return agent;\n}\nvar https_agent;\nvar hasRequiredHttps_agent;\nfunction requireHttps_agent() {\n    if (hasRequiredHttps_agent) return https_agent;\n    hasRequiredHttps_agent = 1;\n    const OriginalHttpsAgent = (https__WEBPACK_IMPORTED_MODULE_7___default().Agent);\n    const HttpAgent = /*@__PURE__*/ requireAgent();\n    const { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = /*@__PURE__*/ requireConstants();\n    class HttpsAgent extends HttpAgent {\n        constructor(options){\n            super(options);\n            this.defaultPort = 443;\n            this.protocol = \"https:\";\n            this.maxCachedSessions = this.options.maxCachedSessions;\n            /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n                this.maxCachedSessions = 100;\n            }\n            this._sessionCache = {\n                map: {},\n                list: []\n            };\n        }\n        createConnection(options, oncreate) {\n            const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n            this[INIT_SOCKET](socket, options);\n            return socket;\n        }\n    }\n    // https://github.com/nodejs/node/blob/master/lib/https.js#L89\n    HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n    [\n        \"getName\",\n        \"_getSession\",\n        \"_cacheSession\",\n        // https://github.com/nodejs/node/pull/4982\n        \"_evictSession\"\n    ].forEach(function(method) {\n        /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n            HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];\n        }\n    });\n    https_agent = HttpsAgent;\n    return https_agent;\n}\nvar hasRequiredAgentkeepalive;\nfunction requireAgentkeepalive() {\n    if (hasRequiredAgentkeepalive) return agentkeepalive.exports;\n    hasRequiredAgentkeepalive = 1;\n    agentkeepalive.exports = /*@__PURE__*/ requireAgent();\n    agentkeepalive.exports.HttpsAgent = /*@__PURE__*/ requireHttps_agent();\n    agentkeepalive.exports.constants = /*@__PURE__*/ requireConstants();\n    return agentkeepalive.exports;\n}\nvar agentkeepaliveExports = /*@__PURE__*/ requireAgentkeepalive();\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar fastStableStringify$1;\nvar hasRequiredFastStableStringify;\nfunction requireFastStableStringify() {\n    if (hasRequiredFastStableStringify) return fastStableStringify$1;\n    hasRequiredFastStableStringify = 1;\n    var objToString = Object.prototype.toString;\n    var objKeys = Object.keys || function(obj) {\n        var keys = [];\n        for(var name in obj){\n            keys.push(name);\n        }\n        return keys;\n    };\n    function stringify(val, isArrayProp) {\n        var i, max, str, keys, key, propVal, toStr;\n        if (val === true) {\n            return \"true\";\n        }\n        if (val === false) {\n            return \"false\";\n        }\n        switch(typeof val){\n            case \"object\":\n                if (val === null) {\n                    return null;\n                } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                    return stringify(val.toJSON(), isArrayProp);\n                } else {\n                    toStr = objToString.call(val);\n                    if (toStr === \"[object Array]\") {\n                        str = \"[\";\n                        max = val.length - 1;\n                        for(i = 0; i < max; i++){\n                            str += stringify(val[i], true) + \",\";\n                        }\n                        if (max > -1) {\n                            str += stringify(val[i], true);\n                        }\n                        return str + \"]\";\n                    } else if (toStr === \"[object Object]\") {\n                        // only object is left\n                        keys = objKeys(val).sort();\n                        max = keys.length;\n                        str = \"\";\n                        i = 0;\n                        while(i < max){\n                            key = keys[i];\n                            propVal = stringify(val[key], false);\n                            if (propVal !== undefined) {\n                                if (str) {\n                                    str += \",\";\n                                }\n                                str += JSON.stringify(key) + \":\" + propVal;\n                            }\n                            i++;\n                        }\n                        return \"{\" + str + \"}\";\n                    } else {\n                        return JSON.stringify(val);\n                    }\n                }\n            case \"function\":\n            case \"undefined\":\n                return isArrayProp ? null : undefined;\n            case \"string\":\n                return JSON.stringify(val);\n            default:\n                return isFinite(val) ? val : null;\n        }\n    }\n    fastStableStringify$1 = function(val) {\n        var returnVal = stringify(val, false);\n        if (returnVal !== undefined) {\n            return \"\" + returnVal;\n        }\n    };\n    return fastStableStringify$1;\n}\nvar fastStableStringifyExports = /*@__PURE__*/ requireFastStableStringify();\nvar fastStableStringify = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringifyExports);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await node_fetch__WEBPACK_IMPORTED_MODULE_9__[\"default\"](processedInput, init);\n};\nclass RpcWebSocketClient extends rpc_websockets__WEBPACK_IMPORTED_MODULE_10__.CommonClient {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = (0,rpc_websockets__WEBPACK_IMPORTED_MODULE_10__.WebSocket)(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lastExtendedSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"lastExtendedStartIndex\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n        // option\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, (value)=>buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function applyDefaultMemcmpEncodingToFilters(filters) {\n    return filters.map((filter)=>\"memcmp\" in filter ? {\n            ...filter,\n            memcmp: {\n                ...filter.memcmp,\n                encoding: filter.memcmp.encoding ?? \"base58\"\n            }\n        } : filter);\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.any)())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    \"solana-core\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    \"feature-set\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ParsedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString,\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)()\n});\nconst PartiallyDecodedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    programId: PublicKeyFromString,\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n        ])\n    }))),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            ParsedInstructionStruct,\n            PartiallyDecodedInstructionStruct\n        ]))\n    }))))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    range: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new agentkeepaliveExports.HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_7__.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_7__.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8___default())(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    address: PublicKeyFromString,\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: BufferFromRawAccountData,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    space: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: ParsedAccountDataResult,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n    ParsedAccountDataResult\n]), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    state: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"active\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"inactive\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"activating\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"deactivating\")\n    ]),\n    active: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    root: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"firstShredReceived\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"completed\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"optimisticConfirmation\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"root\")\n        ]),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"createdBank\"),\n        parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"frozen\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"dead\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    ])),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    current: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult),\n    delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"processed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"confirmed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"finalized\")\n]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    err: TransactionErrorResult,\n    confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKey: PublicKeyFromString,\n    writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        header: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    source: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"transaction\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n        program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, RawInstructionResult);\n    } else {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }))\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    costUnits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction)\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    costUnits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(0),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"legacy\")\n]);\n/** @internal */ const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    transaction: ConfirmedTransactionResult,\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    result: notificationResultAndContext(LogsResult),\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"1.0.0-maintenance\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   *\n   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", {\n            ...configWithoutEncoding,\n            ...configWithoutEncoding.filters ? {\n                filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)\n            } : null\n        });\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const { context, value: { blockhash } } = await this.getLatestBlockhashAndContext(commitment);\n        const feeCalculator = {\n            get lamportsPerSignature () {\n                throw new Error(\"The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is \" + \"no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee \" + \"for a given message.\");\n            },\n            toJSON () {\n                return {};\n            }\n        };\n        return {\n            context,\n            value: {\n                blockhash,\n                feeCalculator\n            }\n        };\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n                config.innerInstructions = configOrSigners.innerInstructions;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n            config.innerInstructions = configOrSigners.innerInstructions;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError({\n                action: \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs = undefined;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError({\n                action: skipPreflight ? \"send\" : \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            console.error(`Received ${e instanceof Error ? \"\" : \"JSON-RPC \"}error calling \\`${method}\\``, {\n                                args,\n                                error: e\n                            });\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onAccountChange(publicKey, callback, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\", config);\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , config ? config : maybeFilters ? {\n            filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__.getU64Encoder)().encode(params.recentSlot)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"padding\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"ethAddressOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"ethAddressInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"messageInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, \"ethAddress\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, \"signature\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    name: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    website: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    details: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    iconUrl: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer) {\n        let byteArray = [\n            ...buffer\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.assert)(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // votes.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"confirmationCount\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"votes\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"rootSlotValid\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"rootSlot\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // authorizedVoters.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"authorizedVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            publicKey(\"authorizedPubkey\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epochOfLastAuthorizedSwitch\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"idx\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // epochCredits.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"credits\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"prevCredits\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"epochCredits\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: sendOptions?.skipPreflight ? \"send\" : \"simulate\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNnQjtBQUN6QjtBQUNDO0FBQ3NCO0FBQ3VCO0FBQ2Y7QUFDVDtBQUN1QjtBQUN0QztBQUNFO0FBQ1k7QUFDc0k7QUFDaEk7QUFDVjtBQUNpQjtBQUNUO0FBQ0k7QUFFcEQ7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBRUQsTUFBTXdDLHFCQUFxQnZDLDJEQUFPQSxDQUFDd0MsS0FBSyxDQUFDQyxnQkFBZ0I7QUFDekQsTUFBTUMsa0JBQWtCO0lBQ3RCLE1BQU1DLGdCQUFnQjNDLDJEQUFPQSxDQUFDd0MsS0FBSyxDQUFDQyxnQkFBZ0I7SUFDcEQsTUFBTUcsWUFBWUMsYUFBYUY7SUFDL0IsTUFBTUcsWUFBWSxJQUFJQyxXQUFXO0lBQ2pDRCxVQUFVRSxHQUFHLENBQUNMO0lBQ2RHLFVBQVVFLEdBQUcsQ0FBQ0osV0FBVztJQUN6QixPQUFPO1FBQ0xBO1FBQ0FFO0lBQ0Y7QUFDRjtBQUNBLE1BQU1ELGVBQWU3QywyREFBT0EsQ0FBQzZDLFlBQVk7QUFDekMsU0FBU0ksVUFBVUwsU0FBUztJQUMxQixJQUFJO1FBQ0Y1QywyREFBT0EsQ0FBQ2tELGFBQWEsQ0FBQ0MsT0FBTyxDQUFDUDtRQUM5QixPQUFPO0lBQ1QsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFDQSxNQUFNUSxPQUFPLENBQUNDLFNBQVNQLFlBQWM5QywyREFBT0EsQ0FBQ29ELElBQUksQ0FBQ0MsU0FBU1AsVUFBVVEsS0FBSyxDQUFDLEdBQUc7QUFDOUUsTUFBTUMsU0FBU3ZELDJEQUFPQSxDQUFDdUQsTUFBTTtBQUU3QixNQUFNQyxXQUFXQyxDQUFBQTtJQUNmLElBQUkxRCww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QVdBO2dCQUNYNlQsb0JBQW9CLENBQUMsU0FBUyxFQUFFOUYsS0FBS0MsU0FBUyxDQUFDMEksUUFBUSxDQUFDLENBQUM7WUFDM0Q7UUFDRjtRQUNBLE1BQU0sSUFBSXRhLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTRELFVBQVUsU0FBUyxFQUFFK04sS0FBS0MsU0FBUyxDQUFDMEksUUFBUSxDQUFDLENBQUM7SUFDbkY7SUFDQSxPQUFPMVc7QUFDVDtBQUVBOztDQUVDLEdBQ0QsTUFBTXMyQyxtQkFBbUI7QUFFNmdELENBQ3RpRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5lc20uanM/OGZhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IGJzNTggZnJvbSAnYnM1OCc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBkZXNlcmlhbGl6ZVVuY2hlY2tlZCB9IGZyb20gJ2JvcnNoJztcbmltcG9ydCAqIGFzIEJ1ZmZlckxheW91dCBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgYmxvYiB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyBnZXRVNjRDb2RlYywgZ2V0VTY0RW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLW51bWJlcnMnO1xuaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSAndXRpbCc7XG5pbXBvcnQgcmVxdWlyZSQkMCQxIGZyb20gJ2h0dHAnO1xuaW1wb3J0IHJlcXVpcmUkJDAkMiwgeyBBZ2VudCB9IGZyb20gJ2h0dHBzJztcbmltcG9ydCB7IGNvZXJjZSwgaW5zdGFuY2UsIHN0cmluZywgdHVwbGUsIGxpdGVyYWwsIHVua25vd24sIHR5cGUsIG51bWJlciwgYXJyYXksIG51bGxhYmxlLCBvcHRpb25hbCwgYm9vbGVhbiwgcmVjb3JkLCB1bmlvbiwgY3JlYXRlLCBhbnksIGFzc2VydCBhcyBhc3NlcnQkMSB9IGZyb20gJ3N1cGVyc3RydWN0JztcbmltcG9ydCBScGNDbGllbnQgZnJvbSAnamF5c29uL2xpYi9jbGllbnQvYnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBub2RlRmV0Y2ggZnJvbSAnbm9kZS1mZXRjaCc7XG5pbXBvcnQgeyBDb21tb25DbGllbnQsIFdlYlNvY2tldCB9IGZyb20gJ3JwYy13ZWJzb2NrZXRzJztcbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTMnO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuXG4vKipcbiAqIEEgNjQgYnl0ZSBzZWNyZXQga2V5LCB0aGUgZmlyc3QgMzIgYnl0ZXMgb2Ygd2hpY2ggaXMgdGhlXG4gKiBwcml2YXRlIHNjYWxhciBhbmQgdGhlIGxhc3QgMzIgYnl0ZXMgaXMgdGhlIHB1YmxpYyBrZXkuXG4gKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gKi9cblxuLyoqXG4gKiBFZDI1NTE5IEtleXBhaXJcbiAqL1xuXG5jb25zdCBnZW5lcmF0ZVByaXZhdGVLZXkgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXk7XG5jb25zdCBnZW5lcmF0ZUtleXBhaXIgPSAoKSA9PiB7XG4gIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHByaXZhdGVTY2FsYXIpO1xuICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHNlY3JldEtleS5zZXQocHJpdmF0ZVNjYWxhcik7XG4gIHNlY3JldEtleS5zZXQocHVibGljS2V5LCAzMik7XG4gIHJldHVybiB7XG4gICAgcHVibGljS2V5LFxuICAgIHNlY3JldEtleVxuICB9O1xufTtcbmNvbnN0IGdldFB1YmxpY0tleSA9IGVkMjU1MTkuZ2V0UHVibGljS2V5O1xuZnVuY3Rpb24gaXNPbkN1cnZlKHB1YmxpY0tleSkge1xuICB0cnkge1xuICAgIGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY29uc3Qgc2lnbiA9IChtZXNzYWdlLCBzZWNyZXRLZXkpID0+IGVkMjU1MTkuc2lnbihtZXNzYWdlLCBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpKTtcbmNvbnN0IHZlcmlmeSA9IGVkMjU1MTkudmVyaWZ5O1xuXG5jb25zdCB0b0J1ZmZlciA9IGFyciA9PiB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAoYXJyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpO1xuICB9XG59O1xuXG4vLyBDbGFzcyB3cmFwcGluZyBhIHBsYWluIG9iamVjdFxuY2xhc3MgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyk7XG4gIH1cbiAgZW5jb2RlKCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcykpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGUoZGF0YSkge1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZShTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlVW5jaGVja2VkKGRhdGEpIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVVbmNoZWNrZWQoU09MQU5BX1NDSEVNQSwgdGhpcywgZGF0YSk7XG4gIH1cbn1cblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIGEgUnVzdC1jb21wYXRpYmxlIGVudW0sIHNpbmNlIGVudW1zIGFyZSBvbmx5IHN0cmluZ3Mgb3Jcbi8vIG51bWJlcnMgaW4gcHVyZSBKU1xuY2xhc3MgRW51bSBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLmVudW0gPSAnJztcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudW0gY2FuIG9ubHkgdGFrZSBzaW5nbGUgdmFsdWUnKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMocHJvcGVydGllcykubWFwKGtleSA9PiB7XG4gICAgICB0aGlzLmVudW0gPSBrZXk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFNPTEFOQV9TQ0hFTUEgPSBuZXcgTWFwKCk7XG5cbnZhciBfUHVibGljS2V5O1xuXG4vKipcbiAqIE1heGltdW0gbGVuZ3RoIG9mIGRlcml2ZWQgcHVia2V5IHNlZWRcbiAqL1xuY29uc3QgTUFYX1NFRURfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogU2l6ZSBvZiBwdWJsaWMga2V5IGluIGJ5dGVzXG4gKi9cbmNvbnN0IFBVQkxJQ19LRVlfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogVmFsdWUgdG8gYmUgY29udmVydGVkIGludG8gcHVibGljIGtleVxuICovXG5cbi8qKlxuICogSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgUHVibGljS2V5IGNsYXNzXG4gKi9cblxuZnVuY3Rpb24gaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5fYm4gIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gbG9jYWwgY291bnRlciB1c2VkIGJ5IFB1YmxpY0tleS51bmlxdWUoKVxubGV0IHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgPSAxO1xuXG4vKipcbiAqIEEgcHVibGljIGtleVxuICovXG5jbGFzcyBQdWJsaWNLZXkgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFB1YmxpY0tleSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIGVkMjU1MTkgcHVibGljIGtleSBhcyBidWZmZXIgb3IgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2JuID0gdm9pZCAwO1xuICAgIGlmIChpc1B1YmxpY0tleURhdGEodmFsdWUpKSB7XG4gICAgICB0aGlzLl9ibiA9IHZhbHVlLl9ibjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gYXNzdW1lIGJhc2UgNTggZW5jb2RpbmcgYnkgZGVmYXVsdFxuICAgICAgICBjb25zdCBkZWNvZGVkID0gYnM1OC5kZWNvZGUodmFsdWUpO1xuICAgICAgICBpZiAoZGVjb2RlZC5sZW5ndGggIT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOKGRlY29kZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm4gPSBuZXcgQk4odmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2JuLmJ5dGVMZW5ndGgoKSA+IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5IGlucHV0YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB1bmlxdWUgUHVibGljS2V5IGZvciB0ZXN0cyBhbmQgYmVuY2htYXJrcyB1c2luZyBhIGNvdW50ZXJcbiAgICovXG4gIHN0YXRpYyB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleSh1bmlxdWVQdWJsaWNLZXlDb3VudGVyKTtcbiAgICB1bmlxdWVQdWJsaWNLZXlDb3VudGVyICs9IDE7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoa2V5LnRvQnVmZmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcHVibGljIGtleSB2YWx1ZS4gVGhlIGJhc2U1OC1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBpcyBhbGwgb25lcyAoYXMgc2VlbiBiZWxvdylcbiAgICogVGhlIHVuZGVybHlpbmcgQk4gbnVtYmVyIGlzIDMyIGJ5dGVzIHRoYXQgYXJlIGFsbCB6ZXJvc1xuICAgKi9cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBwdWJsaWNLZXlzIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHB1YmxpY0tleSkge1xuICAgIHJldHVybiB0aGlzLl9ibi5lcShwdWJsaWNLZXkuX2JuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvQmFzZTU4KCkge1xuICAgIHJldHVybiBiczU4LmVuY29kZSh0aGlzLnRvQnl0ZXMoKSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnl0ZXMoKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnVmZmVyKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLl9ibi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBjb25zdCB6ZXJvUGFkID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICBiLmNvcHkoemVyb1BhZCwgMzIgLSBiLmxlbmd0aCk7XG4gICAgcmV0dXJuIHplcm9QYWQ7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBgUHVibGljS2V5KCR7dGhpcy50b1N0cmluZygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYmFzZS01OCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBwdWJsaWMga2V5IGZyb20gYW5vdGhlciBrZXksIGEgc2VlZCwgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICogVGhlIHByb2dyYW0gSUQgd2lsbCBhbHNvIHNlcnZlIGFzIHRoZSBvd25lciBvZiB0aGUgcHVibGljIGtleSwgZ2l2aW5nXG4gICAqIGl0IHBlcm1pc3Npb24gdG8gd3JpdGUgZGF0YSB0byB0aGUgYWNjb3VudC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVdpdGhTZWVkKGZyb21QdWJsaWNLZXksIHNlZWQsIHByb2dyYW1JZCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2Zyb21QdWJsaWNLZXkudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oc2VlZCksIHByb2dyYW1JZC50b0J1ZmZlcigpXSk7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYoYnVmZmVyKTtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHJvZ3JhbSBhZGRyZXNzIGZyb20gc2VlZHMgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICBzZWVkcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICBpZiAoc2VlZC5sZW5ndGggPiBNQVhfU0VFRF9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTWF4IHNlZWQgbGVuZ3RoIGV4Y2VlZGVkYCk7XG4gICAgICB9XG4gICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIHRvQnVmZmVyKHNlZWQpXSk7XG4gICAgfSk7XG4gICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBwcm9ncmFtSWQudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oJ1Byb2dyYW1EZXJpdmVkQWRkcmVzcycpXSk7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYoYnVmZmVyKTtcbiAgICBpZiAoaXNPbkN1cnZlKHB1YmxpY0tleUJ5dGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlZWRzLCBhZGRyZXNzIG11c3QgZmFsbCBvZmYgdGhlIGN1cnZlYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luYyB2ZXJzaW9uIG9mIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVByb2dyYW1BZGRyZXNzKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIHZhbGlkIHByb2dyYW0gYWRkcmVzc1xuICAgKlxuICAgKiBWYWxpZCBwcm9ncmFtIGFkZHJlc3NlcyBtdXN0IGZhbGwgb2ZmIHRoZSBlZDI1NTE5IGN1cnZlLiAgVGhpcyBmdW5jdGlvblxuICAgKiBpdGVyYXRlcyBhIG5vbmNlIHVudGlsIGl0IGZpbmRzIG9uZSB0aGF0IHdoZW4gY29tYmluZWQgd2l0aCB0aGUgc2VlZHNcbiAgICogcmVzdWx0cyBpbiBhIHZhbGlkIHByb2dyYW0gYWRkcmVzcy5cbiAgICovXG4gIHN0YXRpYyBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICBsZXQgbm9uY2UgPSAyNTU7XG4gICAgbGV0IGFkZHJlc3M7XG4gICAgd2hpbGUgKG5vbmNlICE9IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlZWRzV2l0aE5vbmNlID0gc2VlZHMuY29uY2F0KEJ1ZmZlci5mcm9tKFtub25jZV0pKTtcbiAgICAgICAgYWRkcmVzcyA9IHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzV2l0aE5vbmNlLCBwcm9ncmFtSWQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgbm9uY2UtLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2FkZHJlc3MsIG5vbmNlXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBhIHZpYWJsZSBwcm9ncmFtIGFkZHJlc3Mgbm9uY2VgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luYyB2ZXJzaW9uIG9mIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZmluZFByb2dyYW1BZGRyZXNzU3luY30gaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRQcm9ncmFtQWRkcmVzcyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGF0IGEgcHVia2V5IGlzIG9uIHRoZSBlZDI1NTE5IGN1cnZlLlxuICAgKi9cbiAgc3RhdGljIGlzT25DdXJ2ZShwdWJrZXlEYXRhKSB7XG4gICAgY29uc3QgcHVia2V5ID0gbmV3IFB1YmxpY0tleShwdWJrZXlEYXRhKTtcbiAgICByZXR1cm4gaXNPbkN1cnZlKHB1YmtleS50b0J5dGVzKCkpO1xuICB9XG59XG5fUHVibGljS2V5ID0gUHVibGljS2V5O1xuUHVibGljS2V5LmRlZmF1bHQgPSBuZXcgX1B1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblNPTEFOQV9TQ0hFTUEuc2V0KFB1YmxpY0tleSwge1xuICBraW5kOiAnc3RydWN0JyxcbiAgZmllbGRzOiBbWydfYm4nLCAndTI1NiddXVxufSk7XG5cbi8qKlxuICogQW4gYWNjb3VudCBrZXkgcGFpciAocHVibGljIGFuZCBzZWNyZXQga2V5cykuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjEuMTAuMCwgcGxlYXNlIHVzZSB7QGxpbmsgS2V5cGFpcn0gaW5zdGVhZC5cbiAqL1xuY2xhc3MgQWNjb3VudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQWNjb3VudCBvYmplY3RcbiAgICpcbiAgICogSWYgdGhlIHNlY3JldEtleSBwYXJhbWV0ZXIgaXMgbm90IHByb3ZpZGVkIGEgbmV3IGtleSBwYWlyIGlzIHJhbmRvbWx5XG4gICAqIGNyZWF0ZWQgZm9yIHRoZSBhY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBzZWNyZXRLZXkgU2VjcmV0IGtleSBmb3IgdGhlIGFjY291bnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNlY3JldEtleSkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wdWJsaWNLZXkgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3NlY3JldEtleSA9IHZvaWQgMDtcbiAgICBpZiAoc2VjcmV0S2V5KSB7XG4gICAgICBjb25zdCBzZWNyZXRLZXlCdWZmZXIgPSB0b0J1ZmZlcihzZWNyZXRLZXkpO1xuICAgICAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHVibGljS2V5ID0gc2VjcmV0S2V5QnVmZmVyLnNsaWNlKDMyLCA2NCk7XG4gICAgICB0aGlzLl9zZWNyZXRLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMCwgMzIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZWNyZXRLZXkgPSB0b0J1ZmZlcihnZW5lcmF0ZVByaXZhdGVLZXkoKSk7XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSB0b0J1ZmZlcihnZXRQdWJsaWNLZXkodGhpcy5fc2VjcmV0S2V5KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IGZvciB0aGlzIGFjY291bnRcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fcHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgKip1bmVuY3J5cHRlZCoqIHNlY3JldCBrZXkgZm9yIHRoaXMgYWNjb3VudC4gVGhlIGZpcnN0IDMyIGJ5dGVzXG4gICAqIGlzIHRoZSBwcml2YXRlIHNjYWxhciBhbmQgdGhlIGxhc3QgMzIgYnl0ZXMgaXMgdGhlIHB1YmxpYyBrZXkuXG4gICAqIFJlYWQgbW9yZTogaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dhcm5lci8yMDExLzExLzI5L2VkMjU1MTkta2V5cy9cbiAgICovXG4gIGdldCBzZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3RoaXMuX3NlY3JldEtleSwgdGhpcy5fcHVibGljS2V5XSwgNjQpO1xuICB9XG59XG5cbmNvbnN0IEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQlBGTG9hZGVyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIE1heGltdW0gb3Zlci10aGUtd2lyZSBzaXplIG9mIGEgVHJhbnNhY3Rpb25cbiAqXG4gKiAxMjgwIGlzIElQdjYgbWluaW11bSBNVFVcbiAqIDQwIGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBJUHY2IGhlYWRlclxuICogOCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgZnJhZ21lbnQgaGVhZGVyXG4gKi9cbmNvbnN0IFBBQ0tFVF9EQVRBX1NJWkUgPSAxMjgwIC0gNDAgLSA4O1xuY29uc3QgVkVSU0lPTl9QUkVGSVhfTUFTSyA9IDB4N2Y7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5cbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlKSB7XG4gICAgc3VwZXIoYFNpZ25hdHVyZSAke3NpZ25hdHVyZX0gaGFzIGV4cGlyZWQ6IGJsb2NrIGhlaWdodCBleGNlZWRlZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHRpbWVvdXRTZWNvbmRzKSB7XG4gICAgc3VwZXIoYFRyYW5zYWN0aW9uIHdhcyBub3QgY29uZmlybWVkIGluICR7dGltZW91dFNlY29uZHMudG9GaXhlZCgyKX0gc2Vjb25kcy4gSXQgaXMgYCArICd1bmtub3duIGlmIGl0IHN1Y2NlZWRlZCBvciBmYWlsZWQuIENoZWNrIHNpZ25hdHVyZSAnICsgYCR7c2lnbmF0dXJlfSB1c2luZyB0aGUgU29sYW5hIEV4cGxvcmVyIG9yIENMSSB0b29scy5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiB0aGUgbm9uY2UgaXMgbm8gbG9uZ2VyIHZhbGlkLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcidcbn0pO1xuXG5jbGFzcyBNZXNzYWdlQWNjb3VudEtleXMge1xuICBjb25zdHJ1Y3RvcihzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBzdGF0aWNBY2NvdW50S2V5cztcbiAgICB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIGtleVNlZ21lbnRzKCkge1xuICAgIGNvbnN0IGtleVNlZ21lbnRzID0gW3RoaXMuc3RhdGljQWNjb3VudEtleXNdO1xuICAgIGlmICh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlKTtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVNlZ21lbnRzO1xuICB9XG4gIGdldChpbmRleCkge1xuICAgIGZvciAoY29uc3Qga2V5U2VnbWVudCBvZiB0aGlzLmtleVNlZ21lbnRzKCkpIHtcbiAgICAgIGlmIChpbmRleCA8IGtleVNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBrZXlTZWdtZW50W2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4IC09IGtleVNlZ21lbnQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5sZW5ndGg7XG4gIH1cbiAgY29tcGlsZUluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAvLyBCYWlsIGVhcmx5IGlmIGFueSBhY2NvdW50IGluZGV4ZXMgd291bGQgb3ZlcmZsb3cgYSB1OFxuICAgIGNvbnN0IFU4X01BWCA9IDI1NTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBVOF9NQVggKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgaW5kZXggb3ZlcmZsb3cgZW5jb3VudGVyZWQgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleUluZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAga2V5SW5kZXhNYXAuc2V0KGtleS50b0Jhc2U1OCgpLCBpbmRleCk7XG4gICAgfSk7XG4gICAgY29uc3QgZmluZEtleUluZGV4ID0ga2V5ID0+IHtcbiAgICAgIGNvbnN0IGtleUluZGV4ID0ga2V5SW5kZXhNYXAuZ2V0KGtleS50b0Jhc2U1OCgpKTtcbiAgICAgIGlmIChrZXlJbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGFuIHVua25vd24gaW5zdHJ1Y3Rpb24gYWNjb3VudCBrZXkgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgICByZXR1cm4ga2V5SW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZmluZEtleUluZGV4KGluc3RydWN0aW9uLnByb2dyYW1JZCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGZpbmRLZXlJbmRleChtZXRhLnB1YmtleSkpLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgcHVibGljS2V5ID0gKHByb3BlcnR5ID0gJ3B1YmxpY0tleScpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5ibG9iKDMyLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBzaWduYXR1cmVcbiAqL1xuY29uc3Qgc2lnbmF0dXJlID0gKHByb3BlcnR5ID0gJ3NpZ25hdHVyZScpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5ibG9iKDY0LCBwcm9wZXJ0eSk7XG59O1xuLyoqXG4gKiBMYXlvdXQgZm9yIGEgUnVzdCBTdHJpbmcgdHlwZVxuICovXG5jb25zdCBydXN0U3RyaW5nID0gKHByb3BlcnR5ID0gJ3N0cmluZycpID0+IHtcbiAgY29uc3QgcnNsID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignbGVuZ3RoJyksIEJ1ZmZlckxheW91dC51MzIoJ2xlbmd0aFBhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LmJsb2IoQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2NoYXJzJyldLCBwcm9wZXJ0eSk7XG4gIGNvbnN0IF9kZWNvZGUgPSByc2wuZGVjb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgX2VuY29kZSA9IHJzbC5lbmNvZGUuYmluZChyc2wpO1xuICBjb25zdCByc2xTaGltID0gcnNsO1xuICByc2xTaGltLmRlY29kZSA9IChiLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gX2RlY29kZShiLCBvZmZzZXQpO1xuICAgIHJldHVybiBkYXRhWydjaGFycyddLnRvU3RyaW5nKCk7XG4gIH07XG4gIHJzbFNoaW0uZW5jb2RlID0gKHN0ciwgYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGNoYXJzOiBCdWZmZXIuZnJvbShzdHIsICd1dGY4JylcbiAgICB9O1xuICAgIHJldHVybiBfZW5jb2RlKGRhdGEsIGIsIG9mZnNldCk7XG4gIH07XG4gIHJzbFNoaW0uYWxsb2MgPSBzdHIgPT4ge1xuICAgIHJldHVybiBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArIEJ1ZmZlckxheW91dC51MzIoKS5zcGFuICsgQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLmxlbmd0aDtcbiAgfTtcbiAgcmV0dXJuIHJzbFNoaW07XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYW4gQXV0aG9yaXplZCBvYmplY3RcbiAqL1xuY29uc3QgYXV0aG9yaXplZCA9IChwcm9wZXJ0eSA9ICdhdXRob3JpemVkJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdzdGFrZXInKSwgcHVibGljS2V5KCd3aXRoZHJhd2VyJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBMb2NrdXAgb2JqZWN0XG4gKi9cbmNvbnN0IGxvY2t1cCA9IChwcm9wZXJ0eSA9ICdsb2NrdXAnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnM2NCgndW5peFRpbWVzdGFtcCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdjdXN0b2RpYW4nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlSW5pdCBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUluaXQgPSAocHJvcGVydHkgPSAndm90ZUluaXQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzIG9iamVjdFxuICovXG5jb25zdCB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzID0gKHByb3BlcnR5ID0gJ3ZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd2b3RlQXV0aG9yaXphdGlvblR5cGUnKSwgcHVibGljS2V5KCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5JyksIHJ1c3RTdHJpbmcoJ2N1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCcpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKV0sIHByb3BlcnR5KTtcbn07XG5mdW5jdGlvbiBnZXRBbGxvYyh0eXBlLCBmaWVsZHMpIHtcbiAgY29uc3QgZ2V0SXRlbUFsbG9jID0gaXRlbSA9PiB7XG4gICAgaWYgKGl0ZW0uc3BhbiA+PSAwKSB7XG4gICAgICByZXR1cm4gaXRlbS5zcGFuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0uYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVtLmFsbG9jKGZpZWxkc1tpdGVtLnByb3BlcnR5XSk7XG4gICAgfSBlbHNlIGlmICgnY291bnQnIGluIGl0ZW0gJiYgJ2VsZW1lbnRMYXlvdXQnIGluIGl0ZW0pIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2l0ZW0ucHJvcGVydHldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5sZW5ndGggKiBnZXRJdGVtQWxsb2MoaXRlbS5lbGVtZW50TGF5b3V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCdmaWVsZHMnIGluIGl0ZW0pIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBgU3RydWN0dXJlYCB3aG9zZSBzaXplIG5lZWRzIHRvIGJlIHJlY3Vyc2l2ZWx5IG1lYXN1cmVkLlxuICAgICAgcmV0dXJuIGdldEFsbG9jKHtcbiAgICAgICAgbGF5b3V0OiBpdGVtXG4gICAgICB9LCBmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH1cbiAgICAvLyBDb3VsZG4ndCBkZXRlcm1pbmUgYWxsb2NhdGVkIHNpemUgb2YgbGF5b3V0XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGxldCBhbGxvYyA9IDA7XG4gIHR5cGUubGF5b3V0LmZpZWxkcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGFsbG9jICs9IGdldEl0ZW1BbGxvYyhpdGVtKTtcbiAgfSk7XG4gIHJldHVybiBhbGxvYztcbn1cblxuZnVuY3Rpb24gZGVjb2RlTGVuZ3RoKGJ5dGVzKSB7XG4gIGxldCBsZW4gPSAwO1xuICBsZXQgc2l6ZSA9IDA7XG4gIGZvciAoOzspIHtcbiAgICBsZXQgZWxlbSA9IGJ5dGVzLnNoaWZ0KCk7XG4gICAgbGVuIHw9IChlbGVtICYgMHg3ZikgPDwgc2l6ZSAqIDc7XG4gICAgc2l6ZSArPSAxO1xuICAgIGlmICgoZWxlbSAmIDB4ODApID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn1cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aChieXRlcywgbGVuKSB7XG4gIGxldCByZW1fbGVuID0gbGVuO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSByZW1fbGVuICYgMHg3ZjtcbiAgICByZW1fbGVuID4+PSA3O1xuICAgIGlmIChyZW1fbGVuID09IDApIHtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbSB8PSAweDgwO1xuICAgICAgYnl0ZXMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG59XG5cbmNsYXNzIENvbXBpbGVkS2V5cyB7XG4gIGNvbnN0cnVjdG9yKHBheWVyLCBrZXlNZXRhTWFwKSB7XG4gICAgdGhpcy5wYXllciA9IHZvaWQgMDtcbiAgICB0aGlzLmtleU1ldGFNYXAgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXllciA9IHBheWVyO1xuICAgIHRoaXMua2V5TWV0YU1hcCA9IGtleU1ldGFNYXA7XG4gIH1cbiAgc3RhdGljIGNvbXBpbGUoaW5zdHJ1Y3Rpb25zLCBwYXllcikge1xuICAgIGNvbnN0IGtleU1ldGFNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZ2V0T3JJbnNlcnREZWZhdWx0ID0gcHVia2V5ID0+IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBwdWJrZXkudG9CYXNlNTgoKTtcbiAgICAgIGxldCBrZXlNZXRhID0ga2V5TWV0YU1hcC5nZXQoYWRkcmVzcyk7XG4gICAgICBpZiAoa2V5TWV0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleU1ldGEgPSB7XG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGlzSW52b2tlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAga2V5TWV0YU1hcC5zZXQoYWRkcmVzcywga2V5TWV0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5TWV0YTtcbiAgICB9O1xuICAgIGNvbnN0IHBheWVyS2V5TWV0YSA9IGdldE9ySW5zZXJ0RGVmYXVsdChwYXllcik7XG4gICAgcGF5ZXJLZXlNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICBwYXllcktleU1ldGEuaXNXcml0YWJsZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCBpeCBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgIGdldE9ySW5zZXJ0RGVmYXVsdChpeC5wcm9ncmFtSWQpLmlzSW52b2tlZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGFjY291bnRNZXRhIG9mIGl4LmtleXMpIHtcbiAgICAgICAgY29uc3Qga2V5TWV0YSA9IGdldE9ySW5zZXJ0RGVmYXVsdChhY2NvdW50TWV0YS5wdWJrZXkpO1xuICAgICAgICBrZXlNZXRhLmlzU2lnbmVyIHx8PSBhY2NvdW50TWV0YS5pc1NpZ25lcjtcbiAgICAgICAga2V5TWV0YS5pc1dyaXRhYmxlIHx8PSBhY2NvdW50TWV0YS5pc1dyaXRhYmxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbXBpbGVkS2V5cyhwYXllciwga2V5TWV0YU1hcCk7XG4gIH1cbiAgZ2V0TWVzc2FnZUNvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgbWFwRW50cmllcyA9IFsuLi50aGlzLmtleU1ldGFNYXAuZW50cmllcygpXTtcbiAgICBhc3NlcnQobWFwRW50cmllcy5sZW5ndGggPD0gMjU2LCAnTWF4IHN0YXRpYyBhY2NvdW50IGtleXMgbGVuZ3RoIGV4Y2VlZGVkJyk7XG4gICAgY29uc3Qgd3JpdGFibGVTaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiBtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgcmVhZG9ubHlTaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiBtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHdyaXRhYmxlTm9uU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gIW1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCByZWFkb25seU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+ICFtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogd3JpdGFibGVTaWduZXJzLmxlbmd0aCArIHJlYWRvbmx5U2lnbmVycy5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiByZWFkb25seVNpZ25lcnMubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiByZWFkb25seU5vblNpZ25lcnMubGVuZ3RoXG4gICAgfTtcblxuICAgIC8vIHNhbml0eSBjaGVja3NcbiAgICB7XG4gICAgICBhc3NlcnQod3JpdGFibGVTaWduZXJzLmxlbmd0aCA+IDAsICdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgd3JpdGFibGUgc2lnbmVyIGtleScpO1xuICAgICAgY29uc3QgW3BheWVyQWRkcmVzc10gPSB3cml0YWJsZVNpZ25lcnNbMF07XG4gICAgICBhc3NlcnQocGF5ZXJBZGRyZXNzID09PSB0aGlzLnBheWVyLnRvQmFzZTU4KCksICdFeHBlY3RlZCBmaXJzdCB3cml0YWJsZSBzaWduZXIga2V5IHRvIGJlIHRoZSBmZWUgcGF5ZXInKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXMgPSBbLi4ud3JpdGFibGVTaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ucmVhZG9ubHlTaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ud3JpdGFibGVOb25TaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ucmVhZG9ubHlOb25TaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKV07XG4gICAgcmV0dXJuIFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXTtcbiAgfVxuICBleHRyYWN0VGFibGVMb29rdXAobG9va3VwVGFibGUpIHtcbiAgICBjb25zdCBbd3JpdGFibGVJbmRleGVzLCBkcmFpbmVkV3JpdGFibGVLZXlzXSA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlLnN0YXRlLmFkZHJlc3Nlcywga2V5TWV0YSA9PiAha2V5TWV0YS5pc1NpZ25lciAmJiAha2V5TWV0YS5pc0ludm9rZWQgJiYga2V5TWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCBbcmVhZG9ubHlJbmRleGVzLCBkcmFpbmVkUmVhZG9ubHlLZXlzXSA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlLnN0YXRlLmFkZHJlc3Nlcywga2V5TWV0YSA9PiAha2V5TWV0YS5pc1NpZ25lciAmJiAha2V5TWV0YS5pc0ludm9rZWQgJiYgIWtleU1ldGEuaXNXcml0YWJsZSk7XG5cbiAgICAvLyBEb24ndCBleHRyYWN0IGxvb2t1cCBpZiBubyBrZXlzIHdlcmUgZm91bmRcbiAgICBpZiAod3JpdGFibGVJbmRleGVzLmxlbmd0aCA9PT0gMCAmJiByZWFkb25seUluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgYWNjb3VudEtleTogbG9va3VwVGFibGUua2V5LFxuICAgICAgd3JpdGFibGVJbmRleGVzLFxuICAgICAgcmVhZG9ubHlJbmRleGVzXG4gICAgfSwge1xuICAgICAgd3JpdGFibGU6IGRyYWluZWRXcml0YWJsZUtleXMsXG4gICAgICByZWFkb25seTogZHJhaW5lZFJlYWRvbmx5S2V5c1xuICAgIH1dO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBkcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGVFbnRyaWVzLCBrZXlNZXRhRmlsdGVyKSB7XG4gICAgY29uc3QgbG9va3VwVGFibGVJbmRleGVzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgZHJhaW5lZEtleXMgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBrZXlNZXRhXSBvZiB0aGlzLmtleU1ldGFNYXAuZW50cmllcygpKSB7XG4gICAgICBpZiAoa2V5TWV0YUZpbHRlcihrZXlNZXRhKSkge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBsb29rdXBUYWJsZUluZGV4ID0gbG9va3VwVGFibGVFbnRyaWVzLmZpbmRJbmRleChlbnRyeSA9PiBlbnRyeS5lcXVhbHMoa2V5KSk7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZUluZGV4ID49IDApIHtcbiAgICAgICAgICBhc3NlcnQobG9va3VwVGFibGVJbmRleCA8IDI1NiwgJ01heCBsb29rdXAgdGFibGUgaW5kZXggZXhjZWVkZWQnKTtcbiAgICAgICAgICBsb29rdXBUYWJsZUluZGV4ZXMucHVzaChsb29rdXBUYWJsZUluZGV4KTtcbiAgICAgICAgICBkcmFpbmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgdGhpcy5rZXlNZXRhTWFwLmRlbGV0ZShhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2xvb2t1cFRhYmxlSW5kZXhlcywgZHJhaW5lZEtleXNdO1xuICB9XG59XG5cbmNvbnN0IEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSA9ICdSZWFjaGVkIGVuZCBvZiBidWZmZXIgdW5leHBlY3RlZGx5JztcblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NoaWZ0YCwgYnV0IHRocm93cyBpZiB0aGUgYXJyYXkgaXMgemVyby1sZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGd1YXJkZWRTaGlmdChieXRlQXJyYXkpIHtcbiAgaWYgKGJ5dGVBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5LnNoaWZ0KCk7XG59XG5cbi8qKlxuICogRGVsZWdhdGVzIHRvIGBBcnJheSNzcGxpY2VgLCBidXQgdGhyb3dzIGlmIHRoZSBzZWN0aW9uIGJlaW5nIHNwbGljZWQgb3V0IGV4dGVuZHMgcGFzdCB0aGUgZW5kIG9mXG4gKiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAuLi5hcmdzKSB7XG4gIGNvbnN0IFtzdGFydF0gPSBhcmdzO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIgLy8gSW1wbGllcyB0aGF0IGBkZWxldGVDb3VudGAgd2FzIHN1cHBsaWVkXG4gID8gc3RhcnQgKyAoYXJnc1sxXSA/PyAwKSA+IGJ5dGVBcnJheS5sZW5ndGggOiBzdGFydCA+PSBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheS5zcGxpY2UoLi4uYXJncyk7XG59XG5cbi8qKlxuICogQW4gaW5zdHJ1Y3Rpb24gdG8gZXhlY3V0ZSBieSBhIHByb2dyYW1cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJvZ3JhbUlkSW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGFjY291bnRzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGF0YVxuICovXG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgaW5zdHJ1Y3Rpb25zIHRvIGJlIHByb2Nlc3NlZCBhdG9taWNhbGx5XG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGVhZGVyID0gYXJncy5oZWFkZXI7XG4gICAgdGhpcy5hY2NvdW50S2V5cyA9IGFyZ3MuYWNjb3VudEtleXMubWFwKGFjY291bnQgPT4gbmV3IFB1YmxpY0tleShhY2NvdW50KSk7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IGFyZ3MuaW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmZvckVhY2goaXggPT4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5zZXQoaXgucHJvZ3JhbUlkSW5kZXgsIHRoaXMuYWNjb3VudEtleXNbaXgucHJvZ3JhbUlkSW5kZXhdKSk7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuICdsZWdhY3knO1xuICB9XG4gIGdldCBzdGF0aWNBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cztcbiAgfVxuICBnZXQgY29tcGlsZWRJbnN0cnVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGl4LmFjY291bnRzLFxuICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSlcbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGFkZHJlc3NUYWJsZUxvb2t1cHMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldEFjY291bnRLZXlzKCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMpO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGFyZ3MpIHtcbiAgICBjb25zdCBjb21waWxlZEtleXMgPSBDb21waWxlZEtleXMuY29tcGlsZShhcmdzLmluc3RydWN0aW9ucywgYXJncy5wYXllcktleSk7XG4gICAgY29uc3QgW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdID0gY29tcGlsZWRLZXlzLmdldE1lc3NhZ2VDb21wb25lbnRzKCk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHN0YXRpY0FjY291bnRLZXlzKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKS5tYXAoaXggPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgIGFjY291bnRzOiBpeC5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgIGRhdGE6IGJzNTguZW5jb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBoZWFkZXIsXG4gICAgICBhY2NvdW50S2V5czogc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGFyZ3MucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgaXNQcm9ncmFtSWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5oYXMoaW5kZXgpO1xuICB9XG4gIHByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnZhbHVlcygpXTtcbiAgfVxuICBub25Qcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzLmZpbHRlcigoXywgaW5kZXgpID0+ICF0aGlzLmlzUHJvZ3JhbUlkKGluZGV4KSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IG51bUtleXMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5Q291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoa2V5Q291bnQsIG51bUtleXMpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBwcm9ncmFtSWRJbmRleFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgY29uc3QgZGF0YSA9IEFycmF5LmZyb20oYnM1OC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSkpO1xuICAgICAgbGV0IGtleUluZGljZXNDb3VudCA9IFtdO1xuICAgICAgZW5jb2RlTGVuZ3RoKGtleUluZGljZXNDb3VudCwgYWNjb3VudHMubGVuZ3RoKTtcbiAgICAgIGxldCBkYXRhQ291bnQgPSBbXTtcbiAgICAgIGVuY29kZUxlbmd0aChkYXRhQ291bnQsIGRhdGEubGVuZ3RoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBrZXlJbmRpY2VzQ291bnQ6IEJ1ZmZlci5mcm9tKGtleUluZGljZXNDb3VudCksXG4gICAgICAgIGtleUluZGljZXM6IGFjY291bnRzLFxuICAgICAgICBkYXRhTGVuZ3RoOiBCdWZmZXIuZnJvbShkYXRhQ291bnQpLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGxldCBpbnN0cnVjdGlvbkNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKGluc3RydWN0aW9uQ291bnQsIGluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgIGxldCBpbnN0cnVjdGlvbkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBCdWZmZXIuZnJvbShpbnN0cnVjdGlvbkNvdW50KS5jb3B5KGluc3RydWN0aW9uQnVmZmVyKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggPSBpbnN0cnVjdGlvbkNvdW50Lmxlbmd0aDtcbiAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJvZ3JhbUlkSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24ua2V5SW5kaWNlc0NvdW50Lmxlbmd0aCwgJ2tleUluZGljZXNDb3VudCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgna2V5SW5kZXgnKSwgaW5zdHJ1Y3Rpb24ua2V5SW5kaWNlcy5sZW5ndGgsICdrZXlJbmRpY2VzJyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmRhdGFMZW5ndGgubGVuZ3RoLCAnZGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgndXNlcmRhdHVtJyksIGluc3RydWN0aW9uLmRhdGEubGVuZ3RoLCAnZGF0YScpXSk7XG4gICAgICBjb25zdCBsZW5ndGggPSBpbnN0cnVjdGlvbkxheW91dC5lbmNvZGUoaW5zdHJ1Y3Rpb24sIGluc3RydWN0aW9uQnVmZmVyLCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCk7XG4gICAgICBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBpbnN0cnVjdGlvbkJ1ZmZlci5zbGljZSgwLCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCk7XG4gICAgY29uc3Qgc2lnbkRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVxdWlyZWRTaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZWFkb25seVNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioa2V5Q291bnQubGVuZ3RoLCAna2V5Q291bnQnKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoJ2tleScpLCBudW1LZXlzLCAna2V5cycpLCBwdWJsaWNLZXkoJ3JlY2VudEJsb2NraGFzaCcpXSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXNdKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzXSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNdKSxcbiAgICAgIGtleUNvdW50OiBCdWZmZXIuZnJvbShrZXlDb3VudCksXG4gICAgICBrZXlzOiB0aGlzLmFjY291bnRLZXlzLm1hcChrZXkgPT4gdG9CdWZmZXIoa2V5LnRvQnl0ZXMoKSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmRlY29kZSh0aGlzLnJlY2VudEJsb2NraGFzaClcbiAgICB9O1xuICAgIGxldCBzaWduRGF0YSA9IEJ1ZmZlci5hbGxvYygyMDQ4KTtcbiAgICBjb25zdCBsZW5ndGggPSBzaWduRGF0YUxheW91dC5lbmNvZGUodHJhbnNhY3Rpb24sIHNpZ25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkJ1ZmZlci5jb3B5KHNpZ25EYXRhLCBsZW5ndGgpO1xuICAgIHJldHVybiBzaWduRGF0YS5zbGljZSgwLCBsZW5ndGggKyBpbnN0cnVjdGlvbkJ1ZmZlci5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNvbXBpbGVkIG1lc3NhZ2UgaW50byBhIE1lc3NhZ2Ugb2JqZWN0LlxuICAgKi9cbiAgc3RhdGljIGZyb20oYnVmZmVyKSB7XG4gICAgLy8gU2xpY2UgdXAgd2lyZSBkYXRhXG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5idWZmZXJdO1xuICAgIGNvbnN0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGlmIChudW1SZXF1aXJlZFNpZ25hdHVyZXMgIT09IChudW1SZXF1aXJlZFNpZ25hdHVyZXMgJiBWRVJTSU9OX1BSRUZJWF9NQVNLKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uZWQgbWVzc2FnZXMgbXVzdCBiZSBkZXNlcmlhbGl6ZWQgd2l0aCBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKCknKTtcbiAgICB9XG4gICAgY29uc3QgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBhY2NvdW50S2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjb3VudENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnQgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgICAgYWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KEJ1ZmZlci5mcm9tKGFjY291bnQpKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2VudEJsb2NraGFzaCA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25Db3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3JhbUlkSW5kZXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgYWNjb3VudENvdW50KTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGFTbGljZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBkYXRhTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBiczU4LmVuY29kZShCdWZmZXIuZnJvbShkYXRhU2xpY2UpKTtcbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUFyZ3MgPSB7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICAgIH0sXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKHJlY2VudEJsb2NraGFzaCkpLFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICBpbnN0cnVjdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBuZXcgTWVzc2FnZShtZXNzYWdlQXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5cbmNsYXNzIE1lc3NhZ2VWMCB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuaGVhZGVyID0gYXJncy5oZWFkZXI7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IGFyZ3Muc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gYXJncy5jb21waWxlZEluc3RydWN0aW9ucztcbiAgICB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMgPSBhcmdzLmFkZHJlc3NUYWJsZUxvb2t1cHM7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IG51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMoKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvdW50ICs9IGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoICsgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBnZXRBY2NvdW50S2V5cyhhcmdzKSB7XG4gICAgbGV0IGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgaWYgKGFyZ3MgJiYgJ2FjY291bnRLZXlzRnJvbUxvb2t1cHMnIGluIGFyZ3MgJiYgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgICBpZiAodGhpcy5udW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzICE9IGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5sZW5ndGggKyBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBvZiBhIG1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgYWNjb3VudCBrZXlzIGZyb20gbG9va3VwcycpO1xuICAgICAgfVxuICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgICB9IGVsc2UgaWYgKGFyZ3MgJiYgJ2FkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzJyBpbiBhcmdzICYmIGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB0aGlzLnJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzKGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBhZGRyZXNzIHRhYmxlIGxvb2t1cHMgd2VyZSBub3QgcmVzb2x2ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlQWNjb3VudEtleXModGhpcy5zdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgY29uc3QgbnVtU3RhdGljQWNjb3VudEtleXMgPSB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPj0gbnVtU3RhdGljQWNjb3VudEtleXMpIHtcbiAgICAgIGNvbnN0IGxvb2t1cEFjY291bnRLZXlzSW5kZXggPSBpbmRleCAtIG51bVN0YXRpY0FjY291bnRLZXlzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cyA9IHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5yZWR1Y2UoKGNvdW50LCBsb29rdXApID0+IGNvdW50ICsgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgsIDApO1xuICAgICAgcmV0dXJuIGxvb2t1cEFjY291bnRLZXlzSW5kZXggPCBudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bnNpZ25lZEFjY291bnRJbmRleCA9IGluZGV4IC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1VbnNpZ25lZEFjY291bnRzID0gbnVtU3RhdGljQWNjb3VudEtleXMgLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA9IG51bVVuc2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gdW5zaWduZWRBY2NvdW50SW5kZXggPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1TaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gaW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgIH1cbiAgfVxuICByZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgIGNvbnN0IGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB7XG4gICAgICB3cml0YWJsZTogW10sXG4gICAgICByZWFkb25seTogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgdGFibGVMb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCB0YWJsZUFjY291bnQgPSBhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cy5maW5kKGFjY291bnQgPT4gYWNjb3VudC5rZXkuZXF1YWxzKHRhYmxlTG9va3VwLmFjY291bnRLZXkpKTtcbiAgICAgIGlmICghdGFibGVBY2NvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBsb29rdXAgdGFibGUgYWNjb3VudCBmb3IgdGFibGUga2V5ICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0YWJsZUxvb2t1cC53cml0YWJsZUluZGV4ZXMpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLnB1c2godGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlc1tpbmRleF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBmb3IgaW5kZXggJHtpbmRleH0gaW4gYWRkcmVzcyBsb29rdXAgdGFibGUgJHt0YWJsZUxvb2t1cC5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAucmVhZG9ubHlJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGFyZ3MpIHtcbiAgICBjb25zdCBjb21waWxlZEtleXMgPSBDb21waWxlZEtleXMuY29tcGlsZShhcmdzLmluc3RydWN0aW9ucywgYXJncy5wYXllcktleSk7XG4gICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB7XG4gICAgICB3cml0YWJsZTogbmV3IEFycmF5KCksXG4gICAgICByZWFkb25seTogbmV3IEFycmF5KClcbiAgICB9O1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlQWNjb3VudHMgPSBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIHx8IFtdO1xuICAgIGZvciAoY29uc3QgbG9va3VwVGFibGUgb2YgbG9va3VwVGFibGVBY2NvdW50cykge1xuICAgICAgY29uc3QgZXh0cmFjdFJlc3VsdCA9IGNvbXBpbGVkS2V5cy5leHRyYWN0VGFibGVMb29rdXAobG9va3VwVGFibGUpO1xuICAgICAgaWYgKGV4dHJhY3RSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBbYWRkcmVzc1RhYmxlTG9va3VwLCB7XG4gICAgICAgICAgd3JpdGFibGUsXG4gICAgICAgICAgcmVhZG9ubHlcbiAgICAgICAgfV0gPSBleHRyYWN0UmVzdWx0O1xuICAgICAgICBhZGRyZXNzVGFibGVMb29rdXBzLnB1c2goYWRkcmVzc1RhYmxlTG9va3VwKTtcbiAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKC4uLndyaXRhYmxlKTtcbiAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5wdXNoKC4uLnJlYWRvbmx5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdID0gY29tcGlsZWRLZXlzLmdldE1lc3NhZ2VDb21wb25lbnRzKCk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHN0YXRpY0FjY291bnRLZXlzLCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzKTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IGFjY291bnRLZXlzLmNvbXBpbGVJbnN0cnVjdGlvbnMoYXJncy5pbnN0cnVjdGlvbnMpO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBhcmdzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgsIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gdGhpcy5zZXJpYWxpemVJbnN0cnVjdGlvbnMoKTtcbiAgICBjb25zdCBlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCwgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gdGhpcy5zZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCk7XG4gICAgY29uc3QgZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCwgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCk7XG4gICAgY29uc3QgbWVzc2FnZUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJlZml4JyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtUmVxdWlyZWRTaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51OCgnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cycpXSwgJ2hlYWRlcicpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgsICdzdGF0aWNBY2NvdW50S2V5cycpLCBwdWJsaWNLZXkoJ3JlY2VudEJsb2NraGFzaCcpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoLmxlbmd0aCwgJ2luc3RydWN0aW9uc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCwgJ3NlcmlhbGl6ZWRJbnN0cnVjdGlvbnMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgubGVuZ3RoLCAnYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgsICdzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcycpXSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBjb25zdCBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVggPSAxIDw8IDc7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2VMZW5ndGggPSBtZXNzYWdlTGF5b3V0LmVuY29kZSh7XG4gICAgICBwcmVmaXg6IE1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCxcbiAgICAgIGhlYWRlcjogdGhpcy5oZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoKSxcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiB0aGlzLnN0YXRpY0FjY291bnRLZXlzLm1hcChrZXkgPT4ga2V5LnRvQnl0ZXMoKSksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKSxcbiAgICAgIGluc3RydWN0aW9uc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCksXG4gICAgICBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9LCBzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRNZXNzYWdlLnNsaWNlKDAsIHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVJbnN0cnVjdGlvbnMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZERhdGFMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWREYXRhTGVuZ3RoLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJvZ3JhbUlkSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgsICdhY2NvdW50S2V5SW5kZXhlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkRGF0YUxlbmd0aC5sZW5ndGgsICdlbmNvZGVkRGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgc2VyaWFsaXplZExlbmd0aCArPSBpbnN0cnVjdGlvbkxheW91dC5lbmNvZGUoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoKSxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICBlbmNvZGVkRGF0YUxlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZERhdGFMZW5ndGgpLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhXG4gICAgICB9LCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMuc2xpY2UoMCwgc2VyaWFsaXplZExlbmd0aCk7XG4gIH1cbiAgc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpIHtcbiAgICBsZXQgc2VyaWFsaXplZExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvbnN0IGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgsIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgsIGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnYWNjb3VudEtleScpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgsICd3cml0YWJsZUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoLCAncmVhZG9ubHlJbmRleGVzJyldKTtcbiAgICAgIHNlcmlhbGl6ZWRMZW5ndGggKz0gYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGFjY291bnRLZXk6IGxvb2t1cC5hY2NvdW50S2V5LnRvQnl0ZXMoKSxcbiAgICAgICAgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCksXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlczogbG9va3VwLndyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCksXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlczogbG9va3VwLnJlYWRvbmx5SW5kZXhlc1xuICAgICAgfSwgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMuc2xpY2UoMCwgc2VyaWFsaXplZExlbmd0aCk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5zZXJpYWxpemVkTWVzc2FnZV07XG4gICAgY29uc3QgcHJlZml4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgY29uc3QgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcbiAgICBhc3NlcnQocHJlZml4ICE9PSBtYXNrZWRQcmVmaXgsIGBFeHBlY3RlZCB2ZXJzaW9uZWQgbWVzc2FnZSBidXQgcmVjZWl2ZWQgbGVnYWN5IG1lc3NhZ2VgKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gbWFza2VkUHJlZml4O1xuICAgIGFzc2VydCh2ZXJzaW9uID09PSAwLCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2Ugd2l0aCB2ZXJzaW9uIDAgYnV0IGZvdW5kIHZlcnNpb24gJHt2ZXJzaW9ufWApO1xuICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSlcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzID0gW107XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLnB1c2gobmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2VudEJsb2NraGFzaCA9IGJzNTguZW5jb2RlKGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9ncmFtSWRJbmRleCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRLZXlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCkpO1xuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50S2V5ID0gbmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3Qgd3JpdGFibGVJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIHdyaXRhYmxlSW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHJlYWRvbmx5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCByZWFkb25seUluZGV4ZXNMZW5ndGgpO1xuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKHtcbiAgICAgICAgYWNjb3VudEtleSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzLFxuICAgICAgICByZWFkb25seUluZGV4ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmNvbnN0IFZlcnNpb25lZE1lc3NhZ2UgPSB7XG4gIGRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpIHtcbiAgICBjb25zdCBwcmVmaXggPSBzZXJpYWxpemVkTWVzc2FnZVswXTtcbiAgICBjb25zdCBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuXG4gICAgLy8gaWYgdGhlIGhpZ2hlc3QgYml0IG9mIHRoZSBwcmVmaXggaXMgbm90IHNldCwgdGhlIG1lc3NhZ2UgaXMgbm90IHZlcnNpb25lZFxuICAgIGlmIChtYXNrZWRQcmVmaXggPT09IHByZWZpeCkge1xuICAgICAgcmV0dXJuICdsZWdhY3knO1xuICAgIH1cblxuICAgIC8vIHRoZSBsb3dlciA3IGJpdHMgb2YgdGhlIHByZWZpeCBpbmRpY2F0ZSB0aGUgbWVzc2FnZSB2ZXJzaW9uXG4gICAgcmV0dXJuIG1hc2tlZFByZWZpeDtcbiAgfSxcbiAgZGVzZXJpYWxpemU6IHNlcmlhbGl6ZWRNZXNzYWdlID0+IHtcbiAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgIHJldHVybiBNZXNzYWdlLmZyb20oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1lc3NhZ2VWMC5kZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gbWVzc2FnZSB2ZXJzaW9uICR7dmVyc2lvbn0gZGVzZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBzaWduYXR1cmUgYXMgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICovXG5cbmxldCBUcmFuc2FjdGlvblN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0dXMpIHtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiXSA9IDBdID0gXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlBST0NFU1NFRFwiXSA9IDFdID0gXCJQUk9DRVNTRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJUSU1FRF9PVVRcIl0gPSAyXSA9IFwiVElNRURfT1VUXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiTk9OQ0VfSU5WQUxJRFwiXSA9IDNdID0gXCJOT05DRV9JTlZBTElEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cztcbn0oe30pO1xuXG4vKipcbiAqIERlZmF1bHQgKGVtcHR5KSBzaWduYXR1cmVcbiAqL1xuY29uc3QgREVGQVVMVF9TSUdOQVRVUkUgPSBCdWZmZXIuYWxsb2MoU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykuZmlsbCgwKTtcblxuLyoqXG4gKiBBY2NvdW50IG1ldGFkYXRhIHVzZWQgdG8gZGVmaW5lIGluc3RydWN0aW9uc1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgVHJhbnNhY3Rpb24uc2VyaWFsaXplKClcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAvKipcbiAgICAgKiBQdWJsaWMga2V5cyB0byBpbmNsdWRlIGluIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiBCb29sZWFuIHJlcHJlc2VudHMgd2hldGhlciB0aGlzIHB1YmtleSBuZWVkcyB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtIElkIHRvIGV4ZWN1dGVcbiAgICAgKi9cbiAgICB0aGlzLnByb2dyYW1JZCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtIGlucHV0XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHRoaXMucHJvZ3JhbUlkID0gb3B0cy5wcm9ncmFtSWQ7XG4gICAgdGhpcy5rZXlzID0gb3B0cy5rZXlzO1xuICAgIGlmIChvcHRzLmRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG9wdHMuZGF0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IHRoaXMua2V5cy5tYXAoKHtcbiAgICAgICAgcHVia2V5LFxuICAgICAgICBpc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZVxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgcHVia2V5OiBwdWJrZXkudG9KU09OKCksXG4gICAgICAgIGlzU2lnbmVyLFxuICAgICAgICBpc1dyaXRhYmxlXG4gICAgICB9KSksXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLnRvSlNPTigpLFxuICAgICAgZGF0YTogWy4uLnRoaXMuZGF0YV1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGFpciBvZiBzaWduYXR1cmUgYW5kIGNvcnJlc3BvbmRpbmcgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogTGlzdCBvZiBUcmFuc2FjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OyBhbiB1bmZvcnR1bmF0ZSBjb25zZXF1ZW5jZSBvZiBiZWluZ1xuLy8gZm9yY2VkIHRvIG92ZXItZXhwb3J0IHR5cGVzIGJ5IHRoZSBkb2N1bWVudGF0aW9uIGdlbmVyYXRvci5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjU4MjBcblxuLyoqXG4gKiBCbG9ja2hhc2gtYmFzZWQgdHJhbnNhY3Rpb25zIGhhdmUgYSBsaWZldGltZSB0aGF0IGFyZSBkZWZpbmVkIGJ5XG4gKiB0aGUgYmxvY2toYXNoIHRoZXkgaW5jbHVkZS4gQW55IHRyYW5zYWN0aW9uIHdob3NlIGJsb2NraGFzaCBpc1xuICogdG9vIG9sZCB3aWxsIGJlIHJlamVjdGVkLlxuICovXG5cbi8qKlxuICogVXNlIHRoZXNlIG9wdGlvbnMgdG8gY29uc3RydWN0IGEgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvbi5cbiAqL1xuXG4vKipcbiAqIE5vbmNlIGluZm9ybWF0aW9uIHRvIGJlIHVzZWQgdG8gYnVpbGQgYW4gb2ZmbGluZSBUcmFuc2FjdGlvbi5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGZpcnN0IChwYXllcikgVHJhbnNhY3Rpb24gc2lnbmF0dXJlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXIgfCBudWxsfSBCdWZmZXIgb2YgcGF5ZXIncyBzaWduYXR1cmVcbiAgICovXG4gIGdldCBzaWduYXR1cmUoKSB7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVzWzBdLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllclxuICAgKi9cblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB3aXRoIGEgYmxvY2toYXNoIGFuZCBsYXN0VmFsaWRCbG9ja0hlaWdodFxuXG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHVzaW5nIGEgZHVyYWJsZSBub25jZVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBgVHJhbnNhY3Rpb25DdG9yRmllbGRzYCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAgICogUGxlYXNlIHN1cHBseSBhIGBUcmFuc2FjdGlvbkJsb2NraGFzaEN0b3JgIGluc3RlYWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gZW1wdHkgVHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmVzIGZvciB0aGUgdHJhbnNhY3Rpb24uICBUeXBpY2FsbHkgY3JlYXRlZCBieSBpbnZva2luZyB0aGVcbiAgICAgKiBgc2lnbigpYCBtZXRob2RcbiAgICAgKi9cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBbXTtcbiAgICB0aGlzLmZlZVBheWVyID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnN0cnVjdGlvbnMgdG8gYXRvbWljYWxseSBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBBIHJlY2VudCB0cmFuc2FjdGlvbiBpZC4gTXVzdCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbGxlclxuICAgICAqL1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGNoYWluIGNhbiBhZHZhbmNlIHRvIGJlZm9yZSB0eCBpcyBkZWNsYXJlZCBleHBpcmVkXG4gICAgICogKi9cbiAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIE5vbmNlIGluZm9ybWF0aW9uLiBJZiBwb3B1bGF0ZWQsIHRyYW5zYWN0aW9uIHdpbGwgdXNlIGEgZHVyYWJsZVxuICAgICAqIE5vbmNlIGhhc2ggaW5zdGVhZCBvZiBhIHJlY2VudEJsb2NraGFzaC4gTXVzdCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbGxlclxuICAgICAqL1xuICAgIHRoaXMubm9uY2VJbmZvID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYSBub25jZSB0cmFuc2FjdGlvbiB0aGlzIHJlcHJlc2VudHMgdGhlIG1pbmltdW0gc2xvdCBmcm9tIHdoaWNoXG4gICAgICogdG8gZXZhbHVhdGUgaWYgdGhlIG5vbmNlIGhhcyBhZHZhbmNlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29uZmlybSB0aGVcbiAgICAgKiB0cmFuc2FjdGlvbi4gVGhpcyBwcm90ZWN0cyBhZ2FpbnN0IGEgY2FzZSB3aGVyZSB0aGUgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uXG4gICAgICogbG9naWMgbG9hZHMgdGhlIG5vbmNlIGFjY291bnQgZnJvbSBhbiBvbGQgc2xvdCBhbmQgYXNzdW1lcyB0aGUgbWlzbWF0Y2ggaW5cbiAgICAgKiBub25jZSB2YWx1ZSBpbXBsaWVzIHRoYXQgdGhlIG5vbmNlIGhhcyBiZWVuIGFkdmFuY2VkLlxuICAgICAqL1xuICAgIHRoaXMubWluTm9uY2VDb250ZXh0U2xvdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9tZXNzYWdlID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2pzb24gPSB2b2lkIDA7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRzLmZlZVBheWVyKSB7XG4gICAgICB0aGlzLmZlZVBheWVyID0gb3B0cy5mZWVQYXllcjtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2lnbmF0dXJlcykge1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gb3B0cy5zaWduYXR1cmVzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdub25jZUluZm8nKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtaW5Db250ZXh0U2xvdCxcbiAgICAgICAgbm9uY2VJbmZvXG4gICAgICB9ID0gb3B0cztcbiAgICAgIHRoaXMubWluTm9uY2VDb250ZXh0U2xvdCA9IG1pbkNvbnRleHRTbG90O1xuICAgICAgdGhpcy5ub25jZUluZm8gPSBub25jZUluZm87XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodFxuICAgICAgfSA9IG9wdHM7XG4gICAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaDtcbiAgICAgIHRoaXMubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICAgIG5vbmNlSW5mb1xuICAgICAgfSA9IG9wdHM7XG4gICAgICBpZiAobm9uY2VJbmZvKSB7XG4gICAgICAgIHRoaXMubm9uY2VJbmZvID0gbm9uY2VJbmZvO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSByZWNlbnRCbG9ja2hhc2g7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoIHx8IG51bGwsXG4gICAgICBmZWVQYXllcjogdGhpcy5mZWVQYXllciA/IHRoaXMuZmVlUGF5ZXIudG9KU09OKCkgOiBudWxsLFxuICAgICAgbm9uY2VJbmZvOiB0aGlzLm5vbmNlSW5mbyA/IHtcbiAgICAgICAgbm9uY2U6IHRoaXMubm9uY2VJbmZvLm5vbmNlLFxuICAgICAgICBub25jZUluc3RydWN0aW9uOiB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLnRvSlNPTigpXG4gICAgICB9IDogbnVsbCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLnRvSlNPTigpKSxcbiAgICAgIHNpZ25lcnM6IHRoaXMuc2lnbmF0dXJlcy5tYXAoKHtcbiAgICAgICAgcHVibGljS2V5XG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXkudG9KU09OKCk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkIG9uZSBvciBtb3JlIGluc3RydWN0aW9ucyB0byB0aGlzIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8IFRyYW5zYWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25DdG9yRmllbGRzID59IGl0ZW1zIC0gSW5zdHJ1Y3Rpb25zIHRvIGFkZCB0byB0aGUgVHJhbnNhY3Rpb25cbiAgICovXG4gIGFkZCguLi5pdGVtcykge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5zdHJ1Y3Rpb25zJyk7XG4gICAgfVxuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoJ2luc3RydWN0aW9ucycgaW4gaXRlbSkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLmNvbmNhdChpdGVtLmluc3RydWN0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKCdkYXRhJyBpbiBpdGVtICYmICdwcm9ncmFtSWQnIGluIGl0ZW0gJiYgJ2tleXMnIGluIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaXRlbSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgY29tcGlsZU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX21lc3NhZ2UgJiYgSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KHRoaXMuX2pzb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICB9XG4gICAgbGV0IHJlY2VudEJsb2NraGFzaDtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zO1xuICAgIGlmICh0aGlzLm5vbmNlSW5mbykge1xuICAgICAgcmVjZW50QmxvY2toYXNoID0gdGhpcy5ub25jZUluZm8ubm9uY2U7XG4gICAgICBpZiAodGhpcy5pbnN0cnVjdGlvbnNbMF0gIT0gdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbikge1xuICAgICAgICBpbnN0cnVjdGlvbnMgPSBbdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbiwgLi4udGhpcy5pbnN0cnVjdGlvbnNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaCA9IHRoaXMucmVjZW50QmxvY2toYXNoO1xuICAgICAgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIGlmICghcmVjZW50QmxvY2toYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHJlY2VudEJsb2NraGFzaCByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA8IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gaW5zdHJ1Y3Rpb25zIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGxldCBmZWVQYXllcjtcbiAgICBpZiAodGhpcy5mZWVQYXllcikge1xuICAgICAgZmVlUGF5ZXIgPSB0aGlzLmZlZVBheWVyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA+IDAgJiYgdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleSkge1xuICAgICAgLy8gVXNlIGltcGxpY2l0IGZlZSBwYXllclxuICAgICAgZmVlUGF5ZXIgPSB0aGlzLnNpZ25hdHVyZXNbMF0ucHVibGljS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZlZSBwYXllciByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGluc3RydWN0aW9uc1tpXS5wcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIGluZGV4ICR7aX0gaGFzIHVuZGVmaW5lZCBwcm9ncmFtIGlkYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW1JZHMgPSBbXTtcbiAgICBjb25zdCBhY2NvdW50TWV0YXMgPSBbXTtcbiAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBpbnN0cnVjdGlvbi5rZXlzLmZvckVhY2goYWNjb3VudE1ldGEgPT4ge1xuICAgICAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICAgICAgLi4uYWNjb3VudE1ldGFcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGluc3RydWN0aW9uLnByb2dyYW1JZC50b1N0cmluZygpO1xuICAgICAgaWYgKCFwcm9ncmFtSWRzLmluY2x1ZGVzKHByb2dyYW1JZCkpIHtcbiAgICAgICAgcHJvZ3JhbUlkcy5wdXNoKHByb2dyYW1JZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBcHBlbmQgcHJvZ3JhbUlEIGFjY291bnQgbWV0YXNcbiAgICBwcm9ncmFtSWRzLmZvckVhY2gocHJvZ3JhbUlkID0+IHtcbiAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBuZXcgUHVibGljS2V5KHByb2dyYW1JZCksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQ3VsbCBkdXBsaWNhdGUgYWNjb3VudCBtZXRhc1xuICAgIGNvbnN0IHVuaXF1ZU1ldGFzID0gW107XG4gICAgYWNjb3VudE1ldGFzLmZvckVhY2goYWNjb3VudE1ldGEgPT4ge1xuICAgICAgY29uc3QgcHVia2V5U3RyaW5nID0gYWNjb3VudE1ldGEucHVia2V5LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCB1bmlxdWVJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgICAgcmV0dXJuIHgucHVia2V5LnRvU3RyaW5nKCkgPT09IHB1YmtleVN0cmluZztcbiAgICAgIH0pO1xuICAgICAgaWYgKHVuaXF1ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzV3JpdGFibGUgPSB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSB8fCBhY2NvdW50TWV0YS5pc1dyaXRhYmxlO1xuICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPSB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgfHwgYWNjb3VudE1ldGEuaXNTaWduZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmlxdWVNZXRhcy5wdXNoKGFjY291bnRNZXRhKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNvcnQuIFByaW9yaXRpemluZyBmaXJzdCBieSBzaWduZXIsIHRoZW4gYnkgd3JpdGFibGVcbiAgICB1bmlxdWVNZXRhcy5zb3J0KGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeC5pc1NpZ25lciAhPT0geS5pc1NpZ25lcikge1xuICAgICAgICAvLyBTaWduZXJzIGFsd2F5cyBjb21lIGJlZm9yZSBub24tc2lnbmVyc1xuICAgICAgICByZXR1cm4geC5pc1NpZ25lciA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIGlmICh4LmlzV3JpdGFibGUgIT09IHkuaXNXcml0YWJsZSkge1xuICAgICAgICAvLyBXcml0YWJsZSBhY2NvdW50cyBhbHdheXMgY29tZSBiZWZvcmUgcmVhZC1vbmx5IGFjY291bnRzXG4gICAgICAgIHJldHVybiB4LmlzV3JpdGFibGUgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UsIHNvcnQgYnkgcHVia2V5LCBzdHJpbmd3aXNlLlxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9jYWxlTWF0Y2hlcjogJ2Jlc3QgZml0JyxcbiAgICAgICAgdXNhZ2U6ICdzb3J0JyxcbiAgICAgICAgc2Vuc2l0aXZpdHk6ICd2YXJpYW50JyxcbiAgICAgICAgaWdub3JlUHVuY3R1YXRpb246IGZhbHNlLFxuICAgICAgICBudW1lcmljOiBmYWxzZSxcbiAgICAgICAgY2FzZUZpcnN0OiAnbG93ZXInXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHgucHVia2V5LnRvQmFzZTU4KCkubG9jYWxlQ29tcGFyZSh5LnB1YmtleS50b0Jhc2U1OCgpLCAnZW4nLCBvcHRpb25zKTtcbiAgICB9KTtcblxuICAgIC8vIE1vdmUgZmVlIHBheWVyIHRvIHRoZSBmcm9udFxuICAgIGNvbnN0IGZlZVBheWVySW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICByZXR1cm4geC5wdWJrZXkuZXF1YWxzKGZlZVBheWVyKTtcbiAgICB9KTtcbiAgICBpZiAoZmVlUGF5ZXJJbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBbcGF5ZXJNZXRhXSA9IHVuaXF1ZU1ldGFzLnNwbGljZShmZWVQYXllckluZGV4LCAxKTtcbiAgICAgIHBheWVyTWV0YS5pc1NpZ25lciA9IHRydWU7XG4gICAgICBwYXllck1ldGEuaXNXcml0YWJsZSA9IHRydWU7XG4gICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHBheWVyTWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXF1ZU1ldGFzLnVuc2hpZnQoe1xuICAgICAgICBwdWJrZXk6IGZlZVBheWVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWxsb3cgdW5rbm93biBzaWduZXJzXG4gICAgZm9yIChjb25zdCBzaWduYXR1cmUgb2YgdGhpcy5zaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bmlxdWVJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhzaWduYXR1cmUucHVibGljS2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHVuaXF1ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKCF1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIpIHtcbiAgICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2FybignVHJhbnNhY3Rpb24gcmVmZXJlbmNlcyBhIHNpZ25hdHVyZSB0aGF0IGlzIHVubmVjZXNzYXJ5LCAnICsgJ29ubHkgdGhlIGZlZSBwYXllciBhbmQgaW5zdHJ1Y3Rpb24gc2lnbmVyIGFjY291bnRzIHNob3VsZCBzaWduIGEgdHJhbnNhY3Rpb24uICcgKyAnVGhpcyBiZWhhdmlvciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gcmVsZWFzZS4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNpZ25lcjogJHtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSAwO1xuICAgIGxldCBudW1SZWFkb25seVNpZ25lZEFjY291bnRzID0gMDtcbiAgICBsZXQgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzID0gMDtcblxuICAgIC8vIFNwbGl0IG91dCBzaWduaW5nIGZyb20gbm9uLXNpZ25pbmcga2V5cyBhbmQgY291bnQgaGVhZGVyIHZhbHVlc1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBbXTtcbiAgICBjb25zdCB1bnNpZ25lZEtleXMgPSBbXTtcbiAgICB1bmlxdWVNZXRhcy5mb3JFYWNoKCh7XG4gICAgICBwdWJrZXksXG4gICAgICBpc1NpZ25lcixcbiAgICAgIGlzV3JpdGFibGVcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzICs9IDE7XG4gICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5zaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gc2lnbmVkS2V5cy5jb25jYXQodW5zaWduZWRLZXlzKTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhLFxuICAgICAgICBwcm9ncmFtSWRcbiAgICAgIH0gPSBpbnN0cnVjdGlvbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBhY2NvdW50S2V5cy5pbmRleE9mKHByb2dyYW1JZC50b1N0cmluZygpKSxcbiAgICAgICAgYWNjb3VudHM6IGluc3RydWN0aW9uLmtleXMubWFwKG1ldGEgPT4gYWNjb3VudEtleXMuaW5kZXhPZihtZXRhLnB1YmtleS50b1N0cmluZygpKSksXG4gICAgICAgIGRhdGE6IGJzNTguZW5jb2RlKGRhdGEpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgYXNzZXJ0KGluc3RydWN0aW9uLnByb2dyYW1JZEluZGV4ID49IDApO1xuICAgICAgaW5zdHJ1Y3Rpb24uYWNjb3VudHMuZm9yRWFjaChrZXlJbmRleCA9PiBhc3NlcnQoa2V5SW5kZXggPj0gMCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICAgIH0sXG4gICAgICBhY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogY29tcGlsZWRJbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9jb21waWxlKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNvbXBpbGVNZXNzYWdlKCk7XG4gICAgY29uc3Qgc2lnbmVkS2V5cyA9IG1lc3NhZ2UuYWNjb3VudEtleXMuc2xpY2UoMCwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA9PT0gc2lnbmVkS2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5zaWduYXR1cmVzLmV2ZXJ5KChwYWlyLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gc2lnbmVkS2V5c1tpbmRleF0uZXF1YWxzKHBhaXIucHVibGljS2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHZhbGlkKSByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmVkS2V5cy5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYnVmZmVyIG9mIHRoZSBUcmFuc2FjdGlvbiBkYXRhIHRoYXQgbmVlZCB0byBiZSBjb3ZlcmVkIGJ5IHNpZ25hdHVyZXNcbiAgICovXG4gIHNlcmlhbGl6ZU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBpbGUoKS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVzdGltYXRlZCBmZWUgYXNzb2NpYXRlZCB3aXRoIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gUlBDIEVuZHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXIgfCBudWxsPn0gVGhlIGVzdGltYXRlZCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVkRmVlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gKGF3YWl0IGNvbm5lY3Rpb24uZ2V0RmVlRm9yTWVzc2FnZSh0aGlzLmNvbXBpbGVNZXNzYWdlKCkpKS52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBwdWJsaWMga2V5cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2lnbiB0aGUgVHJhbnNhY3Rpb24uXG4gICAqIFRoZSBmaXJzdCBzaWduZXIgd2lsbCBiZSB1c2VkIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICpcbiAgICogU2lnbmF0dXJlcyBjYW4gYmUgYWRkZWQgd2l0aCBlaXRoZXIgYHBhcnRpYWxTaWduYCBvciBgYWRkU2lnbmF0dXJlYFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYwLjg0LjAuIE9ubHkgdGhlIGZlZSBwYXllciBuZWVkcyB0byBiZVxuICAgKiBzcGVjaWZpZWQgYW5kIGl0IGNhbiBiZSBzZXQgaW4gdGhlIFRyYW5zYWN0aW9uIGNvbnN0cnVjdG9yIG9yIHdpdGggdGhlXG4gICAqIGBmZWVQYXllcmAgcHJvcGVydHkuXG4gICAqL1xuICBzZXRTaWduZXJzKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lcnMuZmlsdGVyKHB1YmxpY0tleSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBwdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLm1hcChwdWJsaWNLZXkgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIHRoZSBUcmFuc2FjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgc2lnbmVycy4gTXVsdGlwbGUgc2lnbmF0dXJlcyBtYXlcbiAgICogYmUgYXBwbGllZCB0byBhIFRyYW5zYWN0aW9uLiBUaGUgZmlyc3Qgc2lnbmF0dXJlIGlzIGNvbnNpZGVyZWQgXCJwcmltYXJ5XCJcbiAgICogYW5kIGlzIHVzZWQgaWRlbnRpZnkgYW5kIGNvbmZpcm0gdHJhbnNhY3Rpb25zLlxuICAgKlxuICAgKiBJZiB0aGUgVHJhbnNhY3Rpb24gYGZlZVBheWVyYCBpcyBub3Qgc2V0LCB0aGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFRyYW5zYWN0aW9uIGZpZWxkcyBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGFmdGVyIHRoZSBmaXJzdCBjYWxsIHRvIGBzaWduYCxcbiAgICogYXMgZG9pbmcgc28gbWF5IGludmFsaWRhdGUgdGhlIHNpZ25hdHVyZSBhbmQgY2F1c2UgdGhlIFRyYW5zYWN0aW9uIHRvIGJlXG4gICAqIHJlamVjdGVkLlxuICAgKlxuICAgKiBUaGUgVHJhbnNhY3Rpb24gbXVzdCBiZSBhc3NpZ25lZCBhIHZhbGlkIGByZWNlbnRCbG9ja2hhc2hgIGJlZm9yZSBpbnZva2luZyB0aGlzIG1ldGhvZFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHNpZ24oLi4uc2lnbmVycykge1xuICAgIGlmIChzaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gRGVkdXBlIHNpZ25lcnNcbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVuaXF1ZVNpZ25lcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBrZXkgPSBzaWduZXIucHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHVuaXF1ZVNpZ25lcnMucHVzaChzaWduZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSB1bmlxdWVTaWduZXJzLm1hcChzaWduZXIgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleTogc2lnbmVyLnB1YmxpY0tleVxuICAgIH0pKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnVuaXF1ZVNpZ25lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGFjY291bnRzLiBBbGwgYWNjb3VudHMgbXVzdFxuICAgKiBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQWxsIHRoZSBjYXZlYXRzIGZyb20gdGhlIGBzaWduYCBtZXRob2QgYXBwbHkgdG8gYHBhcnRpYWxTaWduYFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHBhcnRpYWxTaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi5zaWduZXJzKSB7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSBtZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIHNpZ25lcnMuZm9yRWFjaChzaWduZXIgPT4ge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihzaWduRGF0YSwgc2lnbmVyLnNlY3JldEtleSk7XG4gICAgICB0aGlzLl9hZGRTaWduYXR1cmUoc2lnbmVyLnB1YmxpY0tleSwgdG9CdWZmZXIoc2lnbmF0dXJlKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYSB0cmFuc2FjdGlvbi4gVGhlIHB1YmxpYyBrZXlcbiAgICogbXVzdCBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleSBQdWJsaWMga2V5IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmUgQW4gZXh0ZXJuYWxseSBjcmVhdGVkIHNpZ25hdHVyZSB0byBhZGQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpOyAvLyBFbnN1cmUgc2lnbmF0dXJlcyBhcnJheSBpcyBwb3B1bGF0ZWRcbiAgICB0aGlzLl9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2FkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnNpZ25hdHVyZXMuZmluZEluZGV4KHNpZ3BhaXIgPT4gcHVia2V5LmVxdWFscyhzaWdwYWlyLnB1YmxpY0tleSkpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzaWduZXI6ICR7cHVia2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlc1tpbmRleF0uc2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgc2lnbmF0dXJlcyBvZiBhIFRyYW5zYWN0aW9uXG4gICAqIE9wdGlvbmFsIHBhcmFtZXRlciBzcGVjaWZpZXMgaWYgd2UncmUgZXhwZWN0aW5nIGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uIG9yIGEgcGFydGlhbGx5IHNpZ25lZCBvbmUuXG4gICAqIElmIG5vIGJvb2xlYW4gaXMgcHJvdmlkZWQsIHdlIGV4cGVjdCBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1aXJlQWxsU2lnbmF0dXJlcz10cnVlXSBSZXF1aXJlIGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmVzKHJlcXVpcmVBbGxTaWduYXR1cmVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZUVycm9ycyA9IHRoaXMuX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpLCByZXF1aXJlQWxsU2lnbmF0dXJlcyk7XG4gICAgcmV0dXJuICFzaWduYXR1cmVFcnJvcnM7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMobWVzc2FnZSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpIHtcbiAgICBjb25zdCBlcnJvcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHB1YmxpY0tleVxuICAgIH0gb2YgdGhpcy5zaWduYXR1cmVzKSB7XG4gICAgICBpZiAoc2lnbmF0dXJlID09PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgICAgICAgIChlcnJvcnMubWlzc2luZyB8fD0gW10pLnB1c2gocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2ZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkudG9CeXRlcygpKSkge1xuICAgICAgICAgIChlcnJvcnMuaW52YWxpZCB8fD0gW10pLnB1c2gocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzLmludmFsaWQgfHwgZXJyb3JzLm1pc3NpbmcgPyBlcnJvcnMgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBUcmFuc2FjdGlvbiBpbiB0aGUgd2lyZSBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbY29uZmlnXSBDb25maWcgb2YgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IFNpZ25hdHVyZSBvZiB0cmFuc2FjdGlvbiBpbiB3aXJlIGZvcm1hdC5cbiAgICovXG4gIHNlcmlhbGl6ZShjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlcyxcbiAgICAgIHZlcmlmeVNpZ25hdHVyZXNcbiAgICB9ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogdHJ1ZSxcbiAgICAgIHZlcmlmeVNpZ25hdHVyZXM6IHRydWVcbiAgICB9LCBjb25maWcpO1xuICAgIGNvbnN0IHNpZ25EYXRhID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKCk7XG4gICAgaWYgKHZlcmlmeVNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHNpZ0Vycm9ycyA9IHRoaXMuX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKHNpZ25EYXRhLCByZXF1aXJlQWxsU2lnbmF0dXJlcyk7XG4gICAgICBpZiAoc2lnRXJyb3JzKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQuJztcbiAgICAgICAgaWYgKHNpZ0Vycm9ycy5pbnZhbGlkKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5JbnZhbGlkIHNpZ25hdHVyZSBmb3IgcHVibGljIGtleSR7c2lnRXJyb3JzLmludmFsaWQubGVuZ3RoID09PSAxID8gJycgOiAnKHMpJ30gW1xcYCR7c2lnRXJyb3JzLmludmFsaWQubWFwKHAgPT4gcC50b0Jhc2U1OCgpKS5qb2luKCdgLCBgJyl9XFxgXS5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWdFcnJvcnMubWlzc2luZykge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuTWlzc2luZyBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke3NpZ0Vycm9ycy5taXNzaW5nLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSd9IFtcXGAke3NpZ0Vycm9ycy5taXNzaW5nLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKHNpZ25EYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmF0dXJlc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKHNpZ25hdHVyZUNvdW50LCBzaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25MZW5ndGggPSBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0ICsgc2lnbkRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IEJ1ZmZlci5hbGxvYyh0cmFuc2FjdGlvbkxlbmd0aCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoIDwgMjU2KTtcbiAgICBCdWZmZXIuZnJvbShzaWduYXR1cmVDb3VudCkuY29weSh3aXJlVHJhbnNhY3Rpb24sIDApO1xuICAgIHNpZ25hdHVyZXMuZm9yRWFjaCgoe1xuICAgICAgc2lnbmF0dXJlXG4gICAgfSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChzaWduYXR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IDY0LCBgc2lnbmF0dXJlIGhhcyBpbnZhbGlkIGxlbmd0aGApO1xuICAgICAgICBCdWZmZXIuZnJvbShzaWduYXR1cmUpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBpbmRleCAqIDY0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzaWduRGF0YS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgc2lnbmF0dXJlcy5sZW5ndGggKiA2NCk7XG4gICAgYXNzZXJ0KHdpcmVUcmFuc2FjdGlvbi5sZW5ndGggPD0gUEFDS0VUX0RBVEFfU0laRSwgYFRyYW5zYWN0aW9uIHRvbyBsYXJnZTogJHt3aXJlVHJhbnNhY3Rpb24ubGVuZ3RofSA+ICR7UEFDS0VUX0RBVEFfU0laRX1gKTtcbiAgICByZXR1cm4gd2lyZVRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGtleXMoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmtleXMubWFwKGtleU9iaiA9PiBrZXlPYmoucHVia2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBwcm9ncmFtSWQoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLnByb2dyYW1JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgd2lyZSB0cmFuc2FjdGlvbiBpbnRvIGEgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+fSBidWZmZXIgU2lnbmF0dXJlIG9mIHdpcmUgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUcmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgc3RhdGljIGZyb20oYnVmZmVyKSB7XG4gICAgLy8gU2xpY2UgdXAgd2lyZSBkYXRhXG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5idWZmZXJdO1xuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChiczU4LmVuY29kZShCdWZmZXIuZnJvbShzaWduYXR1cmUpKSk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wb3B1bGF0ZShNZXNzYWdlLmZyb20oYnl0ZUFycmF5KSwgc2lnbmF0dXJlcyk7XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGUgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gbWVzc2FnZSBhbmQgc2lnbmF0dXJlc1xuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSBvZiB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNpZ25hdHVyZXMgTGlzdCBvZiBzaWduYXR1cmVzIHRvIGFzc2lnbiB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUaGUgcG9wdWxhdGVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgcG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcyA9IFtdKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICBpZiAobWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBtZXNzYWdlLmFjY291bnRLZXlzWzBdO1xuICAgIH1cbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHNpZ25hdHVyZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ1B1YmtleVBhaXIgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlID09IGJzNTguZW5jb2RlKERFRkFVTFRfU0lHTkFUVVJFKSA/IG51bGwgOiBiczU4LmRlY29kZShzaWduYXR1cmUpLFxuICAgICAgICBwdWJsaWNLZXk6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5kZXhdXG4gICAgICB9O1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5wdXNoKHNpZ1B1YmtleVBhaXIpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2UuaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IGluc3RydWN0aW9uLmFjY291bnRzLm1hcChhY2NvdW50ID0+IHtcbiAgICAgICAgY29uc3QgcHVia2V5ID0gbWVzc2FnZS5hY2NvdW50S2V5c1thY2NvdW50XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMuc29tZShrZXlPYmogPT4ga2V5T2JqLnB1YmxpY0tleS50b1N0cmluZygpID09PSBwdWJrZXkudG9TdHJpbmcoKSkgfHwgbWVzc2FnZS5pc0FjY291bnRTaWduZXIoYWNjb3VudCksXG4gICAgICAgICAgaXNXcml0YWJsZTogbWVzc2FnZS5pc0FjY291bnRXcml0YWJsZShhY2NvdW50KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXMsXG4gICAgICAgIHByb2dyYW1JZDogbWVzc2FnZS5hY2NvdW50S2V5c1tpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleF0sXG4gICAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb24uX21lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRyYW5zYWN0aW9uLl9qc29uID0gdHJhbnNhY3Rpb24udG9KU09OKCk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG59XG5cbmNsYXNzIFRyYW5zYWN0aW9uTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLnBheWVyS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXJLZXkgPSBhcmdzLnBheWVyS2V5O1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgfVxuICBzdGF0aWMgZGVjb21waWxlKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWFkZXIsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIHJlY2VudEJsb2NraGFzaFxuICAgIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgIGFzc2VydChudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID4gMCwgJ01lc3NhZ2UgaGVhZGVyIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBtZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID49IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBtZXNzYWdlLmdldEFjY291bnRLZXlzKGFyZ3MpO1xuICAgIGNvbnN0IHBheWVyS2V5ID0gYWNjb3VudEtleXMuZ2V0KDApO1xuICAgIGlmIChwYXllcktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNvbXBpbGUgbWVzc2FnZSBiZWNhdXNlIG5vIGFjY291bnQga2V5cyB3ZXJlIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tcGlsZWRJeCBvZiBjb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlJbmRleCBvZiBjb21waWxlZEl4LmFjY291bnRLZXlJbmRleGVzKSB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IGFjY291bnRLZXlzLmdldChrZXlJbmRleCk7XG4gICAgICAgIGlmIChwdWJrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQga2V5IGZvciBhY2NvdW50IGtleSBpbmRleCAke2tleUluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU2lnbmVyID0ga2V5SW5kZXggPCBudW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgICAgIGxldCBpc1dyaXRhYmxlO1xuICAgICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUluZGV4IDwgYWNjb3VudEtleXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IC0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCA8XG4gICAgICAgICAgLy8gYWNjb3VudEtleXNGcm9tTG9va3VwcyBjYW5ub3QgYmUgdW5kZWZpbmVkIGJlY2F1c2Ugd2UgYWxyZWFkeSBmb3VuZCBhIHB1YmtleSBmb3IgdGhpcyBpbmRleCBhYm92ZVxuICAgICAgICAgIGFjY291bnRLZXlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBrZXlJbmRleCA8IGhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgICAgaXNXcml0YWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGFjY291bnRLZXlzLmdldChjb21waWxlZEl4LnByb2dyYW1JZEluZGV4KTtcbiAgICAgIGlmIChwcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIHByb2dyYW0gaWQgZm9yIHByb2dyYW0gaWQgaW5kZXggJHtjb21waWxlZEl4LnByb2dyYW1JZEluZGV4fWApO1xuICAgICAgfVxuICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IHRvQnVmZmVyKGNvbXBpbGVkSXguZGF0YSksXG4gICAgICAgIGtleXNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbk1lc3NhZ2Uoe1xuICAgICAgcGF5ZXJLZXksXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9MZWdhY3lNZXNzYWdlKCkge1xuICAgIHJldHVybiBNZXNzYWdlLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNvbXBpbGVUb1YwTWVzc2FnZShhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgIHJldHVybiBNZXNzYWdlVjAuY29tcGlsZSh7XG4gICAgICBwYXllcktleTogdGhpcy5wYXllcktleSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHNcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcnNpb25lZCB0cmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBWZXJzaW9uZWRUcmFuc2FjdGlvbiB7XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UudmVyc2lvbjtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzaWduYXR1cmVzKSB7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdm9pZCAwO1xuICAgIHRoaXMubWVzc2FnZSA9IHZvaWQgMDtcbiAgICBpZiAoc2lnbmF0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQoc2lnbmF0dXJlcy5sZW5ndGggPT09IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcywgJ0V4cGVjdGVkIHNpZ25hdHVyZXMgbGVuZ3RoIHRvIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcycpO1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdFNpZ25hdHVyZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzOyBpKyspIHtcbiAgICAgICAgZGVmYXVsdFNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBkZWZhdWx0U2lnbmF0dXJlcztcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3QgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKHNpZ25hdHVyZSgpLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoLCAnc2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkTWVzc2FnZS5sZW5ndGgsICdzZXJpYWxpemVkTWVzc2FnZScpXSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoID0gdHJhbnNhY3Rpb25MYXlvdXQuZW5jb2RlKHtcbiAgICAgIGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCksXG4gICAgICBzaWduYXR1cmVzOiB0aGlzLnNpZ25hdHVyZXMsXG4gICAgICBzZXJpYWxpemVkTWVzc2FnZVxuICAgIH0sIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbi5zbGljZSgwLCBzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbl07XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IFtdO1xuICAgIGNvbnN0IHNpZ25hdHVyZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZXNMZW5ndGg7IGkrKykge1xuICAgICAgc2lnbmF0dXJlcy5wdXNoKG5ldyBVaW50OEFycmF5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSkpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZShuZXcgVWludDhBcnJheShieXRlQXJyYXkpKTtcbiAgICByZXR1cm4gbmV3IFZlcnNpb25lZFRyYW5zYWN0aW9uKG1lc3NhZ2UsIHNpZ25hdHVyZXMpO1xuICB9XG4gIHNpZ24oc2lnbmVycykge1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0gdGhpcy5tZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHNpZ25lclB1YmtleXMgPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgocHVia2V5ID0+IHB1YmtleS5lcXVhbHMoc2lnbmVyLnB1YmxpY0tleSkpO1xuICAgICAgYXNzZXJ0KHNpZ25lckluZGV4ID49IDAsIGBDYW5ub3Qgc2lnbiB3aXRoIG5vbiBzaWduZXIga2V5ICR7c2lnbmVyLnB1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgICAgdGhpcy5zaWduYXR1cmVzW3NpZ25lckluZGV4XSA9IHNpZ24obWVzc2FnZURhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgIH1cbiAgfVxuICBhZGRTaWduYXR1cmUocHVibGljS2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmJ5dGVMZW5ndGggPT09IDY0LCAnU2lnbmF0dXJlIG11c3QgYmUgNjQgYnl0ZXMgbG9uZycpO1xuICAgIGNvbnN0IHNpZ25lclB1YmtleXMgPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGNvbnN0IHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgocHVia2V5ID0+IHB1YmtleS5lcXVhbHMocHVibGljS2V5KSk7XG4gICAgYXNzZXJ0KHNpZ25lckluZGV4ID49IDAsIGBDYW4gbm90IGFkZCBzaWduYXR1cmU7IFxcYCR7cHVibGljS2V5LnRvQmFzZTU4KCl9XFxgIGlzIG5vdCByZXF1aXJlZCB0byBzaWduIHRoaXMgdHJhbnNhY3Rpb25gKTtcbiAgICB0aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbmF0dXJlO1xuICB9XG59XG5cbi8vIFRPRE86IFRoZXNlIGNvbnN0YW50cyBzaG91bGQgYmUgcmVtb3ZlZCBpbiBmYXZvciBvZiByZWFkaW5nIHRoZW0gb3V0IG9mIGFcbi8vIFN5c2NhbGwgYWNjb3VudFxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOVU1fVElDS1NfUEVSX1NFQ09ORCA9IDE2MDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgREVGQVVMVF9USUNLU19QRVJfU0xPVCA9IDY0O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOVU1fU0xPVFNfUEVSX1NFQ09ORCA9IE5VTV9USUNLU19QRVJfU0VDT05EIC8gREVGQVVMVF9USUNLU19QRVJfU0xPVDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTVNfUEVSX1NMT1QgPSAxMDAwIC8gTlVNX1NMT1RTX1BFUl9TRUNPTkQ7XG5cbmNvbnN0IFNZU1ZBUl9DTE9DS19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJDMW9jazExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyRXBvY2hTY2hlZHUxZTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXIxbnN0cnVjdGlvbnMxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJlY2VudEIxb2NrSGFzaGVzMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRU5UX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJlbnQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRVdBUkRTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJld2FyZHMxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTMW90SGFzaGVzMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclN0YWtlSGlzdG9yeTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY2xhc3MgU2VuZFRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhY3Rpb24sXG4gICAgc2lnbmF0dXJlLFxuICAgIHRyYW5zYWN0aW9uTWVzc2FnZSxcbiAgICBsb2dzXG4gIH0pIHtcbiAgICBjb25zdCBtYXliZUxvZ3NPdXRwdXQgPSBsb2dzID8gYExvZ3M6IFxcbiR7SlNPTi5zdHJpbmdpZnkobG9ncy5zbGljZSgtMTApLCBudWxsLCAyKX0uIGAgOiAnJztcbiAgICBjb25zdCBndWlkZVRleHQgPSAnXFxuQ2F0Y2ggdGhlIGBTZW5kVHJhbnNhY3Rpb25FcnJvcmAgYW5kIGNhbGwgYGdldExvZ3MoKWAgb24gaXQgZm9yIGZ1bGwgZGV0YWlscy4nO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlICdzZW5kJzpcbiAgICAgICAgbWVzc2FnZSA9IGBUcmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gcmVzdWx0ZWQgaW4gYW4gZXJyb3IuIFxcbmAgKyBgJHt0cmFuc2FjdGlvbk1lc3NhZ2V9LiBgICsgbWF5YmVMb2dzT3V0cHV0ICsgZ3VpZGVUZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NpbXVsYXRlJzpcbiAgICAgICAgbWVzc2FnZSA9IGBTaW11bGF0aW9uIGZhaWxlZC4gXFxuTWVzc2FnZTogJHt0cmFuc2FjdGlvbk1lc3NhZ2V9LiBcXG5gICsgbWF5YmVMb2dzT3V0cHV0ICsgZ3VpZGVUZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlID0gYFVua25vd24gYWN0aW9uICckeyhhID0+IGEpKGFjdGlvbil9J2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc2FjdGlvbk1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy50cmFuc2FjdGlvbk1lc3NhZ2UgPSB0cmFuc2FjdGlvbk1lc3NhZ2U7XG4gICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSBsb2dzID8gbG9ncyA6IHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgdHJhbnNhY3Rpb25FcnJvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogdGhpcy50cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgICBsb2dzOiBBcnJheS5pc0FycmF5KHRoaXMudHJhbnNhY3Rpb25Mb2dzKSA/IHRoaXMudHJhbnNhY3Rpb25Mb2dzIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qIEBkZXByZWNhdGVkIFVzZSBgYXdhaXQgZ2V0TG9ncygpYCBpbnN0ZWFkICovXG4gIGdldCBsb2dzKCkge1xuICAgIGNvbnN0IGNhY2hlZExvZ3MgPSB0aGlzLnRyYW5zYWN0aW9uTG9ncztcbiAgICBpZiAoY2FjaGVkTG9ncyAhPSBudWxsICYmIHR5cGVvZiBjYWNoZWRMb2dzID09PSAnb2JqZWN0JyAmJiAndGhlbicgaW4gY2FjaGVkTG9ncykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZExvZ3M7XG4gIH1cbiAgYXN5bmMgZ2V0TG9ncyhjb25uZWN0aW9uKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMudHJhbnNhY3Rpb25Mb2dzKSkge1xuICAgICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb24uZ2V0VHJhbnNhY3Rpb24odGhpcy5zaWduYXR1cmUpLnRoZW4odHggPT4ge1xuICAgICAgICAgIGlmICh0eCAmJiB0eC5tZXRhICYmIHR4Lm1ldGEubG9nTWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ3MgPSB0eC5tZXRhLmxvZ01lc3NhZ2VzO1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbkxvZ3MgPSBsb2dzO1xuICAgICAgICAgICAgcmVzb2x2ZShsb2dzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTG9nIG1lc3NhZ2VzIG5vdCBmb3VuZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNhY3Rpb25Mb2dzO1xuICB9XG59XG5cbi8vIEtlZXAgaW4gc3luYyB3aXRoIGNsaWVudC9zcmMvcnBjX2N1c3RvbV9lcnJvcnMucnNcbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IFNvbGFuYUpTT05SUENFcnJvckNvZGUgPSB7XG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQOiAtMzIwMDEsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFOiAtMzIwMDIsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6IC0zMjAwMyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEU6IC0zMjAwNCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZOiAtMzIwMDUsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFOiAtMzIwMDYsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQ6IC0zMjAwNyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UOiAtMzIwMDgsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQ6IC0zMjAwOSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWDogLTMyMDEwLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFOiAtMzIwMTEsXG4gIEpTT05fUlBDX1NDQU5fRVJST1I6IC0zMjAxMixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0g6IC0zMjAxMyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVDogLTMyMDE0LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTjogLTMyMDE1LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRDogLTMyMDE2XG59O1xuY2xhc3MgU29sYW5hSlNPTlJQQ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29kZSxcbiAgICBtZXNzYWdlLFxuICAgIGRhdGFcbiAgfSwgY3VzdG9tTWVzc2FnZSkge1xuICAgIHN1cGVyKGN1c3RvbU1lc3NhZ2UgIT0gbnVsbCA/IGAke2N1c3RvbU1lc3NhZ2V9OiAke21lc3NhZ2V9YCA6IG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubmFtZSA9ICdTb2xhbmFKU09OUlBDRXJyb3InO1xuICB9XG59XG5cbi8qKlxuICogU2lnbiwgc2VuZCBhbmQgY29uZmlybSBhIHRyYW5zYWN0aW9uLlxuICpcbiAqIElmIGBjb21taXRtZW50YCBvcHRpb24gaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gJ21heCcgY29tbWl0bWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnNcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBzaWduZXJzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgIG1pbkNvbnRleHRTbG90OiBvcHRpb25zLm1pbkNvbnRleHRTbG90XG4gIH07XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzLCBzZW5kT3B0aW9ucyk7XG4gIGxldCBzdGF0dXM7XG4gIGlmICh0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCAhPSBudWxsKSB7XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zPy5hYm9ydFNpZ25hbCxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgYmxvY2toYXNoOiB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHRcbiAgICB9LCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRyYW5zYWN0aW9uLm1pbk5vbmNlQ29udGV4dFNsb3QgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5ub25jZUluZm8gIT0gbnVsbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vbmNlSW5zdHJ1Y3Rpb25cbiAgICB9ID0gdHJhbnNhY3Rpb24ubm9uY2VJbmZvO1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudFB1YmtleSA9IG5vbmNlSW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXk7XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zPy5hYm9ydFNpZ25hbCxcbiAgICAgIG1pbkNvbnRleHRTbG90OiB0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90LFxuICAgICAgbm9uY2VBY2NvdW50UHVia2V5LFxuICAgICAgbm9uY2VWYWx1ZTogdHJhbnNhY3Rpb24ubm9uY2VJbmZvLm5vbmNlLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0aW9ucz8uYWJvcnRTaWduYWwgIT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKCdzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCk6IEEgdHJhbnNhY3Rpb24gd2l0aCBhIGRlcHJlY2F0ZWQgY29uZmlybWF0aW9uIHN0cmF0ZWd5IHdhcyAnICsgJ3N1cHBsaWVkIGFsb25nIHdpdGggYW4gYGFib3J0U2lnbmFsYC4gT25seSB0cmFuc2FjdGlvbnMgaGF2aW5nIGBsYXN0VmFsaWRCbG9ja0hlaWdodGAgJyArICdvciBhIGNvbWJpbmF0aW9uIG9mIGBub25jZUluZm9gIGFuZCBgbWluTm9uY2VDb250ZXh0U2xvdGAgYXJlIGFib3J0YWJsZS4nKTtcbiAgICB9XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfVxuICBpZiAoc3RhdHVzLmVycikge1xuICAgIGlmIChzaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiAnc2VuZCcsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICB0cmFuc2FjdGlvbk1lc3NhZ2U6IGBTdGF0dXM6ICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYCk7XG4gIH1cbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cblxuLy8genp6XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBQb3B1bGF0ZSBhIGJ1ZmZlciBvZiBpbnN0cnVjdGlvbiBkYXRhIHVzaW5nIGFuIEluc3RydWN0aW9uVHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVuY29kZURhdGEodHlwZSwgZmllbGRzKSB7XG4gIGNvbnN0IGFsbG9jTGVuZ3RoID0gdHlwZS5sYXlvdXQuc3BhbiA+PSAwID8gdHlwZS5sYXlvdXQuc3BhbiA6IGdldEFsbG9jKHR5cGUsIGZpZWxkcyk7XG4gIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoYWxsb2NMZW5ndGgpO1xuICBjb25zdCBsYXlvdXRGaWVsZHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBpbnN0cnVjdGlvbjogdHlwZS5pbmRleFxuICB9LCBmaWVsZHMpO1xuICB0eXBlLmxheW91dC5lbmNvZGUobGF5b3V0RmllbGRzLCBkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIGluc3RydWN0aW9uIGRhdGEgYnVmZmVyIHVzaW5nIGFuIEluc3RydWN0aW9uVHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlY29kZURhdGEkMSh0eXBlLCBidWZmZXIpIHtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IHR5cGUubGF5b3V0LmRlY29kZShidWZmZXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG4gIGlmIChkYXRhLmluc3RydWN0aW9uICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBpbnN0cnVjdGlvbiBpbmRleCBtaXNtYXRjaCAke2RhdGEuaW5zdHJ1Y3Rpb259ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvOTBiZWRkN2UwNjdiNWI4ZjNkZGJiNDVkYTAwYTRlOWNhYmIyMmM2Mi9zZGsvc3JjL2ZlZV9jYWxjdWxhdG9yLnJzI0w3LUwxMVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBGZWVDYWxjdWxhdG9yTGF5b3V0ID0gQnVmZmVyTGF5b3V0Lm51NjQoJ2xhbXBvcnRzUGVyU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQ2FsY3VsYXRvciBmb3IgdHJhbnNhY3Rpb24gZmVlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzBlYTI4NDNlYzljZGM1MTc1NzJiOGU2MmM5NTlmNDFiNTVjZjQ0NTMvc2RrL3NyYy9ub25jZV9zdGF0ZS5ycyNMMjktTDMyXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5vbmNlQWNjb3VudExheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3ZlcnNpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignc3RhdGUnKSwgcHVibGljS2V5KCdhdXRob3JpemVkUHVia2V5JyksIHB1YmxpY0tleSgnbm9uY2UnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbRmVlQ2FsY3VsYXRvckxheW91dF0sICdmZWVDYWxjdWxhdG9yJyldKTtcbmNvbnN0IE5PTkNFX0FDQ09VTlRfTEVOR1RIID0gTm9uY2VBY2NvdW50TGF5b3V0LnNwYW47XG5cbi8qKlxuICogQSBkdXJhYmxlIG5vbmNlIGlzIGEgMzIgYnl0ZSB2YWx1ZSBlbmNvZGVkIGFzIGEgYmFzZTU4IHN0cmluZy5cbiAqL1xuXG4vKipcbiAqIE5vbmNlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBOb25jZUFjY291bnQge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5hdXRob3JpemVkUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IGFyZ3MuYXV0aG9yaXplZFB1YmtleTtcbiAgICB0aGlzLm5vbmNlID0gYXJncy5ub25jZTtcbiAgICB0aGlzLmZlZUNhbGN1bGF0b3IgPSBhcmdzLmZlZUNhbGN1bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgTm9uY2VBY2NvdW50IGZyb20gdGhlIGFjY291bnQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBOb25jZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50ID0gTm9uY2VBY2NvdW50TGF5b3V0LmRlY29kZSh0b0J1ZmZlcihidWZmZXIpLCAwKTtcbiAgICByZXR1cm4gbmV3IE5vbmNlQWNjb3VudCh7XG4gICAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5hdXRob3JpemVkUHVia2V5KSxcbiAgICAgIG5vbmNlOiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5ub25jZSkudG9TdHJpbmcoKSxcbiAgICAgIGZlZUNhbGN1bGF0b3I6IG5vbmNlQWNjb3VudC5mZWVDYWxjdWxhdG9yXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdTY0KHByb3BlcnR5KSB7XG4gIGNvbnN0IGxheW91dCA9IGJsb2IoOCAvKiBieXRlcyAqLywgcHJvcGVydHkpO1xuICBjb25zdCBkZWNvZGUgPSBsYXlvdXQuZGVjb2RlLmJpbmQobGF5b3V0KTtcbiAgY29uc3QgZW5jb2RlID0gbGF5b3V0LmVuY29kZS5iaW5kKGxheW91dCk7XG4gIGNvbnN0IGJpZ0ludExheW91dCA9IGxheW91dDtcbiAgY29uc3QgY29kZWMgPSBnZXRVNjRDb2RlYygpO1xuICBiaWdJbnRMYXlvdXQuZGVjb2RlID0gKGJ1ZmZlciwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3Qgc3JjID0gZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICByZXR1cm4gY29kZWMuZGVjb2RlKHNyYyk7XG4gIH07XG4gIGJpZ0ludExheW91dC5lbmNvZGUgPSAoYmlnSW50LCBidWZmZXIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IGNvZGVjLmVuY29kZShiaWdJbnQpO1xuICAgIHJldHVybiBlbmNvZGUoc3JjLCBidWZmZXIsIG9mZnNldCk7XG4gIH07XG4gIHJldHVybiBiaWdJbnRMYXlvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVHJhbnNmZXIgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXNzaWduIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgbm9uY2UgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBub25jZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFkdmFuY2Ugbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBXaXRoZHJhdyBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZSBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFsbG9jYXRlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWxsb2NhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXNzaWduIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFRyYW5zZmVyIHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqIERlY29kZWQgdHJhbnNmZXIgc3lzdGVtIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uICovXG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyV2l0aFNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uICovXG5cbi8qKlxuICogU3lzdGVtIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFN5c3RlbUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3lzdGVtSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY3JlYXRlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB0cmFuc2ZlciBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlVHJhbnNmZXIoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXIsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB0cmFuc2ZlciB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVRyYW5zZmVyV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhbGxvY2F0ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBzcGFjZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHNwYWNlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBbGxvY2F0ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXNzaWduIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBc3NpZ24oaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbiwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhc3NpZ24gd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBc3NpZ25XaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ25XaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY3JlYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGluaXRpYWxpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlSW5pdGlhbGl6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhZHZhbmNlIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUFkdmFuY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWR2YW5jZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSB3aXRoZHJhdyBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhd05vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGF1dGhvcml6ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBTeXN0ZW1Qcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTeXN0ZW1JbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3lzdGVtIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ246IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2Zlcjoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgQ3JlYXRlV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFkdmFuY2VOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBXaXRoZHJhd05vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA1LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBJbml0aWFsaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDYsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWQnKV0pXG4gIH0sXG4gIEF1dGhvcml6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdhdXRob3JpemVkJyldKVxuICB9LFxuICBBbGxvY2F0ZToge1xuICAgIGluZGV4OiA4LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyldKVxuICB9LFxuICBBbGxvY2F0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDksXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFzc2lnbldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFRyYW5zZmVyV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ2xhbXBvcnRzJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFVwZ3JhZGVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogMTIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFN5c3RlbSBwcm9ncmFtXG4gKi9cbmNsYXNzIFN5c3RlbVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTeXN0ZW0gcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCB0cmFuc2ZlcnMgbGFtcG9ydHMgZnJvbSBvbmUgYWNjb3VudCB0byBhbm90aGVyXG4gICAqL1xuICBzdGF0aWMgdHJhbnNmZXIocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogQmlnSW50KHBhcmFtcy5sYW1wb3J0cyksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcjtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubGFtcG9ydHMpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhc3NpZ25zIGFuIGFjY291bnQgdG8gYSBwcm9ncmFtXG4gICAqL1xuICBzdGF0aWMgYXNzaWduKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbjtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHByb2dyYW1JZFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnRXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLm5ld0FjY291bnRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG4gICAgaWYgKCFwYXJhbXMuYmFzZVB1YmtleS5lcXVhbHMocGFyYW1zLmZyb21QdWJrZXkpKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZU5vbmNlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zICYmICdzZWVkJyBpbiBwYXJhbXMpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnRXaXRoU2VlZCh7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGJhc2VQdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IE5PTkNFX0FDQ09VTlRfTEVOR1RILFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdFBhcmFtcyA9IHtcbiAgICAgIG5vbmNlUHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleVxuICAgIH07XG4gICAgdHJhbnNhY3Rpb24uYWRkKHRoaXMubm9uY2VJbml0aWFsaXplKGluaXRQYXJhbXMpKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW5zdHJ1Y3Rpb24gdG8gaW5pdGlhbGl6ZSBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZUluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDogdG9CdWZmZXIocGFyYW1zLmF1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGFkdmFuY2UgdGhlIG5vbmNlIGluIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlQWR2YW5jZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWR2YW5jZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgd2l0aGRyYXdzIGxhbXBvcnRzIGZyb20gYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VXaXRoZHJhdyhwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBQdWJsaWNLZXkgYXMgdGhlIGF1dGhvcml0eVxuICAgKiBvbiBhIE5vbmNlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgbm9uY2VBdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMubmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhbGxvY2F0ZXMgc3BhY2UgaW4gYW4gYWNjb3VudCB3aXRob3V0IGZ1bmRpbmdcbiAgICovXG4gIHN0YXRpYyBhbGxvY2F0ZShwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBzcGFjZTogcGFyYW1zLnNwYWNlXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vLyBLZWVwIHByb2dyYW0gY2h1bmtzIHVuZGVyIFBBQ0tFVF9EQVRBX1NJWkUsIGxlYXZpbmcgZW5vdWdoIHJvb20gZm9yIHRoZVxuLy8gcmVzdCBvZiB0aGUgVHJhbnNhY3Rpb24gZmllbGRzXG4vL1xuLy8gVE9ETzogcmVwbGFjZSAzMDAgd2l0aCBhIHByb3BlciBjb25zdGFudCBmb3IgdGhlIHNpemUgb2YgdGhlIG90aGVyXG4vLyBUcmFuc2FjdGlvbiBmaWVsZHNcbmNvbnN0IENIVU5LX1NJWkUgPSBQQUNLRVRfREFUQV9TSVpFIC0gMzAwO1xuXG4vKipcbiAqIFByb2dyYW0gbG9hZGVyIGludGVyZmFjZVxuICovXG5jbGFzcyBMb2FkZXIge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiBwcm9ncmFtIGRhdGEgcGxhY2VkIGluIGVhY2ggbG9hZCBUcmFuc2FjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBsb2FkIGEgcHJvZ3JhbSBub3QgaW5jbHVkaW5nXG4gICAqIHJldHJpZXNcbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRyYW5zYWN0aW9uIGZlZXNcbiAgICovXG4gIHN0YXRpYyBnZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpIHtcbiAgICByZXR1cm4gMiAqIChcbiAgICAvLyBFdmVyeSB0cmFuc2FjdGlvbiByZXF1aXJlcyB0d28gc2lnbmF0dXJlcyAocGF5ZXIgKyBwcm9ncmFtKVxuICAgIE1hdGguY2VpbChkYXRhTGVuZ3RoIC8gTG9hZGVyLmNodW5rU2l6ZSkgKyAxICtcbiAgICAvLyBBZGQgb25lIGZvciBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAxKSAvLyBBZGQgb25lIGZvciBGaW5hbGl6ZSB0cmFuc2FjdGlvblxuICAgIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIGdlbmVyaWMgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHBheWVyIFN5c3RlbSBhY2NvdW50IHRoYXQgcGF5cyB0byBsb2FkIHRoZSBwcm9ncmFtXG4gICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGxvYWRlclxuICAgKiBAcGFyYW0gZGF0YSBQcm9ncmFtIG9jdGV0c1xuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBwcm9ncmFtSWQsIGRhdGEpIHtcbiAgICB7XG4gICAgICBjb25zdCBiYWxhbmNlTmVlZGVkID0gYXdhaXQgY29ubmVjdGlvbi5nZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oZGF0YS5sZW5ndGgpO1xuXG4gICAgICAvLyBGZXRjaCBwcm9ncmFtIGFjY291bnQgaW5mbyB0byBjaGVjayBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhwcm9ncmFtLnB1YmxpY0tleSwgJ2NvbmZpcm1lZCcpO1xuICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgIGlmIChwcm9ncmFtSW5mbyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZXhlY3V0YWJsZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2dyYW0gbG9hZCBmYWlsZWQsIGFjY291bnQgaXMgYWxyZWFkeSBleGVjdXRhYmxlJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5kYXRhLmxlbmd0aCAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFsbG9jYXRlKHtcbiAgICAgICAgICAgIGFjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgc3BhY2U6IGRhdGEubGVuZ3RoXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvZ3JhbUluZm8ub3duZXIuZXF1YWxzKHByb2dyYW1JZCkpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFzc2lnbih7XG4gICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHByb2dyYW1JZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbUluZm8ubGFtcG9ydHMgPCBiYWxhbmNlTmVlZGVkKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgICB0b1B1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCAtIHByb2dyYW1JbmZvLmxhbXBvcnRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCA+IDAgPyBiYWxhbmNlTmVlZGVkIDogMSxcbiAgICAgICAgICBzcGFjZTogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgcHJvZ3JhbUlkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGFjY291bnQgaXMgYWxyZWFkeSBjcmVhdGVkIGNvcnJlY3RseSwgc2tpcCB0aGlzIHN0ZXBcbiAgICAgIC8vIGFuZCBwcm9jZWVkIGRpcmVjdGx5IHRvIGxvYWRpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgICBpZiAodHJhbnNhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignb2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MzIoJ2J5dGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC51MzIoJ2J5dGVzTGVuZ3RoUGFkZGluZycpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgnYnl0ZScpLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnYnl0ZXMnKV0pO1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IExvYWRlci5jaHVua1NpemU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IGFycmF5ID0gZGF0YTtcbiAgICBsZXQgdHJhbnNhY3Rpb25zID0gW107XG4gICAgd2hpbGUgKGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXkuc2xpY2UoMCwgY2h1bmtTaXplKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoY2h1bmtTaXplICsgMTYpO1xuICAgICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgICBpbnN0cnVjdGlvbjogMCxcbiAgICAgICAgLy8gTG9hZCBpbnN0cnVjdGlvblxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGJ5dGVzOiBieXRlcyxcbiAgICAgICAgYnl0ZXNMZW5ndGg6IDAsXG4gICAgICAgIGJ5dGVzTGVuZ3RoUGFkZGluZzogMFxuICAgICAgfSwgZGF0YSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICAgIGtleXM6IFt7XG4gICAgICAgICAgcHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb25zLnB1c2goc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgfSkpO1xuXG4gICAgICAvLyBEZWxheSBiZXR3ZWVuIHNlbmRzIGluIGFuIGF0dGVtcHQgdG8gcmVkdWNlIHJhdGUgbGltaXQgZXJyb3JzXG4gICAgICBpZiAoY29ubmVjdGlvbi5fcnBjRW5kcG9pbnQuaW5jbHVkZXMoJ3NvbGFuYS5jb20nKSkge1xuICAgICAgICBjb25zdCBSRVFVRVNUU19QRVJfU0VDT05EID0gNDtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCAvIFJFUVVFU1RTX1BFUl9TRUNPTkQpO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgIGFycmF5ID0gYXJyYXkuc2xpY2UoY2h1bmtTaXplKTtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zKTtcblxuICAgIC8vIEZpbmFsaXplIHRoZSBhY2NvdW50IGxvYWRlZCB3aXRoIHByb2dyYW0gZGF0YSBmb3IgZXhlY3V0aW9uXG4gICAge1xuICAgICAgY29uc3QgZGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoZGF0YUxheW91dC5zcGFuKTtcbiAgICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDEgLy8gRmluYWxpemUgaW5zdHJ1Y3Rpb25cbiAgICAgIH0sIGRhdGEpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGVwbG95Q29tbWl0bWVudCA9ICdwcm9jZXNzZWQnO1xuICAgICAgY29uc3QgZmluYWxpemVTaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZTogZmluYWxpemVTaWduYXR1cmUsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgICAgYmxvY2toYXNoOiB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2hcbiAgICAgIH0sIGRlcGxveUNvbW1pdG1lbnQpO1xuICAgICAgaWYgKHZhbHVlLmVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uICR7ZmluYWxpemVTaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9KWApO1xuICAgICAgfVxuICAgICAgLy8gV2UgcHJldmVudCBwcm9ncmFtcyBmcm9tIGJlaW5nIHVzYWJsZSB1bnRpbCB0aGUgc2xvdCBhZnRlciB0aGVpciBkZXBsb3ltZW50LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yOTY1NFxuICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbG90ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRTbG90KHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGRlcGxveUNvbW1pdG1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY3VycmVudFNsb3QgPiBjb250ZXh0LnNsb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLyogZW1wdHkgKi9cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yb3VuZChNU19QRVJfU0xPVCAvIDIpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3VjY2Vzc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5Mb2FkZXIuY2h1bmtTaXplID0gQ0hVTktfU0laRTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS4xNy4yMC5cbiAqL1xuY29uc3QgQlBGX0xPQURFUl9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQlBGTG9hZGVyMjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIGEgcHJvZ3JhbSBsb2FkZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS4xNy4yMC5cbiAqL1xuY2xhc3MgQnBmTG9hZGVyIHtcbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgKiByZXRyaWVzXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAqL1xuICBzdGF0aWMgZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIExvYWRlci5nZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYSBTQkYgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHBheWVyIEFjY291bnQgdGhhdCB3aWxsIHBheSBwcm9ncmFtIGxvYWRpbmcgZmVlc1xuICAgKiBAcGFyYW0gcHJvZ3JhbSBBY2NvdW50IHRvIGxvYWQgdGhlIHByb2dyYW0gaW50b1xuICAgKiBAcGFyYW0gZWxmIFRoZSBlbnRpcmUgRUxGIGNvbnRhaW5pbmcgdGhlIFNCRiBwcm9ncmFtXG4gICAqIEBwYXJhbSBsb2FkZXJQcm9ncmFtSWQgVGhlIHByb2dyYW0gaWQgb2YgdGhlIEJQRiBsb2FkZXIgdG8gdXNlXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9ncmFtIHdhcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBwcm9ncmFtIHdhcyBhbHJlYWR5IGxvYWRlZFxuICAgKi9cbiAgc3RhdGljIGxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIGVsZiwgbG9hZGVyUHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIExvYWRlci5sb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBsb2FkZXJQcm9ncmFtSWQsIGVsZik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIGFnZW50a2VlcGFsaXZlID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBtcztcbnZhciBoYXNSZXF1aXJlZE1zO1xuXG5mdW5jdGlvbiByZXF1aXJlTXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRNcykgcmV0dXJuIG1zO1xuXHRoYXNSZXF1aXJlZE1zID0gMTtcblx0dmFyIHMgPSAxMDAwO1xuXHR2YXIgbSA9IHMgKiA2MDtcblx0dmFyIGggPSBtICogNjA7XG5cdHZhciBkID0gaCAqIDI0O1xuXHR2YXIgdyA9IGQgKiA3O1xuXHR2YXIgeSA9IGQgKiAzNjUuMjU7XG5cblx0LyoqXG5cdCAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG5cdCAqXG5cdCAqIE9wdGlvbnM6XG5cdCAqXG5cdCAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG5cdCAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRtcyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cdCAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG5cdCAgICByZXR1cm4gcGFyc2UodmFsKTtcblx0ICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcblx0ICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuXHQgIH1cblx0ICB0aHJvdyBuZXcgRXJyb3IoXG5cdCAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcblx0ICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuXHQgICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBwYXJzZShzdHIpIHtcblx0ICBzdHIgPSBTdHJpbmcoc3RyKTtcblx0ICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG5cdCAgICBzdHJcblx0ICApO1xuXHQgIGlmICghbWF0Y2gpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcblx0ICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuXHQgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSAneWVhcnMnOlxuXHQgICAgY2FzZSAneWVhcic6XG5cdCAgICBjYXNlICd5cnMnOlxuXHQgICAgY2FzZSAneXInOlxuXHQgICAgY2FzZSAneSc6XG5cdCAgICAgIHJldHVybiBuICogeTtcblx0ICAgIGNhc2UgJ3dlZWtzJzpcblx0ICAgIGNhc2UgJ3dlZWsnOlxuXHQgICAgY2FzZSAndyc6XG5cdCAgICAgIHJldHVybiBuICogdztcblx0ICAgIGNhc2UgJ2RheXMnOlxuXHQgICAgY2FzZSAnZGF5Jzpcblx0ICAgIGNhc2UgJ2QnOlxuXHQgICAgICByZXR1cm4gbiAqIGQ7XG5cdCAgICBjYXNlICdob3Vycyc6XG5cdCAgICBjYXNlICdob3VyJzpcblx0ICAgIGNhc2UgJ2hycyc6XG5cdCAgICBjYXNlICdocic6XG5cdCAgICBjYXNlICdoJzpcblx0ICAgICAgcmV0dXJuIG4gKiBoO1xuXHQgICAgY2FzZSAnbWludXRlcyc6XG5cdCAgICBjYXNlICdtaW51dGUnOlxuXHQgICAgY2FzZSAnbWlucyc6XG5cdCAgICBjYXNlICdtaW4nOlxuXHQgICAgY2FzZSAnbSc6XG5cdCAgICAgIHJldHVybiBuICogbTtcblx0ICAgIGNhc2UgJ3NlY29uZHMnOlxuXHQgICAgY2FzZSAnc2Vjb25kJzpcblx0ICAgIGNhc2UgJ3NlY3MnOlxuXHQgICAgY2FzZSAnc2VjJzpcblx0ICAgIGNhc2UgJ3MnOlxuXHQgICAgICByZXR1cm4gbiAqIHM7XG5cdCAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuXHQgICAgY2FzZSAnbXNlY3MnOlxuXHQgICAgY2FzZSAnbXNlYyc6XG5cdCAgICBjYXNlICdtcyc6XG5cdCAgICAgIHJldHVybiBuO1xuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbXNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcblx0ICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG5cdCAgaWYgKG1zQWJzID49IGQpIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBoKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gbSkge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IHMpIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG5cdCAgfVxuXHQgIHJldHVybiBtcyArICdtcyc7XG5cdH1cblxuXHQvKipcblx0ICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBmbXRMb25nKG1zKSB7XG5cdCAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuXHQgIGlmIChtc0FicyA+PSBkKSB7XG5cdCAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gaCkge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBtKSB7XG5cdCAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gcykge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcblx0ICB9XG5cdCAgcmV0dXJuIG1zICsgJyBtcyc7XG5cdH1cblxuXHQvKipcblx0ICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcblx0ICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuXHQgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xuXHR9XG5cdHJldHVybiBtcztcbn1cblxuLyohXG4gKiBodW1hbml6ZS1tcyAtIGluZGV4LmpzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBkZWFkX2hvcnNlIDxkZWFkX2hvcnNlQHFxLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBodW1hbml6ZU1zO1xudmFyIGhhc1JlcXVpcmVkSHVtYW5pemVNcztcblxuZnVuY3Rpb24gcmVxdWlyZUh1bWFuaXplTXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRIdW1hbml6ZU1zKSByZXR1cm4gaHVtYW5pemVNcztcblx0aGFzUmVxdWlyZWRIdW1hbml6ZU1zID0gMTtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIHV0aWwgPSByZXF1aXJlJCQwO1xuXHR2YXIgbXMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVNcygpO1xuXG5cdGh1bWFuaXplTXMgPSBmdW5jdGlvbiAodCkge1xuXHQgIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicpIHJldHVybiB0O1xuXHQgIHZhciByID0gbXModCk7XG5cdCAgaWYgKHIgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgdmFyIGVyciA9IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnaHVtYW5pemUtbXMoJWopIHJlc3VsdCB1bmRlZmluZWQnLCB0KSk7XG5cdCAgICBjb25zb2xlLndhcm4oZXJyLnN0YWNrKTtcblx0ICB9XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cdHJldHVybiBodW1hbml6ZU1zO1xufVxuXG52YXIgY29uc3RhbnRzO1xudmFyIGhhc1JlcXVpcmVkQ29uc3RhbnRzO1xuXG5mdW5jdGlvbiByZXF1aXJlQ29uc3RhbnRzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQ29uc3RhbnRzKSByZXR1cm4gY29uc3RhbnRzO1xuXHRoYXNSZXF1aXJlZENvbnN0YW50cyA9IDE7XG5cblx0Y29uc3RhbnRzID0ge1xuXHQgIC8vIGFnZW50XG5cdCAgQ1VSUkVOVF9JRDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjdXJyZW50SWQnKSxcblx0ICBDUkVBVEVfSUQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3JlYXRlSWQnKSxcblx0ICBJTklUX1NPQ0tFVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNpbml0U29ja2V0JyksXG5cdCAgQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT046IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3JlYXRlSHR0cHNDb25uZWN0aW9uJyksXG5cdCAgLy8gc29ja2V0XG5cdCAgU09DS0VUX0NSRUFURURfVElNRTogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRDcmVhdGVkVGltZScpLFxuXHQgIFNPQ0tFVF9OQU1FOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldE5hbWUnKSxcblx0ICBTT0NLRVRfUkVRVUVTVF9DT1VOVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRSZXF1ZXN0Q291bnQnKSxcblx0ICBTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRSZXF1ZXN0RmluaXNoZWRDb3VudCcpLFxuXHR9O1xuXHRyZXR1cm4gY29uc3RhbnRzO1xufVxuXG52YXIgYWdlbnQ7XG52YXIgaGFzUmVxdWlyZWRBZ2VudDtcblxuZnVuY3Rpb24gcmVxdWlyZUFnZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQWdlbnQpIHJldHVybiBhZ2VudDtcblx0aGFzUmVxdWlyZWRBZ2VudCA9IDE7XG5cblx0Y29uc3QgT3JpZ2luYWxBZ2VudCA9IHJlcXVpcmUkJDAkMS5BZ2VudDtcblx0Y29uc3QgbXMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVIdW1hbml6ZU1zKCk7XG5cdGNvbnN0IGRlYnVnID0gcmVxdWlyZSQkMC5kZWJ1Z2xvZygnYWdlbnRrZWVwYWxpdmUnKTtcblx0Y29uc3Qge1xuXHQgIElOSVRfU09DS0VULFxuXHQgIENVUlJFTlRfSUQsXG5cdCAgQ1JFQVRFX0lELFxuXHQgIFNPQ0tFVF9DUkVBVEVEX1RJTUUsXG5cdCAgU09DS0VUX05BTUUsXG5cdCAgU09DS0VUX1JFUVVFU1RfQ09VTlQsXG5cdCAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQsXG5cdH0gPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblxuXHQvLyBPcmlnaW5hbEFnZW50IGNvbWUgZnJvbVxuXHQvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjEyLjAvbGliL19odHRwX2FnZW50LmpzXG5cdC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjEyLjAvbGliL19odHRwX2FnZW50LmpzXG5cblx0Ly8gbm9kZSA8PSAxMFxuXHRsZXQgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMTtcblx0Y29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJywgMSlbMF0uc3Vic3RyaW5nKDEpKTtcblx0aWYgKG1ham9yVmVyc2lvbiA+PSAxMSAmJiBtYWpvclZlcnNpb24gPD0gMTIpIHtcblx0ICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAyO1xuXHR9IGVsc2UgaWYgKG1ham9yVmVyc2lvbiA+PSAxMykge1xuXHQgIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDM7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSkge1xuXHQgIGNvbnNvbGUubG9nKCdbYWdlbnRrZWVwYWxpdmU6ZGVwcmVjYXRlZF0gJXMnLCBtZXNzYWdlKTtcblx0fVxuXG5cdGNsYXNzIEFnZW50IGV4dGVuZHMgT3JpZ2luYWxBZ2VudCB7XG5cdCAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXHQgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgICBvcHRpb25zLmtlZXBBbGl2ZSA9IG9wdGlvbnMua2VlcEFsaXZlICE9PSBmYWxzZTtcblx0ICAgIC8vIGRlZmF1bHQgaXMga2VlcC1hbGl2ZSBhbmQgNHMgZnJlZSBzb2NrZXQgdGltZW91dFxuXHQgICAgLy8gc2VlIGh0dHBzOi8vbWVkaXVtLmNvbS9zc2Vuc2UtdGVjaC9yZWR1Y2UtbmV0d29ya2luZy1lcnJvcnMtaW4tbm9kZWpzLTIzYjRlYjlmMmQ4M1xuXHQgICAgaWYgKG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gNDAwMDtcblx0ICAgIH1cblx0ICAgIC8vIExlZ2FjeSBBUEk6IGtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG5cdCAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0KSB7XG5cdCAgICAgIGRlcHJlY2F0ZSgnb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG5cdCAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICAgIGRlbGV0ZSBvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICB9XG5cdCAgICAvLyBMZWdhY3kgQVBJOiBmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBzaG91bGQgYmUgcmVuYW1lIHRvIGBmcmVlU29ja2V0VGltZW91dGBcblx0ICAgIGlmIChvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0KSB7XG5cdCAgICAgIGRlcHJlY2F0ZSgnb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcblx0ICAgICAgZGVsZXRlIG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICB9XG5cblx0ICAgIC8vIFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyIHRpbWVvdXQgbWlsbGlzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gdGhlIHNvY2tldC5cblx0ICAgIC8vIEJ5IGRlZmF1bHQgaXMgZG91YmxlIGZyZWUgc29ja2V0IHRpbWVvdXQuXG5cdCAgICBpZiAob3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgLy8gbWFrZSBzdXJlIHNvY2tldCBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dCA+PSA4c1xuXHQgICAgICBvcHRpb25zLnRpbWVvdXQgPSBNYXRoLm1heChvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ICogMiwgODAwMCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIHN1cHBvcnQgaHVtYW5pemUgZm9ybWF0XG5cdCAgICBvcHRpb25zLnRpbWVvdXQgPSBtcyhvcHRpb25zLnRpbWVvdXQpO1xuXHQgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG1zKG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQpO1xuXHQgICAgb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPSBvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCA/IG1zKG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMKSA6IDA7XG5cblx0ICAgIHN1cGVyKG9wdGlvbnMpO1xuXG5cdCAgICB0aGlzW0NVUlJFTlRfSURdID0gMDtcblxuXHQgICAgLy8gY3JlYXRlIHNvY2tldCBzdWNjZXNzIGNvdW50ZXJcblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCA9IDA7XG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICB0aGlzLmNsb3NlU29ja2V0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgLy8gc29ja2V0IGVycm9yIGV2ZW50IGNvdW50XG5cdCAgICB0aGlzLmVycm9yU29ja2V0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgLy8gcmVxdWVzdCBmaW5pc2hlZCBjb3VudGVyXG5cdCAgICB0aGlzLnJlcXVlc3RDb3VudCA9IDA7XG5cdCAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIC8vIGluY2x1ZGluZyBmcmVlIHNvY2tldCB0aW1lb3V0IGNvdW50ZXJcblx0ICAgIHRoaXMudGltZW91dFNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgdGhpcy5vbignZnJlZScsIHNvY2tldCA9PiB7XG5cdCAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwXG5cdCAgICAgIC8vIE5vZGUuanMgbmF0aXZlIGFnZW50IHdpbGwgY2hlY2sgc29ja2V0IHRpbWVvdXQgZXFzIGFnZW50Lm9wdGlvbnMudGltZW91dC5cblx0ICAgICAgLy8gVXNlIHRoZSB0dGwgb3IgZnJlZVNvY2tldFRpbWVvdXQgdG8gb3ZlcndyaXRlLlxuXHQgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5jYWxjU29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgICBpZiAodGltZW91dCA+IDAgJiYgc29ja2V0LnRpbWVvdXQgIT09IHRpbWVvdXQpIHtcblx0ICAgICAgICBzb2NrZXQuc2V0VGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgZ2V0IGZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0KCkge1xuXHQgICAgZGVwcmVjYXRlKCdhZ2VudC5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dDtcblx0ICB9XG5cblx0ICBnZXQgdGltZW91dCgpIHtcblx0ICAgIGRlcHJlY2F0ZSgnYWdlbnQudGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMudGltZW91dCBpbnN0ZWFkJyk7XG5cdCAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG5cdCAgfVxuXG5cdCAgZ2V0IHNvY2tldEFjdGl2ZVRUTCgpIHtcblx0ICAgIGRlcHJlY2F0ZSgnYWdlbnQuc29ja2V0QWN0aXZlVFRMIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgaW5zdGVhZCcpO1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEw7XG5cdCAgfVxuXG5cdCAgY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KSB7XG5cdCAgICAvKipcblx0ICAgICAqIHJldHVybiA8PSAwOiBzaG91bGQgZnJlZSBzb2NrZXRcblx0ICAgICAqIHJldHVybiA+IDA6IHNob3VsZCB1cGRhdGUgc29ja2V0IHRpbWVvdXRcblx0ICAgICAqIHJldHVybiB1bmRlZmluZWQ6IG5vdCBmaW5kIGN1c3RvbSB0aW1lb3V0XG5cdCAgICAgKi9cblx0ICAgIGxldCBmcmVlU29ja2V0VGltZW91dCA9IHRoaXMub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dDtcblx0ICAgIGNvbnN0IHNvY2tldEFjdGl2ZVRUTCA9IHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEw7XG5cdCAgICBpZiAoc29ja2V0QWN0aXZlVFRMKSB7XG5cdCAgICAgIC8vIGNoZWNrIHNvY2tldEFjdGl2ZVRUTFxuXHQgICAgICBjb25zdCBhbGl2ZVRpbWUgPSBEYXRlLm5vdygpIC0gc29ja2V0W1NPQ0tFVF9DUkVBVEVEX1RJTUVdO1xuXHQgICAgICBjb25zdCBkaWZmID0gc29ja2V0QWN0aXZlVFRMIC0gYWxpdmVUaW1lO1xuXHQgICAgICBpZiAoZGlmZiA8PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIGRpZmY7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0ICYmIGRpZmYgPCBmcmVlU29ja2V0VGltZW91dCkge1xuXHQgICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0ID0gZGlmZjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gc2V0IGZyZWVTb2NrZXRUaW1lb3V0XG5cdCAgICBpZiAoZnJlZVNvY2tldFRpbWVvdXQpIHtcblx0ICAgICAgLy8gc2V0IGZyZWUga2VlcGFsaXZlIHRpbWVyXG5cdCAgICAgIC8vIHRyeSB0byB1c2Ugc29ja2V0IGN1c3RvbSBmcmVlU29ja2V0VGltZW91dCBmaXJzdCwgc3VwcG9ydCBoZWFkZXJzWydrZWVwLWFsaXZlJ11cblx0ICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtbW9kdWxlcy91cmxsaWIvYmxvYi9iNzYwNTMwMjA5MjNmNGQ5OWExYzkzY2YyZTE2ZTBjNWJhMTBiYWNmL2xpYi91cmxsaWIuanMjTDQ5OFxuXHQgICAgICBjb25zdCBjdXN0b21GcmVlU29ja2V0VGltZW91dCA9IHNvY2tldC5mcmVlU29ja2V0VGltZW91dCB8fCBzb2NrZXQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICAgIHJldHVybiBjdXN0b21GcmVlU29ja2V0VGltZW91dCB8fCBmcmVlU29ja2V0VGltZW91dDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBrZWVwU29ja2V0QWxpdmUoc29ja2V0KSB7XG5cdCAgICBjb25zdCByZXN1bHQgPSBzdXBlci5rZWVwU29ja2V0QWxpdmUoc29ja2V0KTtcblx0ICAgIC8vIHNob3VsZCBub3Qga2VlcEFsaXZlLCBkbyBub3RoaW5nXG5cdCAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblxuXHQgICAgY29uc3QgY3VzdG9tVGltZW91dCA9IHRoaXMuY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KTtcblx0ICAgIGlmICh0eXBlb2YgY3VzdG9tVGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoY3VzdG9tVGltZW91dCA8PSAwKSB7XG5cdCAgICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZnJlZSBidXQgbmVlZCB0byBkZXN0cm95IGJ5IFRUTCwgcmVxdWVzdCBjb3VudCAlcywgZGlmZiBpcyAlcycsXG5cdCAgICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSwgY3VzdG9tVGltZW91dCk7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmIChzb2NrZXQudGltZW91dCAhPT0gY3VzdG9tVGltZW91dCkge1xuXHQgICAgICBzb2NrZXQuc2V0VGltZW91dChjdXN0b21UaW1lb3V0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIC8vIG9ubHkgY2FsbCBvbiBhZGRSZXF1ZXN0XG5cdCAgcmV1c2VTb2NrZXQoLi4uYXJncykge1xuXHQgICAgLy8gcmV1c2VTb2NrZXQoc29ja2V0LCByZXEpXG5cdCAgICBzdXBlci5yZXVzZVNvY2tldCguLi5hcmdzKTtcblx0ICAgIGNvbnN0IHNvY2tldCA9IGFyZ3NbMF07XG5cdCAgICBjb25zdCByZXEgPSBhcmdzWzFdO1xuXHQgICAgcmVxLnJldXNlZFNvY2tldCA9IHRydWU7XG5cdCAgICBjb25zdCBhZ2VudFRpbWVvdXQgPSB0aGlzLm9wdGlvbnMudGltZW91dDtcblx0ICAgIGlmIChnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkgIT09IGFnZW50VGltZW91dCkge1xuXHQgICAgICAvLyByZXNldCB0aW1lb3V0IGJlZm9yZSB1c2Vcblx0ICAgICAgc29ja2V0LnNldFRpbWVvdXQoYWdlbnRUaW1lb3V0KTtcblx0ICAgICAgZGVidWcoJyVzIHJlc2V0IHRpbWVvdXQgdG8gJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGFnZW50VGltZW91dCk7XG5cdCAgICB9XG5cdCAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdKys7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHJldXNlIG9uIGFkZFJlcXVlc3QsIHRpbWVvdXQgJXNtcycsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG5cdCAgICAgIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSk7XG5cdCAgfVxuXG5cdCAgW0NSRUFURV9JRF0oKSB7XG5cdCAgICBjb25zdCBpZCA9IHRoaXNbQ1VSUkVOVF9JRF0rKztcblx0ICAgIGlmICh0aGlzW0NVUlJFTlRfSURdID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgdGhpc1tDVVJSRU5UX0lEXSA9IDA7XG5cdCAgICByZXR1cm4gaWQ7XG5cdCAgfVxuXG5cdCAgW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpIHtcblx0ICAgIC8vIGJ1Z2ZpeCBoZXJlLlxuXHQgICAgLy8gaHR0cHMgb24gbm9kZSA4LCAxMCB3b24ndCBzZXQgYWdlbnQub3B0aW9ucy50aW1lb3V0IGJ5IGRlZmF1bHRcblx0ICAgIC8vIFRPRE86IG5lZWQgdG8gZml4IG9uIG5vZGUgaXRzZWxmXG5cdCAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG5cdCAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG5cdCAgICAgIGlmICghdGltZW91dCkge1xuXHQgICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KG9wdGlvbnMudGltZW91dCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQWxpdmUpIHtcblx0ICAgICAgLy8gRGlzYWJsZSBOYWdsZSdzIGFsZ29yaXRobTogaHR0cDovL2Jsb2cuY2F1c3Rpay5jb20vMjAxMi8wNC8wOC9zY2FsaW5nLW5vZGUtanMtdG8tMTAway1jb25jdXJyZW50LWNvbm5lY3Rpb25zL1xuXHQgICAgICAvLyBodHRwczovL2ZlbmdtazIuY29tL2JlbmNobWFyay9uYWdsZS1hbGdvcml0aG0tZGVsYXllZC1hY2stbW9jay5odG1sXG5cdCAgICAgIHNvY2tldC5zZXROb0RlbGF5KHRydWUpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudCsrO1xuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwpIHtcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9DUkVBVEVEX1RJTUVdID0gRGF0ZS5ub3coKTtcblx0ICAgIH1cblx0ICAgIC8vIGRvbid0IHNob3cgdGhlIGhvbGUgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tJyBrZXkgc3RyaW5nXG5cdCAgICBzb2NrZXRbU09DS0VUX05BTUVdID0gYHNvY2tbJHt0aGlzW0NSRUFURV9JRF0oKX0jJHtvcHRpb25zLl9hZ2VudEtleX1dYC5zcGxpdCgnLS0tLS1CRUdJTicsIDEpWzBdO1xuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSA9IDE7XG5cdCAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdID0gMDtcblx0ICAgIGluc3RhbGxMaXN0ZW5lcnModGhpcywgc29ja2V0LCBvcHRpb25zKTtcblx0ICB9XG5cblx0ICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG5cdCAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cdCAgICBjb25zdCBvbk5ld0NyZWF0ZSA9IChlcnIsIHNvY2tldCkgPT4ge1xuXHQgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG5cdCAgICAgIGNhbGxlZCA9IHRydWU7XG5cblx0ICAgICAgaWYgKGVycikge1xuXHQgICAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCsrO1xuXHQgICAgICAgIHJldHVybiBvbmNyZWF0ZShlcnIpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXNbSU5JVF9TT0NLRVRdKHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgICAgIG9uY3JlYXRlKGVyciwgc29ja2V0KTtcblx0ICAgIH07XG5cblx0ICAgIGNvbnN0IG5ld1NvY2tldCA9IHN1cGVyLmNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25OZXdDcmVhdGUpO1xuXHQgICAgaWYgKG5ld1NvY2tldCkgb25OZXdDcmVhdGUobnVsbCwgbmV3U29ja2V0KTtcblx0ICAgIHJldHVybiBuZXdTb2NrZXQ7XG5cdCAgfVxuXG5cdCAgZ2V0IHN0YXR1c0NoYW5nZWQoKSB7XG5cdCAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudCAhPT0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLmNsb3NlU29ja2V0Q291bnQgIT09IHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLmVycm9yU29ja2V0Q291bnQgIT09IHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCAhPT0gdGhpcy50aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5yZXF1ZXN0Q291bnQgIT09IHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrO1xuXHQgICAgaWYgKGNoYW5nZWQpIHtcblx0ICAgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQ7XG5cdCAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayA9IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudDtcblx0ICAgICAgdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5jbG9zZVNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmVycm9yU29ja2V0Q291bnQ7XG5cdCAgICAgIHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy50aW1lb3V0U29ja2V0Q291bnQ7XG5cdCAgICAgIHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrID0gdGhpcy5yZXF1ZXN0Q291bnQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY2hhbmdlZDtcblx0ICB9XG5cblx0ICBnZXRDdXJyZW50U3RhdHVzKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgY3JlYXRlU29ja2V0Q291bnQ6IHRoaXMuY3JlYXRlU29ja2V0Q291bnQsXG5cdCAgICAgIGNyZWF0ZVNvY2tldEVycm9yQ291bnQ6IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCxcblx0ICAgICAgY2xvc2VTb2NrZXRDb3VudDogdGhpcy5jbG9zZVNvY2tldENvdW50LFxuXHQgICAgICBlcnJvclNvY2tldENvdW50OiB0aGlzLmVycm9yU29ja2V0Q291bnQsXG5cdCAgICAgIHRpbWVvdXRTb2NrZXRDb3VudDogdGhpcy50aW1lb3V0U29ja2V0Q291bnQsXG5cdCAgICAgIHJlcXVlc3RDb3VudDogdGhpcy5yZXF1ZXN0Q291bnQsXG5cdCAgICAgIGZyZWVTb2NrZXRzOiBpbnNwZWN0KHRoaXMuZnJlZVNvY2tldHMpLFxuXHQgICAgICBzb2NrZXRzOiBpbnNwZWN0KHRoaXMuc29ja2V0cyksXG5cdCAgICAgIHJlcXVlc3RzOiBpbnNwZWN0KHRoaXMucmVxdWVzdHMpLFxuXHQgICAgfTtcblx0ICB9XG5cdH1cblxuXHQvLyBub2RlIDggZG9uJ3QgaGFzIHRpbWVvdXQgYXR0cmlidXRlIG9uIHNvY2tldFxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8yMTIwNC9maWxlcyNkaWZmLWU2ZWYwMjRjMzc3NWQ3ODdjMzg0ODdhNjMwOWU0OTFkUjQwOFxuXHRmdW5jdGlvbiBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkge1xuXHQgIHJldHVybiBzb2NrZXQudGltZW91dCB8fCBzb2NrZXQuX2lkbGVUaW1lb3V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zdGFsbExpc3RlbmVycyhhZ2VudCwgc29ja2V0LCBvcHRpb25zKSB7XG5cdCAgZGVidWcoJyVzIGNyZWF0ZSwgdGltZW91dCAlc21zJywgc29ja2V0W1NPQ0tFVF9OQU1FXSwgZ2V0U29ja2V0VGltZW91dChzb2NrZXQpKTtcblxuXHQgIC8vIGxpc3RlbmVyIHNvY2tldCBldmVudHM6IGNsb3NlLCB0aW1lb3V0LCBlcnJvciwgZnJlZVxuXHQgIGZ1bmN0aW9uIG9uRnJlZSgpIHtcblx0ICAgIC8vIGNyZWF0ZSBhbmQgc29ja2V0LmVtaXQoJ2ZyZWUnKSBsb2dpY1xuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9faHR0cF9hZ2VudC5qcyNMMzExXG5cdCAgICAvLyBubyByZXEgb24gdGhlIHNvY2tldCwgaXQgc2hvdWxkIGJlIHRoZSBuZXcgc29ja2V0XG5cdCAgICBpZiAoIXNvY2tldC5faHR0cE1lc3NhZ2UgJiYgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSA9PT0gMSkgcmV0dXJuO1xuXG5cdCAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKys7XG5cdCAgICBhZ2VudC5yZXF1ZXN0Q291bnQrKztcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZnJlZScsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuXG5cdCAgICAvLyBzaG91bGQgcmV1c2Ugb24gcGVkZGluZyByZXF1ZXN0cz9cblx0ICAgIGNvbnN0IG5hbWUgPSBhZ2VudC5nZXROYW1lKG9wdGlvbnMpO1xuXHQgICAgaWYgKHNvY2tldC53cml0YWJsZSAmJiBhZ2VudC5yZXF1ZXN0c1tuYW1lXSAmJiBhZ2VudC5yZXF1ZXN0c1tuYW1lXS5sZW5ndGgpIHtcblx0ICAgICAgLy8gd2lsbCBiZSByZXVzZSBvbiBhZ2VudCBmcmVlIGxpc3RlbmVyXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0rKztcblx0ICAgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSB3aWxsIGJlIHJldXNlIG9uIGFnZW50IGZyZWUgZXZlbnQnLFxuXHQgICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuXHQgICAgfVxuXHQgIH1cblx0ICBzb2NrZXQub24oJ2ZyZWUnLCBvbkZyZWUpO1xuXG5cdCAgZnVuY3Rpb24gb25DbG9zZShpc0Vycm9yKSB7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGNsb3NlLCBpc0Vycm9yOiAlcycsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGlzRXJyb3IpO1xuXHQgICAgYWdlbnQuY2xvc2VTb2NrZXRDb3VudCsrO1xuXHQgIH1cblx0ICBzb2NrZXQub24oJ2Nsb3NlJywgb25DbG9zZSk7XG5cblx0ICAvLyBzdGFydCBzb2NrZXQgdGltZW91dCBoYW5kbGVyXG5cdCAgZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuXHQgICAgLy8gb25UaW1lb3V0IGFuZCBlbWl0UmVxdWVzdFRpbWVvdXQoX2h0dHBfY2xpZW50LmpzKVxuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEyLngvbGliL19odHRwX2NsaWVudC5qcyNMNzExXG5cdCAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gc29ja2V0Lmxpc3RlbmVycygndGltZW91dCcpLmxlbmd0aDtcblx0ICAgIC8vIG5vZGUgPD0gMTAsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAxLCBvblRpbWVvdXRcblx0ICAgIC8vIDExIDwgbm9kZSA8PSAxMiwgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDIsIG9uVGltZW91dCBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0XG5cdCAgICAvLyBub2RlID49IDEzLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMywgb25UaW1lb3V0LFxuXHQgICAgLy8gICBvblRpbWVvdXQoaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzIwMDAvZmlsZXMjZGlmZi01ZjdmYjA4NTA0MTJjNmJlMTg5ZmFlZGRlYTZjNTM1OVIzMzMpXG5cdCAgICAvLyAgIGFuZCBlbWl0UmVxdWVzdFRpbWVvdXRcblx0ICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG5cdCAgICBjb25zdCByZXEgPSBzb2NrZXQuX2h0dHBNZXNzYWdlO1xuXHQgICAgY29uc3QgcmVxVGltZW91dExpc3RlbmVyQ291bnQgPSByZXEgJiYgcmVxLmxpc3RlbmVycygndGltZW91dCcpLmxlbmd0aCB8fCAwO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSB0aW1lb3V0IGFmdGVyICVzbXMsIGxpc3RlbmVycyAlcywgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ICVzLCBoYXNIdHRwUmVxdWVzdCAlcywgSHR0cFJlcXVlc3QgdGltZW91dExpc3RlbmVyQ291bnQgJXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuXHQgICAgICB0aW1lb3V0LCBsaXN0ZW5lckNvdW50LCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQsICEhcmVxLCByZXFUaW1lb3V0TGlzdGVuZXJDb3VudCk7XG5cdCAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuXHQgICAgICBkZWJ1ZygndGltZW91dCBsaXN0ZW5lcnM6ICVzJywgc29ja2V0Lmxpc3RlbmVycygndGltZW91dCcpLm1hcChmID0+IGYubmFtZSkuam9pbignLCAnKSk7XG5cdCAgICB9XG5cdCAgICBhZ2VudC50aW1lb3V0U29ja2V0Q291bnQrKztcblx0ICAgIGNvbnN0IG5hbWUgPSBhZ2VudC5nZXROYW1lKG9wdGlvbnMpO1xuXHQgICAgaWYgKGFnZW50LmZyZWVTb2NrZXRzW25hbWVdICYmIGFnZW50LmZyZWVTb2NrZXRzW25hbWVdLmluZGV4T2Yoc29ja2V0KSAhPT0gLTEpIHtcblx0ICAgICAgLy8gZnJlZSBzb2NrZXQgdGltZW91dCwgZGVzdHJveSBxdWlldGx5XG5cdCAgICAgIHNvY2tldC5kZXN0cm95KCk7XG5cdCAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIGZyZWVTb2NrZXRzIGxpc3QgaW1tZWRpYXRlbHkgdG8gcHJldmVudCBuZXcgcmVxdWVzdHNcblx0ICAgICAgLy8gZnJvbSBiZWluZyBzZW50IHRocm91Z2ggdGhpcyBzb2NrZXQuXG5cdCAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgICBkZWJ1ZygnJXMgaXMgZnJlZSwgZGVzdHJveSBxdWlldGx5Jywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBpZiB0aGVyZSBpcyBubyBhbnkgcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGVyLFxuXHQgICAgICAvLyBhZ2VudCBuZWVkIHRvIGhhbmRsZSBzb2NrZXQgdGltZW91dCBpdHNlbGYuXG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIGN1c3RvbSByZXF1ZXN0IHNvY2tldCB0aW1lb3V0IGhhbmRsZSBsb2dpYyBtdXN0IGZvbGxvdyB0aGVzZSBydWxlczpcblx0ICAgICAgLy8gIDEuIERlc3Ryb3kgc29ja2V0IGZpcnN0XG5cdCAgICAgIC8vICAyLiBNdXN0IGVtaXQgc29ja2V0ICdhZ2VudFJlbW92ZScgZXZlbnQgdGVsbCBhZ2VudCByZW1vdmUgc29ja2V0XG5cdCAgICAgIC8vICAgICBmcm9tIGZyZWVTb2NrZXRzIGxpc3QgaW1tZWRpYXRlbHkuXG5cdCAgICAgIC8vICAgICBPdGhlcmlzZSB5b3UgbWF5IGJlIGdldCAnc29ja2V0IGhhbmcgdXAnIGVycm9yIHdoZW4gcmV1c2Vcblx0ICAgICAgLy8gICAgIGZyZWUgc29ja2V0IGFuZCB0aW1lb3V0IGhhcHBlbiBpbiB0aGUgc2FtZSB0aW1lLlxuXHQgICAgICBpZiAocmVxVGltZW91dExpc3RlbmVyQ291bnQgPT09IDApIHtcblx0ICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignU29ja2V0IHRpbWVvdXQnKTtcblx0ICAgICAgICBlcnJvci5jb2RlID0gJ0VSUl9TT0NLRVRfVElNRU9VVCc7XG5cdCAgICAgICAgZXJyb3IudGltZW91dCA9IHRpbWVvdXQ7XG5cdCAgICAgICAgLy8gbXVzdCBtYW51YWxseSBjYWxsIHNvY2tldC5lbmQoKSBvciBzb2NrZXQuZGVzdHJveSgpIHRvIGVuZCB0aGUgY29ubmVjdGlvbi5cblx0ICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9zZXR0aW1lb3V0X3RpbWVvdXRfY2FsbGJhY2tcblx0ICAgICAgICBzb2NrZXQuZGVzdHJveShlcnJvcik7XG5cdCAgICAgICAgYWdlbnQucmVtb3ZlU29ja2V0KHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgICAgICAgZGVidWcoJyVzIGRlc3Ryb3kgd2l0aCB0aW1lb3V0IGVycm9yJywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgc29ja2V0Lm9uKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcblxuXHQgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG5cdCAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gc29ja2V0Lmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGg7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGVycm9yOiAlcywgbGlzdGVuZXJDb3VudDogJXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuXHQgICAgICBlcnIsIGxpc3RlbmVyQ291bnQpO1xuXHQgICAgYWdlbnQuZXJyb3JTb2NrZXRDb3VudCsrO1xuXHQgICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcblx0ICAgICAgLy8gaWYgc29ja2V0IGRvbid0IGNvbnRhaW4gZXJyb3IgZXZlbnQgaGFuZGxlciwgZG9uJ3QgY2F0Y2ggaXQsIGVtaXQgaXQgYWdhaW5cblx0ICAgICAgZGVidWcoJyVzIGVtaXQgdW5jYXVnaHQgZXJyb3IgZXZlbnQnLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcblx0ICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuXHQgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBzb2NrZXQub24oJ2Vycm9yJywgb25FcnJvcik7XG5cblx0ICBmdW5jdGlvbiBvblJlbW92ZSgpIHtcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgYWdlbnRSZW1vdmUnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblx0ICAgIC8vIFdlIG5lZWQgdGhpcyBmdW5jdGlvbiBmb3IgY2FzZXMgbGlrZSBIVFRQICd1cGdyYWRlJ1xuXHQgICAgLy8gKGRlZmluZWQgYnkgV2ViU29ja2V0cykgd2hlcmUgd2UgbmVlZCB0byByZW1vdmUgYSBzb2NrZXQgZnJvbSB0aGVcblx0ICAgIC8vIHBvb2wgYmVjYXVzZSBpdCdsbCBiZSBsb2NrZWQgdXAgaW5kZWZpbml0ZWx5XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSk7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2ZyZWUnLCBvbkZyZWUpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcblx0ICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG5cdCAgfVxuXHQgIHNvY2tldC5vbignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG5cdH1cblxuXHRhZ2VudCA9IEFnZW50O1xuXG5cdGZ1bmN0aW9uIGluc3BlY3Qob2JqKSB7XG5cdCAgY29uc3QgcmVzID0ge307XG5cdCAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG5cdCAgICByZXNba2V5XSA9IG9ialtrZXldLmxlbmd0aDtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHRyZXR1cm4gYWdlbnQ7XG59XG5cbnZhciBodHRwc19hZ2VudDtcbnZhciBoYXNSZXF1aXJlZEh0dHBzX2FnZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlSHR0cHNfYWdlbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRIdHRwc19hZ2VudCkgcmV0dXJuIGh0dHBzX2FnZW50O1xuXHRoYXNSZXF1aXJlZEh0dHBzX2FnZW50ID0gMTtcblxuXHRjb25zdCBPcmlnaW5hbEh0dHBzQWdlbnQgPSByZXF1aXJlJCQwJDIuQWdlbnQ7XG5cdGNvbnN0IEh0dHBBZ2VudCA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUFnZW50KCk7XG5cdGNvbnN0IHtcblx0ICBJTklUX1NPQ0tFVCxcblx0ICBDUkVBVEVfSFRUUFNfQ09OTkVDVElPTixcblx0fSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUNvbnN0YW50cygpO1xuXG5cdGNsYXNzIEh0dHBzQWdlbnQgZXh0ZW5kcyBIdHRwQWdlbnQge1xuXHQgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0ICAgIHN1cGVyKG9wdGlvbnMpO1xuXG5cdCAgICB0aGlzLmRlZmF1bHRQb3J0ID0gNDQzO1xuXHQgICAgdGhpcy5wcm90b2NvbCA9ICdodHRwczonO1xuXHQgICAgdGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9IHRoaXMub3B0aW9ucy5tYXhDYWNoZWRTZXNzaW9ucztcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgICBpZiAodGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPSAxMDA7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3Nlc3Npb25DYWNoZSA9IHtcblx0ICAgICAgbWFwOiB7fSxcblx0ICAgICAgbGlzdDogW10sXG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25jcmVhdGUpIHtcblx0ICAgIGNvbnN0IHNvY2tldCA9IHRoaXNbQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT05dKG9wdGlvbnMsIG9uY3JlYXRlKTtcblx0ICAgIHRoaXNbSU5JVF9TT0NLRVRdKHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgICByZXR1cm4gc29ja2V0O1xuXHQgIH1cblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaHR0cHMuanMjTDg5XG5cdEh0dHBzQWdlbnQucHJvdG90eXBlW0NSRUFURV9IVFRQU19DT05ORUNUSU9OXSA9IE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbjtcblxuXHRbXG5cdCAgJ2dldE5hbWUnLFxuXHQgICdfZ2V0U2Vzc2lvbicsXG5cdCAgJ19jYWNoZVNlc3Npb24nLFxuXHQgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzQ5ODJcblx0ICAnX2V2aWN0U2Vzc2lvbicsXG5cdF0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgIGlmICh0eXBlb2YgT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdID0gT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdO1xuXHQgIH1cblx0fSk7XG5cblx0aHR0cHNfYWdlbnQgPSBIdHRwc0FnZW50O1xuXHRyZXR1cm4gaHR0cHNfYWdlbnQ7XG59XG5cbnZhciBoYXNSZXF1aXJlZEFnZW50a2VlcGFsaXZlO1xuXG5mdW5jdGlvbiByZXF1aXJlQWdlbnRrZWVwYWxpdmUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZSkgcmV0dXJuIGFnZW50a2VlcGFsaXZlLmV4cG9ydHM7XG5cdGhhc1JlcXVpcmVkQWdlbnRrZWVwYWxpdmUgPSAxO1xuXG5cdGFnZW50a2VlcGFsaXZlLmV4cG9ydHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVBZ2VudCgpO1xuXHRhZ2VudGtlZXBhbGl2ZS5leHBvcnRzLkh0dHBzQWdlbnQgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVIdHRwc19hZ2VudCgpO1xuXHRhZ2VudGtlZXBhbGl2ZS5leHBvcnRzLmNvbnN0YW50cyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUNvbnN0YW50cygpO1xuXHRyZXR1cm4gYWdlbnRrZWVwYWxpdmUuZXhwb3J0cztcbn1cblxudmFyIGFnZW50a2VlcGFsaXZlRXhwb3J0cyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUFnZW50a2VlcGFsaXZlKCk7XG52YXIgSHR0cEtlZXBBbGl2ZUFnZW50ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGFnZW50a2VlcGFsaXZlRXhwb3J0cyk7XG5cbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5JDE7XG52YXIgaGFzUmVxdWlyZWRGYXN0U3RhYmxlU3RyaW5naWZ5O1xuXG5mdW5jdGlvbiByZXF1aXJlRmFzdFN0YWJsZVN0cmluZ2lmeSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEZhc3RTdGFibGVTdHJpbmdpZnkpIHJldHVybiBmYXN0U3RhYmxlU3RyaW5naWZ5JDE7XG5cdGhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeSA9IDE7XG5cdHZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHR2YXIga2V5cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdFx0a2V5cy5wdXNoKG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGtleXM7XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBzdHJpbmdpZnkodmFsLCBpc0FycmF5UHJvcCkge1xuXHRcdHZhciBpLCBtYXgsIHN0ciwga2V5cywga2V5LCBwcm9wVmFsLCB0b1N0cjtcblx0XHRpZiAodmFsID09PSB0cnVlKSB7XG5cdFx0XHRyZXR1cm4gXCJ0cnVlXCI7XG5cdFx0fVxuXHRcdGlmICh2YWwgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm4gXCJmYWxzZVwiO1xuXHRcdH1cblx0XHRzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcblx0XHRcdGNhc2UgXCJvYmplY3RcIjpcblx0XHRcdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbC50b0pTT04gJiYgdHlwZW9mIHZhbC50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkodmFsLnRvSlNPTigpLCBpc0FycmF5UHJvcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG9TdHIgPSBvYmpUb1N0cmluZy5jYWxsKHZhbCk7XG5cdFx0XHRcdFx0aWYgKHRvU3RyID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdFx0XHRcdHN0ciA9ICdbJztcblx0XHRcdFx0XHRcdG1heCA9IHZhbC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcblx0XHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpICsgJywnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG1heCA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBzdHIgKyAnXSc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0XHRcdFx0Ly8gb25seSBvYmplY3QgaXMgbGVmdFxuXHRcdFx0XHRcdFx0a2V5cyA9IG9iaktleXModmFsKS5zb3J0KCk7XG5cdFx0XHRcdFx0XHRtYXggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHN0ciA9IFwiXCI7XG5cdFx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbWF4KSB7XG5cdFx0XHRcdFx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0XHRcdHByb3BWYWwgPSBzdHJpbmdpZnkodmFsW2tleV0sIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0aWYgKHByb3BWYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChzdHIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0ciArPSAnLCc7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzonICsgcHJvcFZhbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ3snICsgc3RyICsgJ30nO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgXCJmdW5jdGlvblwiOlxuXHRcdFx0Y2FzZSBcInVuZGVmaW5lZFwiOlxuXHRcdFx0XHRyZXR1cm4gaXNBcnJheVByb3AgPyBudWxsIDogdW5kZWZpbmVkO1xuXHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBpc0Zpbml0ZSh2YWwpID8gdmFsIDogbnVsbDtcblx0XHR9XG5cdH1cblxuXHRmYXN0U3RhYmxlU3RyaW5naWZ5JDEgPSBmdW5jdGlvbih2YWwpIHtcblx0XHR2YXIgcmV0dXJuVmFsID0gc3RyaW5naWZ5KHZhbCwgZmFsc2UpO1xuXHRcdGlmIChyZXR1cm5WYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICcnKyByZXR1cm5WYWw7XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gZmFzdFN0YWJsZVN0cmluZ2lmeSQxO1xufVxuXG52YXIgZmFzdFN0YWJsZVN0cmluZ2lmeUV4cG9ydHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVGYXN0U3RhYmxlU3RyaW5naWZ5KCk7XG52YXIgZmFzdFN0YWJsZVN0cmluZ2lmeSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmYXN0U3RhYmxlU3RyaW5naWZ5RXhwb3J0cyk7XG5cbmNvbnN0IE1JTklNVU1fU0xPVF9QRVJfRVBPQ0ggPSAzMjtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIGluIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2Ygc2VsZi5cbmZ1bmN0aW9uIHRyYWlsaW5nWmVyb3Mobikge1xuICBsZXQgdHJhaWxpbmdaZXJvcyA9IDA7XG4gIHdoaWxlIChuID4gMSkge1xuICAgIG4gLz0gMjtcbiAgICB0cmFpbGluZ1plcm9zKys7XG4gIH1cbiAgcmV0dXJuIHRyYWlsaW5nWmVyb3M7XG59XG5cbi8vIFJldHVybnMgdGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gblxuZnVuY3Rpb24gbmV4dFBvd2VyT2ZUd28obikge1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIDE7XG4gIG4tLTtcbiAgbiB8PSBuID4+IDE7XG4gIG4gfD0gbiA+PiAyO1xuICBuIHw9IG4gPj4gNDtcbiAgbiB8PSBuID4+IDg7XG4gIG4gfD0gbiA+PiAxNjtcbiAgbiB8PSBuID4+IDMyO1xuICByZXR1cm4gbiArIDE7XG59XG5cbi8qKlxuICogRXBvY2ggc2NoZWR1bGVcbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vdGVybWlub2xvZ3kjZXBvY2gpXG4gKiBDYW4gYmUgcmV0cmlldmVkIHdpdGggdGhlIHtAbGluayBDb25uZWN0aW9uLmdldEVwb2NoU2NoZWR1bGV9IG1ldGhvZFxuICovXG5jbGFzcyBFcG9jaFNjaGVkdWxlIHtcbiAgY29uc3RydWN0b3Ioc2xvdHNQZXJFcG9jaCwgbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0LCB3YXJtdXAsIGZpcnN0Tm9ybWFsRXBvY2gsIGZpcnN0Tm9ybWFsU2xvdCkge1xuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2xvdHMgaW4gZWFjaCBlcG9jaCAqL1xuICAgIHRoaXMuc2xvdHNQZXJFcG9jaCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIG51bWJlciBvZiBzbG90cyBiZWZvcmUgYmVnaW5uaW5nIG9mIGFuIGVwb2NoIHRvIGNhbGN1bGF0ZSBhIGxlYWRlciBzY2hlZHVsZSBmb3IgdGhhdCBlcG9jaCAqL1xuICAgIHRoaXMubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0ID0gdm9pZCAwO1xuICAgIC8qKiBJbmRpY2F0ZXMgd2hldGhlciBlcG9jaHMgc3RhcnQgc2hvcnQgYW5kIGdyb3cgKi9cbiAgICB0aGlzLndhcm11cCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGZpcnN0IGVwb2NoIHdpdGggYHNsb3RzUGVyRXBvY2hgIHNsb3RzICovXG4gICAgdGhpcy5maXJzdE5vcm1hbEVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZmlyc3Qgc2xvdCBvZiBgZmlyc3ROb3JtYWxFcG9jaGAgKi9cbiAgICB0aGlzLmZpcnN0Tm9ybWFsU2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnNsb3RzUGVyRXBvY2ggPSBzbG90c1BlckVwb2NoO1xuICAgIHRoaXMubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0ID0gbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0O1xuICAgIHRoaXMud2FybXVwID0gd2FybXVwO1xuICAgIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCA9IGZpcnN0Tm9ybWFsRXBvY2g7XG4gICAgdGhpcy5maXJzdE5vcm1hbFNsb3QgPSBmaXJzdE5vcm1hbFNsb3Q7XG4gIH1cbiAgZ2V0RXBvY2goc2xvdCkge1xuICAgIHJldHVybiB0aGlzLmdldEVwb2NoQW5kU2xvdEluZGV4KHNsb3QpWzBdO1xuICB9XG4gIGdldEVwb2NoQW5kU2xvdEluZGV4KHNsb3QpIHtcbiAgICBpZiAoc2xvdCA8IHRoaXMuZmlyc3ROb3JtYWxTbG90KSB7XG4gICAgICBjb25zdCBlcG9jaCA9IHRyYWlsaW5nWmVyb3MobmV4dFBvd2VyT2ZUd28oc2xvdCArIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0ggKyAxKSkgLSB0cmFpbGluZ1plcm9zKE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpIC0gMTtcbiAgICAgIGNvbnN0IGVwb2NoTGVuID0gdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpO1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gc2xvdCAtIChlcG9jaExlbiAtIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpO1xuICAgICAgcmV0dXJuIFtlcG9jaCwgc2xvdEluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9ybWFsU2xvdEluZGV4ID0gc2xvdCAtIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgICAgY29uc3Qgbm9ybWFsRXBvY2hJbmRleCA9IE1hdGguZmxvb3Iobm9ybWFsU2xvdEluZGV4IC8gdGhpcy5zbG90c1BlckVwb2NoKTtcbiAgICAgIGNvbnN0IGVwb2NoID0gdGhpcy5maXJzdE5vcm1hbEVwb2NoICsgbm9ybWFsRXBvY2hJbmRleDtcbiAgICAgIGNvbnN0IHNsb3RJbmRleCA9IG5vcm1hbFNsb3RJbmRleCAlIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgfVxuICB9XG4gIGdldEZpcnN0U2xvdEluRXBvY2goZXBvY2gpIHtcbiAgICBpZiAoZXBvY2ggPD0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICByZXR1cm4gKE1hdGgucG93KDIsIGVwb2NoKSAtIDEpICogTUlOSU1VTV9TTE9UX1BFUl9FUE9DSDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChlcG9jaCAtIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkgKiB0aGlzLnNsb3RzUGVyRXBvY2ggKyB0aGlzLmZpcnN0Tm9ybWFsU2xvdDtcbiAgICB9XG4gIH1cbiAgZ2V0TGFzdFNsb3RJbkVwb2NoKGVwb2NoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaCkgKyB0aGlzLmdldFNsb3RzSW5FcG9jaChlcG9jaCkgLSAxO1xuICB9XG4gIGdldFNsb3RzSW5FcG9jaChlcG9jaCkge1xuICAgIGlmIChlcG9jaCA8IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIGVwb2NoICsgdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNsb3RzUGVyRXBvY2g7XG4gICAgfVxuICB9XG59XG5cbnZhciBmZXRjaEltcGwgPSB0eXBlb2YgZ2xvYmFsVGhpcy5mZXRjaCA9PT0gJ2Z1bmN0aW9uJyA/XG4vLyBUaGUgRmV0Y2ggQVBJIGlzIHN1cHBvcnRlZCBleHBlcmltZW50YWxseSBpbiBOb2RlIDE3LjUrIGFuZCBuYXRpdmVseSBpbiBOb2RlIDE4Ky5cbmdsb2JhbFRoaXMuZmV0Y2ggOlxuLy8gT3RoZXJ3aXNlIHVzZSB0aGUgcG9seWZpbGwuXG5hc3luYyBmdW5jdGlvbiAoaW5wdXQsIGluaXQpIHtcbiAgY29uc3QgcHJvY2Vzc2VkSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIGlucHV0LnNsaWNlKDAsIDIpID09PSAnLy8nID8gJ2h0dHBzOicgKyBpbnB1dCA6IGlucHV0O1xuICByZXR1cm4gYXdhaXQgbm9kZUZldGNoLmRlZmF1bHQocHJvY2Vzc2VkSW5wdXQsIGluaXQpO1xufTtcblxuY2xhc3MgUnBjV2ViU29ja2V0Q2xpZW50IGV4dGVuZHMgQ29tbW9uQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoYWRkcmVzcywgb3B0aW9ucywgZ2VuZXJhdGVfcmVxdWVzdF9pZCkge1xuICAgIGNvbnN0IHdlYlNvY2tldEZhY3RvcnkgPSB1cmwgPT4ge1xuICAgICAgY29uc3QgcnBjID0gV2ViU29ja2V0KHVybCwge1xuICAgICAgICBhdXRvY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgbWF4X3JlY29ubmVjdHM6IDUsXG4gICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgcmVjb25uZWN0X2ludGVydmFsOiAxMDAwLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICAgIGlmICgnc29ja2V0JyBpbiBycGMpIHtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjLnNvY2tldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHJwYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBycGM7XG4gICAgfTtcbiAgICBzdXBlcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzLCBvcHRpb25zLCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKTtcbiAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSB2b2lkIDA7XG4gIH1cbiAgY2FsbCguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMudW5kZXJseWluZ1NvY2tldD8ucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gMSAvKiBXZWJTb2NrZXQuT1BFTiAqLykge1xuICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIGNhbGwgYSBKU09OLVJQQyBtZXRob2QgYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gIH1cbiAgbm90aWZ5KC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIubm90aWZ5KC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUcmllZCB0byBzZW5kIGEgSlNPTi1SUEMgbm90aWZpY2F0aW9uIGAnICsgYXJnc1swXSArICdgIGJ1dCB0aGUgc29ja2V0IHdhcyBub3QgYENPTk5FQ1RJTkdgIG9yIGBPUEVOYCAoYHJlYWR5U3RhdGVgIHdhcyAnICsgcmVhZHlTdGF0ZSArICcpJykpO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBEZWNvZGUgYWNjb3VudCBkYXRhIGJ1ZmZlciB1c2luZyBhbiBBY2NvdW50VHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlY29kZURhdGEodHlwZSwgZGF0YSkge1xuICBsZXQgZGVjb2RlZDtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkID0gdHlwZS5sYXlvdXQuZGVjb2RlKGRhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG4gIGlmIChkZWNvZGVkLnR5cGVJbmRleCAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhY2NvdW50IGRhdGE7IGFjY291bnQgdHlwZSBtaXNtYXRjaCAke2RlY29kZWQudHlwZUluZGV4fSAhPSAke3R5cGUuaW5kZXh9YCk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8vLyBUaGUgc2VyaWFsaXplZCBzaXplIG9mIGxvb2t1cCB0YWJsZSBtZXRhZGF0YVxuY29uc3QgTE9PS1VQX1RBQkxFX01FVEFfU0laRSA9IDU2O1xuY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gYXJncy5rZXk7XG4gICAgdGhpcy5zdGF0ZSA9IGFyZ3Muc3RhdGU7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgY29uc3QgVTY0X01BWCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJyk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZGVhY3RpdmF0aW9uU2xvdCA9PT0gVTY0X01BWDtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoYWNjb3VudERhdGEpIHtcbiAgICBjb25zdCBtZXRhID0gZGVjb2RlRGF0YShMb29rdXBUYWJsZU1ldGFMYXlvdXQsIGFjY291bnREYXRhKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc2VzTGVuID0gYWNjb3VudERhdGEubGVuZ3RoIC0gTE9PS1VQX1RBQkxFX01FVEFfU0laRTtcbiAgICBhc3NlcnQoc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiA+PSAwLCAnbG9va3VwIHRhYmxlIGlzIGludmFsaWQnKTtcbiAgICBhc3NlcnQoc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiAlIDMyID09PSAwLCAnbG9va3VwIHRhYmxlIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBudW1TZXJpYWxpemVkQWRkcmVzc2VzID0gc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiAvIDMyO1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3Nlc1xuICAgIH0gPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCBudW1TZXJpYWxpemVkQWRkcmVzc2VzLCAnYWRkcmVzc2VzJyldKS5kZWNvZGUoYWNjb3VudERhdGEuc2xpY2UoTE9PS1VQX1RBQkxFX01FVEFfU0laRSkpO1xuICAgIHJldHVybiB7XG4gICAgICBkZWFjdGl2YXRpb25TbG90OiBtZXRhLmRlYWN0aXZhdGlvblNsb3QsXG4gICAgICBsYXN0RXh0ZW5kZWRTbG90OiBtZXRhLmxhc3RFeHRlbmRlZFNsb3QsXG4gICAgICBsYXN0RXh0ZW5kZWRTbG90U3RhcnRJbmRleDogbWV0YS5sYXN0RXh0ZW5kZWRTdGFydEluZGV4LFxuICAgICAgYXV0aG9yaXR5OiBtZXRhLmF1dGhvcml0eS5sZW5ndGggIT09IDAgPyBuZXcgUHVibGljS2V5KG1ldGEuYXV0aG9yaXR5WzBdKSA6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpXG4gICAgfTtcbiAgfVxufVxuY29uc3QgTG9va3VwVGFibGVNZXRhTGF5b3V0ID0ge1xuICBpbmRleDogMSxcbiAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd0eXBlSW5kZXgnKSwgdTY0KCdkZWFjdGl2YXRpb25TbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCdsYXN0RXh0ZW5kZWRTbG90JyksIEJ1ZmZlckxheW91dC51OCgnbGFzdEV4dGVuZGVkU3RhcnRJbmRleCcpLCBCdWZmZXJMYXlvdXQudTgoKSxcbiAgLy8gb3B0aW9uXG4gIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnU4KCksIC0xKSwgJ2F1dGhvcml0eScpXSlcbn07XG5cbmNvbnN0IFVSTF9SRSA9IC9eW146XSs6XFwvXFwvKFteOltdK3xcXFtbXlxcXV0rXFxdKSg6XFxkKyk/KC4qKS9pO1xuZnVuY3Rpb24gbWFrZVdlYnNvY2tldFVybChlbmRwb2ludCkge1xuICBjb25zdCBtYXRjaGVzID0gZW5kcG9pbnQubWF0Y2goVVJMX1JFKTtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihgRmFpbGVkIHRvIHZhbGlkYXRlIGVuZHBvaW50IFVSTCBcXGAke2VuZHBvaW50fVxcYGApO1xuICB9XG4gIGNvbnN0IFtfLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBob3N0aXNoLCBwb3J0V2l0aENvbG9uLCByZXN0XSA9IG1hdGNoZXM7XG4gIGNvbnN0IHByb3RvY29sID0gZW5kcG9pbnQuc3RhcnRzV2l0aCgnaHR0cHM6JykgPyAnd3NzOicgOiAnd3M6JztcbiAgY29uc3Qgc3RhcnRQb3J0ID0gcG9ydFdpdGhDb2xvbiA9PSBudWxsID8gbnVsbCA6IHBhcnNlSW50KHBvcnRXaXRoQ29sb24uc2xpY2UoMSksIDEwKTtcbiAgY29uc3Qgd2Vic29ja2V0UG9ydCA9XG4gIC8vIE9ubHkgc2hpZnQgdGhlIHBvcnQgYnkgKzEgYXMgYSBjb252ZW50aW9uIGZvciB3cyhzKSBvbmx5IGlmIGdpdmVuIGVuZHBvaW50XG4gIC8vIGlzIGV4cGxpY2l0bHkgc3BlY2lmeWluZyB0aGUgZW5kcG9pbnQgcG9ydCAoSFRUUC1iYXNlZCBSUEMpLCBhc3N1bWluZ1xuICAvLyB3ZSdyZSBkaXJlY3RseSB0cnlpbmcgdG8gY29ubmVjdCB0byBhZ2F2ZS12YWxpZGF0b3IncyB3cyBsaXN0ZW5pbmcgcG9ydC5cbiAgLy8gV2hlbiB0aGUgZW5kcG9pbnQgb21pdHMgdGhlIHBvcnQsIHdlJ3JlIGNvbm5lY3RpbmcgdG8gdGhlIHByb3RvY29sXG4gIC8vIGRlZmF1bHQgcG9ydHM6IGh0dHAoODApIG9yIGh0dHBzKDQ0MykgYW5kIGl0J3MgYXNzdW1lZCB3ZSdyZSBiZWhpbmQgYSByZXZlcnNlXG4gIC8vIHByb3h5IHdoaWNoIG1hbmFnZXMgV2ViU29ja2V0IHVwZ3JhZGUgYW5kIGJhY2tlbmQgcG9ydCByZWRpcmVjdGlvbi5cbiAgc3RhcnRQb3J0ID09IG51bGwgPyAnJyA6IGA6JHtzdGFydFBvcnQgKyAxfWA7XG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdGlzaH0ke3dlYnNvY2tldFBvcnR9JHtyZXN0fWA7XG59XG5cbmNvbnN0IFB1YmxpY0tleUZyb21TdHJpbmcgPSBjb2VyY2UoaW5zdGFuY2UoUHVibGljS2V5KSwgc3RyaW5nKCksIHZhbHVlID0+IG5ldyBQdWJsaWNLZXkodmFsdWUpKTtcbmNvbnN0IFJhd0FjY291bnREYXRhUmVzdWx0ID0gdHVwbGUoW3N0cmluZygpLCBsaXRlcmFsKCdiYXNlNjQnKV0pO1xuY29uc3QgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhID0gY29lcmNlKGluc3RhbmNlKEJ1ZmZlciksIFJhd0FjY291bnREYXRhUmVzdWx0LCB2YWx1ZSA9PiBCdWZmZXIuZnJvbSh2YWx1ZVswXSwgJ2Jhc2U2NCcpKTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIHVzZSBhIHJlY2VudCBibG9ja2hhc2ggZm9yIHVwIHRvIDMwIHNlY29uZHNcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyA9IDMwICogMTAwMDtcblxuLyoqXG4gKiBIQUNLLlxuICogQ29waWVkIGZyb20gcnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50LlxuICogT3RoZXJ3aXNlLCBgeWFybiBidWlsZGAgZmFpbHMgd2l0aDpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXZlbHVzY2hlci9jMDU3ZWNhODFkNDc5ZWY3MDVjZGI1MzE2MmY5OTcxZFxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEV2ZXJ5IHN1YnNjcmlwdGlvbiBjb250YWlucyB0aGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoXG4gKiB0aGUgc2VydmVyLCBhbmQgYSBsaXN0IG9mIGNhbGxlcnMgaW50ZXJlc3RlZCBpbiBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBBIHN1YnNjcmlwdGlvbiBtYXkgYmUgaW4gdmFyaW91cyBzdGF0ZXMgb2YgY29ubmVjdGVkbmVzcy4gT25seSB3aGVuIGl0IGlzXG4gKiBmdWxseSBjb25uZWN0ZWQgd2lsbCBpdCBoYXZlIGEgc2VydmVyIHN1YnNjcmlwdGlvbiBpZCBhc3NvY2lhdGVkIHdpdGggaXQuXG4gKiBUaGlzIGlkIGNhbiBiZSByZXR1cm5lZCB0byB0aGUgc2VydmVyIHRvIHVuc3Vic2NyaWJlIHRoZSBjbGllbnQgZW50aXJlbHkuXG4gKi9cblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBlbmNhcHN1bGF0ZXMgYSBzdWJzY3JpcHRpb24ncyBSUEMgbWV0aG9kXG4gKiBuYW1lcyBhbmQgbm90aWZpY2F0aW9uIChjYWxsYmFjaykgc2lnbmF0dXJlLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBVdGlsaXR5IHR5cGUgdGhhdCBrZWVwcyB0YWdnZWQgdW5pb25zIGludGFjdCB3aGlsZSBvbWl0dGluZyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhIHNpbmdsZSBzdWJzY3JpYmFibGUgJ3RvcGljLicgSXQncyBtYWRlIHVwIG9mOlxuICpcbiAqIC0gVGhlIGFyZ3MgdXNlZCB0byBvcGVuIHRoZSBzdWJzY3JpcHRpb24gd2l0aCB0aGUgc2VydmVyLFxuICogLSBUaGUgc3RhdGUgb2YgdGhlIHN1YnNjcmlwdGlvbiwgaW4gdGVybXMgb2YgaXRzIGNvbm5lY3RlZG5lc3MsIGFuZFxuICogLSBUaGUgc2V0IG9mIGNhbGxiYWNrcyB0byBjYWxsIHdoZW4gdGhlIHNlcnZlciBwdWJsaXNoZXMgbm90aWZpY2F0aW9uc1xuICpcbiAqIFRoaXMgcmVjb3JkIGdldHMgaW5kZXhlZCBieSBgU3Vic2NyaXB0aW9uQ29uZmlnSGFzaGAgYW5kIGlzIHVzZWQgdG9cbiAqIHNldCB1cCBzdWJzY3JpcHRpb25zLCBmYW4gb3V0IG5vdGlmaWNhdGlvbnMsIGFuZCB0cmFjayBzdWJzY3JpcHRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEV4dHJhIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gZm9yIFJQQyByZXNwb25zZXNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHNlbmRpbmcgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBjb25maXJtaW5nIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1xuICovXG5cbi8qKlxuICogUlBDIFJlc3BvbnNlIHdpdGggZXh0cmEgY29udGV4dHVhbCBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnMgdGhhdCB1c2VzIHRoZSBsYXN0IHZhbGlkXG4gKiBibG9jayBoZWlnaHQgZm9yIGEgZ2l2ZW4gYmxvY2toYXNoIHRvIGNoZWNrIGZvciB0cmFuc2FjdGlvbiBleHBpcmF0aW9uLlxuICovXG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgY29uZmlybWluZyBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9ucy5cbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgc2hhcmVkIGJ5IGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYWxsIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdHJhdGVnaWVzXG4gKi9cblxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBhc3NlcnRFbmRwb2ludFVybChwdXRhdGl2ZVVybCkge1xuICBpZiAoL15odHRwcz86Ly50ZXN0KHB1dGF0aXZlVXJsKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmRwb2ludCBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJyk7XG4gIH1cbiAgcmV0dXJuIHB1dGF0aXZlVXJsO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gIGxldCBjb21taXRtZW50O1xuICBsZXQgY29uZmlnO1xuICBpZiAodHlwZW9mIGNvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb21taXRtZW50ID0gY29tbWl0bWVudE9yQ29uZmlnO1xuICB9IGVsc2UgaWYgKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQ6IHNwZWNpZmllZENvbW1pdG1lbnQsXG4gICAgICAuLi5zcGVjaWZpZWRDb25maWdcbiAgICB9ID0gY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIGNvbW1pdG1lbnQgPSBzcGVjaWZpZWRDb21taXRtZW50O1xuICAgIGNvbmZpZyA9IHNwZWNpZmllZENvbmZpZztcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1pdG1lbnQsXG4gICAgY29uZmlnXG4gIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzKGZpbHRlcnMpIHtcbiAgcmV0dXJuIGZpbHRlcnMubWFwKGZpbHRlciA9PiAnbWVtY21wJyBpbiBmaWx0ZXIgPyB7XG4gICAgLi4uZmlsdGVyLFxuICAgIG1lbWNtcDoge1xuICAgICAgLi4uZmlsdGVyLm1lbWNtcCxcbiAgICAgIGVuY29kaW5nOiBmaWx0ZXIubWVtY21wLmVuY29kaW5nID8/ICdiYXNlNTgnXG4gICAgfVxuICB9IDogZmlsdGVyKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnBjUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gdW5pb24oW3R5cGUoe1xuICAgIGpzb25ycGM6IGxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdHJpbmcoKSxcbiAgICByZXN1bHRcbiAgfSksIHR5cGUoe1xuICAgIGpzb25ycGM6IGxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdHJpbmcoKSxcbiAgICBlcnJvcjogdHlwZSh7XG4gICAgICBjb2RlOiB1bmtub3duKCksXG4gICAgICBtZXNzYWdlOiBzdHJpbmcoKSxcbiAgICAgIGRhdGE6IG9wdGlvbmFsKGFueSgpKVxuICAgIH0pXG4gIH0pXSk7XG59XG5jb25zdCBVbmtub3duUnBjUmVzdWx0ID0gY3JlYXRlUnBjUmVzdWx0KHVua25vd24oKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHQoc2NoZW1hKSB7XG4gIHJldHVybiBjb2VyY2UoY3JlYXRlUnBjUmVzdWx0KHNjaGVtYSksIFVua25vd25ScGNSZXN1bHQsIHZhbHVlID0+IHtcbiAgICBpZiAoJ2Vycm9yJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgcmVzdWx0OiBjcmVhdGUodmFsdWUucmVzdWx0LCBzY2hlbWEpXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiBqc29uUnBjUmVzdWx0KHR5cGUoe1xuICAgIGNvbnRleHQ6IHR5cGUoe1xuICAgICAgc2xvdDogbnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGUoe1xuICAgIGNvbnRleHQ6IHR5cGUoe1xuICAgICAgc2xvdDogbnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCByZXNwb25zZSkge1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcjogcmVzcG9uc2UuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IHJlc3BvbnNlLmFjY291bnRLZXlzLm1hcChhY2NvdW50S2V5ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudEtleSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiByZXNwb25zZS5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9uczogcmVzcG9uc2UuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSlcbiAgICAgIH0pKSxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IHJlc3BvbnNlLmFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UocmVzcG9uc2UpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCB3aGVuIHF1ZXJ5aW5nIHN0YXRlXG4gKiA8cHJlPlxuICogICAncHJvY2Vzc2VkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuXG4vLyBEZXByZWNhdGVkIGFzIG9mIHYxLjUuNVxuXG4vKipcbiAqIEEgc3Vic2V0IG9mIENvbW1pdG1lbnQgbGV2ZWxzLCB3aGljaCBhcmUgYXQgbGVhc3Qgb3B0aW1pc3RpY2FsbHkgY29uZmlybWVkXG4gKiA8cHJlPlxuICogICAnY29uZmlybWVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbGFyZ2VzdCBhY2NvdW50cyBxdWVyeVxuICogPHByZT5cbiAqICAgJ2NpcmN1bGF0aW5nJzogICAgUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseVxuICogICAnbm9uQ2lyY3VsYXRpbmcnOiBSZXR1cm4gdGhlIGxhcmdlc3QgYWNjb3VudHMgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseVxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEFjY291bnRJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCYWxhbmNlYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN0YWtlTWluaW11bURlbGVnYXRpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrSGVpZ2h0YCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRFcG9jaEluZm9gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEluZmxhdGlvblJld2FyZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0TGF0ZXN0QmxvY2toYXNoYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBpc0Jsb2NraGFzaFZhbGlkYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTbG90YCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTbG90TGVhZGVyYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRUcmFuc2FjdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhcmdlc3RBY2NvdW50c2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3VwcGx5YCByZXF1ZXN0IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGRlc2NyaWJpbmcgYSBjbHVzdGVyIG5vZGVcbiAqL1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGRlc2NyaWJpbmcgYSB2b3RlIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjbHVzdGVyIHZvdGUgYWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIE5ldHdvcmsgSW5mbGF0aW9uXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL2ltcGxlbWVudGVkLXByb3Bvc2Fscy9lZF9vdmVydmlldylcbiAqL1xuXG5jb25zdCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCA9IHR5cGUoe1xuICBmb3VuZGF0aW9uOiBudW1iZXIoKSxcbiAgZm91bmRhdGlvblRlcm06IG51bWJlcigpLFxuICBpbml0aWFsOiBudW1iZXIoKSxcbiAgdGFwZXI6IG51bWJlcigpLFxuICB0ZXJtaW5hbDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIFRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhbiBlcG9jaFxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJld2FyZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheShudWxsYWJsZSh0eXBlKHtcbiAgZXBvY2g6IG51bWJlcigpLFxuICBlZmZlY3RpdmVTbG90OiBudW1iZXIoKSxcbiAgYW1vdW50OiBudW1iZXIoKSxcbiAgcG9zdEJhbGFuY2U6IG51bWJlcigpLFxuICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCA9IGFycmF5KHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgcHJpb3JpdGl6YXRpb25GZWU6IG51bWJlcigpXG59KSk7XG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SYXRlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SYXRlUmVzdWx0ID0gdHlwZSh7XG4gIHRvdGFsOiBudW1iZXIoKSxcbiAgdmFsaWRhdG9yOiBudW1iZXIoKSxcbiAgZm91bmRhdGlvbjogbnVtYmVyKCksXG4gIGVwb2NoOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZXBvY2hcbiAqL1xuXG5jb25zdCBHZXRFcG9jaEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXBvY2g6IG51bWJlcigpLFxuICBzbG90SW5kZXg6IG51bWJlcigpLFxuICBzbG90c0luRXBvY2g6IG51bWJlcigpLFxuICBhYnNvbHV0ZVNsb3Q6IG51bWJlcigpLFxuICBibG9ja0hlaWdodDogb3B0aW9uYWwobnVtYmVyKCkpLFxuICB0cmFuc2FjdGlvbkNvdW50OiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCA9IHR5cGUoe1xuICBzbG90c1BlckVwb2NoOiBudW1iZXIoKSxcbiAgbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0OiBudW1iZXIoKSxcbiAgd2FybXVwOiBib29sZWFuKCksXG4gIGZpcnN0Tm9ybWFsRXBvY2g6IG51bWJlcigpLFxuICBmaXJzdE5vcm1hbFNsb3Q6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBMZWFkZXIgc2NoZWR1bGVcbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vdGVybWlub2xvZ3kjbGVhZGVyLXNjaGVkdWxlKVxuICovXG5cbmNvbnN0IEdldExlYWRlclNjaGVkdWxlUmVzdWx0ID0gcmVjb3JkKHN0cmluZygpLCBhcnJheShudW1iZXIoKSkpO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGVycm9yIG9yIG51bGxcbiAqL1xuY29uc3QgVHJhbnNhY3Rpb25FcnJvclJlc3VsdCA9IG51bGxhYmxlKHVuaW9uKFt0eXBlKHt9KSwgc3RyaW5nKCldKSk7XG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1cyBmb3IgYSB0cmFuc2FjdGlvblxuICovXG5jb25zdCBTaWduYXR1cmVTdGF0dXNSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0XG59KTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBzaWduYXR1cmUgcmVjZWl2ZWQgbm90aWZpY2F0aW9uXG4gKi9cbmNvbnN0IFNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0ID0gbGl0ZXJhbCgncmVjZWl2ZWRTaWduYXR1cmUnKTtcblxuLyoqXG4gKiBWZXJzaW9uIGluZm8gZm9yIGEgbm9kZVxuICovXG5cbmNvbnN0IFZlcnNpb25SZXN1bHQgPSB0eXBlKHtcbiAgJ3NvbGFuYS1jb3JlJzogc3RyaW5nKCksXG4gICdmZWF0dXJlLXNldCc6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5jb25zdCBQYXJzZWRJbnN0cnVjdGlvblN0cnVjdCA9IHR5cGUoe1xuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBwYXJzZWQ6IHVua25vd24oKVxufSk7XG5jb25zdCBQYXJ0aWFsbHlEZWNvZGVkSW5zdHJ1Y3Rpb25TdHJ1Y3QgPSB0eXBlKHtcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50czogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZyksXG4gIGRhdGE6IHN0cmluZygpXG59KTtcbmNvbnN0IFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgZXJyOiBudWxsYWJsZSh1bmlvbihbdHlwZSh7fSksIHN0cmluZygpXSkpLFxuICBsb2dzOiBudWxsYWJsZShhcnJheShzdHJpbmcoKSkpLFxuICBhY2NvdW50czogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkobnVsbGFibGUodHlwZSh7XG4gICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgIG93bmVyOiBzdHJpbmcoKSxcbiAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgZGF0YTogYXJyYXkoc3RyaW5nKCkpLFxuICAgIHJlbnRFcG9jaDogb3B0aW9uYWwobnVtYmVyKCkpXG4gIH0pKSkpKSxcbiAgdW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpLFxuICByZXR1cm5EYXRhOiBvcHRpb25hbChudWxsYWJsZSh0eXBlKHtcbiAgICBwcm9ncmFtSWQ6IHN0cmluZygpLFxuICAgIGRhdGE6IHR1cGxlKFtzdHJpbmcoKSwgbGl0ZXJhbCgnYmFzZTY0JyldKVxuICB9KSkpLFxuICBpbm5lckluc3RydWN0aW9uczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkodHlwZSh7XG4gICAgaW5kZXg6IG51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodW5pb24oW1BhcnNlZEluc3RydWN0aW9uU3RydWN0LCBQYXJ0aWFsbHlEZWNvZGVkSW5zdHJ1Y3Rpb25TdHJ1Y3RdKSlcbiAgfSkpKSlcbn0pKTtcblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uTWV0YX0gaW5zdGVhZC5cbiAqL1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgYWRkcmVzc2VzIGxvYWRlZCBieSBhIHRyYW5zYWN0aW9uIHVzaW5nIGFkZHJlc3MgdGFibGUgbG9va3Vwc1xuICovXG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgcGFyc2VkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBtZXNzYWdlIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBBIHBhcnRpYWxseSBkZWNvZGVkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBtZXNzYWdlIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCBhZGRyZXNzIHRhYmxlIGxvb2t1cFxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZVxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIGFuZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25XaXRoTWV0YX0gaW5zdGVhZC5cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXIgd2l0aCBtZXRhXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBibG9jayBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLlxuICovXG5cbi8qKlxuICogQSBCbG9jayBvbiB0aGUgbGVkZ2VyIHdpdGggc2lnbmF0dXJlcyBvbmx5XG4gKi9cblxuLyoqXG4gKiByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrUHJvZHVjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgYnlJZGVudGl0eTogcmVjb3JkKHN0cmluZygpLCBhcnJheShudW1iZXIoKSkpLFxuICByYW5nZTogdHlwZSh7XG4gICAgZmlyc3RTbG90OiBudW1iZXIoKSxcbiAgICBsYXN0U2xvdDogbnVtYmVyKClcbiAgfSlcbn0pKTtcblxuLyoqXG4gKiBBIHBlcmZvcm1hbmNlIHNhbXBsZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJwY0NsaWVudCh1cmwsIGh0dHBIZWFkZXJzLCBjdXN0b21GZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KSB7XG4gIGNvbnN0IGZldGNoID0gY3VzdG9tRmV0Y2ggPyBjdXN0b21GZXRjaCA6IGZldGNoSW1wbDtcbiAgbGV0IGFnZW50O1xuICB7XG4gICAgaWYgKGh0dHBBZ2VudCA9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGFnZW50T3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBPbmUgc2Vjb25kIGZld2VyIHRoYW4gdGhlIFNvbGFuYSBSUEMncyBrZWVwYWxpdmUgdGltZW91dC5cbiAgICAgICAgICAvLyBSZWFkIG1vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzI3ODU5I2lzc3VlY29tbWVudC0xMzQwMDk3ODg5XG4gICAgICAgICAgZnJlZVNvY2tldFRpbWVvdXQ6IDE5MDAwLFxuICAgICAgICAgIGtlZXBBbGl2ZTogdHJ1ZSxcbiAgICAgICAgICBtYXhTb2NrZXRzOiAyNVxuICAgICAgICB9O1xuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpKSB7XG4gICAgICAgICAgYWdlbnQgPSBuZXcgYWdlbnRrZWVwYWxpdmVFeHBvcnRzLkh0dHBzQWdlbnQoYWdlbnRPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZ2VudCA9IG5ldyBIdHRwS2VlcEFsaXZlQWdlbnQoYWdlbnRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaHR0cEFnZW50ICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpc0h0dHBzID0gdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpO1xuICAgICAgICBpZiAoaXNIdHRwcyAmJiAhKGh0dHBBZ2VudCBpbnN0YW5jZW9mIEFnZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVuZHBvaW50IGAnICsgdXJsICsgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHBzLkFnZW50YC4gWW91IGhhdmUsIGluc3RlYWQsIHN1cHBsaWVkIGFuICcgKyAnYGh0dHAuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzSHR0cHMgJiYgaHR0cEFnZW50IGluc3RhbmNlb2YgQWdlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbmRwb2ludCBgJyArIHVybCArICdgIGNhbiBvbmx5IGJlIHBhaXJlZCB3aXRoIGFuIGBodHRwLkFnZW50YC4gWW91IGhhdmUsIGluc3RlYWQsIHN1cHBsaWVkIGFuICcgKyAnYGh0dHBzLkFnZW50YCB0aHJvdWdoIGBodHRwQWdlbnRgLicpO1xuICAgICAgICB9XG4gICAgICAgIGFnZW50ID0gaHR0cEFnZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgZmV0Y2hXaXRoTWlkZGxld2FyZTtcbiAgaWYgKGZldGNoTWlkZGxld2FyZSkge1xuICAgIGZldGNoV2l0aE1pZGRsZXdhcmUgPSBhc3luYyAoaW5mbywgaW5pdCkgPT4ge1xuICAgICAgY29uc3QgbW9kaWZpZWRGZXRjaEFyZ3MgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmV0Y2hNaWRkbGV3YXJlKGluZm8sIGluaXQsIChtb2RpZmllZEluZm8sIG1vZGlmaWVkSW5pdCkgPT4gcmVzb2x2ZShbbW9kaWZpZWRJbmZvLCBtb2RpZmllZEluaXRdKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2goLi4ubW9kaWZpZWRGZXRjaEFyZ3MpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgY2xpZW50QnJvd3NlciA9IG5ldyBScGNDbGllbnQoYXN5bmMgKHJlcXVlc3QsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgIGFnZW50LFxuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sIGh0dHBIZWFkZXJzIHx8IHt9LCBDT01NT05fSFRUUF9IRUFERVJTKVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID0gNTtcbiAgICAgIGxldCByZXM7XG4gICAgICBsZXQgd2FpdFRpbWUgPSA1MDA7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChmZXRjaFdpdGhNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2hXaXRoTWlkZGxld2FyZSh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT09IDQyOSAvKiBUb28gbWFueSByZXF1ZXN0cyAqLykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgLT0gMTtcbiAgICAgICAgaWYgKHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fS4gIFJldHJ5aW5nIGFmdGVyICR7d2FpdFRpbWV9bXMgZGVsYXkuLi5gKTtcbiAgICAgICAgYXdhaXQgc2xlZXAod2FpdFRpbWUpO1xuICAgICAgICB3YWl0VGltZSAqPSAyO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9OiAke3RleHR9YCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfSwge30pO1xuICByZXR1cm4gY2xpZW50QnJvd3Nlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY1JlcXVlc3QoY2xpZW50KSB7XG4gIHJldHVybiAobWV0aG9kLCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudC5yZXF1ZXN0KG1ldGhvZCwgYXJncywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gcmVxdWVzdHMgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBEbyBub3RoaW5nIGlmIHJlcXVlc3RzIGlzIGVtcHR5XG4gICAgICBpZiAocmVxdWVzdHMubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKTtcbiAgICAgIGNvbnN0IGJhdGNoID0gcmVxdWVzdHMubWFwKHBhcmFtcyA9PiB7XG4gICAgICAgIHJldHVybiBjbGllbnQucmVxdWVzdChwYXJhbXMubWV0aG9kTmFtZSwgcGFyYW1zLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBjbGllbnQucmVxdWVzdChiYXRjaCwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25Hb3Zlcm5vclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaEluZm9cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEVwb2NoSW5mb1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0RXBvY2hJbmZvUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RXBvY2hTY2hlZHVsZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExlYWRlclNjaGVkdWxlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJtaW5pbXVtTGVkZ2VyU2xvdFwiIGFuZCBcImdldEZpcnN0QXZhaWxhYmxlQmxvY2tcIiBtZXNzYWdlc1xuICovXG5jb25zdCBTbG90UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudW1iZXIoKSk7XG5cbi8qKlxuICogU3VwcGx5XG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U3VwcGx5XCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTdXBwbHlScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgdG90YWw6IG51bWJlcigpLFxuICBjaXJjdWxhdGluZzogbnVtYmVyKCksXG4gIG5vbkNpcmN1bGF0aW5nOiBudW1iZXIoKSxcbiAgbm9uQ2lyY3VsYXRpbmdBY2NvdW50czogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pKTtcblxuLyoqXG4gKiBUb2tlbiBhbW91bnQgb2JqZWN0IHdoaWNoIHJldHVybnMgYSB0b2tlbiBhbW91bnQgaW4gZGlmZmVyZW50IGZvcm1hdHNcbiAqIGZvciB2YXJpb3VzIGNsaWVudCB1c2UgY2FzZXMuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyBzdHJ1Y3R1cmUgZm9yIHRva2VuIGFtb3VudHNcbiAqL1xuY29uc3QgVG9rZW5BbW91bnRSZXN1bHQgPSB0eXBlKHtcbiAgYW1vdW50OiBzdHJpbmcoKSxcbiAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZGVjaW1hbHM6IG51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogb3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcblxuLyoqXG4gKiBUb2tlbiBhZGRyZXNzIGFuZCBiYWxhbmNlLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuTGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhbW91bnQ6IHN0cmluZygpLFxuICB1aUFtb3VudDogbnVsbGFibGUobnVtYmVyKCkpLFxuICBkZWNpbWFsczogbnVtYmVyKCksXG4gIHVpQW1vdW50U3RyaW5nOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgZGF0YTogQnVmZmVyRnJvbVJhd0FjY291bnREYXRhLFxuICAgIHJlbnRFcG9jaDogbnVtYmVyKClcbiAgfSlcbn0pKSk7XG5jb25zdCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCA9IHR5cGUoe1xuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHNwYWNlOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZSB3aXRoIHBhcnNlZCBkYXRhXG4gKi9cbmNvbnN0IEdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogdHlwZSh7XG4gICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCxcbiAgICByZW50RXBvY2g6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIFBhaXIgb2YgYW4gYWNjb3VudCBhZGRyZXNzIGFuZCBpdHMgYmFsYW5jZVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExhcmdlc3RBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZ1xufSkpKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBLZXllZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuY29uc3QgUGFyc2VkT3JSYXdBY2NvdW50RGF0YSA9IGNvZXJjZSh1bmlvbihbaW5zdGFuY2UoQnVmZmVyKSwgUGFyc2VkQWNjb3VudERhdGFSZXN1bHRdKSwgdW5pb24oW1Jhd0FjY291bnREYXRhUmVzdWx0LCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLCB2YWx1ZSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBkYXRhOiBQYXJzZWRPclJhd0FjY291bnREYXRhLFxuICByZW50RXBvY2g6IG51bWJlcigpXG59KTtcbmNvbnN0IEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0YWtlQWN0aXZhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdGF0ZTogdW5pb24oW2xpdGVyYWwoJ2FjdGl2ZScpLCBsaXRlcmFsKCdpbmFjdGl2ZScpLCBsaXRlcmFsKCdhY3RpdmF0aW5nJyksIGxpdGVyYWwoJ2RlYWN0aXZhdGluZycpXSksXG4gIGFjdGl2ZTogbnVtYmVyKCksXG4gIGluYWN0aXZlOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlwiIG1lc3NhZ2VcbiAqL1xuXG5jb25zdCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KGFycmF5KHR5cGUoe1xuICBzaWduYXR1cmU6IHN0cmluZygpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBtZW1vOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheSh0eXBlKHtcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbWVtbzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pKSk7XG5cbi8qKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJhY2NvdW50Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChBY2NvdW50SW5mb1Jlc3VsdClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5cbi8qKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJwcm9ncmFtTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0KVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNsb3RJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHBhcmVudDogbnVtYmVyKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICByb290OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNsb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3ROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90SW5mb1Jlc3VsdFxufSk7XG5cbi8qKlxuICogU2xvdCB1cGRhdGVzIHdoaWNoIGNhbiBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gKiAtIGBcImZpcnN0U2hyZWRSZWNlaXZlZFwiYDogY29ubmVjdGVkIG5vZGUgcmVjZWl2ZWQgdGhlIGZpcnN0IHNocmVkIG9mIGEgYmxvY2suXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIG5ldyBibG9jayB0aGF0IGlzIGJlaW5nIHByb2R1Y2VkLlxuICogLSBgXCJjb21wbGV0ZWRcImA6IGNvbm5lY3RlZCBub2RlIGhhcyByZWNlaXZlZCBhbGwgc2hyZWRzIG9mIGEgYmxvY2suIEluZGljYXRlc1xuICogYSBibG9jayB3YXMgcmVjZW50bHkgcHJvZHVjZWQuXG4gKiAtIGBcIm9wdGltaXN0aWNDb25maXJtYXRpb25cImA6IGJsb2NrIHdhcyBvcHRpbWlzdGljYWxseSBjb25maXJtZWQgYnkgdGhlXG4gKiBjbHVzdGVyLiBJdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IGFuIG9wdGltaXN0aWMgY29uZmlybWF0aW9uIG5vdGlmaWNhdGlvblxuICogd2lsbCBiZSBzZW50IGZvciBldmVyeSBmaW5hbGl6ZWQgYmxvY2tzLlxuICogLSBgXCJyb290XCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgcm9vdGVkIHRoaXMgYmxvY2suXG4gKiAtIGBcImNyZWF0ZWRCYW5rXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgaGFzIHN0YXJ0ZWQgdmFsaWRhdGluZyB0aGlzIGJsb2NrLlxuICogLSBgXCJmcm96ZW5cImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBoYXMgdmFsaWRhdGVkIHRoaXMgYmxvY2suXG4gKiAtIGBcImRlYWRcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBmYWlsZWQgdG8gdmFsaWRhdGUgdGhpcyBibG9jay5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbG90VXBkYXRlUmVzdWx0ID0gdW5pb24oW3R5cGUoe1xuICB0eXBlOiB1bmlvbihbbGl0ZXJhbCgnZmlyc3RTaHJlZFJlY2VpdmVkJyksIGxpdGVyYWwoJ2NvbXBsZXRlZCcpLCBsaXRlcmFsKCdvcHRpbWlzdGljQ29uZmlybWF0aW9uJyksIGxpdGVyYWwoJ3Jvb3QnKV0pLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdjcmVhdGVkQmFuaycpLFxuICBwYXJlbnQ6IG51bWJlcigpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdmcm96ZW4nKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIHN0YXRzOiB0eXBlKHtcbiAgICBudW1UcmFuc2FjdGlvbkVudHJpZXM6IG51bWJlcigpLFxuICAgIG51bVN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICAgIG51bUZhaWxlZFRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gICAgbWF4VHJhbnNhY3Rpb25zUGVyRW50cnk6IG51bWJlcigpXG4gIH0pXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2RlYWQnKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIGVycjogc3RyaW5nKClcbn0pXSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNsb3RzVXBkYXRlc05vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IFNsb3RVcGRhdGVSZXN1bHRcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzaWduYXR1cmVOb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNpZ25hdHVyZU5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodW5pb24oW1NpZ25hdHVyZVN0YXR1c1Jlc3VsdCwgU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHRdKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJyb290Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBSb290Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbnVtYmVyKClcbn0pO1xuY29uc3QgQ29udGFjdEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBzdHJpbmcoKSxcbiAgZ29zc2lwOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHRwdTogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBycGM6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgdmVyc2lvbjogbnVsbGFibGUoc3RyaW5nKCkpXG59KTtcbmNvbnN0IFZvdGVBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICB2b3RlUHVia2V5OiBzdHJpbmcoKSxcbiAgbm9kZVB1YmtleTogc3RyaW5nKCksXG4gIGFjdGl2YXRlZFN0YWtlOiBudW1iZXIoKSxcbiAgZXBvY2hWb3RlQWNjb3VudDogYm9vbGVhbigpLFxuICBlcG9jaENyZWRpdHM6IGFycmF5KHR1cGxlKFtudW1iZXIoKSwgbnVtYmVyKCksIG51bWJlcigpXSkpLFxuICBjb21taXNzaW9uOiBudW1iZXIoKSxcbiAgbGFzdFZvdGU6IG51bWJlcigpLFxuICByb290U2xvdDogbnVsbGFibGUobnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Vm90ZUFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRWb3RlQWNjb3VudHMgPSBqc29uUnBjUmVzdWx0KHR5cGUoe1xuICBjdXJyZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpLFxuICBkZWxpbnF1ZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpXG59KSk7XG5jb25zdCBDb25maXJtYXRpb25TdGF0dXMgPSB1bmlvbihbbGl0ZXJhbCgncHJvY2Vzc2VkJyksIGxpdGVyYWwoJ2NvbmZpcm1lZCcpLCBsaXRlcmFsKCdmaW5hbGl6ZWQnKV0pO1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UgPSB0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIGNvbmZpcm1hdGlvbnM6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBjb25maXJtYXRpb25TdGF0dXM6IG9wdGlvbmFsKENvbmZpcm1hdGlvblN0YXR1cylcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTaWduYXR1cmVTdGF0dXNlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShTaWduYXR1cmVTdGF0dXNSZXNwb25zZSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bWJlcigpKTtcbmNvbnN0IEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCA9IHR5cGUoe1xuICBhY2NvdW50S2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICB3cml0YWJsZUluZGV4ZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcmVhZG9ubHlJbmRleGVzOiBhcnJheShudW1iZXIoKSlcbn0pO1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBtZXNzYWdlOiB0eXBlKHtcbiAgICBhY2NvdW50S2V5czogYXJyYXkoc3RyaW5nKCkpLFxuICAgIGhlYWRlcjogdHlwZSh7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IG51bWJlcigpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogbnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IG51bWJlcigpXG4gICAgfSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICAgIGFjY291bnRzOiBhcnJheShudW1iZXIoKSksXG4gICAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICAgIHByb2dyYW1JZEluZGV4OiBudW1iZXIoKVxuICAgIH0pKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpXG4gIH0pXG59KTtcbmNvbnN0IEFubm90YXRlZEFjY291bnRLZXkgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBzaWduZXI6IGJvb2xlYW4oKSxcbiAgd3JpdGFibGU6IGJvb2xlYW4oKSxcbiAgc291cmNlOiBvcHRpb25hbCh1bmlvbihbbGl0ZXJhbCgndHJhbnNhY3Rpb24nKSwgbGl0ZXJhbCgnbG9va3VwVGFibGUnKV0pKVxufSk7XG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50S2V5czogYXJyYXkoQW5ub3RhdGVkQWNjb3VudEtleSksXG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKVxufSk7XG5jb25zdCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZ1xufSk7XG5jb25zdCBSYXdJbnN0cnVjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50czogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZyksXG4gIGRhdGE6IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pO1xuY29uc3QgSW5zdHJ1Y3Rpb25SZXN1bHQgPSB1bmlvbihbUmF3SW5zdHJ1Y3Rpb25SZXN1bHQsIFBhcnNlZEluc3RydWN0aW9uUmVzdWx0XSk7XG5jb25zdCBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQgPSB1bmlvbihbdHlwZSh7XG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBzdHJpbmcoKVxufSksIHR5cGUoe1xuICBhY2NvdW50czogYXJyYXkoc3RyaW5nKCkpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBzdHJpbmcoKVxufSldKTtcbmNvbnN0IFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24gPSBjb2VyY2UoSW5zdHJ1Y3Rpb25SZXN1bHQsIFVua25vd25JbnN0cnVjdGlvblJlc3VsdCwgdmFsdWUgPT4ge1xuICBpZiAoJ2FjY291bnRzJyBpbiB2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIFJhd0luc3RydWN0aW9uUmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIG1lc3NhZ2U6IHR5cGUoe1xuICAgIGFjY291bnRLZXlzOiBhcnJheShBbm5vdGF0ZWRBY2NvdW50S2V5KSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pLFxuICAgIHJlY2VudEJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgYWRkcmVzc1RhYmxlTG9va3Vwczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0KSkpXG4gIH0pXG59KTtcbmNvbnN0IFRva2VuQmFsYW5jZVJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50SW5kZXg6IG51bWJlcigpLFxuICBtaW50OiBzdHJpbmcoKSxcbiAgb3duZXI6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgcHJvZ3JhbUlkOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIHVpVG9rZW5BbW91bnQ6IFRva2VuQW1vdW50UmVzdWx0XG59KTtcbmNvbnN0IExvYWRlZEFkZHJlc3Nlc1Jlc3VsdCA9IHR5cGUoe1xuICB3cml0YWJsZTogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZyksXG4gIHJlYWRvbmx5OiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGZlZTogbnVtYmVyKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChudWxsYWJsZShhcnJheSh0eXBlKHtcbiAgICBpbmRleDogbnVtYmVyKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICAgIGFjY291bnRzOiBhcnJheShudW1iZXIoKSksXG4gICAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICAgIHByb2dyYW1JZEluZGV4OiBudW1iZXIoKVxuICAgIH0pKVxuICB9KSkpKSxcbiAgcHJlQmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcG9zdEJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIGxvZ01lc3NhZ2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShzdHJpbmcoKSkpKSxcbiAgcHJlVG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBwb3N0VG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBsb2FkZWRBZGRyZXNzZXM6IG9wdGlvbmFsKExvYWRlZEFkZHJlc3Nlc1Jlc3VsdCksXG4gIGNvbXB1dGVVbml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSksXG4gIGNvc3RVbml0czogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBudW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogb3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgY29zdFVuaXRzOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0ID0gdW5pb24oW2xpdGVyYWwoMCksIGxpdGVyYWwoJ2xlZ2FjeScpXSk7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IFJld2FyZHNSZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBzdHJpbmcoKSxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBwb3N0QmFsYW5jZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICByZXdhcmRUeXBlOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGNvbW1pc3Npb246IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0QmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2Ugd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgbm9uZWBcbiAqL1xuY29uc3QgR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFBhcnNlZEJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSAgd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgYWNjb3VudHNgXG4gKi9cbmNvbnN0IEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSAgd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgbm9uZWBcbiAqL1xuY29uc3QgR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldENvbmZpcm1lZEJsb2NrXCIgbWVzc2FnZVxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgR2V0QmxvY2tScGNSZXN1bHR9IGluc3RlYWQuXG4gKi9cbmNvbnN0IEdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb246IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSksXG4gIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExhdGVzdEJsb2NraGFzaFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBudW1iZXIoKVxufSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJpc0Jsb2NraGFzaFZhbGlkXCIgbWVzc2FnZVxuICovXG5jb25zdCBJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYm9vbGVhbigpKTtcbmNvbnN0IFBlcmZTYW1wbGVSZXN1bHQgPSB0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIG51bVRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gIG51bVNsb3RzOiBudW1iZXIoKSxcbiAgc2FtcGxlUGVyaW9kU2VjczogbnVtYmVyKClcbn0pO1xuXG4vKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIFwiZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KGFycmF5KFBlcmZTYW1wbGVSZXN1bHQpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bGxhYmxlKHR5cGUoe1xuICBmZWVDYWxjdWxhdG9yOiB0eXBlKHtcbiAgICBsYW1wb3J0c1BlclNpZ25hdHVyZTogbnVtYmVyKClcbiAgfSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJlcXVlc3RBaXJkcm9wXCIgbWVzc2FnZVxuICovXG5jb25zdCBSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzZW5kVHJhbnNhY3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpO1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBsYXRlc3Qgc2xvdCBiZWluZyBwcm9jZXNzZWQgYnkgYSBub2RlXG4gKi9cblxuLyoqXG4gKiBQYXJzZWQgYWNjb3VudCBkYXRhXG4gKi9cblxuLyoqXG4gKiBTdGFrZSBBY3RpdmF0aW9uIGRhdGFcbiAqL1xuXG4vKipcbiAqIERhdGEgc2xpY2UgYXJndW1lbnQgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogTWVtb3J5IGNvbXBhcmlzb24gZmlsdGVyIGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIERhdGEgc2l6ZSBjb21wYXJpc29uIGZpbHRlciBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBBIGZpbHRlciBvYmplY3QgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGdldFByb2dyYW1BY2NvdW50cyByZXF1ZXN0c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGdldFBhcnNlZFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGdldE11bHRpcGxlQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0Tm9uY2VgXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldE5vbmNlQW5kQ29udGV4dGBcbiAqL1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGRlc2NyaWJpbmcgYW4gYWNjb3VudFxuICovXG5cbi8qKlxuICogQWNjb3VudCBpbmZvcm1hdGlvbiBpZGVudGlmaWVkIGJ5IHB1YmtleVxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGFjY291bnQgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBwcm9ncmFtIGFjY291bnQgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzbG90IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2xvdCB1cGRhdGUgbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNpZ25hdHVyZSBzdGF0dXMgbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1cyBub3RpZmljYXRpb24gd2l0aCB0cmFuc2FjdGlvbiByZXN1bHRcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSByZWNlaXZlZCBub3RpZmljYXRpb25cbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHN1YnNjcmlwdGlvbiBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igcm9vdCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IExvZ3NSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBsb2dzOiBhcnJheShzdHJpbmcoKSksXG4gIHNpZ25hdHVyZTogc3RyaW5nKClcbn0pO1xuXG4vKipcbiAqIExvZ3MgcmVzdWx0LlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImxvZ3NOb3RpZmljYXRpb25cIiBtZXNzYWdlLlxuICovXG5jb25zdCBMb2dzTm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChMb2dzUmVzdWx0KSxcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRmlsdGVyIGZvciBsb2cgc3Vic2NyaXB0aW9ucy5cbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBsb2cgbm90aWZpY2F0aW9ucy5cbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSByZXN1bHRcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGVycm9yXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RhdHVzXG4gKiA8cHJlPlxuICogICAncHJvY2Vzc2VkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNvbm5lY3RlZCBub2RlXG4gKiAgICdjb25maXJtZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXNcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIHNpZ25hdHVyZSB3aXRoIGl0cyBzdGF0dXNcbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCBkZWZpbmluZyBoZWFkZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgUlBDIHNlcnZlclxuICovXG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIEphdmFTY3JpcHQgYGZldGNoKClgIEFQSVxuICovXG5cbi8qKlxuICogQSBjYWxsYmFjayB1c2VkIHRvIGF1Z21lbnQgdGhlIG91dGdvaW5nIEhUVFAgcmVxdWVzdFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgaW5zdGFudGlhdGluZyBhIENvbm5lY3Rpb25cbiAqL1xuXG4vKiogQGludGVybmFsICovXG5jb25zdCBDT01NT05fSFRUUF9IRUFERVJTID0ge1xuICAnc29sYW5hLWNsaWVudCc6IGBqcy8ke1wiMS4wLjAtbWFpbnRlbmFuY2VcIn1gXG59O1xuXG4vKipcbiAqIEEgY29ubmVjdGlvbiB0byBhIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gKi9cbmNsYXNzIENvbm5lY3Rpb24ge1xuICAvKipcbiAgICogRXN0YWJsaXNoIGEgSlNPTiBSUEMgY29ubmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnQgVVJMIHRvIHRoZSBmdWxsbm9kZSBKU09OIFJQQyBlbmRwb2ludFxuICAgKiBAcGFyYW0gY29tbWl0bWVudE9yQ29uZmlnIG9wdGlvbmFsIGRlZmF1bHQgY29tbWl0bWVudCBsZXZlbCBvciBvcHRpb25hbCBDb25uZWN0aW9uQ29uZmlnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbmRwb2ludCwgX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9jb21taXRtZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dzRW5kcG9pbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY0NsaWVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbFxuICAgICAqIEEgbnVtYmVyIHRoYXQgd2UgaW5jcmVtZW50IGV2ZXJ5IHRpbWUgYW4gYWN0aXZlIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNhbWUgc29ja2V0IGNvbm5lY3Rpb24gdGhhdCB3YXMgb3BlblxuICAgICAqIHdoZW4gYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgaXMgdGhlIHNhbWUgb25lIHRoYXQncyBhY3RpdmUgd2hlblxuICAgICAqIGl0cyBjb250aW51YXRpb24gZmlyZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmcgPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibG9ja2hhc2hJbmZvID0ge1xuICAgICAgbGF0ZXN0QmxvY2toYXNoOiBudWxsLFxuICAgICAgbGFzdEZldGNoOiAwLFxuICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdXG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2ggPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoID0ge307XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICogc3Vic2NyaXB0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gV2UgbmVlZCB0byB0cmFjayB3aGljaCBvZiB0aGVzZVxuICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgKiAoaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHRlYXIgZG93biB0aGUgc2VydmVyIHN1YnNjcmlwdGlvbikgb3IgYW5cbiAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMgPSBuZXcgU2V0KCk7XG4gICAgLypcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJsb2NrIGhlaWdodCBvZiB0aGUgbm9kZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0QmxvY2tIZWlnaHQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdFByb21pc2VzID0ge307XG4gICAgICByZXR1cm4gYXN5bmMgY29tbWl0bWVudE9yQ29uZmlnID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkoYXJncyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF0gPSByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdID8/IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrSGVpZ2h0JywgYXJncyk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrIGhlaWdodCBpbmZvcm1hdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF07XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgbGV0IHdzRW5kcG9pbnQ7XG4gICAgbGV0IGh0dHBIZWFkZXJzO1xuICAgIGxldCBmZXRjaDtcbiAgICBsZXQgZmV0Y2hNaWRkbGV3YXJlO1xuICAgIGxldCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICBsZXQgaHR0cEFnZW50O1xuICAgIGlmIChfY29tbWl0bWVudE9yQ29uZmlnICYmIHR5cGVvZiBfY29tbWl0bWVudE9yQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fY29tbWl0bWVudCA9IF9jb21taXRtZW50T3JDb25maWc7XG4gICAgfSBlbHNlIGlmIChfY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICB0aGlzLl9jb21taXRtZW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5jb21taXRtZW50O1xuICAgICAgdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmNvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0O1xuICAgICAgd3NFbmRwb2ludCA9IF9jb21taXRtZW50T3JDb25maWcud3NFbmRwb2ludDtcbiAgICAgIGh0dHBIZWFkZXJzID0gX2NvbW1pdG1lbnRPckNvbmZpZy5odHRwSGVhZGVycztcbiAgICAgIGZldGNoID0gX2NvbW1pdG1lbnRPckNvbmZpZy5mZXRjaDtcbiAgICAgIGZldGNoTWlkZGxld2FyZSA9IF9jb21taXRtZW50T3JDb25maWcuZmV0Y2hNaWRkbGV3YXJlO1xuICAgICAgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0O1xuICAgICAgaHR0cEFnZW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5odHRwQWdlbnQ7XG4gICAgfVxuICAgIHRoaXMuX3JwY0VuZHBvaW50ID0gYXNzZXJ0RW5kcG9pbnRVcmwoZW5kcG9pbnQpO1xuICAgIHRoaXMuX3JwY1dzRW5kcG9pbnQgPSB3c0VuZHBvaW50IHx8IG1ha2VXZWJzb2NrZXRVcmwoZW5kcG9pbnQpO1xuICAgIHRoaXMuX3JwY0NsaWVudCA9IGNyZWF0ZVJwY0NsaWVudChlbmRwb2ludCwgaHR0cEhlYWRlcnMsIGZldGNoLCBmZXRjaE1pZGRsZXdhcmUsIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0LCBodHRwQWdlbnQpO1xuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSBjcmVhdGVScGNSZXF1ZXN0KHRoaXMuX3JwY0NsaWVudCk7XG4gICAgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0ID0gY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0KHRoaXMuX3JwY0NsaWVudCk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0ID0gbmV3IFJwY1dlYlNvY2tldENsaWVudCh0aGlzLl9ycGNXc0VuZHBvaW50LCB7XG4gICAgICBhdXRvY29ubmVjdDogZmFsc2UsXG4gICAgICBtYXhfcmVjb25uZWN0czogSW5maW5pdHlcbiAgICB9KTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ29wZW4nLCB0aGlzLl93c09uT3Blbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2Vycm9yJywgdGhpcy5fd3NPbkVycm9yLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignY2xvc2UnLCB0aGlzLl93c09uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdhY2NvdW50Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPbkFjY291bnROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdwcm9ncmFtTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignc2xvdE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TbG90Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignc2xvdHNVcGRhdGVzTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignc2lnbmF0dXJlTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Jvb3ROb3RpZmljYXRpb24nLCB0aGlzLl93c09uUm9vdE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2xvZ3NOb3RpZmljYXRpb24nLCB0aGlzLl93c09uTG9nc05vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBjb21taXRtZW50IHVzZWQgZm9yIHJlcXVlc3RzXG4gICAqL1xuICBnZXQgY29tbWl0bWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tbWl0bWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgUlBDIGVuZHBvaW50XG4gICAqL1xuICBnZXQgcnBjRW5kcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JwY0VuZHBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXksIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldEJhbGFuY2VBbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmFsYW5jZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYmFsYW5jZSBmb3IgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGJhbGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0QmFsYW5jZShwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEJhbGFuY2VBbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKS50aGVuKHggPT4geC52YWx1ZSkuY2F0Y2goZSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgYmFsYW5jZSBvZiBhY2NvdW50ICcgKyBwdWJsaWNLZXkudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZXN0aW1hdGVkIHByb2R1Y3Rpb24gdGltZSBvZiBhIGJsb2NrXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1RpbWUoc2xvdCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrVGltZScsIFtzbG90XSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudWxsYWJsZShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBibG9jayB0aW1lIGZvciBzbG90ICR7c2xvdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxvd2VzdCBzbG90IHRoYXQgdGhlIG5vZGUgaGFzIGluZm9ybWF0aW9uIGFib3V0IGluIGl0cyBsZWRnZXIuXG4gICAqIFRoaXMgdmFsdWUgbWF5IGluY3JlYXNlIG92ZXIgdGltZSBpZiB0aGUgbm9kZSBpcyBjb25maWd1cmVkIHRvIHB1cmdlIG9sZGVyIGxlZGdlciBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRNaW5pbXVtTGVkZ2VyU2xvdCgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdtaW5pbXVtTGVkZ2VyU2xvdCcsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbWluaW11bSBsZWRnZXIgc2xvdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgc2xvdCBvZiB0aGUgbG93ZXN0IGNvbmZpcm1lZCBibG9jayB0aGF0IGhhcyBub3QgYmVlbiBwdXJnZWQgZnJvbSB0aGUgbGVkZ2VyXG4gICAqL1xuICBhc3luYyBnZXRGaXJzdEF2YWlsYWJsZUJsb2NrKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZpcnN0QXZhaWxhYmxlQmxvY2snLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2xvdFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmlyc3QgYXZhaWxhYmxlIGJsb2NrJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHN1cHBseVxuICAgKi9cbiAgYXN5bmMgZ2V0U3VwcGx5KGNvbmZpZykge1xuICAgIGxldCBjb25maWdBcmcgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgY29tbWl0bWVudDogY29uZmlnXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY29uZmlnKSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgY29tbWl0bWVudDogY29uZmlnICYmIGNvbmZpZy5jb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICBjb21taXRtZW50OiB0aGlzLmNvbW1pdG1lbnRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN1cHBseScsIFtjb25maWdBcmddKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTdXBwbHlScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHN1cHBseScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzdXBwbHkgb2YgYSB0b2tlbiBtaW50XG4gICAqL1xuICBhc3luYyBnZXRUb2tlblN1cHBseSh0b2tlbk1pbnRBZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdG9rZW5NaW50QWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5TdXBwbHknLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChUb2tlbkFtb3VudFJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRva2VuIHN1cHBseScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBiYWxhbmNlIG9mIGEgdG9rZW4gYWNjb3VudFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5BY2NvdW50QmFsYW5jZSh0b2tlbkFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0b2tlbkFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudEJhbGFuY2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChUb2tlbkFtb3VudFJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRva2VuIGFjY291bnQgYmFsYW5jZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIHRva2VuIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgYWNjb3VudFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxHZXRQcm9ncmFtQWNjb3VudHNSZXNwb25zZT59XG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkFjY291bnRzQnlPd25lcihvd25lckFkZHJlc3MsIGZpbHRlciwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBsZXQgX2FyZ3MgPSBbb3duZXJBZGRyZXNzLnRvQmFzZTU4KCldO1xuICAgIGlmICgnbWludCcgaW4gZmlsdGVyKSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgbWludDogZmlsdGVyLm1pbnQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWQ6IGZpbHRlci5wcm9ncmFtSWQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoX2FyZ3MsIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudHNCeU93bmVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VG9rZW5BY2NvdW50c0J5T3duZXIpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHRva2VuIGFjY291bnRzIG93bmVkIGJ5IGFjY291bnQgJHtvd25lckFkZHJlc3MudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRva2VuIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgYWNjb3VudFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPFBhcnNlZEFjY291bnREYXRhPn0+Pj59XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lcihvd25lckFkZHJlc3MsIGZpbHRlciwgY29tbWl0bWVudCkge1xuICAgIGxldCBfYXJncyA9IFtvd25lckFkZHJlc3MudG9CYXNlNTgoKV07XG4gICAgaWYgKCdtaW50JyBpbiBmaWx0ZXIpIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBtaW50OiBmaWx0ZXIubWludC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZDogZmlsdGVyLnByb2dyYW1JZC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhfYXJncywgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSBhY2NvdW50ICR7b3duZXJBZGRyZXNzLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSAyMCBsYXJnZXN0IGFjY291bnRzIHdpdGggdGhlaXIgY3VycmVudCBiYWxhbmNlc1xuICAgKi9cbiAgYXN5bmMgZ2V0TGFyZ2VzdEFjY291bnRzKGNvbmZpZykge1xuICAgIGNvbnN0IGFyZyA9IHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZyAmJiBjb25maWcuY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnRcbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSBhcmcuZmlsdGVyIHx8IGFyZy5jb21taXRtZW50ID8gW2FyZ10gOiBbXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMYXJnZXN0QWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxhcmdlc3QgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgdG9rZW4gYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAqIGZvciBhIGdpdmVuIG1pbnQuXG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkxhcmdlc3RBY2NvdW50cyhtaW50QWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW21pbnRBZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkxhcmdlc3RBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRva2VuTGFyZ2VzdEFjY291bnRzUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBsYXJnZXN0IGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXksIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRJbmZvQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRBY2NvdW50SW5mbycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bGxhYmxlKEFjY291bnRJbmZvUmVzdWx0KSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZEFjY291bnRJbmZvKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRBY2NvdW50SW5mbycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bGxhYmxlKFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mbyhwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJyArIHB1YmxpY0tleS50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRNdWx0aXBsZVBhcnNlZEFjY291bnRzKHB1YmxpY0tleXMsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3Qga2V5cyA9IHB1YmxpY0tleXMubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhba2V5c10sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNdWx0aXBsZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGluZm8gZm9yIGFjY291bnRzICR7a2V5c31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5cywgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3Qga2V5cyA9IHB1YmxpY0tleXMubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhba2V5c10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE11bHRpcGxlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShBY2NvdW50SW5mb1Jlc3VsdCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBmb3IgYWNjb3VudHMgJHtrZXlzfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzXG4gICAqL1xuICBhc3luYyBnZXRNdWx0aXBsZUFjY291bnRzSW5mbyhwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dChwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpO1xuICAgIHJldHVybiByZXMudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBlcG9jaCBhY3RpdmF0aW9uIGluZm9ybWF0aW9uIGZvciBhIHN0YWtlIGFjY291bnQgdGhhdCBoYXMgYmVlbiBkZWxlZ2F0ZWRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuMTg7IHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKi9cbiAgYXN5bmMgZ2V0U3Rha2VBY3RpdmF0aW9uKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnLCBlcG9jaCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGVwb2NoOiBlcG9jaCAhPSBudWxsID8gZXBvY2ggOiBjb25maWc/LmVwb2NoXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3Rha2VBY3RpdmF0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChTdGFrZUFjdGl2YXRpb25SZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBTdGFrZSBBY3RpdmF0aW9uICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9ncmFtIGlkXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXI+fT4+fVxuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRQcm9ncmFtQWNjb3VudHMocHJvZ3JhbUlkLCBjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWdPckNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuY29kaW5nLFxuICAgICAgLi4uY29uZmlnV2l0aG91dEVuY29kaW5nXG4gICAgfSA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIGVuY29kaW5nIHx8ICdiYXNlNjQnLCB7XG4gICAgICAuLi5jb25maWdXaXRob3V0RW5jb2RpbmcsXG4gICAgICAuLi4oY29uZmlnV2l0aG91dEVuY29kaW5nLmZpbHRlcnMgPyB7XG4gICAgICAgIGZpbHRlcnM6IGFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzKGNvbmZpZ1dpdGhvdXRFbmNvZGluZy5maWx0ZXJzKVxuICAgICAgfSA6IG51bGwpXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgYmFzZVNjaGVtYSA9IGFycmF5KEtleWVkQWNjb3VudEluZm9SZXN1bHQpO1xuICAgIGNvbnN0IHJlcyA9IGNvbmZpZ1dpdGhvdXRFbmNvZGluZy53aXRoQ29udGV4dCA9PT0gdHJ1ZSA/IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGJhc2VTY2hlbWEpKSA6IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYmFzZVNjaGVtYSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGFjY291bnRzIG93bmVkIGJ5IHByb2dyYW0gJHtwcm9ncmFtSWQudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYW5kIHBhcnNlIGFsbCB0aGUgYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9ncmFtIGlkXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXIgfCBQYXJzZWRBY2NvdW50RGF0YT59Pj59XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMocHJvZ3JhbUlkLCBjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWdPckNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGNvbmZpcm1UcmFuc2FjdGlvbmAgYW5kIHBhc3MgaW4ge0BsaW5rIFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3l9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvbihzdHJhdGVneSwgY29tbWl0bWVudCkge1xuICAgIGxldCByYXdTaWduYXR1cmU7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PSAnc3RyaW5nJykge1xuICAgICAgcmF3U2lnbmF0dXJlID0gc3RyYXRlZ3k7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHN0cmF0ZWd5O1xuICAgICAgaWYgKGNvbmZpZy5hYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29uZmlnLmFib3J0U2lnbmFsLnJlYXNvbik7XG4gICAgICB9XG4gICAgICByYXdTaWduYXR1cmUgPSBjb25maWcuc2lnbmF0dXJlO1xuICAgIH1cbiAgICBsZXQgZGVjb2RlZFNpZ25hdHVyZTtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZFNpZ25hdHVyZSA9IGJzNTguZGVjb2RlKHJhd1NpZ25hdHVyZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25hdHVyZSBtdXN0IGJlIGJhc2U1OCBlbmNvZGVkOiAnICsgcmF3U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgYXNzZXJ0KGRlY29kZWRTaWduYXR1cmUubGVuZ3RoID09PSA2NCwgJ3NpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGgnKTtcbiAgICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc2lnbmF0dXJlOiByYXdTaWduYXR1cmVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JyBpbiBzdHJhdGVneSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRDYW5jZWxsYXRpb25Qcm9taXNlKHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmVcbiAgfSkge1xuICAgIGxldCBzaWduYXR1cmVTdWJzY3JpcHRpb25JZDtcbiAgICBsZXQgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXI7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBjb25maXJtYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB0aGlzLm9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgKHJlc3VsdCwgY29udGV4dCkgPT4ge1xuICAgICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQsXG4gICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBjb21taXRtZW50KTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwID0+IHtcbiAgICAgICAgICBpZiAoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdGhpcy5fb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZShzaWduYXR1cmVTdWJzY3JpcHRpb25JZCwgbmV4dFN0YXRlID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZSA9PT0gJ3N1YnNjcmliZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZT8uZXJyKSB7XG4gICAgICAgICAgICByZWplY3QodmFsdWUuZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChjb21taXRtZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAncHJvY2Vzc2VkJyB8fCB2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdjb25maXJtZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZXhoYXVzdCBlbnVtcyB0byBlbnN1cmUgZnVsbCBjb3ZlcmFnZVxuICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYWJvcnRDb25maXJtYXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAoZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIpIHtcbiAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIoKTtcbiAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfTtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHN0cmF0ZWd5OiB7XG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9KSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBjaGVja0Jsb2NrSGVpZ2h0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrSGVpZ2h0ID0gYXdhaXQgdGhpcy5nZXRCbG9ja0hlaWdodChjb21taXRtZW50KTtcbiAgICAgICAgICByZXR1cm4gYmxvY2tIZWlnaHQ7XG4gICAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRCbG9ja0hlaWdodCA8PSBsYXN0VmFsaWRCbG9ja0hlaWdodCkge1xuICAgICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY3VycmVudEJsb2NrSGVpZ2h0ID0gYXdhaXQgY2hlY2tCbG9ja0hlaWdodCgpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5CTE9DS0hFSUdIVF9FWENFRURFRFxuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25Qcm9taXNlID0gdGhpcy5nZXRDYW5jZWxsYXRpb25Qcm9taXNlKGFib3J0U2lnbmFsKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb25Qcm9taXNlLCBjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzdHJhdGVneToge1xuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBtaW5Db250ZXh0U2xvdCxcbiAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgIG5vbmNlVmFsdWUsXG4gICAgICBzaWduYXR1cmVcbiAgICB9XG4gIH0pIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBjdXJyZW50Tm9uY2VWYWx1ZSA9IG5vbmNlVmFsdWU7XG4gICAgICBsZXQgbGFzdENoZWNrZWRTbG90ID0gbnVsbDtcbiAgICAgIGNvbnN0IGdldEN1cnJlbnROb25jZVZhbHVlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogbm9uY2VBY2NvdW50XG4gICAgICAgICAgfSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudFB1YmtleSwge1xuICAgICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICAgIG1pbkNvbnRleHRTbG90XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdENoZWNrZWRTbG90ID0gY29udGV4dC5zbG90O1xuICAgICAgICAgIHJldHVybiBub25jZUFjY291bnQ/Lm5vbmNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgZm9yIHdoYXRldmVyIHJlYXNvbiB3ZSBjYW4ndCByZWFjaC9yZWFkIHRoZSBub25jZVxuICAgICAgICAgIC8vIGFjY291bnQsIGp1c3Qga2VlcCB1c2luZyB0aGUgbGFzdC1rbm93biB2YWx1ZS5cbiAgICAgICAgICByZXR1cm4gY3VycmVudE5vbmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjdXJyZW50Tm9uY2VWYWx1ZSA9IGF3YWl0IGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChub25jZVZhbHVlICE9PSBjdXJyZW50Tm9uY2VWYWx1ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuTk9OQ0VfSU5WQUxJRCxcbiAgICAgICAgICAgICAgc2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2U6IGxhc3RDaGVja2VkU2xvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMDApO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBhd2FpdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25Qcm9taXNlID0gdGhpcy5nZXRDYW5jZWxsYXRpb25Qcm9taXNlKGFib3J0U2lnbmFsKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb25Qcm9taXNlLCBjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgdGhlIHRyYW5zYWN0aW9uIGlzIGluZGVlZCB1bmNvbmZpcm1lZC5cbiAgICAgICAgbGV0IHNpZ25hdHVyZVN0YXR1cztcbiAgICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoc3RhdHVzID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdHVzLmNvbnRleHQuc2xvdCA8IChvdXRjb21lLnNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlID8/IG1pbkNvbnRleHRTbG90KSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoNDAwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWduYXR1cmVTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25hdHVyZVN0YXR1cz8udmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBjb21taXRtZW50Rm9yU3RhdHVzID0gY29tbWl0bWVudCB8fCAnZmluYWxpemVkJztcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb25maXJtYXRpb25TdGF0dXNcbiAgICAgICAgICB9ID0gc2lnbmF0dXJlU3RhdHVzLnZhbHVlO1xuICAgICAgICAgIHN3aXRjaCAoY29tbWl0bWVudEZvclN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdwcm9jZXNzZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gRXhoYXVzdGl2ZSBzd2l0Y2guXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgKF8gPT4ge30pKGNvbW1pdG1lbnRGb3JTdGF0dXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBzaWduYXR1cmVTdGF0dXMuY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgIGVycjogc2lnbmF0dXJlU3RhdHVzLnZhbHVlLmVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHNpZ25hdHVyZVxuICB9KSB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgdGltZW91dE1zID0gdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgfHwgNjAgKiAxMDAwO1xuICAgICAgc3dpdGNoIChjb21taXRtZW50KSB7XG4gICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGltZW91dE1zID0gdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgfHwgMzAgKiAxMDAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHtcbiAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5USU1FRF9PVVQsXG4gICAgICAgIHRpbWVvdXRNc1xuICAgICAgfSksIHRpbWVvdXRNcyk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcihzaWduYXR1cmUsIG91dGNvbWUudGltZW91dE1zIC8gMTAwMCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldENsdXN0ZXJOb2RlcygpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDbHVzdGVyTm9kZXMnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShDb250YWN0SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjbHVzdGVyIG5vZGVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgcGFydGljaXBhdGluZyBpbiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Vm90ZUFjY291bnRzKGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRWb3RlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRWb3RlQWNjb3VudHMpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHZvdGUgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc2xvdCB0aGF0IHRoZSBub2RlIGlzIHByb2Nlc3NpbmdcbiAgICovXG4gIGFzeW5jIGdldFNsb3QoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgbGVhZGVyIG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRTbG90TGVhZGVyKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3RMZWFkZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN0cmluZygpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYGxpbWl0YCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0U2xvdGBcbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0U2xvdCBmZXRjaCBzbG90IGxlYWRlcnMgc3RhcnRpbmcgZnJvbSB0aGlzIHNsb3RcbiAgICogQHBhcmFtIGxpbWl0IG51bWJlciBvZiBzbG90IGxlYWRlcnMgdG8gcmV0dXJuXG4gICAqL1xuICBhc3luYyBnZXRTbG90TGVhZGVycyhzdGFydFNsb3QsIGxpbWl0KSB7XG4gICAgY29uc3QgYXJncyA9IFtzdGFydFNsb3QsIGxpbWl0XTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVycycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZykpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90IGxlYWRlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzIG9mIGEgc2lnbmF0dXJlXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlLCBjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHZhbHVlc1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1c2VzKFtzaWduYXR1cmVdLCBjb25maWcpO1xuICAgIGFzc2VydCh2YWx1ZXMubGVuZ3RoID09PSAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzdGF0dXNlcyBvZiBhIGJhdGNoIG9mIHNpZ25hdHVyZXNcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZVN0YXR1c2VzKHNpZ25hdHVyZXMsIGNvbmZpZykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtzaWduYXR1cmVzXTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBwYXJhbXMucHVzaChjb25maWcpO1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTaWduYXR1cmVTdGF0dXNlcycsIHBhcmFtcyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNpZ25hdHVyZSBzdGF0dXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gY291bnQgb2YgdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb25Db3VudCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbiBjb3VudCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCB0b3RhbCBjdXJyZW5jeSBzdXBwbHkgb2YgdGhlIGNsdXN0ZXIgaW4gbGFtcG9ydHNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuMi44LiBQbGVhc2UgdXNlIHtAbGluayBnZXRTdXBwbHl9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRUb3RhbFN1cHBseShjb21taXRtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRTdXBwbHkoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGV4Y2x1ZGVOb25DaXJjdWxhdGluZ0FjY291bnRzTGlzdDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWUudG90YWw7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNsdXN0ZXIgSW5mbGF0aW9uR292ZXJub3IgcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uR292ZXJub3IoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvbkdvdmVybm9yJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgaW5mbGF0aW9uIHJld2FyZCBmb3IgYSBsaXN0IG9mIGFkZHJlc3NlcyBmb3IgYW4gZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvblJld2FyZChhZGRyZXNzZXMsIGVwb2NoLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2FkZHJlc3Nlcy5tYXAocHVia2V5ID0+IHB1YmtleS50b0Jhc2U1OCgpKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25SZXdhcmQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SZXdhcmRSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByZXdhcmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNwZWNpZmljIGluZmxhdGlvbiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SYXRlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJhdGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJhdGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIEVwb2NoIEluZm8gcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXBvY2hJbmZvKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoSW5mbycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEVwb2NoSW5mb1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggaW5mbycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgRXBvY2ggU2NoZWR1bGUgcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXBvY2hTY2hlZHVsZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRFcG9jaFNjaGVkdWxlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIHNjaGVkdWxlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVwb2NoU2NoZWR1bGUgPSByZXMucmVzdWx0O1xuICAgIHJldHVybiBuZXcgRXBvY2hTY2hlZHVsZShlcG9jaFNjaGVkdWxlLnNsb3RzUGVyRXBvY2gsIGVwb2NoU2NoZWR1bGUubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0LCBlcG9jaFNjaGVkdWxlLndhcm11cCwgZXBvY2hTY2hlZHVsZS5maXJzdE5vcm1hbEVwb2NoLCBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsU2xvdCk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxlYWRlciBzY2hlZHVsZSBmb3IgdGhlIGN1cnJlbnQgZXBvY2hcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8TGVhZGVyU2NoZWR1bGU+Pn1cbiAgICovXG4gIGFzeW5jIGdldExlYWRlclNjaGVkdWxlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExlYWRlclNjaGVkdWxlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsZWFkZXIgc2NoZWR1bGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIG1pbmltdW0gYmFsYW5jZSBuZWVkZWQgdG8gZXhlbXB0IGFuIGFjY291bnQgb2YgYGRhdGFMZW5ndGhgXG4gICAqIHNpemUgZnJvbSByZW50XG4gICAqL1xuICBhc3luYyBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oZGF0YUxlbmd0aCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2RhdGFMZW5ndGhdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gZmV0Y2ggbWluaW11bSBiYWxhbmNlIGZvciByZW50IGV4ZW1wdGlvbicpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+Pn1cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOS4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRMYXRlc3RCbG9ja2hhc2h9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgYmxvY2toYXNoXG4gICAgICB9XG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KTtcbiAgICBjb25zdCBmZWVDYWxjdWxhdG9yID0ge1xuICAgICAgZ2V0IGxhbXBvcnRzUGVyU2lnbmF0dXJlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjYXBhYmlsaXR5IHRvIGZldGNoIGBsYW1wb3J0c1BlclNpZ25hdHVyZWAgdXNpbmcgdGhlIGBnZXRSZWNlbnRCbG9ja2hhc2hgIEFQSSBpcyAnICsgJ25vIGxvbmdlciBvZmZlcmVkIGJ5IHRoZSBuZXR3b3JrLiBVc2UgdGhlIGBnZXRGZWVGb3JNZXNzYWdlYCBBUEkgdG8gb2J0YWluIHRoZSBmZWUgJyArICdmb3IgYSBnaXZlbiBtZXNzYWdlLicpO1xuICAgICAgfSxcbiAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBibG9ja2hhc2gsXG4gICAgICAgIGZlZUNhbGN1bGF0b3JcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHJlY2VudCBwZXJmb3JtYW5jZSBzYW1wbGVzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8UGVyZlNhbXBsZT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzKGxpbWl0KSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzJywgbGltaXQgPyBbbGltaXRdIDogW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGZlZSBjYWxjdWxhdG9yIGZvciBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS45LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEZlZUZvck1lc3NhZ2V9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoKGJsb2NraGFzaCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2Jsb2NraGFzaF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmZWUgY2FsY3VsYXRvcicpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9ID0gcmVzLnJlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlLmZlZUNhbGN1bGF0b3IgOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0RmVlRm9yTWVzc2FnZShtZXNzYWdlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2UgPSB0b0J1ZmZlcihtZXNzYWdlLnNlcmlhbGl6ZSgpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbd2lyZU1lc3NhZ2VdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVGb3JNZXNzYWdlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGZvciBtZXNzYWdlJyk7XG4gICAgfVxuICAgIGlmIChyZXMucmVzdWx0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBwcmlvcml0aXphdGlvbiBmZWVzIGZyb20gcmVjZW50IGJsb2Nrcy5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcyhjb25maWcpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGNvbmZpZz8ubG9ja2VkV3JpdGFibGVBY2NvdW50cz8ubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgY29uc3QgYXJncyA9IGFjY291bnRzPy5sZW5ndGggPyBbYWNjb3VudHNdIDogW107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgcHJpb3JpdGl6YXRpb24gZmVlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTx7YmxvY2toYXNoOiBCbG9ja2hhc2gsIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3J9Pn1cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRMYXRlc3RCbG9ja2hhc2h9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRCbG9ja2hhc2goY29tbWl0bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCk7XG4gICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsYXRlc3QgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTxCbG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2toYXNoKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD59XG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExhdGVzdEJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGF0ZXN0IGJsb2NraGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBibG9ja2hhc2ggaXMgc3RpbGwgdmFsaWQgb3Igbm90XG4gICAqL1xuICBhc3luYyBpc0Jsb2NraGFzaFZhbGlkKGJsb2NraGFzaCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnaXNCbG9ja2hhc2hWYWxpZCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBibG9ja2hhc2ggYCcgKyBibG9ja2hhc2ggKyAnYGlzIHZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBub2RlIHZlcnNpb25cbiAgICovXG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VmVyc2lvbicsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFZlcnNpb25SZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2ZXJzaW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBnZW5lc2lzIGhhc2hcbiAgICovXG4gIGFzeW5jIGdldEdlbmVzaXNIYXNoKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEdlbmVzaXNIYXNoJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBnZW5lc2lzIGhhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0QmxvY2soc2xvdCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNvbmZpZz8udHJhbnNhY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgJ2FjY291bnRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9ID0gcmVzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHJlc3VsdC50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHZlcnNpb24sIHRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoZSwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgYmxvY2tcbiAgICovXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFBhcnNlZEJsb2NrKHNsb3QsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChjb25maWc/LnRyYW5zYWN0aW9uRGV0YWlscykge1xuICAgICAgICBjYXNlICdhY2NvdW50cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZEJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihlLCAnZmFpbGVkIHRvIGdldCBibG9jaycpO1xuICAgIH1cbiAgfVxuICAvKlxuICAgKiBSZXR1cm5zIHJlY2VudCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uIGZyb20gdGhlIGN1cnJlbnQgb3IgcHJldmlvdXMgZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrUHJvZHVjdGlvbihjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBsZXQgZXh0cmE7XG4gICAgbGV0IGNvbW1pdG1lbnQ7XG4gICAgaWYgKHR5cGVvZiBjb25maWdPckNvbW1pdG1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb21taXRtZW50ID0gY29uZmlnT3JDb21taXRtZW50O1xuICAgIH0gZWxzZSBpZiAoY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGMsXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH0gPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgICBjb21taXRtZW50ID0gYztcbiAgICAgIGV4dHJhID0gcmVzdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGV4dHJhKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1Byb2R1Y3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0VHJhbnNhY3Rpb25gIHVzaW5nIGFcbiAgICogYEdldFZlcnNpb25lZFRyYW5zYWN0aW9uQ29uZmlnYCBieSBzZXR0aW5nIHRoZVxuICAgKiBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oc2lnbmF0dXJlLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgLi4ucmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHJlc3VsdC52ZXJzaW9uLCByZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0VHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rIFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRUcmFuc2FjdGlvbnNgIHVzaW5nIGFcbiAgICogYEdldFZlcnNpb25lZFRyYW5zYWN0aW9uQ29uZmlnYCBieSBzZXR0aW5nIHRoZVxuICAgKiBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgLi4ucmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UocmVzdWx0LnZlcnNpb24sIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFRyYW5zYWN0aW9ucyBhbmQgdHJhbnNhY3Rpb24gc3RhdHVzZXMgZnJvbSB0aGUgY2x1c3RlclxuICAgKiBmb3IgYSBjb25maXJtZWQgYmxvY2suXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0QmxvY2t9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRCbG9jayhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBibG9jayA9IHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKHRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYmxvY2ssXG4gICAgICB0cmFuc2FjdGlvbnM6IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXRhLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbi5tZXNzYWdlLCB0cmFuc2FjdGlvbi5zaWduYXR1cmVzKVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGNvbmZpcm1lZCBibG9ja3MgYmV0d2VlbiB0d28gc2xvdHNcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrcyhzdGFydFNsb3QsIGVuZFNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChlbmRTbG90ICE9PSB1bmRlZmluZWQgPyBbc3RhcnRTbG90LCBlbmRTbG90XSA6IFtzdGFydFNsb3RdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja3MnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgU2lnbmF0dXJlcyBmcm9tIHRoZSBjbHVzdGVyIGZvciBhIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tTaWduYXR1cmVzKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwge1xuICAgICAgdHJhbnNhY3Rpb25EZXRhaWxzOiAnc2lnbmF0dXJlcycsXG4gICAgICByZXdhcmRzOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgU2lnbmF0dXJlcyBmcm9tIHRoZSBjbHVzdGVyIGZvciBhIGNvbmZpcm1lZCBibG9jaywgZXhjbHVkaW5nIHJld2FyZHNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRCbG9ja1NpZ25hdHVyZXN9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCB7XG4gICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgIHJld2FyZHM6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm1lZCBibG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFRyYW5zYWN0aW9ufSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKTtcbiAgICBjb25zdCBzaWduYXR1cmVzID0gcmVzdWx0LnRyYW5zYWN0aW9uLnNpZ25hdHVyZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbi5wb3B1bGF0ZShtZXNzYWdlLCBzaWduYXR1cmVzKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb259IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0VHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuIGFkZHJlc3NcbiAgICogd2l0aGluIGEgc3BlY2lmaWVkIHNsb3QgcmFuZ2UuIE1heCByYW5nZSBhbGxvd2VkIGlzIDEwLDAwMCBzbG90cy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuMy4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBxdWVyaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIHN0YXJ0U2xvdCBzdGFydCBzbG90LCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIGVuZFNsb3QgZW5kIHNsb3QsIGluY2x1c2l2ZVxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MoYWRkcmVzcywgc3RhcnRTbG90LCBlbmRTbG90KSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgZmlyc3RBdmFpbGFibGVCbG9jayA9IGF3YWl0IHRoaXMuZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpO1xuICAgIHdoaWxlICghKCd1bnRpbCcgaW4gb3B0aW9ucykpIHtcbiAgICAgIHN0YXJ0U2xvdC0tO1xuICAgICAgaWYgKHN0YXJ0U2xvdCA8PSAwIHx8IHN0YXJ0U2xvdCA8IGZpcnN0QXZhaWxhYmxlQmxvY2spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKHN0YXJ0U2xvdCwgJ2ZpbmFsaXplZCcpO1xuICAgICAgICBpZiAoYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0aW9ucy51bnRpbCA9IGJsb2NrLnNpZ25hdHVyZXNbYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdza2lwcGVkJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhpZ2hlc3RDb25maXJtZWRSb290ID0gYXdhaXQgdGhpcy5nZXRTbG90KCdmaW5hbGl6ZWQnKTtcbiAgICB3aGlsZSAoISgnYmVmb3JlJyBpbiBvcHRpb25zKSkge1xuICAgICAgZW5kU2xvdCsrO1xuICAgICAgaWYgKGVuZFNsb3QgPiBoaWdoZXN0Q29uZmlybWVkUm9vdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoZW5kU2xvdCk7XG4gICAgICAgIGlmIChibG9jay5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRpb25zLmJlZm9yZSA9IGJsb2NrLnNpZ25hdHVyZXNbYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdza2lwcGVkJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29uZmlybWVkU2lnbmF0dXJlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyKGFkZHJlc3MsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb25maXJtZWRTaWduYXR1cmVJbmZvLm1hcChpbmZvID0+IGluZm8uc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuXG4gICAqIGFkZHJlc3MgYmFja3dhcmRzIGluIHRpbWUgZnJvbSB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlIG9yIG1vc3QgcmVjZW50IGNvbmZpcm1lZCBibG9ja1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyKGFkZHJlc3MsIG9wdGlvbnMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbYWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MoYWRkcmVzcywgb3B0aW9ucywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFthZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZXNGb3JBZGRyZXNzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNpZ25hdHVyZXMgZm9yIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0xvb2t1cFRhYmxlKGFjY291bnRLZXksIGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogYWNjb3VudEluZm9cbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQoYWNjb3VudEtleSwgY29uZmlnKTtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmIChhY2NvdW50SW5mbyAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBuZXcgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCh7XG4gICAgICAgIGtleTogYWNjb3VudEtleSxcbiAgICAgICAgc3RhdGU6IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQuZGVzZXJpYWxpemUoYWNjb3VudEluZm8uZGF0YSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY29udGVudHMgb2YgYSBOb25jZSBhY2NvdW50IGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogYWNjb3VudEluZm9cbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IE5vbmNlQWNjb3VudC5mcm9tQWNjb3VudERhdGEoYWNjb3VudEluZm8uZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2Uobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpLnRoZW4oeCA9PiB4LnZhbHVlKS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBub25jZSBmb3IgYWNjb3VudCAnICsgbm9uY2VBY2NvdW50LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCBhbiBhbGxvY2F0aW9uIG9mIGxhbXBvcnRzIHRvIHRoZSBzcGVjaWZpZWQgYWRkcmVzc1xuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSwgTEFNUE9SVFNfUEVSX1NPTCB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbiAgICpcbiAgICogKGFzeW5jICgpID0+IHtcbiAgICogICBjb25zdCBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oXCJodHRwczovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb21cIiwgXCJjb25maXJtZWRcIik7XG4gICAqICAgY29uc3QgbXlBZGRyZXNzID0gbmV3IFB1YmxpY0tleShcIjJucjFiSEZUODZXOXRHbnl2bVlXNHZjSEtzUUIzc1ZRZm5kZGFzejRrRXhNXCIpO1xuICAgKiAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdEFpcmRyb3AobXlBZGRyZXNzLCBMQU1QT1JUU19QRVJfU09MKTtcbiAgICogICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUpO1xuICAgKiB9KSgpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHJlcXVlc3RBaXJkcm9wKHRvLCBsYW1wb3J0cykge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3JlcXVlc3RBaXJkcm9wJywgW3RvLnRvQmFzZTU4KCksIGxhbXBvcnRzXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBhaXJkcm9wIHRvICR7dG8udG9CYXNlNTgoKX0gZmFpbGVkYCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpIHtcbiAgICBpZiAoIWRpc2FibGVDYWNoZSkge1xuICAgICAgLy8gV2FpdCBmb3IgcG9sbGluZyB0byBmaW5pc2hcbiAgICAgIHdoaWxlICh0aGlzLl9wb2xsaW5nQmxvY2toYXNoKSB7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lU2luY2VGZXRjaCA9IERhdGUubm93KCkgLSB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhc3RGZXRjaDtcbiAgICAgIGNvbnN0IGV4cGlyZWQgPSB0aW1lU2luY2VGZXRjaCA+PSBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUztcbiAgICAgIGlmICh0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaCAhPT0gbnVsbCAmJiAhZXhwaXJlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2g7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9wb2xsTmV3QmxvY2toYXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfcG9sbE5ld0Jsb2NraGFzaCgpIHtcbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGNhY2hlZExhdGVzdEJsb2NraGFzaCA9IHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoO1xuICAgICAgY29uc3QgY2FjaGVkQmxvY2toYXNoID0gY2FjaGVkTGF0ZXN0QmxvY2toYXNoID8gY2FjaGVkTGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCA6IG51bGw7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2goJ2ZpbmFsaXplZCcpO1xuICAgICAgICBpZiAoY2FjaGVkQmxvY2toYXNoICE9PSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoKSB7XG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mbyA9IHtcbiAgICAgICAgICAgIGxhdGVzdEJsb2NraGFzaCxcbiAgICAgICAgICAgIGxhc3RGZXRjaDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uU2lnbmF0dXJlczogW10sXG4gICAgICAgICAgICBzaW11bGF0ZWRTaWduYXR1cmVzOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGxhdGVzdEJsb2NraGFzaDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGZvciBhcHByb3hpbWF0ZWx5IGhhbGYgYSBzbG90XG4gICAgICAgIGF3YWl0IHNsZWVwKE1TX1BFUl9TTE9UIC8gMik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBvYnRhaW4gYSBuZXcgYmxvY2toYXNoIGFmdGVyICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWc6IGNvbmZpZ0FyZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnQXJnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBzdGFrZSBtaW5pbXVtIGRlbGVnYXRpb25gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzaW11bGF0ZVRyYW5zYWN0aW9ufSB3aXRoIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvbn0gYW5kIHtAbGluayBTaW11bGF0ZVRyYW5zYWN0aW9uQ29uZmlnfSBwYXJhbWV0ZXJzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk9yTWVzc2FnZSwgY29uZmlnT3JTaWduZXJzLCBpbmNsdWRlQWNjb3VudHMpIHtcbiAgICBpZiAoJ21lc3NhZ2UnIGluIHRyYW5zYWN0aW9uT3JNZXNzYWdlKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uZWRUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdmVyc2lvbmVkVHguc2VyaWFsaXplKCk7XG4gICAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSBCdWZmZXIuZnJvbSh3aXJlVHJhbnNhY3Rpb24pLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZ09yU2lnbmVycykgfHwgaW5jbHVkZUFjY291bnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uZmlnID0gY29uZmlnT3JTaWduZXJzIHx8IHt9O1xuICAgICAgY29uZmlnLmVuY29kaW5nID0gJ2Jhc2U2NCc7XG4gICAgICBpZiAoISgnY29tbWl0bWVudCcgaW4gY29uZmlnKSkge1xuICAgICAgICBjb25maWcuY29tbWl0bWVudCA9IHRoaXMuY29tbWl0bWVudDtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWdPclNpZ25lcnMgJiYgdHlwZW9mIGNvbmZpZ09yU2lnbmVycyA9PT0gJ29iamVjdCcgJiYgJ2lubmVySW5zdHJ1Y3Rpb25zJyBpbiBjb25maWdPclNpZ25lcnMpIHtcbiAgICAgICAgY29uZmlnLmlubmVySW5zdHJ1Y3Rpb25zID0gY29uZmlnT3JTaWduZXJzLmlubmVySW5zdHJ1Y3Rpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzaW11bGF0ZSB0cmFuc2FjdGlvbjogJyArIHJlcy5lcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgaWYgKHRyYW5zYWN0aW9uT3JNZXNzYWdlIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcbiAgICAgIGxldCBvcmlnaW5hbFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBvcmlnaW5hbFR4LmZlZVBheWVyO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2UuaW5zdHJ1Y3Rpb25zO1xuICAgICAgdHJhbnNhY3Rpb24ubm9uY2VJbmZvID0gb3JpZ2luYWxUeC5ub25jZUluZm87XG4gICAgICB0cmFuc2FjdGlvbi5zaWduYXR1cmVzID0gb3JpZ2luYWxUeC5zaWduYXR1cmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLnBvcHVsYXRlKHRyYW5zYWN0aW9uT3JNZXNzYWdlKTtcbiAgICAgIC8vIEhBQ0s6IHRoaXMgZnVuY3Rpb24gcmVsaWVzIG9uIG11dGF0aW5nIHRoZSBwb3B1bGF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gdHJhbnNhY3Rpb24uX2pzb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChjb25maWdPclNpZ25lcnMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb25maWdPclNpZ25lcnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBjb25maWdPclNpZ25lcnM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm5vbmNlSW5mbyAmJiBzaWduZXJzKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGlzYWJsZUNhY2hlID0gdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmc7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgaWYgKCFzaWduZXJzKSBicmVhaztcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRyYW5zYWN0aW9uLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkgJiYgIXRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWNlbnRCbG9ja2hhc2gsIGFsbCBkb25lLiBMZXQncyBicmVha1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdHJhbnNhY3Rpb24uX2NvbXBpbGUoKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gd2lyZVRyYW5zYWN0aW9uLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICBjb21taXRtZW50OiB0aGlzLmNvbW1pdG1lbnRcbiAgICB9O1xuICAgIGlmIChpbmNsdWRlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IChBcnJheS5pc0FycmF5KGluY2x1ZGVBY2NvdW50cykgPyBpbmNsdWRlQWNjb3VudHMgOiBtZXNzYWdlLm5vblByb2dyYW1JZHMoKSkubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgICBjb25maWdbJ2FjY291bnRzJ10gPSB7XG4gICAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgICAgYWRkcmVzc2VzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2lnbmVycykge1xuICAgICAgY29uZmlnLnNpZ1ZlcmlmeSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjb25maWdPclNpZ25lcnMgJiYgdHlwZW9mIGNvbmZpZ09yU2lnbmVycyA9PT0gJ29iamVjdCcgJiYgJ2lubmVySW5zdHJ1Y3Rpb25zJyBpbiBjb25maWdPclNpZ25lcnMpIHtcbiAgICAgIGNvbmZpZy5pbm5lckluc3RydWN0aW9ucyA9IGNvbmZpZ09yU2lnbmVycy5pbm5lckluc3RydWN0aW9ucztcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2ltdWxhdGVUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgbGV0IGxvZ3M7XG4gICAgICBpZiAoJ2RhdGEnIGluIHJlcy5lcnJvcikge1xuICAgICAgICBsb2dzID0gcmVzLmVycm9yLmRhdGEubG9ncztcbiAgICAgICAgaWYgKGxvZ3MgJiYgQXJyYXkuaXNBcnJheShsb2dzKSkge1xuICAgICAgICAgIGNvbnN0IHRyYWNlSW5kZW50ID0gJ1xcbiAgICAnO1xuICAgICAgICAgIGNvbnN0IGxvZ1RyYWNlID0gdHJhY2VJbmRlbnQgKyBsb2dzLmpvaW4odHJhY2VJbmRlbnQpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzLmVycm9yLm1lc3NhZ2UsIGxvZ1RyYWNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6ICcnLFxuICAgICAgICB0cmFuc2FjdGlvbk1lc3NhZ2U6IHJlcy5lcnJvci5tZXNzYWdlLFxuICAgICAgICBsb2dzOiBsb2dzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNlbmRUcmFuc2FjdGlvbn0gd2l0aCBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvbn1cbiAgICovXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVyc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIGlmICgndmVyc2lvbicgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmIChzaWduZXJzT3JPcHRpb25zICYmIEFycmF5LmlzQXJyYXkoc2lnbmVyc09yT3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHNpZ25lcnNPck9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCAhQXJyYXkuaXNBcnJheShzaWduZXJzT3JPcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gc2lnbmVyc09yT3B0aW9ucztcbiAgICBpZiAodHJhbnNhY3Rpb24ubm9uY2VJbmZvKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGlzYWJsZUNhY2hlID0gdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmc7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRyYW5zYWN0aW9uLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2YgdGhpcyB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gc2VlbiBiZWZvcmUgd2l0aCB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHJlY2VudEJsb2NraGFzaCwgYWxsIGRvbmUuIExldCdzIGJyZWFrXG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgIC8vIG1hdGNoZWQgdG8gb25lIG9mIGFscmVhZHkgcmVjb3JkZWQgc2lnbmF0dXJlcykuXG4gICAgICAgICAgLy8gU28sIHdlIG11c3QgZmV0Y2ggYSBuZXcgYmxvY2toYXNoIGZvciBhIGRpZmZlcmVudCBzaWduYXR1cmUgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgIGRpc2FibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZFJhd1RyYW5zYWN0aW9uKHdpcmVUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzaWduZWQgYW5kIHNlcmlhbGl6ZWQgaW50byB0aGVcbiAgICogd2lyZSBmb3JtYXRcbiAgICovXG4gIGFzeW5jIHNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IHRvQnVmZmVyKHJhd1RyYW5zYWN0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kRW5jb2RlZFRyYW5zYWN0aW9uKGVuY29kZWRUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNpZ25lZCwgc2VyaWFsaXplZCBpbnRvIHRoZVxuICAgKiB3aXJlIGZvcm1hdCwgYW5kIGVuY29kZWQgYXMgYSBiYXNlNjQgc3RyaW5nXG4gICAqL1xuICBhc3luYyBzZW5kRW5jb2RlZFRyYW5zYWN0aW9uKGVuY29kZWRUcmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGVuY29kaW5nOiAnYmFzZTY0J1xuICAgIH07XG4gICAgY29uc3Qgc2tpcFByZWZsaWdodCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwUHJlZmxpZ2h0O1xuICAgIGNvbnN0IHByZWZsaWdodENvbW1pdG1lbnQgPSBza2lwUHJlZmxpZ2h0ID09PSB0cnVlID8gJ3Byb2Nlc3NlZCcgLy8gRklYTUUgUmVtb3ZlIHdoZW4gaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2FnYXZlL3B1bGwvNDgzIGlzIGRlcGxveWVkLlxuICAgIDogb3B0aW9ucyAmJiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50O1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgICBjb25maWcubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5taW5Db250ZXh0U2xvdCAhPSBudWxsKSB7XG4gICAgICBjb25maWcubWluQ29udGV4dFNsb3QgPSBvcHRpb25zLm1pbkNvbnRleHRTbG90O1xuICAgIH1cbiAgICBpZiAoc2tpcFByZWZsaWdodCkge1xuICAgICAgY29uZmlnLnNraXBQcmVmbGlnaHQgPSBza2lwUHJlZmxpZ2h0O1xuICAgIH1cbiAgICBpZiAocHJlZmxpZ2h0Q29tbWl0bWVudCkge1xuICAgICAgY29uZmlnLnByZWZsaWdodENvbW1pdG1lbnQgPSBwcmVmbGlnaHRDb21taXRtZW50O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzZW5kVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgbGV0IGxvZ3MgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoJ2RhdGEnIGluIHJlcy5lcnJvcikge1xuICAgICAgICBsb2dzID0gcmVzLmVycm9yLmRhdGEubG9ncztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogc2tpcFByZWZsaWdodCA/ICdzZW5kJyA6ICdzaW11bGF0ZScsXG4gICAgICAgIHNpZ25hdHVyZTogJycsXG4gICAgICAgIHRyYW5zYWN0aW9uTWVzc2FnZTogcmVzLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGxvZ3M6IGxvZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uT3BlbigpIHtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIC8vIFBpbmcgc2VydmVyIGV2ZXJ5IDVzIHRvIHByZXZlbnQgaWRsZSB0aW1lb3V0c1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9ycGNXZWJTb2NrZXQubm90aWZ5KCdwaW5nJyk7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH0pKCk7XG4gICAgfSwgNTAwMCk7XG4gICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25FcnJvcihlcnIpIHtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBjb25zb2xlLmVycm9yKCd3cyBlcnJvcjonLCBlcnIubWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkNsb3NlKGNvZGUpIHtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uID0gKHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gKyAxKSAlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDEwMDApIHtcbiAgICAgIC8vIGV4cGxpY2l0IGNsb3NlLCBjaGVjayBpZiBhbnkgc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gbWFkZSBzaW5jZSBjbG9zZVxuICAgICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGltcGxpY2l0IGNsb3NlLCBwcmVwYXJlIHN1YnNjcmlwdGlvbnMgZm9yIGF1dG8tcmVjb25uZWN0XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2gpLmZvckVhY2goKFtoYXNoLCBzdWJzY3JpcHRpb25dKSA9PiB7XG4gICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgIHN0YXRlOiAncGVuZGluZydcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NldFN1YnNjcmlwdGlvbihoYXNoLCBuZXh0U3Vic2NyaXB0aW9uKSB7XG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXT8uc3RhdGU7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXSA9IG5leHRTdWJzY3JpcHRpb247XG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbmV4dFN1YnNjcmlwdGlvbi5zdGF0ZSkge1xuICAgICAgY29uc3Qgc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtoYXNoXTtcbiAgICAgIGlmIChzdGF0ZUNoYW5nZUNhbGxiYWNrcykge1xuICAgICAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2IobmV4dFN1YnNjcmlwdGlvbi5zdGF0ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlKGNsaWVudFN1YnNjcmlwdGlvbklkLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgaWYgKGhhc2ggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdIHx8PSBuZXcgU2V0KCk7XG4gICAgc3RhdGVDaGFuZ2VDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RhdGVDaGFuZ2VDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIGlmIChzdGF0ZUNoYW5nZUNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtoYXNoXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2gpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gc3dhbGxvdyBlcnJvciBpZiBzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yIHdoZW4gY2xvc2luZyBzb2NrZXQgY29ubmVjdGlvbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXQuY29ubmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uID0gdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbjtcbiAgICBjb25zdCBpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiA9PT0gdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbjtcbiAgICB9O1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIC8vIERvbid0IGJlIHRlbXB0ZWQgdG8gY2hhbmdlIHRoaXMgdG8gYE9iamVjdC5lbnRyaWVzYC4gV2UgY2FsbFxuICAgIC8vIGBfdXBkYXRlU3Vic2NyaXB0aW9uc2AgcmVjdXJzaXZlbHkgd2hlbiBwcm9jZXNzaW5nIHRoZSBzdGF0ZSxcbiAgICAvLyBzbyBpdCdzIGltcG9ydGFudCB0aGF0IHdlIGxvb2sgdXAgdGhlICpjdXJyZW50KiB2ZXJzaW9uIG9mXG4gICAgLy8gZWFjaCBzdWJzY3JpcHRpb24sIGV2ZXJ5IHRpbWUgd2UgcHJvY2VzcyBhIGhhc2guXG4gICAgT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkubWFwKGFzeW5jIGhhc2ggPT4ge1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBUaGlzIGVudHJ5IGhhcyBzaW5jZSBiZWVuIGRlbGV0ZWQuIFNraXAuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICBjYXNlICd1bnN1YnNjcmliZWQnOlxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogWW91IGNhbiBlbmQgdXAgaGVyZSB3aGVuOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC0gYSBzdWJzY3JpcHRpb24gaGFzIHJlY2VudGx5IHVuc3Vic2NyaWJlZFxuICAgICAgICAgICAgICogICB3aXRob3V0IGhhdmluZyBuZXcgY2FsbGJhY2tzIGFkZGVkIHRvIGl0XG4gICAgICAgICAgICAgKiAgIHdoaWxlIHRoZSB1bnN1YnNjcmliZSB3YXMgaW4gZmxpZ2h0LCBvclxuICAgICAgICAgICAgICogLSB3aGVuIGEgcGVuZGluZyBzdWJzY3JpcHRpb24gaGFzIGl0c1xuICAgICAgICAgICAgICogICBsaXN0ZW5lcnMgcmVtb3ZlZCBiZWZvcmUgYSByZXF1ZXN0IHdhc1xuICAgICAgICAgICAgICogICBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQmVpbmcgdGhhdCBub2JvZHkgaXMgaW50ZXJlc3RlZCBpbiB0aGlzXG4gICAgICAgICAgICAgKiBzdWJzY3JpcHRpb24gYW55IGxvbmdlciwgZGVsZXRlIGl0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uc3RhdGUgPT09ICd1bnN1YnNjcmliZWQnKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3N1YnNjcmlwdGlvbi5zZXJ2ZXJTdWJzY3JpcHRpb25JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgIG1ldGhvZFxuICAgICAgICAgICAgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdWJzY3JpcHRpb25JZCA9IGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5jYWxsKG1ldGhvZCwgYXJncyk7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHNlcnZlclN1YnNjcmlwdGlvbklkLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Vic2NyaWJlZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbc2VydmVyU3Vic2NyaXB0aW9uSWRdID0gc3Vic2NyaXB0aW9uLmNhbGxiYWNrcztcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBSZWNlaXZlZCAke2UgaW5zdGFuY2VvZiBFcnJvciA/ICcnIDogJ0pTT04tUlBDICd9ZXJyb3IgY2FsbGluZyBcXGAke21ldGhvZH1cXGBgLCB7XG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKCFpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUT0RPOiBNYXliZSBhZGQgYW4gJ2Vycm9yZWQnIHN0YXRlIG9yIGEgcmV0cnkgbGltaXQ/XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAncGVuZGluZydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdWJzY3JpYmVkJzpcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvLyBCeSB0aGUgdGltZSB3ZSBzdWNjZXNzZnVsbHkgc2V0IHVwIGEgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBzZXJ2ZXIsIHRoZSBjbGllbnQgc3RvcHBlZCBjYXJpbmcgYWJvdXQgaXQuXG4gICAgICAgICAgICAvLyBUZWFyIGl0IGRvd24gbm93LlxuICAgICAgICAgICAgYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHNlcnZlclN1YnNjcmlwdGlvbklkLFxuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlTWV0aG9kXG4gICAgICAgICAgICAgIH0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuaGFzKHNlcnZlclN1YnNjcmlwdGlvbklkKSkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFNwZWNpYWwgY2FzZS5cbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzdWJzY3JpcHRpb24gdGhhdCBoYXMgYmVlbiBhdXRvLVxuICAgICAgICAgICAgICAgICAqIGRpc3Bvc2VkIGJ5IHRoZSBSUEMsIHRoZW4gd2UgY2FuIHNraXAgdGhlIFJQQyBjYWxsIHRvXG4gICAgICAgICAgICAgICAgICogdGVhciBkb3duIHRoZSBzdWJzY3JpcHRpb24gaGVyZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmRlbGV0ZShzZXJ2ZXJTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ycGNXZWJTb2NrZXQuY2FsbCh1bnN1YnNjcmliZU1ldGhvZCwgW3NlcnZlclN1YnNjcmlwdGlvbklkXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke3Vuc3Vic2NyaWJlTWV0aG9kfSBlcnJvcjpgLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYXliZSBhZGQgYW4gJ2Vycm9yZWQnIHN0YXRlIG9yIGEgcmV0cnkgbGltaXQ/XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Vic2NyaWJlZCdcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJlZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc2VydmVyU3Vic2NyaXB0aW9uSWQsIGNhbGxiYWNrQXJncykge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbc2VydmVyU3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjYihcbiAgICAgICAgLy8gSSBmYWlsZWQgdG8gZmluZCBhIHdheSB0byBjb252aW5jZSBUeXBlU2NyaXB0IHRoYXQgYGNiYCBpcyBvZiB0eXBlXG4gICAgICAgIC8vIGBUQ2FsbGJhY2tgIHdoaWNoIGlzIGNlcnRhaW5seSBjb21wYXRpYmxlIHdpdGggYFBhcmFtZXRlcnM8VENhbGxiYWNrPmAuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ3NjE1XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgLi4uY2FsbGJhY2tBcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdC52YWx1ZSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9tYWtlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkNvbmZpZyxcbiAgLyoqXG4gICAqIFdoZW4gcHJlcGFyaW5nIGBhcmdzYCBmb3IgYSBjYWxsIHRvIGBfbWFrZVN1YnNjcmlwdGlvbmAsIGJlIHN1cmVcbiAgICogdG8gY2FyZWZ1bGx5IGFwcGx5IGEgZGVmYXVsdCBgY29tbWl0bWVudGAgcHJvcGVydHksIGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogLSBJZiB0aGUgdXNlciBzdXBwbGllZCBhIGBjb21taXRtZW50YCB1c2UgdGhhdC5cbiAgICogLSBPdGhlcndpc2UsIGlmIHRoZSBgQ29ubmVjdGlvbjo6Y29tbWl0bWVudGAgaXMgc2V0LCB1c2UgdGhhdC5cbiAgICogLSBPdGhlcndpc2UsIHNldCBpdCB0byB0aGUgUlBDIHNlcnZlciBkZWZhdWx0OiBgZmluYWxpemVkYC5cbiAgICpcbiAgICogVGhpcyBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRvIGVuc3VyZSB0aGF0IHRoZXNlIHR3byBmdW5kYW1lbnRhbGx5XG4gICAqIGlkZW50aWNhbCBzdWJzY3JpcHRpb25zIHByb2R1Y2UgdGhlIHNhbWUgaWRlbnRpZnlpbmcgaGFzaDpcbiAgICpcbiAgICogLSBBIHN1YnNjcmlwdGlvbiBtYWRlIHdpdGhvdXQgc3BlY2lmeWluZyBhIGNvbW1pdG1lbnQuXG4gICAqIC0gQSBzdWJzY3JpcHRpb24gbWFkZSB3aGVyZSB0aGUgY29tbWl0bWVudCBzcGVjaWZpZWQgaXMgdGhlIHNhbWVcbiAgICogICBhcyB0aGUgZGVmYXVsdCBhcHBsaWVkIHRvIHRoZSBzdWJzY3JpcHRpb24gYWJvdmUuXG4gICAqXG4gICAqIEV4YW1wbGU7IHRoZXNlIHR3byBzdWJzY3JpcHRpb25zIG11c3QgcHJvZHVjZSB0aGUgc2FtZSBoYXNoOlxuICAgKlxuICAgKiAtIEFuIGBhY2NvdW50U3Vic2NyaWJlYCBzdWJzY3JpcHRpb24gZm9yIGAnUFVCS0VZJ2BcbiAgICogLSBBbiBgYWNjb3VudFN1YnNjcmliZWAgc3Vic2NyaXB0aW9uIGZvciBgJ1BVQktFWSdgIHdpdGggY29tbWl0bWVudFxuICAgKiAgIGAnZmluYWxpemVkJ2AuXG4gICAqXG4gICAqIFNlZSB0aGUgJ21ha2luZyBhIHN1YnNjcmlwdGlvbiB3aXRoIGRlZmF1bHRlZCBwYXJhbXMgb21pdHRlZCcgdGVzdFxuICAgKiBpbiBgY29ubmVjdGlvbi1zdWJzY3JpcHRpb25zLnRzYCBmb3IgbW9yZS5cbiAgICovXG4gIGFyZ3MpIHtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX25leHRDbGllbnRTdWJzY3JpcHRpb25JZCsrO1xuICAgIGNvbnN0IGhhc2ggPSBmYXN0U3RhYmxlU3RyaW5naWZ5KFtzdWJzY3JpcHRpb25Db25maWcubWV0aG9kLCBhcmdzXSk7XG4gICAgY29uc3QgZXhpc3RpbmdTdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgIGlmIChleGlzdGluZ1N1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0ge1xuICAgICAgICAuLi5zdWJzY3JpcHRpb25Db25maWcsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNhbGxiYWNrczogbmV3IFNldChbc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrXSksXG4gICAgICAgIHN0YXRlOiAncGVuZGluZydcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nU3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5hZGQoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICB9XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdID0gaGFzaDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF0gPSBhc3luYyAoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBhc3NlcnQoc3Vic2NyaXB0aW9uICE9PSB1bmRlZmluZWQsIGBDb3VsZCBub3QgZmluZCBhIFxcYFN1YnNjcmlwdGlvblxcYCB3aGVuIHRlYXJpbmcgZG93biBjbGllbnQgc3Vic2NyaXB0aW9uICMke2NsaWVudFN1YnNjcmlwdGlvbklkfWApO1xuICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5kZWxldGUoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgYWNjb3VudCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBwdWJsaWNLZXkgUHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuXG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBwYXNzIGluIGFuIHtAbGluayBBY2NvdW50U3Vic2NyaXB0aW9uQ29uZmlnfSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBvbkFjY291bnRDaGFuZ2UocHVibGljS2V5LCBjYWxsYmFjaywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyxcbiAgICAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICdiYXNlNjQnLCBjb25maWcpO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnYWNjb3VudFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2FjY291bnRVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGFuIGFjY291bnQgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZUFjY291bnRDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnYWNjb3VudCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbe1xuICAgICAgYWNjb3VudElkOiByZXN1bHQudmFsdWUucHVia2V5LFxuICAgICAgYWNjb3VudEluZm86IHJlc3VsdC52YWx1ZS5hY2NvdW50XG4gICAgfSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgYWNjb3VudHMgb3duZWQgYnkgdGhlXG4gICAqIHNwZWNpZmllZCBwcm9ncmFtIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgb2YgdGhlIHByb2dyYW0gdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBhY2NvdW50IGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIGNvbmZpZ1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cblxuICAvKiogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgcGFzcyBpbiBhIHtAbGluayBQcm9ncmFtQWNjb3VudFN1YnNjcmlwdGlvbkNvbmZpZ30gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgb25Qcm9ncmFtQWNjb3VudENoYW5nZShwcm9ncmFtSWQsIGNhbGxiYWNrLCBjb21taXRtZW50T3JDb25maWcsIG1heWJlRmlsdGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0JyAvKiBlbmNvZGluZyAqLywgY29uZmlnID8gY29uZmlnIDogbWF5YmVGaWx0ZXJzID8ge1xuICAgICAgZmlsdGVyczogYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMobWF5YmVGaWx0ZXJzKVxuICAgIH0gOiB1bmRlZmluZWQgLyogZXh0cmEgKi8pO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAncHJvZ3JhbVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Byb2dyYW1VbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGFuIGFjY291bnQgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVByb2dyYW1BY2NvdW50Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3Byb2dyYW0gYWNjb3VudCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIGxvZ3MgYXJlIGVtaXR0ZWQuXG4gICAqL1xuICBvbkxvZ3MoZmlsdGVyLCBjYWxsYmFjaywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3R5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8ge1xuICAgICAgbWVudGlvbnM6IFtmaWx0ZXIudG9TdHJpbmcoKV1cbiAgICB9IDogZmlsdGVyXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ2xvZ3NTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdsb2dzVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIGxvZ3MgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXIuXG4gICAqL1xuICBhc3luYyByZW1vdmVPbkxvZ3NMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnbG9ncycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Mb2dzTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBMb2dzTm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0LnZhbHVlLCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TbG90Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBTbG90Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gc2xvdCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHNsb3QgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TbG90Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdzbG90U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2xvdFVuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBzbG90IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3Nsb3QgY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gc2xvdCB1cGRhdGVzLiB7QGxpbmsgU2xvdFVwZGF0ZX0nc1xuICAgKiBtYXkgYmUgdXNlZnVsIHRvIHRyYWNrIGxpdmUgcHJvZ3Jlc3Mgb2YgYSBjbHVzdGVyLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBzbG90IHVwZGF0ZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2xvdFVwZGF0ZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnc2xvdHNVcGRhdGVzU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2xvdHNVcGRhdGVzVW5zdWJzY3JpYmUnXG4gICAgfSwgW10gLyogYXJncyAqLyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNsb3QgdXBkYXRlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3Nsb3QgdXBkYXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIGFzeW5jIF91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgc3Vic2NyaXB0aW9uTmFtZSkge1xuICAgIGNvbnN0IGRpc3Bvc2UgPSB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgaWYgKGRpc3Bvc2UpIHtcbiAgICAgIGF3YWl0IGRpc3Bvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdJZ25vcmVkIHVuc3Vic2NyaWJlIHJlcXVlc3QgYmVjYXVzZSBhbiBhY3RpdmUgc3Vic2NyaXB0aW9uIHdpdGggaWQgJyArIGBcXGAke2NsaWVudFN1YnNjcmlwdGlvbklkfVxcYCBmb3IgJyR7c3Vic2NyaXB0aW9uTmFtZX0nIGV2ZW50cyBgICsgJ2NvdWxkIG5vdCBiZSBmb3VuZC4nKTtcbiAgICB9XG4gIH1cbiAgX2J1aWxkQXJncyhhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKSB7XG4gICAgY29uc3QgY29tbWl0bWVudCA9IG92ZXJyaWRlIHx8IHRoaXMuX2NvbW1pdG1lbnQ7XG4gICAgaWYgKGNvbW1pdG1lbnQgfHwgZW5jb2RpbmcgfHwgZXh0cmEpIHtcbiAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgICAgb3B0aW9ucy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgb3B0aW9ucy5jb21taXRtZW50ID0gY29tbWl0bWVudDtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYSkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCBleHRyYSk7XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2gob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSkge1xuICAgIGNvbnN0IGNvbW1pdG1lbnQgPSBvdmVycmlkZSB8fCB0aGlzLl9jb21taXRtZW50O1xuICAgIGlmIChjb21taXRtZW50ICYmICFbJ2NvbmZpcm1lZCcsICdmaW5hbGl6ZWQnXS5pbmNsdWRlcyhjb21taXRtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2luZyBDb25uZWN0aW9uIHdpdGggZGVmYXVsdCBjb21taXRtZW50OiBgJyArIHRoaXMuX2NvbW1pdG1lbnQgKyAnYCwgYnV0IG1ldGhvZCByZXF1aXJlcyBhdCBsZWFzdCBgY29uZmlybWVkYCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNpZ25hdHVyZU5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gJ3JlY2VpdmVkU2lnbmF0dXJlJykge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICAgKiBBZnRlciBhIHNpZ25hdHVyZSBpcyBwcm9jZXNzZWQsIFJQQ3MgYXV0b21hdGljYWxseSBkaXNwb3NlIG9mIHRoZVxuICAgICAgICogc3Vic2NyaXB0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gV2UgbmVlZCB0byB0cmFjayB3aGljaCBvZiB0aGVzZVxuICAgICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICAgKiB3aGV0aGVyIHRoZSBjbGllbnQgaXMgZGVhbGluZyB3aXRoIGEgbm90LXlldC1wcm9jZXNzZWQgc2lnbmF0dXJlXG4gICAgICAgKiAoaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHRlYXIgZG93biB0aGUgc2VydmVyIHN1YnNjcmlwdGlvbikgb3IgYW5cbiAgICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgICAqIGNsZWFyIG91dCB0aGUgc3Vic2NyaXB0aW9uIGxvY2FsbHkgd2l0aG91dCB0ZWxsaW5nIHRoZSBzZXJ2ZXIpLlxuICAgICAgICpcbiAgICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAqL1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCByZXN1bHQudmFsdWUgPT09ICdyZWNlaXZlZFNpZ25hdHVyZScgPyBbe1xuICAgICAgdHlwZTogJ3JlY2VpdmVkJ1xuICAgIH0sIHJlc3VsdC5jb250ZXh0XSA6IFt7XG4gICAgICB0eXBlOiAnc3RhdHVzJyxcbiAgICAgIHJlc3VsdDogcmVzdWx0LnZhbHVlXG4gICAgfSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzaWduYXR1cmUgdXBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBzdHJpbmcgaW4gYmFzZSA1OFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIG9uIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSBjb21taXRtZW50IFNwZWNpZnkgdGhlIGNvbW1pdG1lbnQgbGV2ZWwgc2lnbmF0dXJlIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TaWduYXR1cmUoc2lnbmF0dXJlLCBjYWxsYmFjaywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICk7XG4gICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrOiAobm90aWZpY2F0aW9uLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmIChub3RpZmljYXRpb24udHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgICAgICBjYWxsYmFjayhub3RpZmljYXRpb24ucmVzdWx0LCBjb250ZXh0KTtcbiAgICAgICAgICAvLyBTaWduYXR1cmVzIHN1YnNjcmlwdGlvbnMgYXJlIGF1dG8tcmVtb3ZlZCBieSB0aGUgUlBDIHNlcnZpY2VcbiAgICAgICAgICAvLyBzbyBubyBuZWVkIHRvIGV4cGxpY2l0bHkgc2VuZCBhbiB1bnN1YnNjcmliZSBtZXNzYWdlLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2Q6ICdzaWduYXR1cmVTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYSB0cmFuc2FjdGlvbiBpc1xuICAgKiByZWNlaXZlZCBhbmQvb3IgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBzdHJpbmcgaW4gYmFzZSA1OFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIG9uIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zIEVuYWJsZSByZWNlaXZlZCBub3RpZmljYXRpb25zIGFuZCBzZXQgdGhlIGNvbW1pdG1lbnRcbiAgICogICBsZXZlbCB0aGF0IHNpZ25hdHVyZSBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2lnbmF0dXJlV2l0aE9wdGlvbnMoc2lnbmF0dXJlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAuLi5leHRyYVxuICAgIH0gPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY29tbWl0bWVudDogb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBleHRyYSk7XG4gICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrOiAobm90aWZpY2F0aW9uLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKG5vdGlmaWNhdGlvbiwgY29udGV4dCk7XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc3Vic2NyaXB0aW9ucyBhcmUgYXV0by1yZW1vdmVkIGJ5IHRoZSBSUEMgc2VydmljZVxuICAgICAgICAvLyBzbyBubyBuZWVkIHRvIGV4cGxpY2l0bHkgc2VuZCBhbiB1bnN1YnNjcmliZSBtZXNzYWdlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkLlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kOiAnc2lnbmF0dXJlU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2lnbmF0dXJlVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBzaWduYXR1cmUgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzaWduYXR1cmUgcmVzdWx0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblJvb3ROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFJvb3ROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiByb290IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgcm9vdCBjaGFuZ2VzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblJvb3RDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Jvb3RTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdyb290VW5zdWJzY3JpYmUnXG4gICAgfSwgW10gLyogYXJncyAqLyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHJvb3Qgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVJvb3RDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAncm9vdCBjaGFuZ2UnKTtcbiAgfVxufVxuXG4vKipcbiAqIEtleXBhaXIgc2lnbmVyIGludGVyZmFjZVxuICovXG5cbi8qKlxuICogQW4gYWNjb3VudCBrZXlwYWlyIHVzZWQgZm9yIHNpZ25pbmcgdHJhbnNhY3Rpb25zLlxuICovXG5jbGFzcyBLZXlwYWlyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBrZXlwYWlyIGluc3RhbmNlLlxuICAgKiBHZW5lcmF0ZSByYW5kb20ga2V5cGFpciBpZiBubyB7QGxpbmsgRWQyNTUxOUtleXBhaXJ9IGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0VkMjU1MTlLZXlwYWlyfSBrZXlwYWlyIGVkMjU1MTkga2V5cGFpclxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5cGFpcikge1xuICAgIHRoaXMuX2tleXBhaXIgPSB2b2lkIDA7XG4gICAgdGhpcy5fa2V5cGFpciA9IGtleXBhaXIgPz8gZ2VuZXJhdGVLZXlwYWlyKCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgcmFuZG9tIGtleXBhaXJcbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IEtleXBhaXIoZ2VuZXJhdGVLZXlwYWlyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtleXBhaXIgZnJvbSBhIHJhdyBzZWNyZXQga2V5IGJ5dGUgYXJyYXkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gcmVjcmVhdGUgYSBrZXlwYWlyIGZyb20gYSBwcmV2aW91c2x5XG4gICAqIGdlbmVyYXRlZCBzZWNyZXQga2V5LiBHZW5lcmF0aW5nIGtleXBhaXJzIGZyb20gYSByYW5kb20gc2VlZCBzaG91bGQgYmUgZG9uZVxuICAgKiB3aXRoIHRoZSB7QGxpbmsgS2V5cGFpci5mcm9tU2VlZH0gbWV0aG9kLlxuICAgKlxuICAgKiBAdGhyb3dzIGVycm9yIGlmIHRoZSBwcm92aWRlZCBzZWNyZXQga2V5IGlzIGludmFsaWQgYW5kIHZhbGlkYXRpb24gaXMgbm90IHNraXBwZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZWNyZXRLZXkgc2VjcmV0IGtleSBieXRlIGFycmF5XG4gICAqIEBwYXJhbSBvcHRpb25zIHNraXAgc2VjcmV0IGtleSB2YWxpZGF0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY3JldEtleShzZWNyZXRLZXksIG9wdGlvbnMpIHtcbiAgICBpZiAoc2VjcmV0S2V5LmJ5dGVMZW5ndGggIT09IDY0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gc2VjcmV0S2V5LnNsaWNlKDMyLCA2NCk7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICBjb25zdCBwcml2YXRlU2NhbGFyID0gc2VjcmV0S2V5LnNsaWNlKDAsIDMyKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHByaXZhdGVTY2FsYXIpO1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IDMyOyBpaSsrKSB7XG4gICAgICAgIGlmIChwdWJsaWNLZXlbaWldICE9PSBjb21wdXRlZFB1YmxpY0tleVtpaV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3ZpZGVkIHNlY3JldEtleSBpcyBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKHtcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIHNlY3JldEtleVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEga2V5cGFpciBmcm9tIGEgMzIgYnl0ZSBzZWVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VlZCBzZWVkIGJ5dGUgYXJyYXlcbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VlZChzZWVkKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlZWQpO1xuICAgIGNvbnN0IHNlY3JldEtleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICBzZWNyZXRLZXkuc2V0KHNlZWQpO1xuICAgIHNlY3JldEtleS5zZXQocHVibGljS2V5LCAzMik7XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKHtcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIHNlY3JldEtleVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IGZvciB0aGlzIGtleXBhaXJcbiAgICpcbiAgICogQHJldHVybnMge1B1YmxpY0tleX0gUHVibGljS2V5XG4gICAqL1xuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHRoaXMuX2tleXBhaXIucHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmF3IHNlY3JldCBrZXkgZm9yIHRoaXMga2V5cGFpclxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gU2VjcmV0IGtleSBpbiBhbiBhcnJheSBvZiBVaW50OCBieXRlc1xuICAgKi9cbiAgZ2V0IHNlY3JldEtleSgpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5fa2V5cGFpci5zZWNyZXRLZXkpO1xuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgTG9va3VwVGFibGVJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgYWRkcmVzcyBsb29rdXAgdGFibGUgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBDcmVhdGVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdyZWNlbnRTbG90JyksIEJ1ZmZlckxheW91dC51OCgnYnVtcFNlZWQnKV0pXG4gIH0sXG4gIEZyZWV6ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgRXh0ZW5kTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgpLCBCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnYWRkcmVzc2VzJyldKVxuICB9LFxuICBEZWFjdGl2YXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBDbG9zZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfVxufSk7XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IGluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtsYXlvdXRUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICB0eXBlID0gbGF5b3V0VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEluc3RydWN0aW9uLiBTaG91bGQgYmUgYSBMb29rdXBUYWJsZSBJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlQ3JlYXRlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNCk7XG4gICAgY29uc3Qge1xuICAgICAgcmVjZW50U2xvdFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlTG9va3VwVGFibGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcGF5ZXI6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgcmVjZW50U2xvdDogTnVtYmVyKHJlY2VudFNsb3QpXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRXh0ZW5kTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2luc3RydWN0aW9uLmtleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAyYCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3Nlc1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRXh0ZW5kTG9va3VwVGFibGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcGF5ZXI6IGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMiA/IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5IDogdW5kZWZpbmVkLFxuICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMubWFwKGJ1ZmZlciA9PiBuZXcgUHVibGljS2V5KGJ1ZmZlcikpXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlQ2xvc2VMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHJlY2lwaWVudDogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVGcmVlemVMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZURlYWN0aXZhdGVMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IEFkZHJlc3NMb29rdXBUYWJsZSBQcm9ncmFtJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleXNMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cbiAgc3RhdGljIGNyZWF0ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IFtsb29rdXBUYWJsZUFkZHJlc3MsIGJ1bXBTZWVkXSA9IFB1YmxpY0tleS5maW5kUHJvZ3JhbUFkZHJlc3NTeW5jKFtwYXJhbXMuYXV0aG9yaXR5LnRvQnVmZmVyKCksIGdldFU2NEVuY29kZXIoKS5lbmNvZGUocGFyYW1zLnJlY2VudFNsb3QpXSwgdGhpcy5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICByZWNlbnRTbG90OiBCaWdJbnQocGFyYW1zLnJlY2VudFNsb3QpLFxuICAgICAgYnVtcFNlZWQ6IGJ1bXBTZWVkXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IGxvb2t1cFRhYmxlQWRkcmVzcyxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMucGF5ZXIsXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gW25ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pLCBsb29rdXBUYWJsZUFkZHJlc3NdO1xuICB9XG4gIHN0YXRpYyBmcmVlemVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRnJlZXplTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBleHRlbmRMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRXh0ZW5kTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYWRkcmVzc2VzOiBwYXJhbXMuYWRkcmVzc2VzLm1hcChhZGRyID0+IGFkZHIudG9CeXRlcygpKVxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChwYXJhbXMucGF5ZXIpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBkZWFjdGl2YXRlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsb3NlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNsb3NlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxufVxuQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdBZGRyZXNzTG9va3VwVGFiMWUxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogQ29tcHV0ZSBCdWRnZXQgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSByZXF1ZXN0IHVuaXRzIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVJlcXVlc3RVbml0cyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0cyxcbiAgICAgIGFkZGl0aW9uYWxGZWVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCBoZWFwIGZyYW1lIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVJlcXVlc3RIZWFwRnJhbWUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgYnl0ZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdEhlYXBGcmFtZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgc2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuaXRzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB1bml0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgcHJpY2UgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRQcmljZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICBtaWNyb0xhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2UsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBtaWNyb0xhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQ29tcHV0ZUJ1ZGdldFByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IENvbXB1dGVCdWRnZXRQcm9ncmFtJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBSZXF1ZXN0IHVuaXRzIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCBoZWFwIGZyYW1lIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogU2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgcHJpY2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBDb21wdXRlQnVkZ2V0IEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBSZXF1ZXN0VW5pdHM6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKSwgQnVmZmVyTGF5b3V0LnUzMignYWRkaXRpb25hbEZlZScpXSlcbiAgfSxcbiAgUmVxdWVzdEhlYXBGcmFtZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlcycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRMaW1pdDoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCd1bml0cycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRQcmljZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCB1NjQoJ21pY3JvTGFtcG9ydHMnKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9uIGluc3RydWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBDb21wdXRlIEJ1ZGdldCBwcm9ncmFtXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRMaW1pdH0gYW5kL29yIHtAbGluayBzZXRDb21wdXRlVW5pdFByaWNlfVxuICAgKi9cbiAgc3RhdGljIHJlcXVlc3RVbml0cyhwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0VW5pdHM7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyByZXF1ZXN0SGVhcEZyYW1lKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdExpbWl0KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdFByaWNlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbWljcm9MYW1wb3J0czogQmlnSW50KHBhcmFtcy5taWNyb0xhbXBvcnRzKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkNvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0NvbXB1dGVCdWRnZXQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMkMSA9IDY0O1xuY29uc3QgUFVCTElDX0tFWV9CWVRFUyQxID0gMzI7XG5jb25zdCBTSUdOQVRVUkVfQllURVMgPSA2NDtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwcml2YXRlIGtleVxuICovXG5cbmNvbnN0IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51OCgncGFkZGluZycpLCBCdWZmZXJMYXlvdXQudTE2KCdzaWduYXR1cmVPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdwdWJsaWNLZXlPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YVNpemUnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKV0pO1xuY2xhc3MgRWQyNTUxOVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBlZDI1NTE5IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5IGFuZCBzaWduYXR1cmUuIFRoZVxuICAgKiBwdWJsaWMga2V5IG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLCBhbmQgdGhlIHNpZ25hdHVyZVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIG9mIDY0IGJ5dGVzLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMkMSwgYFB1YmxpYyBLZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVMkMX0gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHVibGljS2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gU0lHTkFUVVJFX0JZVEVTLCBgU2lnbmF0dXJlIG11c3QgYmUgJHtTSUdOQVRVUkVfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3NpZ25hdHVyZS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgcHVibGljS2V5T2Zmc2V0ID0gRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbjtcbiAgICBjb25zdCBzaWduYXR1cmVPZmZzZXQgPSBwdWJsaWNLZXlPZmZzZXQgKyBwdWJsaWNLZXkubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aDtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuYWxsb2MobWVzc2FnZURhdGFPZmZzZXQgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvbkluZGV4ID09IG51bGwgPyAweGZmZmYgLy8gQW4gaW5kZXggb2YgYHUxNjo6TUFYYCBtYWtlcyBpdCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IGluc3RydWN0aW9uLlxuICAgIDogaW5zdHJ1Y3Rpb25JbmRleDtcbiAgICBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5lbmNvZGUoe1xuICAgICAgbnVtU2lnbmF0dXJlcyxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBzaWduYXR1cmVPZmZzZXQsXG4gICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIHB1YmxpY0tleU9mZnNldCxcbiAgICAgIHB1YmxpY0tleUluc3RydWN0aW9uSW5kZXg6IGluZGV4LFxuICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluZGV4XG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChwdWJsaWNLZXksIHB1YmxpY0tleU9mZnNldCk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwoc2lnbmF0dXJlLCBzaWduYXR1cmVPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKG1lc3NhZ2UsIG1lc3NhZ2VEYXRhT2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IEVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGRhdGE6IGluc3RydWN0aW9uRGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTJDEsIGBQcml2YXRlIGtleSBtdXN0IGJlICR7UFJJVkFURV9LRVlfQllURVMkMX0gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHJpdmF0ZUtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXBhaXIgPSBLZXlwYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBrZXlwYWlyLnB1YmxpY0tleS50b0J5dGVzKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduKG1lc3NhZ2UsIGtleXBhaXIuc2VjcmV0S2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cbkVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0VkMjU1MTlTaWdWZXJpZnkxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY29uc3QgZWNkc2FTaWduID0gKG1zZ0hhc2gsIHByaXZLZXkpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxLnNpZ24obXNnSGFzaCwgcHJpdktleSk7XG4gIHJldHVybiBbc2lnbmF0dXJlLnRvQ29tcGFjdFJhd0J5dGVzKCksIHNpZ25hdHVyZS5yZWNvdmVyeV07XG59O1xuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5O1xuY29uc3QgcHVibGljS2V5Q3JlYXRlID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleTtcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMgPSAzMjtcbmNvbnN0IEVUSEVSRVVNX0FERFJFU1NfQllURVMgPSAyMDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMgPSA2NDtcbmNvbnN0IFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSA9IDExO1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYW4gRXRoZXJldW0gYWRkcmVzc1xuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwcml2YXRlIGtleVxuICovXG5cbmNvbnN0IFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51OCgnc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdldGhBZGRyZXNzT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51OCgnZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dC51OCgnbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoMjAsICdldGhBZGRyZXNzJyksIEJ1ZmZlckxheW91dC5ibG9iKDY0LCAnc2lnbmF0dXJlJyksIEJ1ZmZlckxheW91dC51OCgncmVjb3ZlcnlJZCcpXSk7XG5jbGFzcyBTZWNwMjU2azFQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgc2VjcDI1NmsxIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBFdGhlcmV1bSBhZGRyZXNzIGZyb20gYSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXIuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXkgYSA2NCBieXRlIHNlY3AyNTZrMSBwdWJsaWMga2V5IGJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIHB1YmxpY0tleVRvRXRoQWRkcmVzcyhwdWJsaWNLZXkpIHtcbiAgICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUywgYFB1YmxpYyBrZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKHB1YmxpY0tleSkpKS5zbGljZSgtRVRIRVJFVU1fQUREUkVTU19CWVRFUyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY29uc3RydWN0aW5nIEV0aGVyZXVtIGFkZHJlc3M6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhIHB1YmxpYyBrZXkuIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBTZWNwMjU2azFQcm9ncmFtLmNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3Moe1xuICAgICAgZXRoQWRkcmVzczogU2VjcDI1NmsxUHJvZ3JhbS5wdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhbiBFdGhlcmV1bSBhZGRyZXNzLiBUaGUgYWRkcmVzc1xuICAgKiBtdXN0IGJlIGEgaGV4IHN0cmluZyBvciBhIGJ1ZmZlciB0aGF0IGlzIDIwIGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzcyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBldGhBZGRyZXNzOiByYXdBZGRyZXNzLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4ID0gMFxuICAgIH0gPSBwYXJhbXM7XG4gICAgbGV0IGV0aEFkZHJlc3M7XG4gICAgaWYgKHR5cGVvZiByYXdBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHJhd0FkZHJlc3Muc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcy5zdWJzdHIoMiksICdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV0aEFkZHJlc3MgPSBCdWZmZXIuZnJvbShyYXdBZGRyZXNzLCAnaGV4Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV0aEFkZHJlc3MgPSByYXdBZGRyZXNzO1xuICAgIH1cbiAgICBhc3NlcnQoZXRoQWRkcmVzcy5sZW5ndGggPT09IEVUSEVSRVVNX0FERFJFU1NfQllURVMsIGBBZGRyZXNzIG11c3QgYmUgJHtFVEhFUkVVTV9BRERSRVNTX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtldGhBZGRyZXNzLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBjb25zdCBkYXRhU3RhcnQgPSAxICsgU0lHTkFUVVJFX09GRlNFVFNfU0VSSUFMSVpFRF9TSVpFO1xuICAgIGNvbnN0IGV0aEFkZHJlc3NPZmZzZXQgPSBkYXRhU3RhcnQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gZGF0YVN0YXJ0ICsgZXRoQWRkcmVzcy5sZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoICsgMTtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuYWxsb2MoU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBzaWduYXR1cmVPZmZzZXQsXG4gICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgZXRoQWRkcmVzc09mZnNldCxcbiAgICAgIGV0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXgsXG4gICAgICBzaWduYXR1cmU6IHRvQnVmZmVyKHNpZ25hdHVyZSksXG4gICAgICBldGhBZGRyZXNzOiB0b0J1ZmZlcihldGhBZGRyZXNzKSxcbiAgICAgIHJlY292ZXJ5SWRcbiAgICB9LCBpbnN0cnVjdGlvbkRhdGEpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHRvQnVmZmVyKG1lc3NhZ2UpLCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW4pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogU2VjcDI1NmsxUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleTogcGtleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocGtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwa2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHRvQnVmZmVyKHBrZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlIC8qIGlzQ29tcHJlc3NlZCAqLykuc2xpY2UoMSk7IC8vIHRocm93IGF3YXkgbGVhZGluZyBieXRlXG4gICAgICBjb25zdCBtZXNzYWdlSGFzaCA9IEJ1ZmZlci5mcm9tKGtlY2Nha18yNTYodG9CdWZmZXIobWVzc2FnZSkpKTtcbiAgICAgIGNvbnN0IFtzaWduYXR1cmUsIHJlY292ZXJ5SWRdID0gZWNkc2FTaWduKG1lc3NhZ2VIYXNoLCBwcml2YXRlS2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICByZWNvdmVyeUlkLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cblNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnS2VjY2FrU2VjcDI1NmsxMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG52YXIgX0xvY2t1cDtcblxuLyoqXG4gKiBBZGRyZXNzIG9mIHRoZSBzdGFrZSBjb25maWcgYWNjb3VudCB3aGljaCBjb25maWd1cmVzIHRoZSByYXRlXG4gKiBvZiBzdGFrZSB3YXJtdXAgYW5kIGNvb2xkb3duIGFzIHdlbGwgYXMgdGhlIHNsYXNoaW5nIHBlbmFsdHkuXG4gKi9cbmNvbnN0IFNUQUtFX0NPTkZJR19JRCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlQ29uZmlnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGF1dGhvcml0eSBpbmZvXG4gKi9cbmNsYXNzIEF1dGhvcml6ZWQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEF1dGhvcml6ZWQgb2JqZWN0XG4gICAqIEBwYXJhbSBzdGFrZXIgdGhlIHN0YWtlIGF1dGhvcml0eVxuICAgKiBAcGFyYW0gd2l0aGRyYXdlciB0aGUgd2l0aGRyYXcgYXV0aG9yaXR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdGFrZXIsIHdpdGhkcmF3ZXIpIHtcbiAgICAvKiogc3Rha2UgYXV0aG9yaXR5ICovXG4gICAgdGhpcy5zdGFrZXIgPSB2b2lkIDA7XG4gICAgLyoqIHdpdGhkcmF3IGF1dGhvcml0eSAqL1xuICAgIHRoaXMud2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWtlciA9IHN0YWtlcjtcbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB3aXRoZHJhd2VyO1xuICB9XG59XG4vKipcbiAqIFN0YWtlIGFjY291bnQgbG9ja3VwIGluZm9cbiAqL1xuY2xhc3MgTG9ja3VwIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBMb2NrdXAgb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1bml4VGltZXN0YW1wLCBlcG9jaCwgY3VzdG9kaWFuKSB7XG4gICAgLyoqIFVuaXggdGltZXN0YW1wIG9mIGxvY2t1cCBleHBpcmF0aW9uICovXG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdm9pZCAwO1xuICAgIC8qKiBFcG9jaCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMuZXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIExvY2t1cCBjdXN0b2RpYW4gYXV0aG9yaXR5ICovXG4gICAgdGhpcy5jdXN0b2RpYW4gPSB2b2lkIDA7XG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdW5peFRpbWVzdGFtcDtcbiAgICB0aGlzLmVwb2NoID0gZXBvY2g7XG4gICAgdGhpcy5jdXN0b2RpYW4gPSBjdXN0b2RpYW47XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCwgaW5hY3RpdmUgTG9ja3VwIHZhbHVlXG4gICAqL1xufVxuX0xvY2t1cCA9IExvY2t1cDtcbkxvY2t1cC5kZWZhdWx0ID0gbmV3IF9Mb2NrdXAoMCwgMCwgUHVibGljS2V5LmRlZmF1bHQpO1xuLyoqXG4gKiBDcmVhdGUgc3Rha2UgYWNjb3VudCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBDcmVhdGUgc3Rha2UgYWNjb3VudCB3aXRoIHNlZWQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogSW5pdGlhbGl6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBBdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtcyB1c2luZyBhIGRlcml2ZWQga2V5XG4gKi9cbi8qKlxuICogU3BsaXQgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogU3BsaXQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIERlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogTWVyZ2Ugc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogU3Rha2UgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgU3Rha2VJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBTdGFrZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQ6IG5ldyBBdXRob3JpemVkKG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZC5zdGFrZXIpLCBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQud2l0aGRyYXdlcikpLFxuICAgICAgbG9ja3VwOiBuZXcgTG9ja3VwKGxvY2t1cC51bml4VGltZXN0YW1wLCBsb2NrdXAuZXBvY2gsIG5ldyBQdWJsaWNLZXkobG9ja3VwLmN1c3RvZGlhbikpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVEZWxlZ2F0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDYpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlbGVnYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzVdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplLXdpdGgtc2VlZCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5QmFzZTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXR5T3duZXIpLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDMpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNwbGl0IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNwbGl0KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuU3BsaXQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG1lcmdlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU1lcmdlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2UsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzb3VyY2VTdGFrZVB1YktleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDUpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGRlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3Rha2VQcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTdGFrZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzdGFrZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgYXV0aG9yaXplZCgpLCBsb2NrdXAoKV0pXG4gIH0sXG4gIEF1dGhvcml6ZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YWtlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIERlbGVnYXRlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgU3BsaXQ6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgV2l0aGRyYXc6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZToge1xuICAgIGluZGV4OiA1LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIE1lcmdlOiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyksIHJ1c3RTdHJpbmcoJ2F1dGhvcml0eVNlZWQnKSwgcHVibGljS2V5KCdhdXRob3JpdHlPd25lcicpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogU3Rha2UgYXV0aG9yaXphdGlvbiB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQnc1xuICovXG5jb25zdCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgU3Rha2VyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTdGFrZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFN0YWtlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN0YWtlIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24gdG8gYWRkIHRvIGEgU3Rha2UgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXA6IG1heWJlTG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsb2NrdXAgPSBtYXliZUxvY2t1cCB8fCBMb2NrdXAuZGVmYXVsdDtcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHtcbiAgICAgICAgc3Rha2VyOiB0b0J1ZmZlcihhdXRob3JpemVkLnN0YWtlci50b0J1ZmZlcigpKSxcbiAgICAgICAgd2l0aGRyYXdlcjogdG9CdWZmZXIoYXV0aG9yaXplZC53aXRoZHJhd2VyLnRvQnVmZmVyKCkpXG4gICAgICB9LFxuICAgICAgbG9ja3VwOiB7XG4gICAgICAgIHVuaXhUaW1lc3RhbXA6IGxvY2t1cC51bml4VGltZXN0YW1wLFxuICAgICAgICBlcG9jaDogbG9ja3VwLmVwb2NoLFxuICAgICAgICBjdXN0b2RpYW46IHRvQnVmZmVyKGxvY2t1cC5jdXN0b2RpYW4udG9CdWZmZXIoKSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnQgYXRcbiAgICogICBhbiBhZGRyZXNzIGdlbmVyYXRlZCB3aXRoIGBmcm9tYCwgYSBzZWVkLCBhbmQgdGhlIFN0YWtlIHByb2dyYW1JZFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnRXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnRXaXRoU2VlZCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuaW5pdGlhbGl6ZSh7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlbGVnYXRlcyBTdGFrZSB0b2tlbnMgdG8gYSB2YWxpZGF0b3JcbiAgICogVm90ZSBQdWJsaWNLZXkuIFRoaXMgdHJhbnNhY3Rpb24gY2FuIGFsc28gYmUgdXNlZCB0byByZWRlbGVnYXRlIFN0YWtlXG4gICAqIHRvIGEgbmV3IHZhbGlkYXRvciBWb3RlIFB1YmxpY0tleS5cbiAgICovXG4gIHN0YXRpYyBkZWxlZ2F0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICB2b3RlUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1RBS0VfQ09ORklHX0lELFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiBzdGFrZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXR5QmFzZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcixcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgY3VzdG9kaWFuUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleCxcbiAgICAgIGF1dGhvcml0eVNlZWQ6IGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcjogdG9CdWZmZXIoYXV0aG9yaXR5T3duZXIudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpdHlCYXNlLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgc3BsaXRJbnN0cnVjdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBzdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgc3BsaXQocGFyYW1zLFxuICAvLyBDb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgdGhlIG5ldyBzdGFrZSBhY2NvdW50IGluIGxhbXBvcnRzXG4gIHJlbnRFeGVtcHRSZXNlcnZlKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcmVudEV4ZW1wdFJlc2VydmUsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLnNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHNwbGl0cyBTdGFrZSB0b2tlbnMgaW50byBhbm90aGVyIGFjY291bnRcbiAgICogZGVyaXZlZCBmcm9tIGEgYmFzZSBwdWJsaWMga2V5IGFuZCBzZWVkXG4gICAqL1xuICBzdGF0aWMgc3BsaXRXaXRoU2VlZChwYXJhbXMsXG4gIC8vIElmIHRoaXMgc3Rha2UgYWNjb3VudCBpcyBuZXcsIGNvbXB1dGUgdGhlIGNvc3Qgb2YgYWxsb2NhdGluZyBpdCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5LFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFsbG9jYXRlKHtcbiAgICAgIGFjY291bnRQdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5LFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBpZiAocmVudEV4ZW1wdFJlc2VydmUgJiYgcmVudEV4ZW1wdFJlc2VydmUgPiAwKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICB0b1B1YmtleTogc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgbWVyZ2VzIFN0YWtlIGFjY291bnRzLlxuICAgKi9cbiAgc3RhdGljIG1lcmdlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5NZXJnZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHdpdGhkcmF3cyBkZWFjdGl2YXRlZCBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdG9QdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiB0b1B1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlYWN0aXZhdGVzIFN0YWtlIHRva2Vucy5cbiAgICovXG4gIHN0YXRpYyBkZWFjdGl2YXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuU3Rha2VQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbi8qKlxuICogTWF4IHNwYWNlIG9mIGEgU3Rha2UgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS1zdGFrZS1wcm9ncmFtIFN0YWtlU3RhdGUgc3RydWN0IGFzXG4gKiBgU3Rha2VTdGF0ZVYyOjpzaXplX29mKClgOlxuICogaHR0cHM6Ly9kb2NzLnJzL3NvbGFuYS1zdGFrZS1wcm9ncmFtL2xhdGVzdC9zb2xhbmFfc3Rha2VfcHJvZ3JhbS9zdGFrZV9zdGF0ZS9lbnVtLlN0YWtlU3RhdGVWMi5odG1sXG4gKi9cblN0YWtlUHJvZ3JhbS5zcGFjZSA9IDIwMDtcblxuLyoqXG4gKiBWb3RlIGFjY291bnQgaW5mb1xuICovXG5jbGFzcyBWb3RlSW5pdCB7XG4gIC8qKiBbMCwgMTAwXSAqL1xuXG4gIGNvbnN0cnVjdG9yKG5vZGVQdWJrZXksIGF1dGhvcml6ZWRWb3RlciwgYXV0aG9yaXplZFdpdGhkcmF3ZXIsIGNvbW1pc3Npb24pIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gbm9kZVB1YmtleTtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlciA9IGF1dGhvcml6ZWRWb3RlcjtcbiAgICB0aGlzLmF1dGhvcml6ZWRXaXRoZHJhd2VyID0gYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gY29tbWlzc2lvbjtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSB2b3RlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplQWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZVdpdGhTZWVkIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgZnJvbSB2b3RlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBVcGRhdGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgdm90ZSBhY2NvdW50IGluc3RydWN0aW9uIHBhcmFtcy5cbiAqL1xuXG4vKipcbiAqIFZvdGUgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVm90ZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB2b3RlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBWb3RlSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGluaXRpYWxpemUgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbml0aWFsaXplQWNjb3VudChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVJbml0XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5LFxuICAgICAgdm90ZUluaXQ6IG5ldyBWb3RlSW5pdChuZXcgUHVibGljS2V5KHZvdGVJbml0Lm5vZGVQdWJrZXkpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRWb3RlciksIG5ldyBQdWJsaWNLZXkodm90ZUluaXQuYXV0aG9yaXplZFdpdGhkcmF3ZXIpLCB2b3RlSW5pdC5jb21taXNzaW9uKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3M6IHtcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiBuZXcgUHVibGljS2V5KGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkpLFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkOiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH0sXG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFZvdGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBWb3RlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgVm90ZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuXG5jb25zdCBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZUFjY291bnQ6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHZvdGVJbml0KCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCd2b3RlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFVwZGF0ZVZhbGlkYXRvcklkZW50aXR5OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzKCldKVxuICB9XG59KTtcblxuLyoqXG4gKiBWb3RlQXV0aG9yaXplIHR5cGVcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVBdXRob3JpemF0aW9uIGxheW91dHMuXG4gKi9cbmNvbnN0IFZvdGVBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFZvdGVyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBWb3RlIHByb2dyYW1cbiAqL1xuY2xhc3MgVm90ZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBWb3RlIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXksXG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlSW5pdDoge1xuICAgICAgICBub2RlUHVia2V5OiB0b0J1ZmZlcih2b3RlSW5pdC5ub2RlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBhdXRob3JpemVkVm90ZXI6IHRvQnVmZmVyKHZvdGVJbml0LmF1dGhvcml6ZWRWb3Rlci50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXI6IHRvQnVmZmVyKHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyLnRvQnVmZmVyKCkpLFxuICAgICAgICBjb21taXNzaW9uOiB2b3RlSW5pdC5jb21taXNzaW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogbm9kZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemVBY2NvdW50KHtcbiAgICAgIHZvdGVQdWJrZXk6IHBhcmFtcy52b3RlUHVia2V5LFxuICAgICAgbm9kZVB1YmtleTogcGFyYW1zLnZvdGVJbml0Lm5vZGVQdWJrZXksXG4gICAgICB2b3RlSW5pdDogcGFyYW1zLnZvdGVJbml0XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudFxuICAgKiB3aGVyZSB0aGUgY3VycmVudCBWb3RlciBvciBXaXRoZHJhd2VyIGF1dGhvcml0eSBpcyBhIGRlcml2ZWQga2V5LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXk6IHRvQnVmZmVyKGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHZvdGVBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdztcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdG8gd2l0aGRyYXcgc2FmZWx5IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2FzIGNyZWF0ZWQgYXMgYSBzYWZlZ3VhcmQgZm9yIHZvdGUgYWNjb3VudHMgcnVubmluZyB2YWxpZGF0b3JzLCBgc2FmZVdpdGhkcmF3YFxuICAgKiBjaGVja3MgdGhhdCB0aGUgd2l0aGRyYXcgYW1vdW50IHdpbGwgbm90IGV4Y2VlZCB0aGUgc3BlY2lmaWVkIGJhbGFuY2Ugd2hpbGUgbGVhdmluZyBlbm91Z2ggbGVmdFxuICAgKiB0byBjb3ZlciByZW50LiBJZiB5b3Ugd2lzaCB0byBjbG9zZSB0aGUgdm90ZSBhY2NvdW50IGJ5IHdpdGhkcmF3aW5nIHRoZSBmdWxsIGFtb3VudCwgY2FsbCB0aGVcbiAgICogYHdpdGhkcmF3YCBtZXRob2QgZGlyZWN0bHkuXG4gICAqL1xuICBzdGF0aWMgc2FmZVdpdGhkcmF3KHBhcmFtcywgY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSwgcmVudEV4ZW1wdE1pbmltdW0pIHtcbiAgICBpZiAocGFyYW1zLmxhbXBvcnRzID4gY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSAtIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGhkcmF3IHdpbGwgbGVhdmUgdm90ZSBhY2NvdW50IHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzLicpO1xuICAgIH1cbiAgICByZXR1cm4gVm90ZVByb2dyYW0ud2l0aGRyYXcocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHVwZGF0ZSB0aGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgb2YgYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgdXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgbm9kZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5VcGRhdGVWYWxpZGF0b3JJZGVudGl0eTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Wb3RlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFZvdGUgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS12b3RlLXByb2dyYW0gVm90ZVN0YXRlIHN0cnVjdCBhc1xuICogYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtdm90ZS1wcm9ncmFtLzEuOS41L3NvbGFuYV92b3RlX3Byb2dyYW0vdm90ZV9zdGF0ZS9zdHJ1Y3QuVm90ZVN0YXRlLmh0bWwjbWV0aG9kLnNpemVfb2ZcbiAqXG4gKiBLRUVQIElOIFNZTkMgV0lUSCBgVm90ZVN0YXRlOjpzaXplX29mKClgIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9hNDc0Y2IyNGI5MjM4ZjVlZGNjOTgyZjY1YzBiMzdkNGExMDQ2ZjdlL3Nkay9wcm9ncmFtL3NyYy92b3RlL3N0YXRlL21vZC5ycyNMMzQwLUwzNDJcbiAqL1xuVm90ZVByb2dyYW0uc3BhY2UgPSAzNzYyO1xuXG5jb25zdCBWQUxJREFUT1JfSU5GT19LRVkgPSBuZXcgUHVibGljS2V5KCdWYTFpZGF0b3IxbmZvMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBJbmZvIHVzZWQgdG8gaWRlbnRpdHkgdmFsaWRhdG9ycy5cbiAqL1xuXG5jb25zdCBJbmZvU3RyaW5nID0gdHlwZSh7XG4gIG5hbWU6IHN0cmluZygpLFxuICB3ZWJzaXRlOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGRldGFpbHM6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgaWNvblVybDogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBrZXliYXNlVXNlcm5hbWU6IG9wdGlvbmFsKHN0cmluZygpKVxufSk7XG5cbi8qKlxuICogVmFsaWRhdG9ySW5mbyBjbGFzc1xuICovXG5jbGFzcyBWYWxpZGF0b3JJbmZvIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIHZhbGlkIFZhbGlkYXRvckluZm9cbiAgICpcbiAgICogQHBhcmFtIGtleSB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgKiBAcGFyYW0gaW5mbyB2YWxpZGF0b3IgaW5mb3JtYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleSwgaW5mbykge1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBwdWJsaWMga2V5XG4gICAgICovXG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVmFsaWRhdG9ySW5mbyBmcm9tIHRoZSBjb25maWcgYWNjb3VudCBkYXRhLiBFeGFjdGx5IHR3byBjb25maWdcbiAgICoga2V5cyBhcmUgcmVxdWlyZWQgaW4gdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgY29uZmlnIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIG51bGwgaWYgaW5mbyB3YXMgbm90IGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZnJvbUNvbmZpZ0RhdGEoYnVmZmVyKSB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5idWZmZXJdO1xuICAgIGNvbnN0IGNvbmZpZ0tleUNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgaWYgKGNvbmZpZ0tleUNvdW50ICE9PSAyKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb25maWdLZXlzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSk7XG4gICAgICBjb25zdCBpc1NpZ25lciA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpID09PSAxO1xuICAgICAgY29uZmlnS2V5cy5wdXNoKHtcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBpc1NpZ25lclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjb25maWdLZXlzWzBdLnB1YmxpY0tleS5lcXVhbHMoVkFMSURBVE9SX0lORk9fS0VZKSkge1xuICAgICAgaWYgKGNvbmZpZ0tleXNbMV0uaXNTaWduZXIpIHtcbiAgICAgICAgY29uc3QgcmF3SW5mbyA9IHJ1c3RTdHJpbmcoKS5kZWNvZGUoQnVmZmVyLmZyb20oYnl0ZUFycmF5KSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSBKU09OLnBhcnNlKHJhd0luZm8pO1xuICAgICAgICBhc3NlcnQkMShpbmZvLCBJbmZvU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0b3JJbmZvKGNvbmZpZ0tleXNbMV0ucHVibGljS2V5LCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuY29uc3QgVk9URV9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEhpc3Rvcnkgb2YgaG93IG1hbnkgY3JlZGl0cyBlYXJuZWQgYnkgdGhlIGVuZCBvZiBlYWNoIGVwb2NoXG4gKi9cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzhhMTJlZDAyOWNmYTM4ZDRhNDU0MDA5MTZjMjQ2M2ZiODJiYmVjOGMvcHJvZ3JhbXMvdm90ZV9hcGkvc3JjL3ZvdGVfc3RhdGUucnMjTDY4LUw4OFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBWb3RlQWNjb3VudExheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnbm9kZVB1YmtleScpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRXaXRoZHJhd2VyJyksIEJ1ZmZlckxheW91dC51OCgnY29tbWlzc2lvbicpLCBCdWZmZXJMYXlvdXQubnU2NCgpLFxuLy8gdm90ZXMubGVuZ3RoXG5CdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dC51MzIoJ2NvbmZpcm1hdGlvbkNvdW50JyldKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ3ZvdGVzJyksIEJ1ZmZlckxheW91dC51OCgncm9vdFNsb3RWYWxpZCcpLCBCdWZmZXJMYXlvdXQubnU2NCgncm9vdFNsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIGF1dGhvcml6ZWRWb3RlcnMubGVuZ3RoXG5CdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdlcG9jaCcpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRWb3RlcicpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdhdXRob3JpemVkVm90ZXJzJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdhdXRob3JpemVkUHVia2V5JyksIEJ1ZmZlckxheW91dC5udTY0KCdlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3RhcmdldEVwb2NoJyldKSwgMzIsICdidWYnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2lkeCcpLCBCdWZmZXJMYXlvdXQudTgoJ2lzRW1wdHknKV0sICdwcmlvclZvdGVycycpLCBCdWZmZXJMYXlvdXQubnU2NCgpLFxuLy8gZXBvY2hDcmVkaXRzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2gnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2NyZWRpdHMnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3ByZXZDcmVkaXRzJyldKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2Vwb2NoQ3JlZGl0cycpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnc2xvdCcpLCBCdWZmZXJMYXlvdXQubnU2NCgndGltZXN0YW1wJyldLCAnbGFzdFRpbWVzdGFtcCcpXSk7XG4vKipcbiAqIFZvdGVBY2NvdW50IGNsYXNzXG4gKi9cbmNsYXNzIFZvdGVBY2NvdW50IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMubm9kZVB1YmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRXaXRoZHJhd2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnJvb3RTbG90ID0gdm9pZCAwO1xuICAgIHRoaXMudm90ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXJzID0gdm9pZCAwO1xuICAgIHRoaXMucHJpb3JWb3RlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5lcG9jaENyZWRpdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0VGltZXN0YW1wID0gdm9pZCAwO1xuICAgIHRoaXMubm9kZVB1YmtleSA9IGFyZ3Mubm9kZVB1YmtleTtcbiAgICB0aGlzLmF1dGhvcml6ZWRXaXRoZHJhd2VyID0gYXJncy5hdXRob3JpemVkV2l0aGRyYXdlcjtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSBhcmdzLmNvbW1pc3Npb247XG4gICAgdGhpcy5yb290U2xvdCA9IGFyZ3Mucm9vdFNsb3Q7XG4gICAgdGhpcy52b3RlcyA9IGFyZ3Mudm90ZXM7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXJzID0gYXJncy5hdXRob3JpemVkVm90ZXJzO1xuICAgIHRoaXMucHJpb3JWb3RlcnMgPSBhcmdzLnByaW9yVm90ZXJzO1xuICAgIHRoaXMuZXBvY2hDcmVkaXRzID0gYXJncy5lcG9jaENyZWRpdHM7XG4gICAgdGhpcy5sYXN0VGltZXN0YW1wID0gYXJncy5sYXN0VGltZXN0YW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIFZvdGVBY2NvdW50IGZyb20gdGhlIGFjY291bnQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBWb3RlQWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGZyb21BY2NvdW50RGF0YShidWZmZXIpIHtcbiAgICBjb25zdCB2ZXJzaW9uT2Zmc2V0ID0gNDtcbiAgICBjb25zdCB2YSA9IFZvdGVBY2NvdW50TGF5b3V0LmRlY29kZSh0b0J1ZmZlcihidWZmZXIpLCB2ZXJzaW9uT2Zmc2V0KTtcbiAgICBsZXQgcm9vdFNsb3QgPSB2YS5yb290U2xvdDtcbiAgICBpZiAoIXZhLnJvb3RTbG90VmFsaWQpIHtcbiAgICAgIHJvb3RTbG90ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWb3RlQWNjb3VudCh7XG4gICAgICBub2RlUHVia2V5OiBuZXcgUHVibGljS2V5KHZhLm5vZGVQdWJrZXkpLFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXI6IG5ldyBQdWJsaWNLZXkodmEuYXV0aG9yaXplZFdpdGhkcmF3ZXIpLFxuICAgICAgY29tbWlzc2lvbjogdmEuY29tbWlzc2lvbixcbiAgICAgIHZvdGVzOiB2YS52b3RlcyxcbiAgICAgIHJvb3RTbG90LFxuICAgICAgYXV0aG9yaXplZFZvdGVyczogdmEuYXV0aG9yaXplZFZvdGVycy5tYXAocGFyc2VBdXRob3JpemVkVm90ZXIpLFxuICAgICAgcHJpb3JWb3RlcnM6IGdldFByaW9yVm90ZXJzKHZhLnByaW9yVm90ZXJzKSxcbiAgICAgIGVwb2NoQ3JlZGl0czogdmEuZXBvY2hDcmVkaXRzLFxuICAgICAgbGFzdFRpbWVzdGFtcDogdmEubGFzdFRpbWVzdGFtcFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUF1dGhvcml6ZWRWb3Rlcih7XG4gIGF1dGhvcml6ZWRWb3RlcixcbiAgZXBvY2hcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBlcG9jaCxcbiAgICBhdXRob3JpemVkVm90ZXI6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZFZvdGVyKVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VQcmlvclZvdGVycyh7XG4gIGF1dGhvcml6ZWRQdWJrZXksXG4gIGVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCxcbiAgdGFyZ2V0RXBvY2hcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRQdWJrZXkpLFxuICAgIGVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCxcbiAgICB0YXJnZXRFcG9jaFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UHJpb3JWb3RlcnMoe1xuICBidWYsXG4gIGlkeCxcbiAgaXNFbXB0eVxufSkge1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gWy4uLmJ1Zi5zbGljZShpZHggKyAxKS5tYXAocGFyc2VQcmlvclZvdGVycyksIC4uLmJ1Zi5zbGljZSgwLCBpZHgpLm1hcChwYXJzZVByaW9yVm90ZXJzKV07XG59XG5cbmNvbnN0IGVuZHBvaW50ID0ge1xuICBodHRwOiB7XG4gICAgZGV2bmV0OiAnaHR0cDovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHA6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tJyxcbiAgICAnbWFpbm5ldC1iZXRhJzogJ2h0dHA6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20vJ1xuICB9LFxuICBodHRwczoge1xuICAgIGRldm5ldDogJ2h0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJyxcbiAgICB0ZXN0bmV0OiAnaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tJyxcbiAgICAnbWFpbm5ldC1iZXRhJzogJ2h0dHBzOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfVxufTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBSUEMgQVBJIFVSTCBmb3IgdGhlIHNwZWNpZmllZCBjbHVzdGVyXG4gKiBAcGFyYW0ge0NsdXN0ZXJ9IFtjbHVzdGVyPVwiZGV2bmV0XCJdIC0gVGhlIGNsdXN0ZXIgbmFtZSBvZiB0aGUgUlBDIEFQSSBVUkwgdG8gdXNlLiBQb3NzaWJsZSBvcHRpb25zOiAnZGV2bmV0JyB8ICd0ZXN0bmV0JyB8ICdtYWlubmV0LWJldGEnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0bHM9XCJodHRwXCJdIC0gVXNlIFRMUyB3aGVuIGNvbm5lY3RpbmcgdG8gY2x1c3Rlci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgc3RyaW5nIG9mIHRoZSBSUEMgZW5kcG9pbnRcbiAqL1xuZnVuY3Rpb24gY2x1c3RlckFwaVVybChjbHVzdGVyLCB0bHMpIHtcbiAgY29uc3Qga2V5ID0gdGxzID09PSBmYWxzZSA/ICdodHRwJyA6ICdodHRwcyc7XG4gIGlmICghY2x1c3Rlcikge1xuICAgIHJldHVybiBlbmRwb2ludFtrZXldWydkZXZuZXQnXTtcbiAgfVxuICBjb25zdCB1cmwgPSBlbmRwb2ludFtrZXldW2NsdXN0ZXJdO1xuICBpZiAoIXVybCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biAke2tleX0gY2x1c3RlcjogJHtjbHVzdGVyfWApO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogU2VuZCBhbmQgY29uZmlybSBhIHJhdyB0cmFuc2FjdGlvblxuICpcbiAqIElmIGBjb21taXRtZW50YCBvcHRpb24gaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gJ21heCcgY29tbWl0bWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7QnVmZmVyfSByYXdUcmFuc2FjdGlvblxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5fSBjb25maXJtYXRpb25TdHJhdGVneVxuICogQHBhcmFtIHtDb25maXJtT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBDYWxsaW5nIGBzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uKClgIHdpdGhvdXQgYSBgY29uZmlybWF0aW9uU3RyYXRlZ3lgXG4gKiBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5hc3luYyBmdW5jdGlvbiBzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHJhd1RyYW5zYWN0aW9uLCBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMsIG1heWJlQ29uZmlybU9wdGlvbnMpIHtcbiAgbGV0IGNvbmZpcm1hdGlvblN0cmF0ZWd5O1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCAnbGFzdFZhbGlkQmxvY2tIZWlnaHQnKSkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2UgaWYgKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCAnbm9uY2VWYWx1ZScpKSB7XG4gICAgY29uZmlybWF0aW9uU3RyYXRlZ3kgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG1heWJlQ29uZmlybU9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgfVxuICBjb25zdCBzZW5kT3B0aW9ucyA9IG9wdGlvbnMgJiYge1xuICAgIHNraXBQcmVmbGlnaHQ6IG9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICBwcmVmbGlnaHRDb21taXRtZW50OiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgb3B0aW9ucy5jb21taXRtZW50LFxuICAgIG1pbkNvbnRleHRTbG90OiBvcHRpb25zLm1pbkNvbnRleHRTbG90XG4gIH07XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLCBzZW5kT3B0aW9ucyk7XG4gIGNvbnN0IGNvbW1pdG1lbnQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudDtcbiAgY29uc3QgY29uZmlybWF0aW9uUHJvbWlzZSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5ID8gY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oY29uZmlybWF0aW9uU3RyYXRlZ3ksIGNvbW1pdG1lbnQpIDogY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KTtcbiAgY29uc3Qgc3RhdHVzID0gKGF3YWl0IGNvbmZpcm1hdGlvblByb21pc2UpLnZhbHVlO1xuICBpZiAoc3RhdHVzLmVycikge1xuICAgIGlmIChzaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiBzZW5kT3B0aW9ucz8uc2tpcFByZWZsaWdodCA/ICdzZW5kJyA6ICdzaW11bGF0ZScsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICB0cmFuc2FjdGlvbk1lc3NhZ2U6IGBTdGF0dXM6ICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJhdyB0cmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWApO1xuICB9XG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8qKlxuICogVGhlcmUgYXJlIDEtYmlsbGlvbiBsYW1wb3J0cyBpbiBvbmUgU09MXG4gKi9cbmNvbnN0IExBTVBPUlRTX1BFUl9TT0wgPSAxMDAwMDAwMDAwO1xuXG5leHBvcnQgeyBBY2NvdW50LCBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50LCBBZGRyZXNzTG9va3VwVGFibGVJbnN0cnVjdGlvbiwgQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSwgQXV0aG9yaXplZCwgQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMsIEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lELCBCUEZfTE9BREVSX1BST0dSQU1fSUQsIEJwZkxvYWRlciwgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUywgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uLCBDb21wdXRlQnVkZ2V0UHJvZ3JhbSwgQ29ubmVjdGlvbiwgRWQyNTUxOVByb2dyYW0sIEVudW0sIEVwb2NoU2NoZWR1bGUsIEZlZUNhbGN1bGF0b3JMYXlvdXQsIEtleXBhaXIsIExBTVBPUlRTX1BFUl9TT0wsIExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLCBMb2FkZXIsIExvY2t1cCwgTUFYX1NFRURfTEVOR1RILCBNZXNzYWdlLCBNZXNzYWdlQWNjb3VudEtleXMsIE1lc3NhZ2VWMCwgTk9OQ0VfQUNDT1VOVF9MRU5HVEgsIE5vbmNlQWNjb3VudCwgUEFDS0VUX0RBVEFfU0laRSwgUFVCTElDX0tFWV9MRU5HVEgsIFB1YmxpY0tleSwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUywgU09MQU5BX1NDSEVNQSwgU1RBS0VfQ09ORklHX0lELCBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLCBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUywgU1lTVkFSX0NMT0NLX1BVQktFWSwgU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWSwgU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVksIFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLCBTWVNWQVJfUkVOVF9QVUJLRVksIFNZU1ZBUl9SRVdBUkRTX1BVQktFWSwgU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSwgU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVksIFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSwgU2VjcDI1NmsxUHJvZ3JhbSwgU2VuZFRyYW5zYWN0aW9uRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvciwgU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSwgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0LCBTdGFrZUluc3RydWN0aW9uLCBTdGFrZVByb2dyYW0sIFN0cnVjdCwgU3lzdGVtSW5zdHJ1Y3Rpb24sIFN5c3RlbVByb2dyYW0sIFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IsIFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yLCBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IsIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sIFRyYW5zYWN0aW9uTWVzc2FnZSwgVHJhbnNhY3Rpb25TdGF0dXMsIFZBTElEQVRPUl9JTkZPX0tFWSwgVkVSU0lPTl9QUkVGSVhfTUFTSywgVk9URV9QUk9HUkFNX0lELCBWYWxpZGF0b3JJbmZvLCBWZXJzaW9uZWRNZXNzYWdlLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiwgVm90ZUFjY291bnQsIFZvdGVBdXRob3JpemF0aW9uTGF5b3V0LCBWb3RlSW5pdCwgVm90ZUluc3RydWN0aW9uLCBWb3RlUHJvZ3JhbSwgY2x1c3RlckFwaVVybCwgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbiwgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsImVkMjU1MTkiLCJCTiIsImJzNTgiLCJzaGEyNTYiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsImRlc2VyaWFsaXplVW5jaGVja2VkIiwiQnVmZmVyTGF5b3V0IiwiYmxvYiIsImdldFU2NENvZGVjIiwiZ2V0VTY0RW5jb2RlciIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQwJDEiLCJyZXF1aXJlJCQwJDIiLCJBZ2VudCIsImNvZXJjZSIsImluc3RhbmNlIiwic3RyaW5nIiwidHVwbGUiLCJsaXRlcmFsIiwidW5rbm93biIsInR5cGUiLCJudW1iZXIiLCJhcnJheSIsIm51bGxhYmxlIiwib3B0aW9uYWwiLCJib29sZWFuIiwicmVjb3JkIiwidW5pb24iLCJjcmVhdGUiLCJhbnkiLCJhc3NlcnQiLCJhc3NlcnQkMSIsIlJwY0NsaWVudCIsIm5vZGVGZXRjaCIsIkNvbW1vbkNsaWVudCIsIldlYlNvY2tldCIsImtlY2Nha18yNTYiLCJzZWNwMjU2azEiLCJnZW5lcmF0ZVByaXZhdGVLZXkiLCJ1dGlscyIsInJhbmRvbVByaXZhdGVLZXkiLCJnZW5lcmF0ZUtleXBhaXIiLCJwcml2YXRlU2NhbGFyIiwicHVibGljS2V5IiwiZ2V0UHVibGljS2V5Iiwic2VjcmV0S2V5IiwiVWludDhBcnJheSIsInNldCIsImlzT25DdXJ2ZSIsIkV4dGVuZGVkUG9pbnQiLCJmcm9tSGV4Iiwic2lnbiIsIm1lc3NhZ2UiLCJzbGljZSIsInZlcmlmeSIsInRvQnVmZmVyIiwiYXJyIiwiaXNCdWZmZXIiLCJmcm9tIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJTdHJ1Y3QiLCJjb25zdHJ1Y3RvciIsInByb3BlcnRpZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmNvZGUiLCJTT0xBTkFfU0NIRU1BIiwiZGVjb2RlIiwiZGF0YSIsImRlY29kZVVuY2hlY2tlZCIsIkVudW0iLCJlbnVtIiwia2V5cyIsImxlbmd0aCIsIkVycm9yIiwibWFwIiwia2V5IiwiTWFwIiwiX1B1YmxpY0tleSIsIk1BWF9TRUVEX0xFTkdUSCIsIlBVQkxJQ19LRVlfTEVOR1RIIiwiaXNQdWJsaWNLZXlEYXRhIiwidmFsdWUiLCJfYm4iLCJ1bmRlZmluZWQiLCJ1bmlxdWVQdWJsaWNLZXlDb3VudGVyIiwiUHVibGljS2V5IiwiZGVjb2RlZCIsInVuaXF1ZSIsImVxdWFscyIsImVxIiwidG9CYXNlNTgiLCJ0b0J5dGVzIiwidG9KU09OIiwiYnVmIiwiYiIsInRvQXJyYXlMaWtlIiwiemVyb1BhZCIsImFsbG9jIiwiY29weSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidG9TdHJpbmciLCJjcmVhdGVXaXRoU2VlZCIsImZyb21QdWJsaWNLZXkiLCJzZWVkIiwicHJvZ3JhbUlkIiwiY29uY2F0IiwicHVibGljS2V5Qnl0ZXMiLCJjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMiLCJzZWVkcyIsImZvckVhY2giLCJUeXBlRXJyb3IiLCJjcmVhdGVQcm9ncmFtQWRkcmVzcyIsImZpbmRQcm9ncmFtQWRkcmVzc1N5bmMiLCJub25jZSIsImFkZHJlc3MiLCJzZWVkc1dpdGhOb25jZSIsImVyciIsImZpbmRQcm9ncmFtQWRkcmVzcyIsInB1YmtleURhdGEiLCJwdWJrZXkiLCJkZWZhdWx0Iiwia2luZCIsImZpZWxkcyIsIkFjY291bnQiLCJfcHVibGljS2V5IiwiX3NlY3JldEtleSIsInNlY3JldEtleUJ1ZmZlciIsIkJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEIiwiUEFDS0VUX0RBVEFfU0laRSIsIlZFUlNJT05fUFJFRklYX01BU0siLCJTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTIiwiVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yIiwic2lnbmF0dXJlIiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IiLCJ0aW1lb3V0U2Vjb25kcyIsInRvRml4ZWQiLCJUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciIsIk1lc3NhZ2VBY2NvdW50S2V5cyIsInN0YXRpY0FjY291bnRLZXlzIiwiYWNjb3VudEtleXNGcm9tTG9va3VwcyIsImtleVNlZ21lbnRzIiwicHVzaCIsIndyaXRhYmxlIiwicmVhZG9ubHkiLCJnZXQiLCJpbmRleCIsImtleVNlZ21lbnQiLCJmbGF0IiwiY29tcGlsZUluc3RydWN0aW9ucyIsImluc3RydWN0aW9ucyIsIlU4X01BWCIsImtleUluZGV4TWFwIiwiZmluZEtleUluZGV4Iiwia2V5SW5kZXgiLCJpbnN0cnVjdGlvbiIsInByb2dyYW1JZEluZGV4IiwiYWNjb3VudEtleUluZGV4ZXMiLCJtZXRhIiwicHJvcGVydHkiLCJydXN0U3RyaW5nIiwicnNsIiwic3RydWN0IiwidTMyIiwib2Zmc2V0IiwiX2RlY29kZSIsImJpbmQiLCJfZW5jb2RlIiwicnNsU2hpbSIsInN0ciIsImNoYXJzIiwic3BhbiIsImF1dGhvcml6ZWQiLCJsb2NrdXAiLCJuczY0Iiwidm90ZUluaXQiLCJ1OCIsInZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MiLCJnZXRBbGxvYyIsImdldEl0ZW1BbGxvYyIsIml0ZW0iLCJmaWVsZCIsIkFycmF5IiwiaXNBcnJheSIsImVsZW1lbnRMYXlvdXQiLCJsYXlvdXQiLCJkZWNvZGVMZW5ndGgiLCJieXRlcyIsImxlbiIsInNpemUiLCJlbGVtIiwic2hpZnQiLCJlbmNvZGVMZW5ndGgiLCJyZW1fbGVuIiwiY29uZGl0aW9uIiwiQ29tcGlsZWRLZXlzIiwicGF5ZXIiLCJrZXlNZXRhTWFwIiwiY29tcGlsZSIsImdldE9ySW5zZXJ0RGVmYXVsdCIsImtleU1ldGEiLCJpc1NpZ25lciIsImlzV3JpdGFibGUiLCJpc0ludm9rZWQiLCJwYXllcktleU1ldGEiLCJpeCIsImFjY291bnRNZXRhIiwiZ2V0TWVzc2FnZUNvbXBvbmVudHMiLCJtYXBFbnRyaWVzIiwiZW50cmllcyIsIndyaXRhYmxlU2lnbmVycyIsImZpbHRlciIsInJlYWRvbmx5U2lnbmVycyIsIndyaXRhYmxlTm9uU2lnbmVycyIsInJlYWRvbmx5Tm9uU2lnbmVycyIsImhlYWRlciIsIm51bVJlcXVpcmVkU2lnbmF0dXJlcyIsIm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMiLCJudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMiLCJwYXllckFkZHJlc3MiLCJleHRyYWN0VGFibGVMb29rdXAiLCJsb29rdXBUYWJsZSIsIndyaXRhYmxlSW5kZXhlcyIsImRyYWluZWRXcml0YWJsZUtleXMiLCJkcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUiLCJzdGF0ZSIsImFkZHJlc3NlcyIsInJlYWRvbmx5SW5kZXhlcyIsImRyYWluZWRSZWFkb25seUtleXMiLCJhY2NvdW50S2V5IiwibG9va3VwVGFibGVFbnRyaWVzIiwia2V5TWV0YUZpbHRlciIsImxvb2t1cFRhYmxlSW5kZXhlcyIsImRyYWluZWRLZXlzIiwibG9va3VwVGFibGVJbmRleCIsImZpbmRJbmRleCIsImVudHJ5IiwiZGVsZXRlIiwiRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFIiwiZ3VhcmRlZFNoaWZ0IiwiYnl0ZUFycmF5IiwiZ3VhcmRlZFNwbGljZSIsImFyZ3MiLCJzdGFydCIsInNwbGljZSIsIk1lc3NhZ2UiLCJhY2NvdW50S2V5cyIsInJlY2VudEJsb2NraGFzaCIsImluZGV4VG9Qcm9ncmFtSWRzIiwiYWNjb3VudCIsInZlcnNpb24iLCJjb21waWxlZEluc3RydWN0aW9ucyIsImFjY291bnRzIiwiYWRkcmVzc1RhYmxlTG9va3VwcyIsImdldEFjY291bnRLZXlzIiwiY29tcGlsZWRLZXlzIiwicGF5ZXJLZXkiLCJpc0FjY291bnRTaWduZXIiLCJpc0FjY291bnRXcml0YWJsZSIsIm51bVNpZ25lZEFjY291bnRzIiwidW5zaWduZWRBY2NvdW50SW5kZXgiLCJudW1VbnNpZ25lZEFjY291bnRzIiwibnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzIiwibnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyIsImlzUHJvZ3JhbUlkIiwiaGFzIiwicHJvZ3JhbUlkcyIsInZhbHVlcyIsIm5vblByb2dyYW1JZHMiLCJfIiwibnVtS2V5cyIsImtleUNvdW50Iiwia2V5SW5kaWNlc0NvdW50IiwiZGF0YUNvdW50Iiwia2V5SW5kaWNlcyIsImRhdGFMZW5ndGgiLCJpbnN0cnVjdGlvbkNvdW50IiwiaW5zdHJ1Y3Rpb25CdWZmZXIiLCJpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCIsImluc3RydWN0aW9uTGF5b3V0Iiwic2VxIiwic2lnbkRhdGFMYXlvdXQiLCJ0cmFuc2FjdGlvbiIsInNpZ25EYXRhIiwiYWNjb3VudENvdW50IiwiaSIsImRhdGFTbGljZSIsIm1lc3NhZ2VBcmdzIiwiTWVzc2FnZVYwIiwibnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyIsImNvdW50IiwibG9va3VwIiwiYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMiLCJyZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyIsIm51bVN0YXRpY0FjY291bnRLZXlzIiwibG9va3VwQWNjb3VudEtleXNJbmRleCIsIm51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXMiLCJyZWR1Y2UiLCJ0YWJsZUxvb2t1cCIsInRhYmxlQWNjb3VudCIsImZpbmQiLCJsb29rdXBUYWJsZUFjY291bnRzIiwiZXh0cmFjdFJlc3VsdCIsImFkZHJlc3NUYWJsZUxvb2t1cCIsImVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCIsInNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMiLCJzZXJpYWxpemVJbnN0cnVjdGlvbnMiLCJlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoIiwic2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMiLCJzZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzIiwiZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgiLCJtZXNzYWdlTGF5b3V0Iiwic2VyaWFsaXplZE1lc3NhZ2UiLCJNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVgiLCJzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCIsInByZWZpeCIsInN0YXRpY0FjY291bnRLZXlzTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25zTGVuZ3RoIiwiYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCIsInNlcmlhbGl6ZWRMZW5ndGgiLCJlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgiLCJlbmNvZGVkRGF0YUxlbmd0aCIsImVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgiLCJlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoIiwiYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0IiwibWFza2VkUHJlZml4IiwiYWNjb3VudEtleUluZGV4ZXNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBzQ291bnQiLCJ3cml0YWJsZUluZGV4ZXNMZW5ndGgiLCJyZWFkb25seUluZGV4ZXNMZW5ndGgiLCJWZXJzaW9uZWRNZXNzYWdlIiwiZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbiIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiREVGQVVMVF9TSUdOQVRVUkUiLCJmaWxsIiwiVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiIsIm9wdHMiLCJUcmFuc2FjdGlvbiIsInNpZ25hdHVyZXMiLCJmZWVQYXllciIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0Iiwibm9uY2VJbmZvIiwibWluTm9uY2VDb250ZXh0U2xvdCIsIl9tZXNzYWdlIiwiX2pzb24iLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtaW5Db250ZXh0U2xvdCIsImJsb2NraGFzaCIsIm5vbmNlSW5zdHJ1Y3Rpb24iLCJzaWduZXJzIiwiYWRkIiwiaXRlbXMiLCJjb21waWxlTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb25zb2xlIiwid2FybiIsImFjY291bnRNZXRhcyIsImluY2x1ZGVzIiwidW5pcXVlTWV0YXMiLCJwdWJrZXlTdHJpbmciLCJ1bmlxdWVJbmRleCIsIngiLCJzb3J0IiwieSIsIm9wdGlvbnMiLCJsb2NhbGVNYXRjaGVyIiwidXNhZ2UiLCJzZW5zaXRpdml0eSIsImlnbm9yZVB1bmN0dWF0aW9uIiwibnVtZXJpYyIsImNhc2VGaXJzdCIsImxvY2FsZUNvbXBhcmUiLCJmZWVQYXllckluZGV4IiwicGF5ZXJNZXRhIiwidW5zaGlmdCIsInNpZ25lZEtleXMiLCJ1bnNpZ25lZEtleXMiLCJpbmRleE9mIiwiX2NvbXBpbGUiLCJ2YWxpZCIsImV2ZXJ5IiwicGFpciIsInNlcmlhbGl6ZU1lc3NhZ2UiLCJnZXRFc3RpbWF0ZWRGZWUiLCJjb25uZWN0aW9uIiwiZ2V0RmVlRm9yTWVzc2FnZSIsInNldFNpZ25lcnMiLCJzZWVuIiwiU2V0IiwidW5pcXVlU2lnbmVycyIsInNpZ25lciIsIl9wYXJ0aWFsU2lnbiIsInBhcnRpYWxTaWduIiwiX2FkZFNpZ25hdHVyZSIsImFkZFNpZ25hdHVyZSIsInNpZ3BhaXIiLCJ2ZXJpZnlTaWduYXR1cmVzIiwicmVxdWlyZUFsbFNpZ25hdHVyZXMiLCJzaWduYXR1cmVFcnJvcnMiLCJfZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMiLCJlcnJvcnMiLCJtaXNzaW5nIiwiaW52YWxpZCIsImNvbmZpZyIsInNpZ0Vycm9ycyIsImVycm9yTWVzc2FnZSIsInAiLCJqb2luIiwiX3NlcmlhbGl6ZSIsInNpZ25hdHVyZUNvdW50IiwidHJhbnNhY3Rpb25MZW5ndGgiLCJ3aXJlVHJhbnNhY3Rpb24iLCJrZXlPYmoiLCJwb3B1bGF0ZSIsInNpZ1B1YmtleVBhaXIiLCJzb21lIiwiVHJhbnNhY3Rpb25NZXNzYWdlIiwiZGVjb21waWxlIiwiY29tcGlsZWRJeCIsImNvbXBpbGVUb0xlZ2FjeU1lc3NhZ2UiLCJjb21waWxlVG9WME1lc3NhZ2UiLCJWZXJzaW9uZWRUcmFuc2FjdGlvbiIsImRlZmF1bHRTaWduYXR1cmVzIiwiZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgiLCJ0cmFuc2FjdGlvbkxheW91dCIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCIsInNpZ25hdHVyZXNMZW5ndGgiLCJtZXNzYWdlRGF0YSIsInNpZ25lclB1YmtleXMiLCJzaWduZXJJbmRleCIsIk5VTV9USUNLU19QRVJfU0VDT05EIiwiREVGQVVMVF9USUNLU19QRVJfU0xPVCIsIk5VTV9TTE9UU19QRVJfU0VDT05EIiwiTVNfUEVSX1NMT1QiLCJTWVNWQVJfQ0xPQ0tfUFVCS0VZIiwiU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWSIsIlNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZIiwiU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkiLCJTWVNWQVJfUkVOVF9QVUJLRVkiLCJTWVNWQVJfUkVXQVJEU19QVUJLRVkiLCJTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZIiwiU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVkiLCJTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkiLCJTZW5kVHJhbnNhY3Rpb25FcnJvciIsImFjdGlvbiIsInRyYW5zYWN0aW9uTWVzc2FnZSIsImxvZ3MiLCJtYXliZUxvZ3NPdXRwdXQiLCJndWlkZVRleHQiLCJhIiwidHJhbnNhY3Rpb25Mb2dzIiwidHJhbnNhY3Rpb25FcnJvciIsImNhY2hlZExvZ3MiLCJnZXRMb2dzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJnZXRUcmFuc2FjdGlvbiIsInRoZW4iLCJ0eCIsImxvZ01lc3NhZ2VzIiwiY2F0Y2giLCJTb2xhbmFKU09OUlBDRXJyb3JDb2RlIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRSIsIkpTT05fUlBDX1NDQU5fRVJST1IiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTiIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEIiwiU29sYW5hSlNPTlJQQ0Vycm9yIiwiY29kZSIsImN1c3RvbU1lc3NhZ2UiLCJuYW1lIiwic2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiIsInNlbmRPcHRpb25zIiwic2tpcFByZWZsaWdodCIsInByZWZsaWdodENvbW1pdG1lbnQiLCJjb21taXRtZW50IiwibWF4UmV0cmllcyIsInNlbmRUcmFuc2FjdGlvbiIsInN0YXR1cyIsImNvbmZpcm1UcmFuc2FjdGlvbiIsImFib3J0U2lnbmFsIiwibm9uY2VBY2NvdW50UHVia2V5Iiwibm9uY2VWYWx1ZSIsInNsZWVwIiwibXMiLCJzZXRUaW1lb3V0IiwiZW5jb2RlRGF0YSIsImFsbG9jTGVuZ3RoIiwibGF5b3V0RmllbGRzIiwiZGVjb2RlRGF0YSQxIiwiRmVlQ2FsY3VsYXRvckxheW91dCIsIm51NjQiLCJOb25jZUFjY291bnRMYXlvdXQiLCJOT05DRV9BQ0NPVU5UX0xFTkdUSCIsIk5vbmNlQWNjb3VudCIsImF1dGhvcml6ZWRQdWJrZXkiLCJmZWVDYWxjdWxhdG9yIiwiZnJvbUFjY291bnREYXRhIiwibm9uY2VBY2NvdW50IiwidTY0IiwiYmlnSW50TGF5b3V0IiwiY29kZWMiLCJzcmMiLCJiaWdJbnQiLCJTeXN0ZW1JbnN0cnVjdGlvbiIsImRlY29kZUluc3RydWN0aW9uVHlwZSIsImNoZWNrUHJvZ3JhbUlkIiwiaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0IiwidHlwZUluZGV4IiwiaXhUeXBlIiwiU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVDcmVhdGVBY2NvdW50IiwiY2hlY2tLZXlMZW5ndGgiLCJsYW1wb3J0cyIsInNwYWNlIiwiQ3JlYXRlIiwiZnJvbVB1YmtleSIsIm5ld0FjY291bnRQdWJrZXkiLCJkZWNvZGVUcmFuc2ZlciIsIlRyYW5zZmVyIiwidG9QdWJrZXkiLCJkZWNvZGVUcmFuc2ZlcldpdGhTZWVkIiwiVHJhbnNmZXJXaXRoU2VlZCIsImJhc2VQdWJrZXkiLCJkZWNvZGVBbGxvY2F0ZSIsIkFsbG9jYXRlIiwiYWNjb3VudFB1YmtleSIsImRlY29kZUFsbG9jYXRlV2l0aFNlZWQiLCJiYXNlIiwiQWxsb2NhdGVXaXRoU2VlZCIsImRlY29kZUFzc2lnbiIsIkFzc2lnbiIsImRlY29kZUFzc2lnbldpdGhTZWVkIiwiQXNzaWduV2l0aFNlZWQiLCJkZWNvZGVDcmVhdGVXaXRoU2VlZCIsIkNyZWF0ZVdpdGhTZWVkIiwiZGVjb2RlTm9uY2VJbml0aWFsaXplIiwiSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCIsIm5vbmNlUHVia2V5IiwiZGVjb2RlTm9uY2VBZHZhbmNlIiwiQWR2YW5jZU5vbmNlQWNjb3VudCIsImRlY29kZU5vbmNlV2l0aGRyYXciLCJXaXRoZHJhd05vbmNlQWNjb3VudCIsImRlY29kZU5vbmNlQXV0aG9yaXplIiwiQXV0aG9yaXplTm9uY2VBY2NvdW50IiwibmV3QXV0aG9yaXplZFB1YmtleSIsIlN5c3RlbVByb2dyYW0iLCJleHBlY3RlZExlbmd0aCIsImZyZWV6ZSIsIlVwZ3JhZGVOb25jZUFjY291bnQiLCJjcmVhdGVBY2NvdW50IiwicGFyYW1zIiwidHJhbnNmZXIiLCJCaWdJbnQiLCJjcmVhdGVBY2NvdW50V2l0aFNlZWQiLCJjcmVhdGVOb25jZUFjY291bnQiLCJpbml0UGFyYW1zIiwibm9uY2VJbml0aWFsaXplIiwiaW5zdHJ1Y3Rpb25EYXRhIiwibm9uY2VBZHZhbmNlIiwibm9uY2VXaXRoZHJhdyIsIm5vbmNlQXV0aG9yaXplIiwiYWxsb2NhdGUiLCJDSFVOS19TSVpFIiwiTG9hZGVyIiwiZ2V0TWluTnVtU2lnbmF0dXJlcyIsIk1hdGgiLCJjZWlsIiwiY2h1bmtTaXplIiwibG9hZCIsInByb2dyYW0iLCJiYWxhbmNlTmVlZGVkIiwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uIiwicHJvZ3JhbUluZm8iLCJnZXRBY2NvdW50SW5mbyIsImV4ZWN1dGFibGUiLCJlcnJvciIsIm93bmVyIiwiZGF0YUxheW91dCIsInRyYW5zYWN0aW9ucyIsImJ5dGVzTGVuZ3RoIiwiYnl0ZXNMZW5ndGhQYWRkaW5nIiwiX3JwY0VuZHBvaW50IiwiUkVRVUVTVFNfUEVSX1NFQ09ORCIsImFsbCIsImRlcGxveUNvbW1pdG1lbnQiLCJmaW5hbGl6ZVNpZ25hdHVyZSIsImNvbnRleHQiLCJjdXJyZW50U2xvdCIsImdldFNsb3QiLCJzbG90Iiwicm91bmQiLCJCUEZfTE9BREVSX1BST0dSQU1fSUQiLCJCcGZMb2FkZXIiLCJlbGYiLCJsb2FkZXJQcm9ncmFtSWQiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIl9fZXNNb2R1bGUiLCJhZ2VudGtlZXBhbGl2ZSIsImV4cG9ydHMiLCJoYXNSZXF1aXJlZE1zIiwicmVxdWlyZU1zIiwicyIsIm0iLCJoIiwiZCIsInciLCJ2YWwiLCJwYXJzZSIsImlzRmluaXRlIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsIlN0cmluZyIsIm1hdGNoIiwiZXhlYyIsIm4iLCJwYXJzZUZsb2F0IiwidG9Mb3dlckNhc2UiLCJtc0FicyIsImFicyIsInBsdXJhbCIsImlzUGx1cmFsIiwiaHVtYW5pemVNcyIsImhhc1JlcXVpcmVkSHVtYW5pemVNcyIsInJlcXVpcmVIdW1hbml6ZU1zIiwidXRpbCIsInQiLCJyIiwiZm9ybWF0Iiwic3RhY2siLCJjb25zdGFudHMiLCJoYXNSZXF1aXJlZENvbnN0YW50cyIsInJlcXVpcmVDb25zdGFudHMiLCJDVVJSRU5UX0lEIiwiQ1JFQVRFX0lEIiwiSU5JVF9TT0NLRVQiLCJDUkVBVEVfSFRUUFNfQ09OTkVDVElPTiIsIlNPQ0tFVF9DUkVBVEVEX1RJTUUiLCJTT0NLRVRfTkFNRSIsIlNPQ0tFVF9SRVFVRVNUX0NPVU5UIiwiU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQiLCJhZ2VudCIsImhhc1JlcXVpcmVkQWdlbnQiLCJyZXF1aXJlQWdlbnQiLCJPcmlnaW5hbEFnZW50IiwiZGVidWciLCJkZWJ1Z2xvZyIsImRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCIsIm1ham9yVmVyc2lvbiIsInBhcnNlSW50IiwicHJvY2VzcyIsInNwbGl0Iiwic3Vic3RyaW5nIiwiZGVwcmVjYXRlIiwibG9nIiwia2VlcEFsaXZlIiwiZnJlZVNvY2tldFRpbWVvdXQiLCJrZWVwQWxpdmVUaW1lb3V0IiwiZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQiLCJ0aW1lb3V0IiwibWF4Iiwic29ja2V0QWN0aXZlVFRMIiwiY3JlYXRlU29ja2V0Q291bnQiLCJjcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayIsImNyZWF0ZVNvY2tldEVycm9yQ291bnQiLCJjcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrIiwiY2xvc2VTb2NrZXRDb3VudCIsImNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2siLCJlcnJvclNvY2tldENvdW50IiwiZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayIsInJlcXVlc3RDb3VudCIsInJlcXVlc3RDb3VudExhc3RDaGVjayIsInRpbWVvdXRTb2NrZXRDb3VudCIsInRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayIsIm9uIiwic29ja2V0IiwiY2FsY1NvY2tldFRpbWVvdXQiLCJhbGl2ZVRpbWUiLCJEYXRlIiwibm93IiwiZGlmZiIsImN1c3RvbUZyZWVTb2NrZXRUaW1lb3V0Iiwia2VlcFNvY2tldEFsaXZlIiwicmVzdWx0IiwiY3VzdG9tVGltZW91dCIsInJldXNlU29ja2V0IiwicmVxIiwicmV1c2VkU29ja2V0IiwiYWdlbnRUaW1lb3V0IiwiZ2V0U29ja2V0VGltZW91dCIsImlkIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInNldE5vRGVsYXkiLCJfYWdlbnRLZXkiLCJpbnN0YWxsTGlzdGVuZXJzIiwiY3JlYXRlQ29ubmVjdGlvbiIsIm9uY3JlYXRlIiwiY2FsbGVkIiwib25OZXdDcmVhdGUiLCJuZXdTb2NrZXQiLCJzdGF0dXNDaGFuZ2VkIiwiY2hhbmdlZCIsImdldEN1cnJlbnRTdGF0dXMiLCJmcmVlU29ja2V0cyIsImluc3BlY3QiLCJzb2NrZXRzIiwicmVxdWVzdHMiLCJfaWRsZVRpbWVvdXQiLCJvbkZyZWUiLCJfaHR0cE1lc3NhZ2UiLCJnZXROYW1lIiwib25DbG9zZSIsImlzRXJyb3IiLCJvblRpbWVvdXQiLCJsaXN0ZW5lckNvdW50IiwibGlzdGVuZXJzIiwicmVxVGltZW91dExpc3RlbmVyQ291bnQiLCJlbmFibGVkIiwiZiIsImRlc3Ryb3kiLCJyZW1vdmVTb2NrZXQiLCJvbkVycm9yIiwicmVtb3ZlTGlzdGVuZXIiLCJlbWl0Iiwib25SZW1vdmUiLCJvYmoiLCJyZXMiLCJodHRwc19hZ2VudCIsImhhc1JlcXVpcmVkSHR0cHNfYWdlbnQiLCJyZXF1aXJlSHR0cHNfYWdlbnQiLCJPcmlnaW5hbEh0dHBzQWdlbnQiLCJIdHRwQWdlbnQiLCJIdHRwc0FnZW50IiwiZGVmYXVsdFBvcnQiLCJwcm90b2NvbCIsIm1heENhY2hlZFNlc3Npb25zIiwiX3Nlc3Npb25DYWNoZSIsImxpc3QiLCJtZXRob2QiLCJoYXNSZXF1aXJlZEFnZW50a2VlcGFsaXZlIiwicmVxdWlyZUFnZW50a2VlcGFsaXZlIiwiYWdlbnRrZWVwYWxpdmVFeHBvcnRzIiwiSHR0cEtlZXBBbGl2ZUFnZW50IiwiZmFzdFN0YWJsZVN0cmluZ2lmeSQxIiwiaGFzUmVxdWlyZWRGYXN0U3RhYmxlU3RyaW5naWZ5IiwicmVxdWlyZUZhc3RTdGFibGVTdHJpbmdpZnkiLCJvYmpUb1N0cmluZyIsIm9iaktleXMiLCJpc0FycmF5UHJvcCIsInByb3BWYWwiLCJ0b1N0ciIsInJldHVyblZhbCIsImZhc3RTdGFibGVTdHJpbmdpZnlFeHBvcnRzIiwiZmFzdFN0YWJsZVN0cmluZ2lmeSIsIk1JTklNVU1fU0xPVF9QRVJfRVBPQ0giLCJ0cmFpbGluZ1plcm9zIiwibmV4dFBvd2VyT2ZUd28iLCJFcG9jaFNjaGVkdWxlIiwic2xvdHNQZXJFcG9jaCIsImxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCIsIndhcm11cCIsImZpcnN0Tm9ybWFsRXBvY2giLCJmaXJzdE5vcm1hbFNsb3QiLCJnZXRFcG9jaCIsImdldEVwb2NoQW5kU2xvdEluZGV4IiwiZXBvY2giLCJlcG9jaExlbiIsImdldFNsb3RzSW5FcG9jaCIsInNsb3RJbmRleCIsIm5vcm1hbFNsb3RJbmRleCIsIm5vcm1hbEVwb2NoSW5kZXgiLCJmbG9vciIsImdldEZpcnN0U2xvdEluRXBvY2giLCJwb3ciLCJnZXRMYXN0U2xvdEluRXBvY2giLCJmZXRjaEltcGwiLCJnbG9iYWxUaGlzIiwiZmV0Y2giLCJpbnB1dCIsImluaXQiLCJwcm9jZXNzZWRJbnB1dCIsIlJwY1dlYlNvY2tldENsaWVudCIsImdlbmVyYXRlX3JlcXVlc3RfaWQiLCJ3ZWJTb2NrZXRGYWN0b3J5IiwidXJsIiwicnBjIiwiYXV0b2Nvbm5lY3QiLCJtYXhfcmVjb25uZWN0cyIsInJlY29ubmVjdCIsInJlY29ubmVjdF9pbnRlcnZhbCIsInVuZGVybHlpbmdTb2NrZXQiLCJyZWFkeVN0YXRlIiwibm90aWZ5IiwiZGVjb2RlRGF0YSIsIkxPT0tVUF9UQUJMRV9NRVRBX1NJWkUiLCJBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IiwiaXNBY3RpdmUiLCJVNjRfTUFYIiwiZGVhY3RpdmF0aW9uU2xvdCIsImFjY291bnREYXRhIiwiTG9va3VwVGFibGVNZXRhTGF5b3V0Iiwic2VyaWFsaXplZEFkZHJlc3Nlc0xlbiIsIm51bVNlcmlhbGl6ZWRBZGRyZXNzZXMiLCJsYXN0RXh0ZW5kZWRTbG90IiwibGFzdEV4dGVuZGVkU2xvdFN0YXJ0SW5kZXgiLCJsYXN0RXh0ZW5kZWRTdGFydEluZGV4IiwiYXV0aG9yaXR5IiwiVVJMX1JFIiwibWFrZVdlYnNvY2tldFVybCIsImVuZHBvaW50IiwibWF0Y2hlcyIsImhvc3Rpc2giLCJwb3J0V2l0aENvbG9uIiwicmVzdCIsInN0YXJ0c1dpdGgiLCJzdGFydFBvcnQiLCJ3ZWJzb2NrZXRQb3J0IiwiUHVibGljS2V5RnJvbVN0cmluZyIsIlJhd0FjY291bnREYXRhUmVzdWx0IiwiQnVmZmVyRnJvbVJhd0FjY291bnREYXRhIiwiQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMiLCJhc3NlcnRFbmRwb2ludFVybCIsInB1dGF0aXZlVXJsIiwidGVzdCIsImV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyIsImNvbW1pdG1lbnRPckNvbmZpZyIsInNwZWNpZmllZENvbW1pdG1lbnQiLCJzcGVjaWZpZWRDb25maWciLCJhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyIsImZpbHRlcnMiLCJtZW1jbXAiLCJlbmNvZGluZyIsImNyZWF0ZVJwY1Jlc3VsdCIsImpzb25ycGMiLCJVbmtub3duUnBjUmVzdWx0IiwianNvblJwY1Jlc3VsdCIsInNjaGVtYSIsImpzb25ScGNSZXN1bHRBbmRDb250ZXh0Iiwibm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dCIsInZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UiLCJyZXNwb25zZSIsIkdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0IiwiZm91bmRhdGlvbiIsImZvdW5kYXRpb25UZXJtIiwiaW5pdGlhbCIsInRhcGVyIiwidGVybWluYWwiLCJHZXRJbmZsYXRpb25SZXdhcmRSZXN1bHQiLCJlZmZlY3RpdmVTbG90IiwiYW1vdW50IiwicG9zdEJhbGFuY2UiLCJjb21taXNzaW9uIiwiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0IiwicHJpb3JpdGl6YXRpb25GZWUiLCJHZXRJbmZsYXRpb25SYXRlUmVzdWx0IiwidG90YWwiLCJ2YWxpZGF0b3IiLCJHZXRFcG9jaEluZm9SZXN1bHQiLCJzbG90c0luRXBvY2giLCJhYnNvbHV0ZVNsb3QiLCJibG9ja0hlaWdodCIsInRyYW5zYWN0aW9uQ291bnQiLCJHZXRFcG9jaFNjaGVkdWxlUmVzdWx0IiwiR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQiLCJUcmFuc2FjdGlvbkVycm9yUmVzdWx0IiwiU2lnbmF0dXJlU3RhdHVzUmVzdWx0IiwiU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHQiLCJWZXJzaW9uUmVzdWx0IiwiUGFyc2VkSW5zdHJ1Y3Rpb25TdHJ1Y3QiLCJwYXJzZWQiLCJQYXJ0aWFsbHlEZWNvZGVkSW5zdHJ1Y3Rpb25TdHJ1Y3QiLCJTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0IiwicmVudEVwb2NoIiwidW5pdHNDb25zdW1lZCIsInJldHVybkRhdGEiLCJpbm5lckluc3RydWN0aW9ucyIsIkJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0IiwiYnlJZGVudGl0eSIsInJhbmdlIiwiZmlyc3RTbG90IiwibGFzdFNsb3QiLCJjcmVhdGVScGNDbGllbnQiLCJodHRwSGVhZGVycyIsImN1c3RvbUZldGNoIiwiZmV0Y2hNaWRkbGV3YXJlIiwiZGlzYWJsZVJldHJ5T25SYXRlTGltaXQiLCJodHRwQWdlbnQiLCJhZ2VudE9wdGlvbnMiLCJtYXhTb2NrZXRzIiwiaXNIdHRwcyIsImZldGNoV2l0aE1pZGRsZXdhcmUiLCJpbmZvIiwibW9kaWZpZWRGZXRjaEFyZ3MiLCJtb2RpZmllZEluZm8iLCJtb2RpZmllZEluaXQiLCJjbGllbnRCcm93c2VyIiwicmVxdWVzdCIsImNhbGxiYWNrIiwiYm9keSIsImhlYWRlcnMiLCJDT01NT05fSFRUUF9IRUFERVJTIiwidG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyIsIndhaXRUaW1lIiwic3RhdHVzVGV4dCIsInRleHQiLCJvayIsImNyZWF0ZVJwY1JlcXVlc3QiLCJjbGllbnQiLCJjcmVhdGVScGNCYXRjaFJlcXVlc3QiLCJiYXRjaCIsIm1ldGhvZE5hbWUiLCJHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCIsIkdldEluZmxhdGlvblJhdGVScGNSZXN1bHQiLCJHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQiLCJHZXRFcG9jaEluZm9ScGNSZXN1bHQiLCJHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0IiwiR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQiLCJTbG90UnBjUmVzdWx0IiwiR2V0U3VwcGx5UnBjUmVzdWx0IiwiY2lyY3VsYXRpbmciLCJub25DaXJjdWxhdGluZyIsIm5vbkNpcmN1bGF0aW5nQWNjb3VudHMiLCJUb2tlbkFtb3VudFJlc3VsdCIsInVpQW1vdW50IiwiZGVjaW1hbHMiLCJ1aUFtb3VudFN0cmluZyIsIkdldFRva2VuTGFyZ2VzdEFjY291bnRzUmVzdWx0IiwiR2V0VG9rZW5BY2NvdW50c0J5T3duZXIiLCJQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCIsIkdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyIiwiR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0IiwiQWNjb3VudEluZm9SZXN1bHQiLCJLZXllZEFjY291bnRJbmZvUmVzdWx0IiwiUGFyc2VkT3JSYXdBY2NvdW50RGF0YSIsIlBhcnNlZEFjY291bnRJbmZvUmVzdWx0IiwiS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCIsIlN0YWtlQWN0aXZhdGlvblJlc3VsdCIsImFjdGl2ZSIsImluYWN0aXZlIiwiR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0IiwibWVtbyIsImJsb2NrVGltZSIsIkdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0IiwiQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsInN1YnNjcmlwdGlvbiIsIlByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCIsIlByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0IiwiU2xvdEluZm9SZXN1bHQiLCJwYXJlbnQiLCJyb290IiwiU2xvdE5vdGlmaWNhdGlvblJlc3VsdCIsIlNsb3RVcGRhdGVSZXN1bHQiLCJ0aW1lc3RhbXAiLCJzdGF0cyIsIm51bVRyYW5zYWN0aW9uRW50cmllcyIsIm51bVN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnMiLCJudW1GYWlsZWRUcmFuc2FjdGlvbnMiLCJtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeSIsIlNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQiLCJTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQiLCJSb290Tm90aWZpY2F0aW9uUmVzdWx0IiwiQ29udGFjdEluZm9SZXN1bHQiLCJnb3NzaXAiLCJ0cHUiLCJWb3RlQWNjb3VudEluZm9SZXN1bHQiLCJ2b3RlUHVia2V5Iiwibm9kZVB1YmtleSIsImFjdGl2YXRlZFN0YWtlIiwiZXBvY2hWb3RlQWNjb3VudCIsImVwb2NoQ3JlZGl0cyIsImxhc3RWb3RlIiwicm9vdFNsb3QiLCJHZXRWb3RlQWNjb3VudHMiLCJjdXJyZW50IiwiZGVsaW5xdWVudCIsIkNvbmZpcm1hdGlvblN0YXR1cyIsIlNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlIiwiY29uZmlybWF0aW9ucyIsImNvbmZpcm1hdGlvblN0YXR1cyIsIkdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0IiwiR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0IiwiQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0IiwiQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQiLCJBbm5vdGF0ZWRBY2NvdW50S2V5Iiwic291cmNlIiwiQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQiLCJQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCIsIlJhd0luc3RydWN0aW9uUmVzdWx0IiwiSW5zdHJ1Y3Rpb25SZXN1bHQiLCJVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQiLCJQYXJzZWRPclJhd0luc3RydWN0aW9uIiwiUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQiLCJUb2tlbkJhbGFuY2VSZXN1bHQiLCJhY2NvdW50SW5kZXgiLCJtaW50IiwidWlUb2tlbkFtb3VudCIsIkxvYWRlZEFkZHJlc3Nlc1Jlc3VsdCIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCIsImZlZSIsInByZUJhbGFuY2VzIiwicG9zdEJhbGFuY2VzIiwicHJlVG9rZW5CYWxhbmNlcyIsInBvc3RUb2tlbkJhbGFuY2VzIiwibG9hZGVkQWRkcmVzc2VzIiwiY29tcHV0ZVVuaXRzQ29uc3VtZWQiLCJjb3N0VW5pdHMiLCJQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCJUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QiLCJSZXdhcmRzUmVzdWx0IiwicmV3YXJkVHlwZSIsIkdldEJsb2NrUnBjUmVzdWx0IiwicHJldmlvdXNCbG9ja2hhc2giLCJwYXJlbnRTbG90IiwicmV3YXJkcyIsIkdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZEJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQiLCJHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQiLCJHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0IiwiR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0IiwiSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCIsIlBlcmZTYW1wbGVSZXN1bHQiLCJudW1UcmFuc2FjdGlvbnMiLCJudW1TbG90cyIsInNhbXBsZVBlcmlvZFNlY3MiLCJHZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNScGNSZXN1bHQiLCJHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0IiwibGFtcG9ydHNQZXJTaWduYXR1cmUiLCJSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCIsIlNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkxvZ3NSZXN1bHQiLCJMb2dzTm90aWZpY2F0aW9uUmVzdWx0IiwiQ29ubmVjdGlvbiIsIl9jb21taXRtZW50T3JDb25maWciLCJfY29tbWl0bWVudCIsIl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCIsIl9ycGNXc0VuZHBvaW50IiwiX3JwY0NsaWVudCIsIl9ycGNSZXF1ZXN0IiwiX3JwY0JhdGNoUmVxdWVzdCIsIl9ycGNXZWJTb2NrZXQiLCJfcnBjV2ViU29ja2V0Q29ubmVjdGVkIiwiX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCIsIl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCIsIl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uIiwiX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nIiwiX3BvbGxpbmdCbG9ja2hhc2giLCJfYmxvY2toYXNoSW5mbyIsImxhdGVzdEJsb2NraGFzaCIsImxhc3RGZXRjaCIsInRyYW5zYWN0aW9uU2lnbmF0dXJlcyIsInNpbXVsYXRlZFNpZ25hdHVyZXMiLCJfbmV4dENsaWVudFN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoIiwiX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uc0J5SGFzaCIsIl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMiLCJnZXRCbG9ja0hlaWdodCIsInJlcXVlc3RQcm9taXNlcyIsIl9idWlsZEFyZ3MiLCJyZXF1ZXN0SGFzaCIsInVuc2FmZVJlcyIsIndzRW5kcG9pbnQiLCJjb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCIsIkluZmluaXR5IiwiX3dzT25PcGVuIiwiX3dzT25FcnJvciIsIl93c09uQ2xvc2UiLCJfd3NPbkFjY291bnROb3RpZmljYXRpb24iLCJfd3NPblByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uIiwiX3dzT25TbG90Tm90aWZpY2F0aW9uIiwiX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbiIsIl93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uIiwiX3dzT25Sb290Tm90aWZpY2F0aW9uIiwiX3dzT25Mb2dzTm90aWZpY2F0aW9uIiwicnBjRW5kcG9pbnQiLCJnZXRCYWxhbmNlQW5kQ29udGV4dCIsImdldEJhbGFuY2UiLCJlIiwiZ2V0QmxvY2tUaW1lIiwiZ2V0TWluaW11bUxlZGdlclNsb3QiLCJnZXRGaXJzdEF2YWlsYWJsZUJsb2NrIiwiZ2V0U3VwcGx5IiwiY29uZmlnQXJnIiwiZ2V0VG9rZW5TdXBwbHkiLCJ0b2tlbk1pbnRBZGRyZXNzIiwiZ2V0VG9rZW5BY2NvdW50QmFsYW5jZSIsInRva2VuQWRkcmVzcyIsImdldFRva2VuQWNjb3VudHNCeU93bmVyIiwib3duZXJBZGRyZXNzIiwiX2FyZ3MiLCJnZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsImdldExhcmdlc3RBY2NvdW50cyIsImFyZyIsImdldFRva2VuTGFyZ2VzdEFjY291bnRzIiwibWludEFkZHJlc3MiLCJnZXRBY2NvdW50SW5mb0FuZENvbnRleHQiLCJnZXRQYXJzZWRBY2NvdW50SW5mbyIsImdldE11bHRpcGxlUGFyc2VkQWNjb3VudHMiLCJwdWJsaWNLZXlzIiwicmF3Q29uZmlnIiwiZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0IiwiZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8iLCJnZXRTdGFrZUFjdGl2YXRpb24iLCJnZXRQcm9ncmFtQWNjb3VudHMiLCJjb25maWdPckNvbW1pdG1lbnQiLCJjb25maWdXaXRob3V0RW5jb2RpbmciLCJiYXNlU2NoZW1hIiwid2l0aENvbnRleHQiLCJnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMiLCJzdHJhdGVneSIsInJhd1NpZ25hdHVyZSIsImFib3J0ZWQiLCJyZWFzb24iLCJkZWNvZGVkU2lnbmF0dXJlIiwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3kiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5IiwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSIsImdldENhbmNlbGxhdGlvblByb21pc2UiLCJzaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlIiwic2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQiLCJkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciIsImRvbmUiLCJjb25maXJtYXRpb25Qcm9taXNlIiwib25TaWduYXR1cmUiLCJfX3R5cGUiLCJQUk9DRVNTRUQiLCJzdWJzY3JpcHRpb25TZXR1cFByb21pc2UiLCJyZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAiLCJfb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZSIsIm5leHRTdGF0ZSIsImdldFNpZ25hdHVyZVN0YXR1cyIsImFib3J0Q29uZmlybWF0aW9uIiwicmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIiLCJleHBpcnlQcm9taXNlIiwiY2hlY2tCbG9ja0hlaWdodCIsIl9lIiwiY3VycmVudEJsb2NrSGVpZ2h0IiwiQkxPQ0tIRUlHSFRfRVhDRUVERUQiLCJjYW5jZWxsYXRpb25Qcm9taXNlIiwib3V0Y29tZSIsInJhY2UiLCJjdXJyZW50Tm9uY2VWYWx1ZSIsImxhc3RDaGVja2VkU2xvdCIsImdldEN1cnJlbnROb25jZVZhbHVlIiwiZ2V0Tm9uY2VBbmRDb250ZXh0IiwiTk9OQ0VfSU5WQUxJRCIsInNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlIiwic2lnbmF0dXJlU3RhdHVzIiwiY29tbWl0bWVudEZvclN0YXR1cyIsInRpbWVvdXRJZCIsInRpbWVvdXRNcyIsIlRJTUVEX09VVCIsImNsZWFyVGltZW91dCIsImdldENsdXN0ZXJOb2RlcyIsImdldFZvdGVBY2NvdW50cyIsImdldFNsb3RMZWFkZXIiLCJnZXRTbG90TGVhZGVycyIsInN0YXJ0U2xvdCIsImxpbWl0IiwiZ2V0U2lnbmF0dXJlU3RhdHVzZXMiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwiZ2V0VG90YWxTdXBwbHkiLCJleGNsdWRlTm9uQ2lyY3VsYXRpbmdBY2NvdW50c0xpc3QiLCJnZXRJbmZsYXRpb25Hb3Zlcm5vciIsImdldEluZmxhdGlvblJld2FyZCIsImdldEluZmxhdGlvblJhdGUiLCJnZXRFcG9jaEluZm8iLCJnZXRFcG9jaFNjaGVkdWxlIiwiZXBvY2hTY2hlZHVsZSIsImdldExlYWRlclNjaGVkdWxlIiwiZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dCIsImdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQiLCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMiLCJnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoIiwid2lyZU1lc3NhZ2UiLCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMiLCJsb2NrZWRXcml0YWJsZUFjY291bnRzIiwiZ2V0UmVjZW50QmxvY2toYXNoIiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwiaXNCbG9ja2hhc2hWYWxpZCIsImdldFZlcnNpb24iLCJnZXRHZW5lc2lzSGFzaCIsImdldEJsb2NrIiwiX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQiLCJ0cmFuc2FjdGlvbkRldGFpbHMiLCJnZXRQYXJzZWRCbG9jayIsImdldEJsb2NrUHJvZHVjdGlvbiIsImV4dHJhIiwiYyIsImdldFBhcnNlZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkVHJhbnNhY3Rpb25zIiwiZ2V0VHJhbnNhY3Rpb25zIiwiZ2V0Q29uZmlybWVkQmxvY2siLCJibG9jayIsImdldEJsb2NrcyIsImVuZFNsb3QiLCJnZXRCbG9ja1NpZ25hdHVyZXMiLCJnZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMiLCJnZXRDb25maXJtZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zIiwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJmaXJzdEF2YWlsYWJsZUJsb2NrIiwidW50aWwiLCJoaWdoZXN0Q29uZmlybWVkUm9vdCIsImJlZm9yZSIsImNvbmZpcm1lZFNpZ25hdHVyZUluZm8iLCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIiLCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyIsImdldEFkZHJlc3NMb29rdXBUYWJsZSIsImFjY291bnRJbmZvIiwiZ2V0Tm9uY2UiLCJyZXF1ZXN0QWlyZHJvcCIsInRvIiwiX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodCIsImRpc2FibGVDYWNoZSIsInRpbWVTaW5jZUZldGNoIiwiZXhwaXJlZCIsIl9wb2xsTmV3QmxvY2toYXNoIiwic3RhcnRUaW1lIiwiY2FjaGVkTGF0ZXN0QmxvY2toYXNoIiwiY2FjaGVkQmxvY2toYXNoIiwiZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbiIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbk9yTWVzc2FnZSIsImNvbmZpZ09yU2lnbmVycyIsImluY2x1ZGVBY2NvdW50cyIsInZlcnNpb25lZFR4IiwiZW5jb2RlZFRyYW5zYWN0aW9uIiwib3JpZ2luYWxUeCIsInNpZ1ZlcmlmeSIsInRyYWNlSW5kZW50IiwibG9nVHJhY2UiLCJzaWduZXJzT3JPcHRpb25zIiwic2VuZFJhd1RyYW5zYWN0aW9uIiwicmF3VHJhbnNhY3Rpb24iLCJzZW5kRW5jb2RlZFRyYW5zYWN0aW9uIiwic2V0SW50ZXJ2YWwiLCJfdXBkYXRlU3Vic2NyaXB0aW9ucyIsImNsZWFySW50ZXJ2YWwiLCJoYXNoIiwiX3NldFN1YnNjcmlwdGlvbiIsIm5leHRTdWJzY3JpcHRpb24iLCJwcmV2U3RhdGUiLCJzdGF0ZUNoYW5nZUNhbGxiYWNrcyIsImNiIiwiY2xpZW50U3Vic2NyaXB0aW9uSWQiLCJjbG9zZSIsImNvbm5lY3QiLCJhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uIiwiaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlIiwiY2FsbGJhY2tzIiwic2VydmVyU3Vic2NyaXB0aW9uSWQiLCJ1bnN1YnNjcmliZU1ldGhvZCIsIl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24iLCJjYWxsYmFja0FyZ3MiLCJub3RpZmljYXRpb24iLCJfbWFrZVN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbkNvbmZpZyIsImV4aXN0aW5nU3Vic2NyaXB0aW9uIiwib25BY2NvdW50Q2hhbmdlIiwicmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyIiwiX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uIiwiYWNjb3VudElkIiwib25Qcm9ncmFtQWNjb3VudENoYW5nZSIsIm1heWJlRmlsdGVycyIsInJlbW92ZVByb2dyYW1BY2NvdW50Q2hhbmdlTGlzdGVuZXIiLCJvbkxvZ3MiLCJtZW50aW9ucyIsInJlbW92ZU9uTG9nc0xpc3RlbmVyIiwib25TbG90Q2hhbmdlIiwicmVtb3ZlU2xvdENoYW5nZUxpc3RlbmVyIiwib25TbG90VXBkYXRlIiwicmVtb3ZlU2xvdFVwZGF0ZUxpc3RlbmVyIiwic3Vic2NyaXB0aW9uTmFtZSIsImRpc3Bvc2UiLCJvdmVycmlkZSIsIl9lcnIiLCJvblNpZ25hdHVyZVdpdGhPcHRpb25zIiwib25Sb290Q2hhbmdlIiwicmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyIiwiS2V5cGFpciIsImtleXBhaXIiLCJfa2V5cGFpciIsImdlbmVyYXRlIiwiZnJvbVNlY3JldEtleSIsInNraXBWYWxpZGF0aW9uIiwiY29tcHV0ZWRQdWJsaWNLZXkiLCJpaSIsImZyb21TZWVkIiwiTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJDcmVhdGVMb29rdXBUYWJsZSIsIkZyZWV6ZUxvb2t1cFRhYmxlIiwiRXh0ZW5kTG9va3VwVGFibGUiLCJEZWFjdGl2YXRlTG9va3VwVGFibGUiLCJDbG9zZUxvb2t1cFRhYmxlIiwiQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24iLCJsYXlvdXRUeXBlIiwiZGVjb2RlQ3JlYXRlTG9va3VwVGFibGUiLCJjaGVja0tleXNMZW5ndGgiLCJyZWNlbnRTbG90IiwiZGVjb2RlRXh0ZW5kTG9va3VwVGFibGUiLCJkZWNvZGVDbG9zZUxvb2t1cFRhYmxlIiwicmVjaXBpZW50IiwiZGVjb2RlRnJlZXplTG9va3VwVGFibGUiLCJkZWNvZGVEZWFjdGl2YXRlTG9va3VwVGFibGUiLCJBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtIiwiY3JlYXRlTG9va3VwVGFibGUiLCJsb29rdXBUYWJsZUFkZHJlc3MiLCJidW1wU2VlZCIsImZyZWV6ZUxvb2t1cFRhYmxlIiwiZXh0ZW5kTG9va3VwVGFibGUiLCJhZGRyIiwiZGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiY2xvc2VMb29rdXBUYWJsZSIsIkNvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiIsIkNPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVSZXF1ZXN0VW5pdHMiLCJ1bml0cyIsImFkZGl0aW9uYWxGZWUiLCJSZXF1ZXN0VW5pdHMiLCJkZWNvZGVSZXF1ZXN0SGVhcEZyYW1lIiwiUmVxdWVzdEhlYXBGcmFtZSIsImRlY29kZVNldENvbXB1dGVVbml0TGltaXQiLCJTZXRDb21wdXRlVW5pdExpbWl0IiwiZGVjb2RlU2V0Q29tcHV0ZVVuaXRQcmljZSIsIm1pY3JvTGFtcG9ydHMiLCJTZXRDb21wdXRlVW5pdFByaWNlIiwiQ29tcHV0ZUJ1ZGdldFByb2dyYW0iLCJyZXF1ZXN0VW5pdHMiLCJyZXF1ZXN0SGVhcEZyYW1lIiwic2V0Q29tcHV0ZVVuaXRMaW1pdCIsInNldENvbXB1dGVVbml0UHJpY2UiLCJQUklWQVRFX0tFWV9CWVRFUyQxIiwiUFVCTElDX0tFWV9CWVRFUyQxIiwiU0lHTkFUVVJFX0JZVEVTIiwiRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQiLCJ1MTYiLCJFZDI1NTE5UHJvZ3JhbSIsImNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSIsImluc3RydWN0aW9uSW5kZXgiLCJwdWJsaWNLZXlPZmZzZXQiLCJzaWduYXR1cmVPZmZzZXQiLCJtZXNzYWdlRGF0YU9mZnNldCIsIm51bVNpZ25hdHVyZXMiLCJwYWRkaW5nIiwic2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCIsInB1YmxpY0tleUluc3RydWN0aW9uSW5kZXgiLCJtZXNzYWdlRGF0YVNpemUiLCJtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleCIsImNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwiZWNkc2FTaWduIiwibXNnSGFzaCIsInByaXZLZXkiLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInJlY292ZXJ5IiwiaXNWYWxpZFByaXZhdGVLZXkiLCJwdWJsaWNLZXlDcmVhdGUiLCJQUklWQVRFX0tFWV9CWVRFUyIsIkVUSEVSRVVNX0FERFJFU1NfQllURVMiLCJQVUJMSUNfS0VZX0JZVEVTIiwiU0lHTkFUVVJFX09GRlNFVFNfU0VSSUFMSVpFRF9TSVpFIiwiU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVCIsIlNlY3AyNTZrMVByb2dyYW0iLCJwdWJsaWNLZXlUb0V0aEFkZHJlc3MiLCJyZWNvdmVyeUlkIiwiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzcyIsImV0aEFkZHJlc3MiLCJyYXdBZGRyZXNzIiwic3Vic3RyIiwiZGF0YVN0YXJ0IiwiZXRoQWRkcmVzc09mZnNldCIsImV0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4IiwicGtleSIsIm1lc3NhZ2VIYXNoIiwiX0xvY2t1cCIsIlNUQUtFX0NPTkZJR19JRCIsIkF1dGhvcml6ZWQiLCJzdGFrZXIiLCJ3aXRoZHJhd2VyIiwiTG9ja3VwIiwidW5peFRpbWVzdGFtcCIsImN1c3RvZGlhbiIsIlN0YWtlSW5zdHJ1Y3Rpb24iLCJTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlSW5pdGlhbGl6ZSIsIkluaXRpYWxpemUiLCJzdGFrZVB1YmtleSIsImRlY29kZURlbGVnYXRlIiwiRGVsZWdhdGUiLCJkZWNvZGVBdXRob3JpemUiLCJuZXdBdXRob3JpemVkIiwic3Rha2VBdXRob3JpemF0aW9uVHlwZSIsIkF1dGhvcml6ZSIsIm8iLCJjdXN0b2RpYW5QdWJrZXkiLCJkZWNvZGVBdXRob3JpemVXaXRoU2VlZCIsImF1dGhvcml0eVNlZWQiLCJhdXRob3JpdHlPd25lciIsIkF1dGhvcml6ZVdpdGhTZWVkIiwiYXV0aG9yaXR5QmFzZSIsImRlY29kZVNwbGl0IiwiU3BsaXQiLCJzcGxpdFN0YWtlUHVia2V5IiwiZGVjb2RlTWVyZ2UiLCJNZXJnZSIsInNvdXJjZVN0YWtlUHViS2V5IiwiZGVjb2RlV2l0aGRyYXciLCJXaXRoZHJhdyIsImRlY29kZURlYWN0aXZhdGUiLCJEZWFjdGl2YXRlIiwiU3Rha2VQcm9ncmFtIiwiU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0IiwiU3Rha2VyIiwiV2l0aGRyYXdlciIsImluaXRpYWxpemUiLCJtYXliZUxvY2t1cCIsImRlbGVnYXRlIiwiYXV0aG9yaXplIiwiYXV0aG9yaXplV2l0aFNlZWQiLCJzcGxpdEluc3RydWN0aW9uIiwicmVudEV4ZW1wdFJlc2VydmUiLCJzcGxpdFdpdGhTZWVkIiwibWVyZ2UiLCJ3aXRoZHJhdyIsImRlYWN0aXZhdGUiLCJWb3RlSW5pdCIsImF1dGhvcml6ZWRWb3RlciIsImF1dGhvcml6ZWRXaXRoZHJhd2VyIiwiVm90ZUluc3RydWN0aW9uIiwiVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlSW5pdGlhbGl6ZUFjY291bnQiLCJJbml0aWFsaXplQWNjb3VudCIsInZvdGVBdXRob3JpemF0aW9uVHlwZSIsImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkiLCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQiLCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXkiLCJhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSIsIlZvdGVQcm9ncmFtIiwiVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCJWb3RlQXV0aG9yaXphdGlvbkxheW91dCIsIlZvdGVyIiwiaW5pdGlhbGl6ZUFjY291bnQiLCJzYWZlV2l0aGRyYXciLCJjdXJyZW50Vm90ZUFjY291bnRCYWxhbmNlIiwicmVudEV4ZW1wdE1pbmltdW0iLCJ1cGRhdGVWYWxpZGF0b3JJZGVudGl0eSIsIlZBTElEQVRPUl9JTkZPX0tFWSIsIkluZm9TdHJpbmciLCJ3ZWJzaXRlIiwiZGV0YWlscyIsImljb25VcmwiLCJrZXliYXNlVXNlcm5hbWUiLCJWYWxpZGF0b3JJbmZvIiwiZnJvbUNvbmZpZ0RhdGEiLCJjb25maWdLZXlDb3VudCIsImNvbmZpZ0tleXMiLCJyYXdJbmZvIiwiVk9URV9QUk9HUkFNX0lEIiwiVm90ZUFjY291bnRMYXlvdXQiLCJWb3RlQWNjb3VudCIsInZvdGVzIiwiYXV0aG9yaXplZFZvdGVycyIsInByaW9yVm90ZXJzIiwibGFzdFRpbWVzdGFtcCIsInZlcnNpb25PZmZzZXQiLCJ2YSIsInJvb3RTbG90VmFsaWQiLCJwYXJzZUF1dGhvcml6ZWRWb3RlciIsImdldFByaW9yVm90ZXJzIiwicGFyc2VQcmlvclZvdGVycyIsImVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCIsInRhcmdldEVwb2NoIiwiaWR4IiwiaXNFbXB0eSIsImh0dHAiLCJkZXZuZXQiLCJ0ZXN0bmV0IiwiaHR0cHMiLCJjbHVzdGVyQXBpVXJsIiwiY2x1c3RlciIsInRscyIsInNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24iLCJjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMiLCJtYXliZUNvbmZpcm1PcHRpb25zIiwiY29uZmlybWF0aW9uU3RyYXRlZ3kiLCJMQU1QT1JUU19QRVJfU09MIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMG5CO0FBRTFuQiw0QkFBNEI7QUFFNUIsZUFBZTtBQUNmLElBQUlZLGFBQWEsQ0FBQ0M7SUFDaEIsTUFBTUMscUJBQXFCRCxXQUFXRSxNQUFNLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsTUFBTTtJQUNoRSxJQUFJSCxtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9KLFdBQVdJLE1BQU0sR0FBR0osVUFBVSxDQUFDLEVBQUUsR0FBRyxJQUFJSztJQUNqRDtJQUNBLElBQUlKLG1CQUFtQkcsTUFBTSxLQUFLLEdBQUc7UUFDbkMsT0FBT0gsa0JBQWtCLENBQUMsRUFBRTtJQUM5QjtJQUNBLE1BQU1LLGNBQWNMLG1CQUFtQk0sTUFBTSxDQUFDLENBQUNDLE9BQU9MLE1BQVFLLFFBQVFMLElBQUlDLE1BQU0sRUFBRTtJQUNsRixNQUFNSyxTQUFTLElBQUlKLFdBQVdDO0lBQzlCLElBQUlJLFNBQVM7SUFDYlQsbUJBQW1CVSxPQUFPLENBQUMsQ0FBQ1I7UUFDMUJNLE9BQU9HLEdBQUcsQ0FBQ1QsS0FBS087UUFDaEJBLFVBQVVQLElBQUlDLE1BQU07SUFDdEI7SUFDQSxPQUFPSztBQUNUO0FBQ0EsSUFBSUksV0FBVyxDQUFDQyxPQUFPVjtJQUNyQixJQUFJVSxNQUFNVixNQUFNLElBQUlBLFFBQVEsT0FBT1U7SUFDbkMsTUFBTUMsY0FBYyxJQUFJVixXQUFXRCxRQUFRWSxJQUFJLENBQUM7SUFDaERELFlBQVlILEdBQUcsQ0FBQ0U7SUFDaEIsT0FBT0M7QUFDVDtBQUNBLElBQUlFLFdBQVcsQ0FBQ0gsT0FBT1YsU0FBV1MsU0FBU0MsTUFBTVYsTUFBTSxJQUFJQSxTQUFTVSxRQUFRQSxN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LE9BQU9KLFNBQVdnQixRQUFRTyxLQUFLLENBQUNnRyxNQUFNeEcsUUFBUVgsT0FBT0o7SUFDdEU7QUFDRjtBQUNBLFNBQVN3SCxpQkFBaUIvRixPQUFPLEVBQUVnRyxHQUFHO0lBQ3BDLE9BQU9qRyxjQUFjO1FBQ25CLEdBQUdDLE9BQU87UUFDVkUsTUFBTSxDQUFDdkIsT0FBT0o7WUFDWixNQUFNLENBQUNlLE9BQU9tRyxVQUFVLEdBQUd6RixRQUFRRSxJQUFJLENBQUN2QixPQUFPSjtZQUMvQyxPQUFPO2dCQUFDeUgsSUFBSTFHLE9BQU9YLE9BQU9KO2dCQUFTa0g7YUFBVTtRQUMvQztJQUNGO0FBQ0Y7QUFDQSxTQUFTUSxlQUFlN0YsS0FBSyxFQUFFMEYsS0FBSyxFQUFFRSxHQUFHO0lBQ3ZDLE9BQU83RixZQUFZO1FBQ2pCLEdBQUcwRixpQkFBaUJ6RixPQUFPMEYsTUFBTTtRQUNqQzVGLE1BQU04RixNQUFNRCxpQkFBaUIzRixPQUFPNEYsS0FBSzlGLElBQUksR0FBR0UsTUFBTUYsSUFBSTtJQUM1RDtBQUNGO0FBRXV2QixDQUN2dkIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWNvcmUvZGlzdC9pbmRleC5ub2RlLm1qcz9lZjg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUywgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcblxuLy8gc3JjL2FkZC1jb2RlYy1zZW50aW5lbC50c1xuXG4vLyBzcmMvYnl0ZXMudHNcbnZhciBtZXJnZUJ5dGVzID0gKGJ5dGVBcnJheXMpID0+IHtcbiAgY29uc3Qgbm9uRW1wdHlCeXRlQXJyYXlzID0gYnl0ZUFycmF5cy5maWx0ZXIoKGFycikgPT4gYXJyLmxlbmd0aCk7XG4gIGlmIChub25FbXB0eUJ5dGVBcnJheXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGJ5dGVBcnJheXMubGVuZ3RoID8gYnl0ZUFycmF5c1swXSA6IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgaWYgKG5vbkVtcHR5Qnl0ZUFycmF5cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbm9uRW1wdHlCeXRlQXJyYXlzWzBdO1xuICB9XG4gIGNvbnN0IHRvdGFsTGVuZ3RoID0gbm9uRW1wdHlCeXRlQXJyYXlzLnJlZHVjZSgodG90YWwsIGFycikgPT4gdG90YWwgKyBhcnIubGVuZ3RoLCAwKTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgbm9uRW1wdHlCeXRlQXJyYXlzLmZvckVhY2goKGFycikgPT4ge1xuICAgIHJlc3VsdC5zZXQoYXJyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBhcnIubGVuZ3RoO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgcGFkQnl0ZXMgPSAoYnl0ZXMsIGxlbmd0aCkgPT4ge1xuICBpZiAoYnl0ZXMubGVuZ3RoID49IGxlbmd0aCkgcmV0dXJuIGJ5dGVzO1xuICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCkuZmlsbCgwKTtcbiAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzKTtcbiAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufTtcbnZhciBmaXhCeXRlcyA9IChieXRlcywgbGVuZ3RoKSA9PiBwYWRCeXRlcyhieXRlcy5sZW5ndGggPD0gbGVuZ3RoID8gYnl0ZXMgOiBieXRlcy5zbGljZSgwLCBsZW5ndGgpLCBsZW5ndGgpO1xuZnVuY3Rpb24gY29udGFpbnNCeXRlcyhkYXRhLCBieXRlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHNsaWNlID0gb2Zmc2V0ID09PSAwICYmIGRhdGEubGVuZ3RoID09PSBieXRlcy5sZW5ndGggPyBkYXRhIDogZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGJ5dGVzLmxlbmd0aCk7XG4gIGlmIChzbGljZS5sZW5ndGggIT09IGJ5dGVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYnl0ZXMuZXZlcnkoKGIsIGkpID0+IGIgPT09IHNsaWNlW2ldKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSB7XG4gIHJldHVybiBcImZpeGVkU2l6ZVwiIGluIGVuY29kZXIgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbmNvZGVyKGVuY29kZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpKTtcbiAgICAgIGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihkZWNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldClbMF1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhjb2RlYykge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uY29kZWMsXG4gICAgZGVjb2RlOiAoYnl0ZXMsIG9mZnNldCA9IDApID0+IGNvZGVjLnJlYWQoYnl0ZXMsIG9mZnNldClbMF0sXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGNvZGVjKSk7XG4gICAgICBjb2RlYy53cml0ZSh2YWx1ZSwgYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0ZpeGVkU2l6ZShjb2RlYykge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBjb2RlYyAmJiB0eXBlb2YgY29kZWMuZml4ZWRTaXplID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNGaXhlZFNpemUoY29kZWMpIHtcbiAgaWYgKCFpc0ZpeGVkU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIHJldHVybiAhaXNGaXhlZFNpemUoY29kZWMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgaWYgKCFpc1ZhcmlhYmxlU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVDb2RlYyhlbmNvZGVyLCBkZWNvZGVyKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAhPT0gaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gpO1xuICB9XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLmZpeGVkU2l6ZSAhPT0gZGVjb2Rlci5maXhlZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyRml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSxcbiAgICAgIGVuY29kZXJGaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiAhaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5tYXhTaXplICE9PSBkZWNvZGVyLm1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwge1xuICAgICAgZGVjb2Rlck1heFNpemU6IGRlY29kZXIubWF4U2l6ZSxcbiAgICAgIGVuY29kZXJNYXhTaXplOiBlbmNvZGVyLm1heFNpemVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRlY29kZXIsXG4gICAgLi4uZW5jb2RlcixcbiAgICBkZWNvZGU6IGRlY29kZXIuZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2Rlci5lbmNvZGUsXG4gICAgcmVhZDogZGVjb2Rlci5yZWFkLFxuICAgIHdyaXRlOiBlbmNvZGVyLndyaXRlXG4gIH07XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTZW50aW5lbChlbmNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAoZmluZFNlbnRpbmVsSW5kZXgoZW5jb2RlckJ5dGVzLCBzZW50aW5lbCkgPj0gMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsIHtcbiAgICAgICAgZW5jb2RlZEJ5dGVzOiBlbmNvZGVyQnl0ZXMsXG4gICAgICAgIGhleEVuY29kZWRCeXRlczogaGV4Qnl0ZXMoZW5jb2RlckJ5dGVzKSxcbiAgICAgICAgaGV4U2VudGluZWw6IGhleEJ5dGVzKHNlbnRpbmVsKSxcbiAgICAgICAgc2VudGluZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICAgIGJ5dGVzLnNldChzZW50aW5lbCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gc2VudGluZWwubGVuZ3RoO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplOiBlbmNvZGVyLmZpeGVkU2l6ZSArIHNlbnRpbmVsLmxlbmd0aCwgd3JpdGUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgLi4uZW5jb2Rlci5tYXhTaXplICE9IG51bGwgPyB7IG1heFNpemU6IGVuY29kZXIubWF4U2l6ZSArIHNlbnRpbmVsLmxlbmd0aCB9IDoge30sXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpICsgc2VudGluZWwubGVuZ3RoLFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkRGVjb2RlclNlbnRpbmVsKGRlY29kZXIsIHNlbnRpbmVsKSB7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGNhbmRpZGF0ZUJ5dGVzID0gb2Zmc2V0ID09PSAwID8gYnl0ZXMgOiBieXRlcy5zbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IHNlbnRpbmVsSW5kZXggPSBmaW5kU2VudGluZWxJbmRleChjYW5kaWRhdGVCeXRlcywgc2VudGluZWwpO1xuICAgIGlmIChzZW50aW5lbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIHtcbiAgICAgICAgZGVjb2RlZEJ5dGVzOiBjYW5kaWRhdGVCeXRlcyxcbiAgICAgICAgaGV4RGVjb2RlZEJ5dGVzOiBoZXhCeXRlcyhjYW5kaWRhdGVCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcHJlU2VudGluZWxCeXRlcyA9IGNhbmRpZGF0ZUJ5dGVzLnNsaWNlKDAsIHNlbnRpbmVsSW5kZXgpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUocHJlU2VudGluZWxCeXRlcyksIG9mZnNldCArIHByZVNlbnRpbmVsQnl0ZXMubGVuZ3RoICsgc2VudGluZWwubGVuZ3RoXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCByZWFkIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIC4uLmRlY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBkZWNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIHJlYWRcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTZW50aW5lbChjb2RlYywgc2VudGluZWwpLCBhZGREZWNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSk7XG59XG5mdW5jdGlvbiBmaW5kU2VudGluZWxJbmRleChieXRlcywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGJ5dGVzLmZpbmRJbmRleCgoYnl0ZSwgaW5kZXgsIGFycikgPT4ge1xuICAgIGlmIChzZW50aW5lbC5sZW5ndGggPT09IDEpIHJldHVybiBieXRlID09PSBzZW50aW5lbFswXTtcbiAgICByZXR1cm4gY29udGFpbnNCeXRlcyhhcnIsIHNlbnRpbmVsLCBpbmRleCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGV4Qnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGlmIChieXRlcy5sZW5ndGggLSBvZmZzZXQgPD0gMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLCB7XG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgZXhwZWN0ZWQsIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGJ5dGVzTGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoYnl0ZXNMZW5ndGggPCBleHBlY3RlZCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwge1xuICAgICAgYnl0ZXNMZW5ndGgsXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgZXhwZWN0ZWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKGNvZGVjRGVzY3JpcHRpb24sIG9mZnNldCwgYnl0ZXNMZW5ndGgpIHtcbiAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnl0ZXNMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2l6ZS1wcmVmaXgudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTaXplUHJlZml4KGVuY29kZXIsIHByZWZpeCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBvZmZzZXQgPSBwcmVmaXgud3JpdGUoZW5jb2RlckJ5dGVzLmxlbmd0aCwgYnl0ZXMsIG9mZnNldCk7XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGVuY29kZXIuZml4ZWRTaXplLCB3cml0ZSB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBlbmNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGVuY29kZXIpID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZW5jb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZW5jb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZXJTaXplID0gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpO1xuICAgICAgcmV0dXJuIGdldEVuY29kZWRTaXplKGVuY29kZXJTaXplLCBwcmVmaXgpICsgZW5jb2RlclNpemU7XG4gICAgfSxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTaXplUHJlZml4KGRlY29kZXIsIHByZWZpeCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBbYmlnaW50U2l6ZSwgZGVjb2Rlck9mZnNldF0gPSBwcmVmaXgucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyKGJpZ2ludFNpemUpO1xuICAgIG9mZnNldCA9IGRlY29kZXJPZmZzZXQ7XG4gICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuICAgIH1cbiAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiYWRkRGVjb2RlclNpemVQcmVmaXhcIiwgc2l6ZSwgYnl0ZXMpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUoYnl0ZXMpLCBvZmZzZXQgKyBzaXplXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGRlY29kZXIuZml4ZWRTaXplLCByZWFkIH0pO1xuICB9XG4gIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IHByZWZpeC5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IGRlY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZGVjb2RlcikgPyBkZWNvZGVyLmZpeGVkU2l6ZSA6IGRlY29kZXIubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBtYXhTaXplID0gcHJlZml4TWF4U2l6ZSAhPT0gbnVsbCAmJiBkZWNvZGVyTWF4U2l6ZSAhPT0gbnVsbCA/IHByZWZpeE1heFNpemUgKyBkZWNvZGVyTWF4U2l6ZSA6IG51bGw7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sIHJlYWQgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NpemVQcmVmaXgoY29kZWMsIHByZWZpeCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpLCBhZGREZWNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSk7XG59XG5cbi8vIHNyYy9maXgtY29kZWMtc2l6ZS50c1xuZnVuY3Rpb24gZml4RW5jb2RlclNpemUoZW5jb2RlciwgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgZml4ZWRTaXplOiBmaXhlZEJ5dGVzLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlQnl0ZUFycmF5ID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgY29uc3QgZml4ZWRCeXRlQXJyYXkgPSB2YXJpYWJsZUJ5dGVBcnJheS5sZW5ndGggPiBmaXhlZEJ5dGVzID8gdmFyaWFibGVCeXRlQXJyYXkuc2xpY2UoMCwgZml4ZWRCeXRlcykgOiB2YXJpYWJsZUJ5dGVBcnJheTtcbiAgICAgIGJ5dGVzLnNldChmaXhlZEJ5dGVBcnJheSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBmaXhlZEJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaXhEZWNvZGVyU2l6ZShkZWNvZGVyLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXCJmaXhDb2RlY1NpemVcIiwgZml4ZWRCeXRlcywgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBpZiAob2Zmc2V0ID4gMCB8fCBieXRlcy5sZW5ndGggPiBmaXhlZEJ5dGVzKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBmaXhlZEJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgICAgICBieXRlcyA9IGZpeEJ5dGVzKGJ5dGVzLCBkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBbdmFsdWVdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBbdmFsdWUsIG9mZnNldCArIGZpeGVkQnl0ZXNdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaXhDb2RlY1NpemUoY29kZWMsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhmaXhFbmNvZGVyU2l6ZShjb2RlYywgZml4ZWRCeXRlcyksIGZpeERlY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSk7XG59XG5cbi8vIHNyYy9vZmZzZXQtY29kZWMudHNcbmZ1bmN0aW9uIG9mZnNldEVuY29kZXIoZW5jb2RlciwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBwcmVPZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBCeXRlcyA9IChvZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldEVuY29kZXJcIiwgbmV3UHJlT2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgcG9zdE9mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBuZXdQcmVPZmZzZXQpO1xuICAgICAgY29uc3QgbmV3UG9zdE9mZnNldCA9IGNvbmZpZy5wb3N0T2Zmc2V0ID8gY29uZmlnLnBvc3RPZmZzZXQoeyBieXRlcywgbmV3UHJlT2Zmc2V0LCBwb3N0T2Zmc2V0LCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHBvc3RPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXRFbmNvZGVyXCIsIG5ld1Bvc3RPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3UG9zdE9mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Zmc2V0RGVjb2RlcihkZWNvZGVyLCBjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBwcmVPZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBCeXRlcyA9IChvZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldERlY29kZXJcIiwgbmV3UHJlT2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgW3ZhbHVlLCBwb3N0T2Zmc2V0XSA9IGRlY29kZXIucmVhZChieXRlcywgbmV3UHJlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IG5ld1Bvc3RPZmZzZXQgPSBjb25maWcucG9zdE9mZnNldCA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwb3N0T2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RGVjb2RlclwiLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgbmV3UG9zdE9mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9mZnNldENvZGVjKGNvZGVjLCBjb25maWcpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhvZmZzZXRFbmNvZGVyKGNvZGVjLCBjb25maWcpLCBvZmZzZXREZWNvZGVyKGNvZGVjLCBjb25maWcpKTtcbn1cbmZ1bmN0aW9uIG1vZHVsbyhkaXZpZGVuZCwgZGl2aXNvcikge1xuICBpZiAoZGl2aXNvciA9PT0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xufVxuZnVuY3Rpb24gcmVzaXplRW5jb2RlcihlbmNvZGVyLCByZXNpemUpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgY29uc3QgZml4ZWRTaXplID0gcmVzaXplKGVuY29kZXIuZml4ZWRTaXplKTtcbiAgICBpZiAoZml4ZWRTaXplIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICBieXRlc0xlbmd0aDogZml4ZWRTaXplLFxuICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZUVuY29kZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgbmV3U2l6ZSA9IHJlc2l6ZShlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpKTtcbiAgICAgIGlmIChuZXdTaXplIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgICAgYnl0ZXNMZW5ndGg6IG5ld1NpemUsXG4gICAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVFbmNvZGVyXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3U2l6ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzaXplRGVjb2RlcihkZWNvZGVyLCByZXNpemUpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgY29uc3QgZml4ZWRTaXplID0gcmVzaXplKGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICBpZiAoZml4ZWRTaXplIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICBieXRlc0xlbmd0aDogZml4ZWRTaXplLFxuICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZURlY29kZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplIH0pO1xuICB9XG4gIHJldHVybiBkZWNvZGVyO1xufVxuZnVuY3Rpb24gcmVzaXplQ29kZWMoY29kZWMsIHJlc2l6ZSkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHJlc2l6ZUVuY29kZXIoY29kZWMsIHJlc2l6ZSksIHJlc2l6ZURlY29kZXIoY29kZWMsIHJlc2l6ZSkpO1xufVxuXG4vLyBzcmMvcGFkLWNvZGVjLnRzXG5mdW5jdGlvbiBwYWRMZWZ0RW5jb2RlcihlbmNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgcmVzaXplRW5jb2RlcihlbmNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkUmlnaHRFbmNvZGVyKGVuY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RW5jb2RlcihcbiAgICByZXNpemVFbmNvZGVyKGVuY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0RGVjb2RlcihkZWNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgcmVzaXplRGVjb2RlcihkZWNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkUmlnaHREZWNvZGVyKGRlY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RGVjb2RlcihcbiAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0Q29kZWMoY29kZWMsIG9mZnNldCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHBhZExlZnRFbmNvZGVyKGNvZGVjLCBvZmZzZXQpLCBwYWRMZWZ0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSk7XG59XG5mdW5jdGlvbiBwYWRSaWdodENvZGVjKGNvZGVjLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRSaWdodEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZFJpZ2h0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSk7XG59XG5cbi8vIHNyYy9yZXZlcnNlLWNvZGVjLnRzXG5mdW5jdGlvbiBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2Uoc291cmNlLCB0YXJnZXRfV0lMTF9NVVRBVEUsIHNvdXJjZU9mZnNldCwgc291cmNlTGVuZ3RoLCB0YXJnZXRPZmZzZXQgPSAwKSB7XG4gIHdoaWxlIChzb3VyY2VPZmZzZXQgPCAtLXNvdXJjZUxlbmd0aCkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZUxlbmd0aF07XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZUxlbmd0aCArIHRhcmdldE9mZnNldF0gPSBsZWZ0VmFsdWU7XG4gICAgc291cmNlT2Zmc2V0Kys7XG4gIH1cbiAgaWYgKHNvdXJjZU9mZnNldCA9PT0gc291cmNlTGVuZ3RoKSB7XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZU9mZnNldCArIHRhcmdldE9mZnNldF0gPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgfVxufVxuZnVuY3Rpb24gcmV2ZXJzZUVuY29kZXIoZW5jb2Rlcikge1xuICBhc3NlcnRJc0ZpeGVkU2l6ZShlbmNvZGVyKTtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBieXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBlbmNvZGVyLmZpeGVkU2l6ZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdPZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VEZWNvZGVyKGRlY29kZXIpIHtcbiAgYXNzZXJ0SXNGaXhlZFNpemUoZGVjb2Rlcik7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCByZXZlcnNlZEJ5dGVzID0gYnl0ZXMuc2xpY2UoKTtcbiAgICAgIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIHJldmVyc2VkQnl0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgZGVjb2Rlci5maXhlZFNpemVcbiAgICAgICk7XG4gICAgICByZXR1cm4gZGVjb2Rlci5yZWFkKHJldmVyc2VkQnl0ZXMsIG9mZnNldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VDb2RlYyhjb2RlYykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHJldmVyc2VFbmNvZGVyKGNvZGVjKSwgcmV2ZXJzZURlY29kZXIoY29kZWMpKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybS1jb2RlYy50c1xuZnVuY3Rpb24gdHJhbnNmb3JtRW5jb2RlcihlbmNvZGVyLCB1bm1hcCkge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uaXNWYXJpYWJsZVNpemUoZW5jb2RlcikgPyB7IC4uLmVuY29kZXIsIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHVubWFwKHZhbHVlKSkgfSA6IGVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4gZW5jb2Rlci53cml0ZSh1bm1hcCh2YWx1ZSksIGJ5dGVzLCBvZmZzZXQpXG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRGVjb2RlcihkZWNvZGVyLCBtYXApIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IFt2YWx1ZSwgbmV3T2Zmc2V0XSA9IGRlY29kZXIucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBbbWFwKHZhbHVlLCBieXRlcywgb2Zmc2V0KSwgbmV3T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ29kZWMoY29kZWMsIHVubWFwLCBtYXApIHtcbiAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAuLi50cmFuc2Zvcm1FbmNvZGVyKGNvZGVjLCB1bm1hcCksXG4gICAgcmVhZDogbWFwID8gdHJhbnNmb3JtRGVjb2Rlcihjb2RlYywgbWFwKS5yZWFkIDogY29kZWMucmVhZFxuICB9KTtcbn1cblxuZXhwb3J0IHsgYWRkQ29kZWNTZW50aW5lbCwgYWRkQ29kZWNTaXplUHJlZml4LCBhZGREZWNvZGVyU2VudGluZWwsIGFkZERlY29kZXJTaXplUHJlZml4LCBhZGRFbmNvZGVyU2VudGluZWwsIGFkZEVuY29kZXJTaXplUHJlZml4LCBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMsIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSwgYXNzZXJ0SXNGaXhlZFNpemUsIGFzc2VydElzVmFyaWFibGVTaXplLCBjb21iaW5lQ29kZWMsIGNvbnRhaW5zQnl0ZXMsIGNyZWF0ZUNvZGVjLCBjcmVhdGVEZWNvZGVyLCBjcmVhdGVFbmNvZGVyLCBmaXhCeXRlcywgZml4Q29kZWNTaXplLCBmaXhEZWNvZGVyU2l6ZSwgZml4RW5jb2RlclNpemUsIGdldEVuY29kZWRTaXplLCBpc0ZpeGVkU2l6ZSwgaXNWYXJpYWJsZVNpemUsIG1lcmdlQnl0ZXMsIG9mZnNldENvZGVjLCBvZmZzZXREZWNvZGVyLCBvZmZzZXRFbmNvZGVyLCBwYWRCeXRlcywgcGFkTGVmdENvZGVjLCBwYWRMZWZ0RGVjb2RlciwgcGFkTGVmdEVuY29kZXIsIHBhZFJpZ2h0Q29kZWMsIHBhZFJpZ2h0RGVjb2RlciwgcGFkUmlnaHRFbmNvZGVyLCByZXNpemVDb2RlYywgcmVzaXplRGVjb2RlciwgcmVzaXplRW5jb2RlciwgcmV2ZXJzZUNvZGVjLCByZXZlcnNlRGVjb2RlciwgcmV2ZXJzZUVuY29kZXIsIHRyYW5zZm9ybUNvZGVjLCB0cmFuc2Zvcm1EZWNvZGVyLCB0cmFuc2Zvcm1FbmNvZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCIsIm1lcmdlQnl0ZXMiLCJieXRlQXJyYXlzIiwibm9uRW1wdHlCeXRlQXJyYXlzIiwiZmlsdGVyIiwiYXJyIiwibGVuZ3RoIiwiVWludDhBcnJheSIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwidG90YWwiLCJyZXN1bHQiLCJvZmZzZXQiLCJmb3JFYWNoIiwic2V0IiwicGFkQnl0ZXMiLCJieXRlcyIsInBhZGRlZEJ5dGVzIiwiZmlsbCIsImZpeEJ5dGVzIiwic2xpY2UiLCJjb250YWluc0J5dGVzIiwiZGF0YSIsImV2ZXJ5IiwiYiIsImkiLCJnZXRFbmNvZGVkU2l6ZSIsInZhbHVlIiwiZW5jb2RlciIsImZpeGVkU2l6ZSIsImdldFNpemVGcm9tVmFsdWUiLCJjcmVhdGVFbmNvZGVyIiwiT2JqZWN0IiwiZnJlZXplIiwiZW5jb2RlIiwid3JpdGUiLCJjcmVhdGVEZWNvZGVyIiwiZGVjb2RlciIsImRlY29kZSIsInJlYWQiLCJjcmVhdGVDb2RlYyIsImNvZGVjIiwiaXNGaXhlZFNpemUiLCJhc3NlcnRJc0ZpeGVkU2l6ZSIsImlzVmFyaWFibGVTaXplIiwiYXNzZXJ0SXNWYXJpYWJsZVNpemUiLCJjb21iaW5lQ29kZWMiLCJkZWNvZGVyRml4ZWRTaXplIiwiZW5jb2RlckZpeGVkU2l6ZSIsIm1heFNpemUiLCJkZWNvZGVyTWF4U2l6ZSIsImVuY29kZXJNYXhTaXplIiwiYWRkRW5jb2RlclNlbnRpbmVsIiwic2VudGluZWwiLCJlbmNvZGVyQnl0ZXMiLCJmaW5kU2VudGluZWxJbmRleCIsImVuY29kZWRCeXRlcyIsImhleEVuY29kZWRCeXRlcyIsImhleEJ5dGVzIiwiaGV4U2VudGluZWwiLCJhZGREZWNvZGVyU2VudGluZWwiLCJjYW5kaWRhdGVCeXRlcyIsInNlbnRpbmVsSW5kZXgiLCJkZWNvZGVkQnl0ZXMiLCJoZXhEZWNvZGVkQnl0ZXMiLCJwcmVTZW50aW5lbEJ5dGVzIiwiYWRkQ29kZWNTZW50aW5lbCIsImZpbmRJbmRleCIsImJ5dGUiLCJpbmRleCIsInN0ciIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMiLCJjb2RlY0Rlc2NyaXB0aW9uIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsImV4cGVjdGVkIiwiYnl0ZXNMZW5ndGgiLCJhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UiLCJhZGRFbmNvZGVyU2l6ZVByZWZpeCIsInByZWZpeCIsInByZWZpeE1heFNpemUiLCJlbmNvZGVyU2l6ZSIsImFkZERlY29kZXJTaXplUHJlZml4IiwiYmlnaW50U2l6ZSIsImRlY29kZXJPZmZzZXQiLCJzaXplIiwiTnVtYmVyIiwiYWRkQ29kZWNTaXplUHJlZml4IiwiZml4RW5jb2RlclNpemUiLCJmaXhlZEJ5dGVzIiwidmFyaWFibGVCeXRlQXJyYXkiLCJmaXhlZEJ5dGVBcnJheSIsImZpeERlY29kZXJTaXplIiwiZml4Q29kZWNTaXplIiwib2Zmc2V0RW5jb2RlciIsImNvbmZpZyIsInByZU9mZnNldCIsIndyYXBCeXRlcyIsIm1vZHVsbyIsIm5ld1ByZU9mZnNldCIsInBvc3RPZmZzZXQiLCJuZXdQb3N0T2Zmc2V0Iiwib2Zmc2V0RGVjb2RlciIsIm9mZnNldENvZGVjIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwicmVzaXplRW5jb2RlciIsInJlc2l6ZSIsIm5ld1NpemUiLCJyZXNpemVEZWNvZGVyIiwicmVzaXplQ29kZWMiLCJwYWRMZWZ0RW5jb2RlciIsInBhZFJpZ2h0RW5jb2RlciIsInBhZExlZnREZWNvZGVyIiwicGFkUmlnaHREZWNvZGVyIiwicGFkTGVmdENvZGVjIiwicGFkUmlnaHRDb2RlYyIsImNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZSIsInNvdXJjZSIsInRhcmdldF9XSUxMX01VVEFURSIsInNvdXJjZU9mZnNldCIsInNvdXJjZUxlbmd0aCIsInRhcmdldE9mZnNldCIsImxlZnRWYWx1ZSIsInJldmVyc2VFbmNvZGVyIiwibmV3T2Zmc2V0IiwicmV2ZXJzZURlY29kZXIiLCJyZXZlcnNlZEJ5dGVzIiwicmV2ZXJzZUNvZGVjIiwidHJhbnNmb3JtRW5jb2RlciIsInVubWFwIiwidHJhbnNmb3JtRGVjb2RlciIsIm1hcCIsInRyYW5zZm9ybUNvZGVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Endian: () => (/* binding */ Endian),\n/* harmony export */   assertNumberIsBetweenForCodec: () => (/* binding */ assertNumberIsBetweenForCodec),\n/* harmony export */   getF32Codec: () => (/* binding */ getF32Codec),\n/* harmony export */   getF32Decoder: () => (/* binding */ getF32Decoder),\n/* harmony export */   getF32Encoder: () => (/* binding */ getF32Encoder),\n/* harmony export */   getF64Codec: () => (/* binding */ getF64Codec),\n/* harmony export */   getF64Decoder: () => (/* binding */ getF64Decoder),\n/* harmony export */   getF64Encoder: () => (/* binding */ getF64Encoder),\n/* harmony export */   getI128Codec: () => (/* binding */ getI128Codec),\n/* harmony export */   getI128Decoder: () => (/* binding */ getI128Decoder),\n/* harmony export */   getI128Encoder: () => (/* binding */ getI128Encoder),\n/* harmony export */   getI16Codec: () => (/* binding */ getI16Codec),\n/* harmony export */   getI16Decoder: () => (/* binding */ getI16Decoder),\n/* harmony export */   getI16Encoder: () => (/* binding */ getI16Encoder),\n/* harmony export */   getI32Codec: () => (/* binding */ getI32Codec),\n/* harmony export */   getI32Decoder: () => (/* binding */ getI32Decoder),\n/* harmony export */   getI32Encoder: () => (/* binding */ getI32Encoder),\n/* harmony export */   getI64Codec: () => (/* binding */ getI64Codec),\n/* harmony export */   getI64Decoder: () => (/* binding */ getI64Decoder),\n/* harmony export */   getI64Encoder: () => (/* binding */ getI64Encoder),\n/* harmony export */   getI8Codec: () => (/* binding */ getI8Codec),\n/* harmony export */   getI8Decoder: () => (/* binding */ getI8Decoder),\n/* harmony export */   getI8Encoder: () => (/* binding */ getI8Encoder),\n/* harmony export */   getShortU16Codec: () => (/* binding */ getShortU16Codec),\n/* harmony export */   getShortU16Decoder: () => (/* binding */ getShortU16Decoder),\n/* harmony export */   getShortU16Encoder: () => (/* binding */ getShortU16Encoder),\n/* harmony export */   getU128Codec: () => (/* binding */ getU128Codec),\n/* harmony export */   getU128Decoder: () => (/* binding */ getU128Decoder),\n/* harmony export */   getU128Encoder: () => (/* binding */ getU128Encoder),\n/* harmony export */   getU16Codec: () => (/* binding */ getU16Codec),\n/* harmony export */   getU16Decoder: () => (/* binding */ getU16Decoder),\n/* harmony export */   getU16Encoder: () => (/* binding */ getU16Encoder),\n/* harmony export */   getU32Codec: () => (/* binding */ getU32Codec),\n/* harmony export */   getU32Decoder: () => (/* binding */ getU32Decoder),\n/* harmony export */   getU32Encoder: () => (/* binding */ getU32Encoder),\n/* harmony export */   getU64Codec: () => (/* binding */ getU64Codec),\n/* harmony export */   getU64Decoder: () => (/* binding */ getU64Decoder),\n/* harmony export */   getU64Encoder: () => (/* binding */ getU64Encoder),\n/* harmony export */   getU8Codec: () => (/* binding */ getU8Codec),\n/* harmony export */   getU8Decoder: () => (/* binding */ getU8Decoder),\n/* harmony export */   getU8Encoder: () => (/* binding */ getU8Encoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs\");\n\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n    if (value < min || value > max) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value\n        });\n    }\n}\n// src/common.ts\nvar Endian = /* @__PURE__ */ ((Endian2)=>{\n    Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n    Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n    return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n    return config?.endian === 1 /* Big */  ? false : true;\n}\nfunction numberEncoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        fixedSize: input.size,\n        write (value, bytes, offset) {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        }\n    });\n}\nfunction numberDecoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        fixedSize: input.size,\n        read (bytes, offset = 0) {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayIsNotEmptyForCodec)(input.name, bytes, offset);\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayHasEnoughBytesForCodec)(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [\n                input.get(view, isLittleEndian(input.config)),\n                offset + input.size\n            ];\n        }\n    });\n}\nfunction toArrayBuffer(bytes, offset, length) {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n// src/f32.ts\nvar getF32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f32\",\n        set: (view, value, le)=>view.setFloat32(0, Number(value), le),\n        size: 4\n    });\nvar getF32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat32(0, le),\n        name: \"f32\",\n        size: 4\n    });\nvar getF32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f64\",\n        set: (view, value, le)=>view.setFloat64(0, Number(value), le),\n        size: 8\n    });\nvar getF64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat64(0, le),\n        name: \"f64\",\n        size: 8\n    });\nvar getF64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i128\",\n        range: [\n            -BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getI128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"i128\",\n        size: 16\n    });\nvar getI128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i16\",\n        range: [\n            -Number(\"0x7fff\") - 1,\n            Number(\"0x7fff\")\n        ],\n        set: (view, value, le)=>view.setInt16(0, Number(value), le),\n        size: 2\n    });\nvar getI16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt16(0, le),\n        name: \"i16\",\n        size: 2\n    });\nvar getI16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i32\",\n        range: [\n            -Number(\"0x7fffffff\") - 1,\n            Number(\"0x7fffffff\")\n        ],\n        set: (view, value, le)=>view.setInt32(0, Number(value), le),\n        size: 4\n    });\nvar getI32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt32(0, le),\n        name: \"i32\",\n        size: 4\n    });\nvar getI32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i64\",\n        range: [\n            -BigInt(\"0x7fffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigInt64(0, BigInt(value), le),\n        size: 8\n    });\nvar getI64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigInt64(0, le),\n        name: \"i64\",\n        size: 8\n    });\nvar getI64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = ()=>numberEncoderFactory({\n        name: \"i8\",\n        range: [\n            -Number(\"0x7f\") - 1,\n            Number(\"0x7f\")\n        ],\n        set: (view, value)=>view.setInt8(0, Number(value)),\n        size: 1\n    });\nvar getI8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getInt8(0),\n        name: \"i8\",\n        size: 1\n    });\nvar getI8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>{\n            if (value <= 127) return 1;\n            if (value <= 16383) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value, bytes, offset)=>{\n            assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n            const shortU16Bytes = [\n                0\n            ];\n            for(let ii = 0;; ii += 1){\n                const alignedValue = Number(value) >> ii * 7;\n                if (alignedValue === 0) {\n                    break;\n                }\n                const nextSevenBits = 127 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    shortU16Bytes[ii - 1] |= 128;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        }\n    });\nvar getShortU16Decoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        maxSize: 3,\n        read: (bytes, offset)=>{\n            let value = 0;\n            let byteCount = 0;\n            while(++byteCount){\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 127 & currentByte;\n                value |= nextSevenBits << byteIndex * 7;\n                if ((currentByte & 128) === 0) {\n                    break;\n                }\n            }\n            return [\n                value,\n                offset + byteCount\n            ];\n        }\n    });\nvar getShortU16Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u128\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getU128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"u128\",\n        size: 16\n    });\nvar getU128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u16\",\n        range: [\n            0,\n            Number(\"0xffff\")\n        ],\n        set: (view, value, le)=>view.setUint16(0, Number(value), le),\n        size: 2\n    });\nvar getU16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint16(0, le),\n        name: \"u16\",\n        size: 2\n    });\nvar getU16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u32\",\n        range: [\n            0,\n            Number(\"0xffffffff\")\n        ],\n        set: (view, value, le)=>view.setUint32(0, Number(value), le),\n        size: 4\n    });\nvar getU32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint32(0, le),\n        name: \"u32\",\n        size: 4\n    });\nvar getU32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u64\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigUint64(0, BigInt(value), le),\n        size: 8\n    });\nvar getU64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigUint64(0, le),\n        name: \"u64\",\n        size: 8\n    });\nvar getU64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = ()=>numberEncoderFactory({\n        name: \"u8\",\n        range: [\n            0,\n            Number(\"0xff\")\n        ],\n        set: (view, value)=>view.setUint8(0, Number(value)),\n        size: 1\n    });\nvar getU8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getUint8(0),\n        name: \"u8\",\n        size: 1\n    });\nvar getU8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU8Encoder(), getU8Decoder());\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RjtBQUNtRTtBQUUzSixvQkFBb0I7QUFDcEIsU0FBU08sOEJBQThCQyxnQkFBZ0IsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEtBQUs7SUFDdEUsSUFBSUEsUUFBUUYsT0FBT0UsUUFBUUQsS0FBSztRQUM5QixNQUFNLElBQUlWLHVEQUFXQSxDQUFDQyxxRkFBeUNBLEVBQUU7WUFDL0RPO1lBQ0FFO1lBQ0FEO1lBQ0FFO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZ0JBQWdCO0FBQ2hCLElBQUlDLFNBQXlCLGFBQUgsR0FBSSxFQUFDQztJQUM3QkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUNqQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUM5QixPQUFPQTtBQUNULEdBQUdELFVBQVUsQ0FBQztBQUNkLFNBQVNFLGVBQWVDLE1BQU07SUFDNUIsT0FBT0EsUUFBUUMsV0FBVyxFQUFFLE9BQU8sTUFBSyxRQUFRO0FBQ2xEO0FBQ0EsU0FBU0MscUJBQXFCQyxLQUFLO0lBQ2pDLE9BQU9kLGtFQUFhQSxDQUFDO1FBQ25CZSxXQUFXRCxNQUFNRSxJQUFJO1FBQ3JCQyxPQUFNVixLQUFLLEVBQUVXLEtBQUssRUFBRUMsTUFBTTtZQUN4QixJQUFJTCxNQUFNTSxLQUFLLEVBQUU7Z0JBQ2ZqQiw4QkFBOEJXLE1BQU1PLElBQUksRUFBRVAsTUFBTU0sS0FBSyxDQUFDLEVBQUUsRUFBRU4sTUFBTU0sS0FBSyxDQUFDLEVBQUUsRUFBRWI7WUFDNUU7WUFDQSxNQUFNZSxjQUFjLElBQUlDLFlBQVlULE1BQU1FLElBQUk7WUFDOUNG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Q3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLW51bWJlcnMvZGlzdC9pbmRleC5ub2RlLm1qcz81OWVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcbmltcG9ydCB7IGNvbWJpbmVDb2RlYywgY3JlYXRlRGVjb2RlciwgY3JlYXRlRW5jb2RlciwgYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5cbi8vIHNyYy9hc3NlcnRpb25zLnRzXG5mdW5jdGlvbiBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBtaW4sIG1heCwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFLCB7XG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgbWF4LFxuICAgICAgbWluLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvY29tbW9uLnRzXG52YXIgRW5kaWFuID0gLyogQF9fUFVSRV9fICovICgoRW5kaWFuMikgPT4ge1xuICBFbmRpYW4yW0VuZGlhbjJbXCJMaXR0bGVcIl0gPSAwXSA9IFwiTGl0dGxlXCI7XG4gIEVuZGlhbjJbRW5kaWFuMltcIkJpZ1wiXSA9IDFdID0gXCJCaWdcIjtcbiAgcmV0dXJuIEVuZGlhbjI7XG59KShFbmRpYW4gfHwge30pO1xuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oY29uZmlnKSB7XG4gIHJldHVybiBjb25maWc/LmVuZGlhbiA9PT0gMSAvKiBCaWcgKi8gPyBmYWxzZSA6IHRydWU7XG59XG5mdW5jdGlvbiBudW1iZXJFbmNvZGVyRmFjdG9yeShpbnB1dCkge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgZml4ZWRTaXplOiBpbnB1dC5zaXplLFxuICAgIHdyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KSB7XG4gICAgICBpZiAoaW5wdXQucmFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVySXNCZXR3ZWVuRm9yQ29kZWMoaW5wdXQubmFtZSwgaW5wdXQucmFuZ2VbMF0sIGlucHV0LnJhbmdlWzFdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihpbnB1dC5zaXplKTtcbiAgICAgIGlucHV0LnNldChuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4oaW5wdXQuY29uZmlnKSk7XG4gICAgICBieXRlcy5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGlucHV0LnNpemU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG51bWJlckRlY29kZXJGYWN0b3J5KGlucHV0KSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGlucHV0LnNpemUsXG4gICAgcmVhZChieXRlcywgb2Zmc2V0ID0gMCkge1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjKGlucHV0Lm5hbWUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhpbnB1dC5uYW1lLCBpbnB1dC5zaXplLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcodG9BcnJheUJ1ZmZlcihieXRlcywgb2Zmc2V0LCBpbnB1dC5zaXplKSk7XG4gICAgICByZXR1cm4gW2lucHV0LmdldCh2aWV3LCBpc0xpdHRsZUVuZGlhbihpbnB1dC5jb25maWcpKSwgb2Zmc2V0ICsgaW5wdXQuc2l6ZV07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnl0ZXMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGNvbnN0IGJ5dGVzT2Zmc2V0ID0gYnl0ZXMuYnl0ZU9mZnNldCArIChvZmZzZXQgPz8gMCk7XG4gIGNvbnN0IGJ5dGVzTGVuZ3RoID0gbGVuZ3RoID8/IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gIHJldHVybiBieXRlcy5idWZmZXIuc2xpY2UoYnl0ZXNPZmZzZXQsIGJ5dGVzT2Zmc2V0ICsgYnl0ZXNMZW5ndGgpO1xufVxuXG4vLyBzcmMvZjMyLnRzXG52YXIgZ2V0RjMyRW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiZjMyXCIsXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRGbG9hdDMyKDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0RjMyRGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEZsb2F0MzIoMCwgbGUpLFxuICBuYW1lOiBcImYzMlwiLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRGMzJDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEYzMkVuY29kZXIoY29uZmlnKSwgZ2V0RjMyRGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRGNjRFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJmNjRcIixcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldEZsb2F0NjQoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRGNjREZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0RmxvYXQ2NCgwLCBsZSksXG4gIG5hbWU6IFwiZjY0XCIsXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldEY2NENvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0RjY0RW5jb2Rlcihjb25maWcpLCBnZXRGNjREZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEkxMjhFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJpMTI4XCIsXG4gIHJhbmdlOiBbLUJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikgLSAxbiwgQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4ge1xuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBsZSA/IDggOiAwO1xuICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gbGUgPyAwIDogODtcbiAgICBjb25zdCByaWdodE1hc2sgPSAweGZmZmZmZmZmZmZmZmZmZmZuO1xuICAgIHZpZXcuc2V0QmlnSW50NjQobGVmdE9mZnNldCwgQmlnSW50KHZhbHVlKSA+PiA2NG4sIGxlKTtcbiAgICB2aWV3LnNldEJpZ1VpbnQ2NChyaWdodE9mZnNldCwgQmlnSW50KHZhbHVlKSAmIHJpZ2h0TWFzaywgbGUpO1xuICB9LFxuICBzaXplOiAxNlxufSk7XG52YXIgZ2V0STEyOERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4ge1xuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBsZSA/IDggOiAwO1xuICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gbGUgPyAwIDogODtcbiAgICBjb25zdCBsZWZ0ID0gdmlldy5nZXRCaWdJbnQ2NChsZWZ0T2Zmc2V0LCBsZSk7XG4gICAgY29uc3QgcmlnaHQgPSB2aWV3LmdldEJpZ1VpbnQ2NChyaWdodE9mZnNldCwgbGUpO1xuICAgIHJldHVybiAobGVmdCA8PCA2NG4pICsgcmlnaHQ7XG4gIH0sXG4gIG5hbWU6IFwiaTEyOFwiLFxuICBzaXplOiAxNlxufSk7XG52YXIgZ2V0STEyOENvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0STEyOEVuY29kZXIoY29uZmlnKSwgZ2V0STEyOERlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0STE2RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiaTE2XCIsXG4gIHJhbmdlOiBbLU51bWJlcihcIjB4N2ZmZlwiKSAtIDEsIE51bWJlcihcIjB4N2ZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRJbnQxNigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gIHNpemU6IDJcbn0pO1xudmFyIGdldEkxNkRlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRJbnQxNigwLCBsZSksXG4gIG5hbWU6IFwiaTE2XCIsXG4gIHNpemU6IDJcbn0pO1xudmFyIGdldEkxNkNvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0STE2RW5jb2Rlcihjb25maWcpLCBnZXRJMTZEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEkzMkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImkzMlwiLFxuICByYW5nZTogWy1OdW1iZXIoXCIweDdmZmZmZmZmXCIpIC0gMSwgTnVtYmVyKFwiMHg3ZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRJbnQzMigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gIHNpemU6IDRcbn0pO1xudmFyIGdldEkzMkRlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRJbnQzMigwLCBsZSksXG4gIG5hbWU6IFwiaTMyXCIsXG4gIHNpemU6IDRcbn0pO1xudmFyIGdldEkzMkNvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0STMyRW5jb2Rlcihjb25maWcpLCBnZXRJMzJEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEk2NEVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImk2NFwiLFxuICByYW5nZTogWy1CaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIikgLSAxbiwgQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldEJpZ0ludDY0KDAsIEJpZ0ludCh2YWx1ZSksIGxlKSxcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0STY0RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEJpZ0ludDY0KDAsIGxlKSxcbiAgbmFtZTogXCJpNjRcIixcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0STY0Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRJNjRFbmNvZGVyKGNvbmZpZyksIGdldEk2NERlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0SThFbmNvZGVyID0gKCkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBuYW1lOiBcImk4XCIsXG4gIHJhbmdlOiBbLU51bWJlcihcIjB4N2ZcIikgLSAxLCBOdW1iZXIoXCIweDdmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUpID0+IHZpZXcuc2V0SW50OCgwLCBOdW1iZXIodmFsdWUpKSxcbiAgc2l6ZTogMVxufSk7XG52YXIgZ2V0SThEZWNvZGVyID0gKCkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBnZXQ6ICh2aWV3KSA9PiB2aWV3LmdldEludDgoMCksXG4gIG5hbWU6IFwiaThcIixcbiAgc2l6ZTogMVxufSk7XG52YXIgZ2V0SThDb2RlYyA9ICgpID0+IGNvbWJpbmVDb2RlYyhnZXRJOEVuY29kZXIoKSwgZ2V0SThEZWNvZGVyKCkpO1xudmFyIGdldFNob3J0VTE2RW5jb2RlciA9ICgpID0+IGNyZWF0ZUVuY29kZXIoe1xuICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPD0gMTI3KSByZXR1cm4gMTtcbiAgICBpZiAodmFsdWUgPD0gMTYzODMpIHJldHVybiAyO1xuICAgIHJldHVybiAzO1xuICB9LFxuICBtYXhTaXplOiAzLFxuICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgYXNzZXJ0TnVtYmVySXNCZXR3ZWVuRm9yQ29kZWMoXCJzaG9ydFUxNlwiLCAwLCA2NTUzNSwgdmFsdWUpO1xuICAgIGNvbnN0IHNob3J0VTE2Qnl0ZXMgPSBbMF07XG4gICAgZm9yIChsZXQgaWkgPSAwOyA7IGlpICs9IDEpIHtcbiAgICAgIGNvbnN0IGFsaWduZWRWYWx1ZSA9IE51bWJlcih2YWx1ZSkgPj4gaWkgKiA3O1xuICAgICAgaWYgKGFsaWduZWRWYWx1ZSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRTZXZlbkJpdHMgPSAxMjcgJiBhbGlnbmVkVmFsdWU7XG4gICAgICBzaG9ydFUxNkJ5dGVzW2lpXSA9IG5leHRTZXZlbkJpdHM7XG4gICAgICBpZiAoaWkgPiAwKSB7XG4gICAgICAgIHNob3J0VTE2Qnl0ZXNbaWkgLSAxXSB8PSAxMjg7XG4gICAgICB9XG4gICAgfVxuICAgIGJ5dGVzLnNldChzaG9ydFUxNkJ5dGVzLCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQgKyBzaG9ydFUxNkJ5dGVzLmxlbmd0aDtcbiAgfVxufSk7XG52YXIgZ2V0U2hvcnRVMTZEZWNvZGVyID0gKCkgPT4gY3JlYXRlRGVjb2Rlcih7XG4gIG1heFNpemU6IDMsXG4gIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICB3aGlsZSAoKytieXRlQ291bnQpIHtcbiAgICAgIGNvbnN0IGJ5dGVJbmRleCA9IGJ5dGVDb3VudCAtIDE7XG4gICAgICBjb25zdCBjdXJyZW50Qnl0ZSA9IGJ5dGVzW29mZnNldCArIGJ5dGVJbmRleF07XG4gICAgICBjb25zdCBuZXh0U2V2ZW5CaXRzID0gMTI3ICYgY3VycmVudEJ5dGU7XG4gICAgICB2YWx1ZSB8PSBuZXh0U2V2ZW5CaXRzIDw8IGJ5dGVJbmRleCAqIDc7XG4gICAgICBpZiAoKGN1cnJlbnRCeXRlICYgMTI4KSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt2YWx1ZSwgb2Zmc2V0ICsgYnl0ZUNvdW50XTtcbiAgfVxufSk7XG52YXIgZ2V0U2hvcnRVMTZDb2RlYyA9ICgpID0+IGNvbWJpbmVDb2RlYyhnZXRTaG9ydFUxNkVuY29kZXIoKSwgZ2V0U2hvcnRVMTZEZWNvZGVyKCkpO1xudmFyIGdldFUxMjhFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJ1MTI4XCIsXG4gIHJhbmdlOiBbMG4sIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgY29uc3QgcmlnaHRNYXNrID0gMHhmZmZmZmZmZmZmZmZmZmZmbjtcbiAgICB2aWV3LnNldEJpZ1VpbnQ2NChsZWZ0T2Zmc2V0LCBCaWdJbnQodmFsdWUpID4+IDY0biwgbGUpO1xuICAgIHZpZXcuc2V0QmlnVWludDY0KHJpZ2h0T2Zmc2V0LCBCaWdJbnQodmFsdWUpICYgcmlnaHRNYXNrLCBsZSk7XG4gIH0sXG4gIHNpemU6IDE2XG59KTtcbnZhciBnZXRVMTI4RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB7XG4gICAgY29uc3QgbGVmdE9mZnNldCA9IGxlID8gOCA6IDA7XG4gICAgY29uc3QgcmlnaHRPZmZzZXQgPSBsZSA/IDAgOiA4O1xuICAgIGNvbnN0IGxlZnQgPSB2aWV3LmdldEJpZ1VpbnQ2NChsZWZ0T2Zmc2V0LCBsZSk7XG4gICAgY29uc3QgcmlnaHQgPSB2aWV3LmdldEJpZ1VpbnQ2NChyaWdodE9mZnNldCwgbGUpO1xuICAgIHJldHVybiAobGVmdCA8PCA2NG4pICsgcmlnaHQ7XG4gIH0sXG4gIG5hbWU6IFwidTEyOFwiLFxuICBzaXplOiAxNlxufSk7XG52YXIgZ2V0VTEyOENvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0VTEyOEVuY29kZXIoY29uZmlnKSwgZ2V0VTEyOERlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VTE2RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTE2XCIsXG4gIHJhbmdlOiBbMCwgTnVtYmVyKFwiMHhmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldFVpbnQxNigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gIHNpemU6IDJcbn0pO1xudmFyIGdldFUxNkRlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRVaW50MTYoMCwgbGUpLFxuICBuYW1lOiBcInUxNlwiLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRVMTZDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldFUxNkVuY29kZXIoY29uZmlnKSwgZ2V0VTE2RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRVMzJFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJ1MzJcIixcbiAgcmFuZ2U6IFswLCBOdW1iZXIoXCIweGZmZmZmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldFVpbnQzMigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gIHNpemU6IDRcbn0pO1xudmFyIGdldFUzMkRlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRVaW50MzIoMCwgbGUpLFxuICBuYW1lOiBcInUzMlwiLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRVMzJDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldFUzMkVuY29kZXIoY29uZmlnKSwgZ2V0VTMyRGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRVNjRFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJ1NjRcIixcbiAgcmFuZ2U6IFswbiwgQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldEJpZ1VpbnQ2NCgwLCBCaWdJbnQodmFsdWUpLCBsZSksXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldFU2NERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRCaWdVaW50NjQoMCwgbGUpLFxuICBuYW1lOiBcInU2NFwiLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRVNjRDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldFU2NEVuY29kZXIoY29uZmlnKSwgZ2V0VTY0RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRVOEVuY29kZXIgPSAoKSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIG5hbWU6IFwidThcIixcbiAgcmFuZ2U6IFswLCBOdW1iZXIoXCIweGZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUpID0+IHZpZXcuc2V0VWludDgoMCwgTnVtYmVyKHZhbHVlKSksXG4gIHNpemU6IDFcbn0pO1xudmFyIGdldFU4RGVjb2RlciA9ICgpID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgZ2V0OiAodmlldykgPT4gdmlldy5nZXRVaW50OCgwKSxcbiAgbmFtZTogXCJ1OFwiLFxuICBzaXplOiAxXG59KTtcbnZhciBnZXRVOENvZGVjID0gKCkgPT4gY29tYmluZUNvZGVjKGdldFU4RW5jb2RlcigpLCBnZXRVOERlY29kZXIoKSk7XG5cbmV4cG9ydCB7IEVuZGlhbiwgYXNzZXJ0TnVtYmVySXNCZXR3ZWVuRm9yQ29kZWMsIGdldEYzMkNvZGVjLCBnZXRGMzJEZWNvZGVyLCBnZXRGMzJFbmNvZGVyLCBnZXRGNjRDb2RlYywgZ2V0RjY0RGVjb2RlciwgZ2V0RjY0RW5jb2RlciwgZ2V0STEyOENvZGVjLCBnZXRJMTI4RGVjb2RlciwgZ2V0STEyOEVuY29kZXIsIGdldEkxNkNvZGVjLCBnZXRJMTZEZWNvZGVyLCBnZXRJMTZFbmNvZGVyLCBnZXRJMzJDb2RlYywgZ2V0STMyRGVjb2RlciwgZ2V0STMyRW5jb2RlciwgZ2V0STY0Q29kZWMsIGdldEk2NERlY29kZXIsIGdldEk2NEVuY29kZXIsIGdldEk4Q29kZWMsIGdldEk4RGVjb2RlciwgZ2V0SThFbmNvZGVyLCBnZXRTaG9ydFUxNkNvZGVjLCBnZXRTaG9ydFUxNkRlY29kZXIsIGdldFNob3J0VTE2RW5jb2RlciwgZ2V0VTEyOENvZGVjLCBnZXRVMTI4RGVjb2RlciwgZ2V0VTEyOEVuY29kZXIsIGdldFUxNkNvZGVjLCBnZXRVMTZEZWNvZGVyLCBnZXRVMTZFbmNvZGVyLCBnZXRVMzJDb2RlYywgZ2V0VTMyRGVjb2RlciwgZ2V0VTMyRW5jb2RlciwgZ2V0VTY0Q29kZWMsIGdldFU2NERlY29kZXIsIGdldFU2NEVuY29kZXIsIGdldFU4Q29kZWMsIGdldFU4RGVjb2RlciwgZ2V0VThFbmNvZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFIiwiY29tYmluZUNvZGVjIiwiY3JlYXRlRGVjb2RlciIsImNyZWF0ZUVuY29kZXIiLCJhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMiLCJhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjIiwiYXNzZXJ0TnVtYmVySXNCZXR3ZWVuRm9yQ29kZWMiLCJjb2RlY0Rlc2NyaXB0aW9uIiwibWluIiwibWF4IiwidmFsdWUiLCJFbmRpYW4iLCJFbmRpYW4yIiwiaXNMaXR0bGVFbmRpYW4iLCJjb25maWciLCJlbmRpYW4iLCJudW1iZXJFbmNvZGVyRmFjdG9yeSIsImlucHV0IiwiZml4ZWRTaXplIiwic2l6ZSIsIndyaXRlIiwiYnl0ZXMiLCJvZmZzZXQiLCJyYW5nZSIsIm5hbWUiLCJhcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwic2V0IiwiRGF0YVZpZXciLCJVaW50OEFycmF5IiwibnVtYmVyRGVjb2RlckZhY3RvcnkiLCJyZWFkIiwidmlldyIsInRvQXJyYXlCdWZmZXIiLCJnZXQiLCJsZW5ndGgiLCJieXRlc09mZnNldCIsImJ5dGVPZmZzZXQiLCJieXRlc0xlbmd0aCIsImJ5dGVMZW5ndGgiLCJidWZmZXIiLCJzbGljZSIsImdldEYzMkVuY29kZXIiLCJsZSIsInNldEZsb2F0MzIiLCJOdW1iZXIiLCJnZXRGMzJEZWNvZGVyIiwiZ2V0RmxvYXQzMiIsImdldEYzMkNvZGVjIiwiZ2V0RjY0RW5jb2RlciIsInNldEZsb2F0NjQiLCJnZXRGNjREZWNvZGVyIiwiZ2V0RmxvYXQ2NCIsImdldEY2NENvZGVjIiwiZ2V0STEyOEVuY29kZXIiLCJCaWdJbnQiLCJsZWZ0T2Zmc2V0IiwicmlnaHRPZmZzZXQiLCJyaWdodE1hc2siLCJzZXRCaWdJbnQ2NCIsInNldEJpZ1VpbnQ2NCIsImdldEkxMjhEZWNvZGVyIiwibGVmdCIsImdldEJpZ0ludDY0IiwicmlnaHQiLCJnZXRCaWdVaW50NjQiLCJnZXRJMTI4Q29kZWMiLCJnZXRJMTZFbmNvZGVyIiwic2V0SW50MTYiLCJnZXRJMTZEZWNvZGVyIiwiZ2V0SW50MTYiLCJnZXRJMTZDb2RlYyIsImdldEkzMkVuY29kZXIiLCJzZXRJbnQzMiIsImdldEkzMkRlY29kZXIiLCJnZXRJbnQzMiIsImdldEkzMkNvZGVjIiwiZ2V0STY0RW5jb2RlciIsImdldEk2NERlY29kZXIiLCJnZXRJNjRDb2RlYyIsImdldEk4RW5jb2RlciIsInNldEludDgiLCJnZXRJOERlY29kZXIiLCJnZXRJbnQ4IiwiZ2V0SThDb2RlYyIsImdldFNob3J0VTE2RW5jb2RlciIsImdldFNpemVGcm9tVmFsdWUiLCJtYXhTaXplIiwic2hvcnRVMTZCeXRlcyIsImlpIiwiYWxpZ25lZFZhbHVlIiwibmV4dFNldmVuQml0cyIsImdldFNob3J0VTE2RGVjb2RlciIsImJ5dGVDb3VudCIsImJ5dGVJbmRleCIsImN1cnJlbnRCeXRlIiwiZ2V0U2hvcnRVMTZDb2RlYyIsImdldFUxMjhFbmNvZGVyIiwiZ2V0VTEyOERlY29kZXIiLCJnZXRVMTI4Q29kZWMiLCJnZXRVMTZFbmNvZGVyIiwic2V0VWludDE2IiwiZ2V0VTE2RGVjb2RlciIsImdldFVpbnQxNiIsImdldFUxNkNvZGVjIiwiZ2V0VTMyRW5jb2RlciIsInNldFVpbnQzMiIsImdldFUzMkRlY29kZXIiLCJnZXRVaW50MzIiLCJnZXRVMzJDb2RlYyIsImdldFU2NEVuY29kZXIiLCJnZXRVNjREZWNvZGVyIiwiZ2V0VTY0Q29kZWMiLCJnZXRVOEVuY29kZXIiLCJzZXRVaW50OCIsImdldFU4RGVjb2RlciIsImdldFVpbnQ4IiwiZ2V0VThDb2RlYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MALFORMED_PDA: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MALFORMED_PDA),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED: () => (/* binding */ SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_CONSTANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_CONSTANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE),\n/* harmony export */   SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES: () => (/* binding */ SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES),\n/* harmony export */   SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH),\n/* harmony export */   SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__INVALID_NONCE: () => (/* binding */ SOLANA_ERROR__INVALID_NONCE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_PARAMS: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_PARAMS),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_REQUEST: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_REQUEST),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__PARSE_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__PARSE_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SCAN_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SCAN_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY: () => (/* binding */ SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY),\n/* harmony export */   SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__MALFORMED_BIGINT_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_BIGINT_STRING),\n/* harmony export */   SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR: () => (/* binding */ SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR),\n/* harmony export */   SOLANA_ERROR__MALFORMED_NUMBER_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_NUMBER_STRING),\n/* harmony export */   SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID),\n/* harmony export */   SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD: () => (/* binding */ SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD),\n/* harmony export */   SOLANA_ERROR__RPC__INTEGER_OVERFLOW: () => (/* binding */ SOLANA_ERROR__RPC__INTEGER_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN),\n/* harmony export */   SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING),\n/* harmony export */   SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH: () => (/* binding */ SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE),\n/* harmony export */   SolanaError: () => (/* binding */ SolanaError),\n/* harmony export */   getSolanaErrorFromInstructionError: () => (/* binding */ getSolanaErrorFromInstructionError),\n/* harmony export */   getSolanaErrorFromJsonRpcError: () => (/* binding */ getSolanaErrorFromJsonRpcError),\n/* harmony export */   getSolanaErrorFromTransactionError: () => (/* binding */ getSolanaErrorFromTransactionError),\n/* harmony export */   isSolanaError: () => (/* binding */ isSolanaError),\n/* harmony export */   safeCaptureStackTrace: () => (/* binding */ safeCaptureStackTrace)\n/* harmony export */ });\n// src/codes.ts\nvar SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nvar SOLANA_ERROR__INVALID_NONCE = 2;\nvar SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nvar SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nvar SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nvar SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nvar SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nvar SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nvar SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nvar SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\nvar SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nvar SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nvar SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nvar SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nvar SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nvar SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;\nvar SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nvar SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nvar SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nvar SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nvar SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nvar SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nvar SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nvar SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nvar SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nvar SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\nvar SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;\nvar SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nvar SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\nvar SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;\nvar SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;\nvar SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nvar SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nvar SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nvar SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nvar SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\nvar SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;\nvar SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nvar SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nvar SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nvar SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nvar SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nvar SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nvar SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nvar SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nvar SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nvar SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nvar SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nvar SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nvar SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\nvar SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;\nvar SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nvar SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nvar SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nvar SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nvar SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nvar SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nvar SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nvar SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nvar SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nvar SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nvar SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nvar SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nvar SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nvar SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nvar SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nvar SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nvar SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nvar SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nvar SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nvar SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nvar SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n// src/context.ts\nfunction encodeValue(value) {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join(\"%2C%20\");\n        return \"%5B\" + commaSeparatedValues + /* \"]\" */ \"%5D\";\n    } else if (typeof value === \"bigint\") {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(String(value != null && Object.getPrototypeOf(value) === null ? // Plain objects with no prototype don't have a `toString` method.\n        // Convert them before stringifying them.\n        {\n            ...value\n        } : value));\n    }\n}\nfunction encodeObjectContextEntry([key, value]) {\n    return `${key}=${encodeValue(value)}`;\n}\nfunction encodeContextObject(context) {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join(\"&\");\n    return Buffer.from(searchParamsString, \"utf8\").toString(\"base64\");\n}\n// src/messages.ts\nvar SolanaErrorMessages = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: \"Account not found at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: \"Expected decoded account at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: \"Failed to decode account data at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: \"Accounts not found at addresses: $addresses\",\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: \"Unable to find a viable program address bump seed.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: \"$putativeAddress is not a base58-encoded address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: \"$putativeOffCurveAddress is not a base58-encoded off-curve address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: \"Program address cannot end with PDA marker.\",\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: \"Expected a fixed-size codec, got a variable-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: \"Expected a variable-size codec, got a fixed-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: \"No random values implementation could be found.\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: \"instruction requires an uninitialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: \"instruction tries to borrow reference for an account which is already borrowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"instruction left account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: \"account data too small for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: \"instruction expected an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: \"An account does not have enough lamports to be rent-exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: \"Program arithmetic overflowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: \"Failed to serialize or deserialize account data: $encodedData\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: \"Builtin programs must consume compute units\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: \"Cross-program invocation call depth too deep\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: \"Computational budget exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: \"custom program error: #$code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: \"instruction contains duplicate accounts\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: \"instruction modifications of multiply-passed account differ\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: \"executable accounts must be rent exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: \"instruction changed executable accounts data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: \"instruction changed the balance of an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: \"instruction changed executable bit of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: \"instruction modified data of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: \"instruction spent from the balance of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: \"generic instruction error\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: \"Provided owner is not allowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: \"Account is immutable\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: \"Incorrect authority provided\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: \"incorrect program id for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: \"insufficient funds for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: \"invalid account data for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: \"Invalid account owner\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: \"invalid program argument\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: \"program returned invalid error code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: \"invalid instruction data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: \"Failed to reallocate account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: \"Provided seeds do not result in a valid address\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: \"Max accounts exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: \"Max instruction trace length exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: \"Length of the seed is too long for address generation\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: \"An account required by the instruction is missing\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: \"missing required signature for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: \"instruction illegally modified the program id of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: \"insufficient account keys for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: \"Cross-program invocation with unauthorized signer or writable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: \"Failed to create program execution environment\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: \"Program failed to compile\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: \"Program failed to complete\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: \"instruction modified data of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: \"instruction changed the balance of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: \"instruction modified rent epoch of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: \"sum of account balances before and after instruction do not match\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: \"instruction requires an initialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: \"\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: \"Unsupported program id\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: \"Unsupported sysvar\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: \"The instruction does not have any accounts.\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: \"The instruction does not have any data.\",\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__INVALID_NONCE]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: \"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: \"Minimum context slot has not been reached\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: \"No snapshot\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: \"Transaction simulation failed\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: \"Transaction history is not available from this node\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: \"Transaction signature length mismatch\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: \"Transaction signature verification failure\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: \"$__serverMessage\",\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: \"Key pair bytes must be of length 64, got $byteLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: \"The provided private key does not match the provided public key.\",\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: \"Lamports value must be in the range [0, 2e64-1]\",\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: \"`$value` cannot be parsed as a `BigInt`\",\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: \"$message\",\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: \"`$value` cannot be parsed as a `Number`\",\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: \"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: \"WebSocket was closed before payload could be added to the send buffer\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: \"WebSocket connection closed\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: \"WebSocket failed to connect\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: \"Failed to obtain a subscription id from the server\",\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: \"Could not find an API plan for RPC method: `$method`\",\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: \"HTTP error ($statusCode): $message\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: \"The provided value does not implement the `KeyPairSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: \"More than one `TransactionSendingSigner` was identified.\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: \"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.\",\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: \"Cannot export a non-extractable key.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: \"No digest implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: \"No signature verification implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: \"No key generation implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: \"No signing implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: \"No key export implementation could be found.\",\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: \"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"Transaction processing left an account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: \"Account in use\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: \"Account loaded twice\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: \"Attempt to debit an account but found no record of a prior credit.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: \"This transaction has already been processed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: \"Blockhash not found\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: \"Loader call chain is too deep\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: \"Transactions are currently disabled due to cluster maintenance\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: \"Insufficient funds for fee\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: \"This account may not be used to pay transaction fees\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: \"Transaction contains an invalid account reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: \"Transaction loads an address table account with invalid data\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: \"Transaction address table lookup uses an invalid index\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: \"Transaction loads an address table account with an invalid owner\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: \"This program may not be used for executing instructions\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: \"Transaction loads a writable account that cannot be written\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: \"Transaction exceeded max loaded accounts data size cap\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: \"Transaction requires a fee but has no signature present\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: \"Attempt to load a program that does not exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: \"ResanitizationNeeded\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: \"Transaction failed to sanitize accounts offsets correctly\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: \"Transaction did not pass signature verification\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: \"Transaction locked too many accounts\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: \"Sum of account balances before and after transaction do not match\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: \"The transaction failed with the error `$errorName`\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: \"Transaction version is unsupported\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: \"Transaction would exceed account data limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: \"Transaction would exceed total account data limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: \"Transaction would exceed max account limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: \"Transaction would exceed max Block Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: \"Transaction would exceed max Vote Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: \"Transaction is missing an address at index: $index.\",\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: \"Transaction has no expected signers therefore it cannot be encoded\",\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: \"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: \"Transaction does not have a blockhash lifetime\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: \"Transaction is not a durable nonce transaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: \"No fee payer set in CompiledTransaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: \"Could not find program address at index $index\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: \"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: \"Transaction is missing a fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: \"Transaction first instruction is not advance nonce account instruction.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: \"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.\",\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: \"Transaction is missing signatures for addresses: $addresses.\",\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\"\n};\n// src/message-formatter.ts\nvar START_INDEX = \"i\";\nvar TYPE = \"t\";\nfunction getHumanReadableErrorMessage(code, context = {}) {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return \"\";\n    }\n    let state;\n    function commitStateUpTo(endIndex) {\n        if (state[TYPE] === 2 /* Variable */ ) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(variableName in context ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `${context[variableName]}` : `$${variableName}`);\n        } else if (state[TYPE] === 1 /* Text */ ) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments = [];\n    messageFormatString.split(\"\").forEach((char, ii)=>{\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]: messageFormatString[0] === \"\\\\\" ? 0 /* EscapeSequence */  : messageFormatString[0] === \"$\" ? 2 /* Variable */  : 1 /* Text */ \n            };\n            return;\n        }\n        let nextState;\n        switch(state[TYPE]){\n            case 0 /* EscapeSequence */ :\n                nextState = {\n                    [START_INDEX]: ii,\n                    [TYPE]: 1 /* Text */ \n                };\n                break;\n            case 1 /* Text */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                }\n                break;\n            case 2 /* Variable */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                } else if (!char.match(/\\w/)) {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 1 /* Text */ \n                    };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join(\"\");\n}\nfunction getErrorMessage(code, context = {}) {\n    if (true) {\n        return getHumanReadableErrorMessage(code, context);\n    } else {}\n}\n// src/error.ts\nfunction isSolanaError(e, code) {\n    const isSolanaError2 = e instanceof Error && e.name === \"SolanaError\";\n    if (isSolanaError2) {\n        if (code !== void 0) {\n            return e.context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\nvar SolanaError = class extends Error {\n    constructor(...[code, contextAndErrorOptions]){\n        let context;\n        let errorOptions;\n        if (contextAndErrorOptions) {\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = {\n                    cause\n                };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest;\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        /**\n   * Indicates the root cause of this {@link SolanaError}, if any.\n   *\n   * For example, a transaction error might have an instruction error as its root cause. In this\n   * case, you will be able to access the instruction error on the transaction error as `cause`.\n   */ this.cause = this.cause;\n        this.context = {\n            __code: code,\n            ...context\n        };\n        this.name = \"SolanaError\";\n    }\n};\n// src/stack-trace.ts\nfunction safeCaptureStackTrace(...args) {\n    if (\"captureStackTrace\" in Error && typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(...args);\n    }\n}\n// src/rpc-enum-errors.ts\nfunction getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === \"string\") {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = errorCodeBaseOffset + codeOffset;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n// src/instruction-error.ts\nvar ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"GenericError\",\n    \"InvalidArgument\",\n    \"InvalidInstructionData\",\n    \"InvalidAccountData\",\n    \"AccountDataTooSmall\",\n    \"InsufficientFunds\",\n    \"IncorrectProgramId\",\n    \"MissingRequiredSignature\",\n    \"AccountAlreadyInitialized\",\n    \"UninitializedAccount\",\n    \"UnbalancedInstruction\",\n    \"ModifiedProgramId\",\n    \"ExternalAccountLamportSpend\",\n    \"ExternalAccountDataModified\",\n    \"ReadonlyLamportChange\",\n    \"ReadonlyDataModified\",\n    \"DuplicateAccountIndex\",\n    \"ExecutableModified\",\n    \"RentEpochModified\",\n    \"NotEnoughAccountKeys\",\n    \"AccountDataSizeChanged\",\n    \"AccountNotExecutable\",\n    \"AccountBorrowFailed\",\n    \"AccountBorrowOutstanding\",\n    \"DuplicateAccountOutOfSync\",\n    \"Custom\",\n    \"InvalidError\",\n    \"ExecutableDataModified\",\n    \"ExecutableLamportChange\",\n    \"ExecutableAccountNotRentExempt\",\n    \"UnsupportedProgramId\",\n    \"CallDepth\",\n    \"MissingAccount\",\n    \"ReentrancyNotAllowed\",\n    \"MaxSeedLengthExceeded\",\n    \"InvalidSeeds\",\n    \"InvalidRealloc\",\n    \"ComputationalBudgetExceeded\",\n    \"PrivilegeEscalation\",\n    \"ProgramEnvironmentSetupFailure\",\n    \"ProgramFailedToComplete\",\n    \"ProgramFailedToCompile\",\n    \"Immutable\",\n    \"IncorrectAuthority\",\n    \"BorshIoError\",\n    \"AccountNotRentExempt\",\n    \"InvalidAccountOwner\",\n    \"ArithmeticOverflow\",\n    \"UnsupportedSysvar\",\n    \"IllegalOwner\",\n    \"MaxAccountsDataAllocationsExceeded\",\n    \"MaxAccountsExceeded\",\n    \"MaxInstructionTraceLengthExceeded\",\n    \"BuiltinProgramsMustConsumeComputeUnits\"\n];\nfunction getSolanaErrorFromInstructionError(index, instructionError) {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 4615001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    index: numberIndex,\n                    ...rpcErrorContext !== void 0 ? {\n                        instructionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                return {\n                    code: Number(rpcErrorContext),\n                    index: numberIndex\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                return {\n                    encodedData: rpcErrorContext,\n                    index: numberIndex\n                };\n            }\n            return {\n                index: numberIndex\n            };\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES,\n        rpcEnumError: instructionError\n    }, getSolanaErrorFromInstructionError);\n}\n// src/transaction-error.ts\nvar ORDERED_ERROR_NAMES2 = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"AccountInUse\",\n    \"AccountLoadedTwice\",\n    \"AccountNotFound\",\n    \"ProgramAccountNotFound\",\n    \"InsufficientFundsForFee\",\n    \"InvalidAccountForFee\",\n    \"AlreadyProcessed\",\n    \"BlockhashNotFound\",\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    \"CallChainTooDeep\",\n    \"MissingSignatureForFee\",\n    \"InvalidAccountIndex\",\n    \"SignatureFailure\",\n    \"InvalidProgramForExecution\",\n    \"SanitizeFailure\",\n    \"ClusterMaintenance\",\n    \"AccountBorrowOutstanding\",\n    \"WouldExceedMaxBlockCostLimit\",\n    \"UnsupportedVersion\",\n    \"InvalidWritableAccount\",\n    \"WouldExceedMaxAccountCostLimit\",\n    \"WouldExceedAccountDataBlockLimit\",\n    \"TooManyAccountLocks\",\n    \"AddressLookupTableNotFound\",\n    \"InvalidAddressLookupTableOwner\",\n    \"InvalidAddressLookupTableData\",\n    \"InvalidAddressLookupTableIndex\",\n    \"InvalidRentPayingAccount\",\n    \"WouldExceedMaxVoteCostLimit\",\n    \"WouldExceedAccountDataTotalLimit\",\n    \"DuplicateInstruction\",\n    \"InsufficientFundsForRent\",\n    \"MaxLoadedAccountsDataSizeExceeded\",\n    \"InvalidLoadedAccountsDataSizeLimit\",\n    \"ResanitizationNeeded\",\n    \"ProgramExecutionTemporarilyRestricted\",\n    \"UnbalancedTransaction\"\n];\nfunction getSolanaErrorFromTransactionError(transactionError) {\n    if (typeof transactionError === \"object\" && \"InstructionError\" in transactionError) {\n        return getSolanaErrorFromInstructionError(...transactionError.InstructionError);\n    }\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 7050001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    ...rpcErrorContext !== void 0 ? {\n                        transactionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                return {\n                    index: Number(rpcErrorContext)\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {\n                return {\n                    accountIndex: Number(rpcErrorContext.account_index)\n                };\n            }\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES2,\n        rpcEnumError: transactionError\n    }, getSolanaErrorFromTransactionError);\n}\n// src/json-rpc-error.ts\nfunction getSolanaErrorFromJsonRpcError(putativeErrorResponse) {\n    let out;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data;\n            const causeObject = err ? {\n                cause: getSolanaErrorFromTransactionError(err)\n            } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject\n            });\n        } else {\n            let errorContext;\n            switch(code){\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    errorContext = {\n                        __serverMessage: message\n                    };\n                    break;\n                default:\n                    if (typeof data === \"object\" && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code, errorContext);\n        }\n    } else {\n        const message = typeof putativeErrorResponse === \"object\" && putativeErrorResponse !== null && \"message\" in putativeErrorResponse && typeof putativeErrorResponse.message === \"string\" ? putativeErrorResponse.message : \"Malformed JSON-RPC error with no message attribute\";\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, {\n            error: putativeErrorResponse,\n            message\n        });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\nfunction isRpcErrorResponse(value) {\n    return typeof value === \"object\" && value !== null && \"code\" in value && \"message\" in value && (typeof value.code === \"number\" || typeof value.code === \"bigint\") && typeof value.message === \"string\";\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2Vycm9ycy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZUFBZTtBQUNmLElBQUlBLHNDQUFzQztBQUMxQyxJQUFJQyw4QkFBOEI7QUFDbEMsSUFBSUMsd0NBQXdDO0FBQzVDLElBQUlDLHFEQUFxRDtBQUN6RCxJQUFJQyw4Q0FBOEM7QUFDbEQsSUFBSUMsc0NBQXNDO0FBQzFDLElBQUlDLHdDQUF3QztBQUM1QyxJQUFJQyx3Q0FBd0M7QUFDNUMsSUFBSUMsdUNBQXVDO0FBQzNDLElBQUlDLHlDQUF5QztBQUM3QyxJQUFJQyxzQ0FBc0MsQ0FBQztBQUMzQyxJQUFJQyx5Q0FBeUMsQ0FBQztBQUM5QyxJQUFJQyx5Q0FBeUMsQ0FBQztBQUM5QyxJQUFJQywyQ0FBMkMsQ0FBQztBQUNoRCxJQUFJQywwQ0FBMEMsQ0FBQztBQUMvQyxJQUFJQyxvRUFBb0UsQ0FBQztBQUN6RSxJQUFJQyx1RUFBdUUsQ0FBQztBQUM1RSxJQUFJQyxzRUFBc0UsQ0FBQztBQUMzRSxJQUFJQywwRUFBMEUsQ0FBQztBQUMvRSxJQUFJQyxxQ0FBcUMsQ0FBQztBQUMxQyxJQUFJQyx5RUFBeUUsQ0FBQztBQUM5RSxJQUFJQyx5RUFBeUUsQ0FBQztBQUM5RSxJQUFJQyxzRUFBc0UsQ0FBQztBQUMzRSxJQUFJQyxtREFBbUQsQ0FBQztBQUN4RCxJQUFJ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Q0wsS0FBS0k7Z0JBQ0wsS0FBS0M7Z0JBQ0wsS0FBS0U7Z0JBQ0wsS0FBS0M7Z0JBQ0wsS0FBS1Q7b0JBQ0gwUixlQUFlO3dCQUFFMEIsaUJBQWlCekM7b0JBQVE7b0JBQzFDO2dCQUNGO29CQUNFLElBQUksT0FBT3NDLFNBQVMsWUFBWSxDQUFDNUYsTUFBTUMsT0FBTyxDQUFDMkYsT0FBTzt3QkFDcER2QixlQUFldUI7b0JBQ2pCO1lBQ0o7WUFDQUgsTUFBTSxJQUFJekMsWUFBWTFCLE1BQU0rQztRQUM5QjtJQUNGLE9BQU87UUFDTCxNQUFNZixVQUFVLE9BQU9rQywwQkFBMEIsWUFBWUEsMEJBQTBCLFFBQVEsYUFBYUEseUJBQXlCLE9BQU9BLHNCQUFzQmxDLE9BQU8sS0FBSyxXQUFXa0Msc0JBQXNCbEMsT0FBTyxHQUFHO1FBQ3pObUMsTUFBTSxJQUFJekMsWUFBWTVRLHdDQUF3QztZQUFFNFQsT0FBT1I7WUFBdUJsQztRQUFRO0lBQ3hHO0lBQ0FDLHNCQUFzQmtDLEtBQUtGO0lBQzNCLE9BQU9FO0FBQ1Q7QUFDQSxTQUFTQyxtQkFBbUIzRixLQUFLO0lBQy9CLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsVUFBVUEsU0FBUyxhQUFhQSxTQUFVLFFBQU9BLE1BQU11QixJQUFJLEtBQUssWUFBWSxPQUFPdkIsTUFBTXVCLElBQUksS0FBSyxRQUFPLEtBQU0sT0FBT3ZCLE1BQU11RCxPQUFPLEtBQUs7QUFDaE07QUFFdTNaLENBQ3YzWix1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9lcnJvcnMvZGlzdC9pbmRleC5ub2RlLm1qcz8yZWU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb2Rlcy50c1xudmFyIFNPTEFOQV9FUlJPUl9fQkxPQ0tfSEVJR0hUX0VYQ0VFREVEID0gMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0UgPSAyO1xudmFyIFNPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkQgPSAzO1xudmFyIFNPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RIID0gNTtcbnZhciBTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRSA9IDY7XG52YXIgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklORyA9IDc7XG52YXIgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfTlVNQkVSX1NUUklORyA9IDg7XG52YXIgU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFID0gOTtcbnZhciBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUiA9IDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SID0gLTMyNzAwO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SID0gLTMyNjAzO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TID0gLTMyNjAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX01FVEhPRF9OT1RfRk9VTkQgPSAtMzI2MDE7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9SRVFVRVNUID0gLTMyNjAwO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEID0gLTMyMDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OID0gLTMyMDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQgPSAtMzIwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0ggPSAtMzIwMTM7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUiA9IC0zMjAxMjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFID0gLTMyMDExO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVggPSAtMzIwMTA7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCA9IC0zMjAwOTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QgPSAtMzIwMDg7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRCA9IC0zMjAwNztcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSA9IC0zMjAwNjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFkgPSAtMzIwMDU7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUgPSAtMzIwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSA9IC0zMjAwMztcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSA9IC0zMjAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUCA9IC0zMjAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCA9IDI4ZTU7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gMjgwMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTID0gMjgwMDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVkgPSAyODAwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBID0gMjgwMDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UgPSAyODAwMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCA9IDI4MDAwMDY7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQgPSAyODAwMDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFID0gMjgwMDAwODtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQgPSAyODAwMDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVIgPSAyODAwMDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTID0gMjgwMDAxMTtcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORCA9IDMyM2U0O1xudmFyIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX09ORV9PUl9NT1JFX0FDQ09VTlRTX05PVF9GT1VORCA9IDMyMzAwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVCA9IDMyMzAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfREVDT0RFRF9BQ0NPVU5UID0gMzIzMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9BTExfQUNDT1VOVFNfVE9fQkVfREVDT0RFRCA9IDMyMzAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFQgPSAzNjFlNDtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVEID0gMzYxMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URUQgPSAzNjEwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRVhQT1JUX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjEwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fR0VORVJBVEVfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjEwMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fVkVSSUZZX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjEwMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZID0gMzYxMDAwNztcbnZhciBTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMWUzO1xudmFyIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSCA9IDM3MDRlMztcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfUFJJVkFURV9LRVlfQllURV9MRU5HVEggPSAzNzA0MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEggPSAzNzA0MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gMzcwNDAwMztcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWSA9IDM3MDQwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUyA9IDQxMjhlMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEEgPSA0MTI4MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0ggPSA0MTI4MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04gPSA0NjE1ZTM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUiA9IDQ2MTUwMDE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BUkdVTUVOVCA9IDQ2MTUwMDI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9JTlNUUlVDVElPTl9EQVRBID0gNDYxNTAwMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQSA9IDQ2MTUwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1RPT19TTUFMTCA9IDQ2MTUwMDU7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTID0gNDYxNTAwNjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfUFJPR1JBTV9JRCA9IDQ2MTUwMDc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkUgPSA0NjE1MDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQUxSRUFEWV9JTklUSUFMSVpFRCA9IDQ2MTUwMDk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5UID0gNDYxNTAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX0lOU1RSVUNUSU9OID0gNDYxNTAxMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NT0RJRklFRF9QUk9HUkFNX0lEID0gNDYxNTAxMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkQgPSA0NjE1MDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRCA9IDQ2MTUwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0UgPSA0NjE1MDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0RBVEFfTU9ESUZJRUQgPSA0NjE1MDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYID0gNDYxNTAxNztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX01PRElGSUVEID0gNDYxNTAxODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRU5UX0VQT0NIX01PRElGSUVEID0gNDYxNTAxOTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19OT1RfRU5PVUdIX0FDQ09VTlRfS0VZUyA9IDQ2MTUwMjA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1NJWkVfQ0hBTkdFRCA9IDQ2MTUwMjE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRSA9IDQ2MTUwMjI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVEID0gNDYxNTAyMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORyA9IDQ2MTUwMjQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfT1VUX09GX1NZTkMgPSA0NjE1MDI1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSA9IDQ2MTUwMjY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9FUlJPUiA9IDQ2MTUwMjc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9EQVRBX01PRElGSUVEID0gNDYxNTAyODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0xBTVBPUlRfQ0hBTkdFID0gNDYxNTAyOTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUID0gNDYxNTAzMDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lEID0gNDYxNTAzMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRIID0gNDYxNTAzMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX0FDQ09VTlQgPSA0NjE1MDMzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFRU5UUkFOQ1lfTk9UX0FMTE9XRUQgPSA0NjE1MDM0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9TRUVEX0xFTkdUSF9FWENFRURFRCA9IDQ2MTUwMzU7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEUyA9IDQ2MTUwMzY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DID0gNDYxNTAzNztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DT01QVVRBVElPTkFMX0JVREdFVF9FWENFRURFRCA9IDQ2MTUwMzg7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT04gPSA0NjE1MDM5O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRU5WSVJPTk1FTlRfU0VUVVBfRkFJTFVSRSA9IDQ2MTUwNDA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEUgPSA0NjE1MDQxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEUgPSA0NjE1MDQyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRSA9IDQ2MTUwNDM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX0FVVEhPUklUWSA9IDQ2MTUwNDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQk9SU0hfSU9fRVJST1IgPSA0NjE1MDQ1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUID0gNDYxNTA0NjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVIgPSA0NjE1MDQ3O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FSSVRITUVUSUNfT1ZFUkZMT1cgPSA0NjE1MDQ4O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUiA9IDQ2MTUwNDk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUiA9IDQ2MTUwNTA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0RBVEFfQUxMT0NBVElPTlNfRVhDRUVERUQgPSA0NjE1MDUxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19FWENFRURFRCA9IDQ2MTUwNTI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRCA9IDQ2MTUwNTM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQlVJTFRJTl9QUk9HUkFNU19NVVNUX0NPTlNVTUVfQ09NUFVURV9VTklUUyA9IDQ2MTUwNTQ7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUyA9IDU1MDhlMztcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSID0gNTUwODAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVIgPSA1NTA4MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIgPSA1NTA4MDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSID0gNTUwODAwNDtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0lHTkVSID0gNTUwODAwNTtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUiA9IDU1MDgwMDY7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1BBUlRJQUxfU0lHTkVSID0gNTUwODAwNztcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVIgPSA1NTA4MDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9DQU5OT1RfSEFWRV9NVUxUSVBMRV9TRU5ESU5HX1NJR05FUlMgPSA1NTA4MDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HID0gNTUwODAxMDtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVEID0gNTUwODAxMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX0NBTk5PVF9QQVlfRkVFUyA9IDU2NjNlMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFID0gNTY2MzAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUUgPSA1NjYzMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FID0gNTY2MzAwMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0UgPSA1NjYzMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORyA9IDU2NjMwMDU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF9PVVRfT0ZfUkFOR0UgPSA1NjYzMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCA9IDU2NjMwMDc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lORyA9IDU2NjMwMDg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HID0gNTY2MzAwOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkcgPSA1NjYzMDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9NSVNTSU5HID0gNTY2MzAxMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfU0lHTkFUVVJFX01JU1NJTkcgPSA1NjYzMDEyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkcgPSA1NjYzMDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fRklSU1RfSU5TVFJVQ1RJT05fTVVTVF9CRV9BRFZBTkNFX05PTkNFID0gNTY2MzAxNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fVFJBTlNBQ1RJT04gPSA1NjYzMDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTID0gNTY2MzAxNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0ggPSA1NjYzMDE3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUID0gNTY2MzAxODtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQgPSA1NjYzMDE5O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYQ0VFRFNfU0laRV9MSU1JVCA9IDU2NjMwMjA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTiA9IDcwNWU0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfSU5fVVNFID0gNzA1MDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0xPQURFRF9UV0lDRSA9IDcwNTAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRk9VTkQgPSA3MDUwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fQUNDT1VOVF9OT1RfRk9VTkQgPSA3MDUwMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFID0gNzA1MDAwNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfRk9SX0ZFRSA9IDcwNTAwMDY7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUxSRUFEWV9QUk9DRVNTRUQgPSA3MDUwMDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0JMT0NLSEFTSF9OT1RfRk9VTkQgPSA3MDUwMDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NBTExfQ0hBSU5fVE9PX0RFRVAgPSA3MDUwMDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01JU1NJTkdfU0lHTkFUVVJFX0ZPUl9GRUUgPSA3MDUwMDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9JTkRFWCA9IDcwNTAwMTE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0lHTkFUVVJFX0ZBSUxVUkUgPSA3MDUwMDEyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUFJPR1JBTV9GT1JfRVhFQ1VUSU9OID0gNzA1MDAxMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TQU5JVElaRV9GQUlMVVJFID0gNzA1MDAxNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DTFVTVEVSX01BSU5URU5BTkNFID0gNzA1MDAxNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORyA9IDcwNTAwMTY7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlUID0gNzA1MDAxNztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9WRVJTSU9OID0gNzA1MDAxODtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlQgPSA3MDUwMDE5O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQUNDT1VOVF9DT1NUX0xJTUlUID0gNzA1MDAyMDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX0JMT0NLX0xJTUlUID0gNzA1MDAyMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19UT09fTUFOWV9BQ0NPVU5UX0xPQ0tTID0gNzA1MDAyMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkQgPSA3MDUwMDIzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfT1dORVIgPSA3MDUwMDI0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfREFUQSA9IDcwNTAwMjU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWCA9IDcwNTAwMjY7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5UID0gNzA1MDAyNztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX1ZPVEVfQ09TVF9MSU1JVCA9IDcwNTAwMjg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVCA9IDcwNTAwMjk7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OID0gNzA1MDAzMDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlQgPSA3MDUwMDMxO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVEID0gNzA1MDAzMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfTElNSVQgPSA3MDUwMDMzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1JFU0FOSVRJWkFUSU9OX05FRURFRCA9IDcwNTAwMzQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRCA9IDcwNTAwMzU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9UUkFOU0FDVElPTiA9IDcwNTAwMzY7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSA9IDgwNzhlMztcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCA9IDgwNzgwMDE7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCA9IDgwNzgwMDI7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCA9IDgwNzgwMDM7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0ggPSA4MDc4MDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCA9IDgwNzgwMDU7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCA9IDgwNzgwMDY7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TID0gODA3ODAwNztcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5VTV9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSA9IDgwNzgwMDg7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5UID0gODA3ODAwOTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9FTlVNX1ZBUklBTlQgPSA4MDc4MDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFID0gODA3ODAxMTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UgPSA4MDc4MDEyO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCA9IDgwNzgwMTM7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UgPSA4MDc4MDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVCA9IDgwNzgwMTU7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UgPSA4MDc4MDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRSA9IDgwNzgwMTc7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQgPSA4MDc4MDE4O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRSA9IDgwNzgwMTk7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCA9IDgwNzgwMjA7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyA9IDgwNzgwMjE7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SUyA9IDgwNzgwMjI7XG52YXIgU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1cgPSA4MWU1O1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOID0gODEwMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfRVJST1IgPSA4MTAwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EID0gODEwMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DQU5OT1RfQ1JFQVRFX1NVQlNDUklQVElPTl9QTEFOID0gODE5ZTQ7XG52YXIgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRCA9IDgxOTAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DTE9TRURfQkVGT1JFX01FU1NBR0VfQlVGRkVSRUQgPSA4MTkwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ09OTkVDVElPTl9DTE9TRUQgPSA4MTkwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1QgPSA4MTkwMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX1NUQVRFX01JU1NJTkcgPSA5OWU1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX01VU1RfTk9UX1BPTExfQkVGT1JFX1JFU09MVklOR19FWElTVElOR19NRVNTQUdFX1BST01JU0UgPSA5OTAwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fQ0FDSEVEX0FCT1JUQUJMRV9JVEVSQUJMRV9DQUNIRV9FTlRSWV9NSVNTSU5HID0gOTkwMDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUgPSA5OTAwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fREFUQV9QVUJMSVNIRVJfQ0hBTk5FTF9VTklNUExFTUVOVEVEID0gOTkwMDAwNDtcblxuLy8gc3JjL2NvbnRleHQudHNcbmZ1bmN0aW9uIGVuY29kZVZhbHVlKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGNvbW1hU2VwYXJhdGVkVmFsdWVzID0gdmFsdWUubWFwKGVuY29kZVZhbHVlKS5qb2luKFxuICAgICAgXCIlMkMlMjBcIlxuICAgICAgLyogXCIsIFwiICovXG4gICAgKTtcbiAgICByZXR1cm4gXCIlNUJcIiArIGNvbW1hU2VwYXJhdGVkVmFsdWVzICsgLyogXCJdXCIgKi9cbiAgICBcIiU1RFwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgIHJldHVybiBgJHt2YWx1ZX1uYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgU3RyaW5nKFxuICAgICAgICB2YWx1ZSAhPSBudWxsICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgPyAoXG4gICAgICAgICAgLy8gUGxhaW4gb2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSBkb24ndCBoYXZlIGEgYHRvU3RyaW5nYCBtZXRob2QuXG4gICAgICAgICAgLy8gQ29udmVydCB0aGVtIGJlZm9yZSBzdHJpbmdpZnlpbmcgdGhlbS5cbiAgICAgICAgICB7IC4uLnZhbHVlIH1cbiAgICAgICAgKSA6IHZhbHVlXG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlT2JqZWN0Q29udGV4dEVudHJ5KFtrZXksIHZhbHVlXSkge1xuICByZXR1cm4gYCR7a2V5fT0ke2VuY29kZVZhbHVlKHZhbHVlKX1gO1xufVxuZnVuY3Rpb24gZW5jb2RlQ29udGV4dE9iamVjdChjb250ZXh0KSB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtc1N0cmluZyA9IE9iamVjdC5lbnRyaWVzKGNvbnRleHQpLm1hcChlbmNvZGVPYmplY3RDb250ZXh0RW50cnkpLmpvaW4oXCImXCIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VhcmNoUGFyYW1zU3RyaW5nLCBcInV0ZjhcIikudG9TdHJpbmcoXCJiYXNlNjRcIikgO1xufVxuXG4vLyBzcmMvbWVzc2FnZXMudHNcbnZhciBTb2xhbmFFcnJvck1lc3NhZ2VzID0ge1xuICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fQUNDT1VOVF9OT1RfRk9VTkRdOiBcIkFjY291bnQgbm90IGZvdW5kIGF0IGFkZHJlc3M6ICRhZGRyZXNzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9BTExfQUNDT1VOVFNfVE9fQkVfREVDT0RFRF06IFwiTm90IGFsbCBhY2NvdW50cyB3ZXJlIGRlY29kZWQuIEVuY29kZWQgYWNjb3VudHMgZm91bmQgYXQgYWRkcmVzc2VzOiAkYWRkcmVzc2VzLlwiLFxuICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfREVDT0RFRF9BQ0NPVU5UXTogXCJFeHBlY3RlZCBkZWNvZGVkIGFjY291bnQgYXQgYWRkcmVzczogJGFkZHJlc3NcIixcbiAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVF06IFwiRmFpbGVkIHRvIGRlY29kZSBhY2NvdW50IGRhdGEgYXQgYWRkcmVzczogJGFkZHJlc3NcIixcbiAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX09ORV9PUl9NT1JFX0FDQ09VTlRTX05PVF9GT1VORF06IFwiQWNjb3VudHMgbm90IGZvdW5kIGF0IGFkZHJlc3NlczogJGFkZHJlc3Nlc1wiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0ZBSUxFRF9UT19GSU5EX1ZJQUJMRV9QREFfQlVNUF9TRUVEXTogXCJVbmFibGUgdG8gZmluZCBhIHZpYWJsZSBwcm9ncmFtIGFkZHJlc3MgYnVtcCBzZWVkLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQkFTRTU4X0VOQ09ERURfQUREUkVTU106IFwiJHB1dGF0aXZlQWRkcmVzcyBpcyBub3QgYSBiYXNlNTgtZW5jb2RlZCBhZGRyZXNzLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEhdOiBcIkV4cGVjdGVkIGJhc2U1OCBlbmNvZGVkIGFkZHJlc3MgdG8gZGVjb2RlIHRvIGEgYnl0ZSBhcnJheSBvZiBsZW5ndGggMzIuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVldOiBcIlRoZSBgQ3J5cHRvS2V5YCBtdXN0IGJlIGFuIGBFZDI1NTE5YCBwdWJsaWMga2V5LlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfT0ZGX0NVUlZFX0FERFJFU1NdOiBcIiRwdXRhdGl2ZU9mZkN1cnZlQWRkcmVzcyBpcyBub3QgYSBiYXNlNTgtZW5jb2RlZCBvZmYtY3VydmUgYWRkcmVzcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFXTogXCJJbnZhbGlkIHNlZWRzOyBwb2ludCBtdXN0IGZhbGwgb2ZmIHRoZSBFZDI1NTE5IGN1cnZlLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BTEZPUk1FRF9QREFdOiBcIkV4cGVjdGVkIGdpdmVuIHByb2dyYW0gZGVyaXZlZCBhZGRyZXNzIHRvIGhhdmUgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IFtBZGRyZXNzLCBQcm9ncmFtRGVyaXZlZEFkZHJlc3NCdW1wXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRF06IFwiQSBtYXhpbXVtIG9mICRtYXhTZWVkcyBzZWVkcywgaW5jbHVkaW5nIHRoZSBidW1wIHNlZWQsIG1heSBiZSBzdXBwbGllZCB3aGVuIGNyZWF0aW5nIGFuIGFkZHJlc3MuIFJlY2VpdmVkOiAkYWN0dWFsLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERURdOiBcIlRoZSBzZWVkIGF0IGluZGV4ICRpbmRleCB3aXRoIGxlbmd0aCAkYWN0dWFsIGV4Y2VlZHMgdGhlIG1heGltdW0gbGVuZ3RoIG9mICRtYXhTZWVkTGVuZ3RoIGJ5dGVzLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9CVU1QX1NFRURfT1VUX09GX1JBTkdFXTogXCJFeHBlY3RlZCBwcm9ncmFtIGRlcml2ZWQgYWRkcmVzcyBidW1wIHRvIGJlIGluIHRoZSByYW5nZSBbMCwgMjU1XSwgZ290OiAkYnVtcC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVJdOiBcIlByb2dyYW0gYWRkcmVzcyBjYW5ub3QgZW5kIHdpdGggUERBIG1hcmtlci5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRV06IFwiRXhwZWN0ZWQgYmFzZTU4LWVuY29kZWQgYWRkcmVzcyBzdHJpbmcgb2YgbGVuZ3RoIGluIHRoZSByYW5nZSBbMzIsIDQ0XS4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFXTogXCJFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBibG9ja2FzaCBzdHJpbmcgb2YgbGVuZ3RoIGluIHRoZSByYW5nZSBbMzIsIDQ0XS4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQkxPQ0tfSEVJR0hUX0VYQ0VFREVEXTogXCJUaGUgbmV0d29yayBoYXMgcHJvZ3Jlc3NlZCBwYXN0IHRoZSBsYXN0IGJsb2NrIGZvciB3aGljaCB0aGlzIHRyYW5zYWN0aW9uIGNvdWxkIGhhdmUgYmVlbiBjb21taXR0ZWQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGNhbm5vdCBkZWNvZGUgZW1wdHkgYnl0ZSBhcnJheXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTXTogXCJFbnVtIGNvZGVjIGNhbm5vdCB1c2UgbGV4aWNhbCB2YWx1ZXMgWyRzdHJpbmdWYWx1ZXNdIGFzIGRpc2NyaW1pbmF0b3JzLiBFaXRoZXIgcmVtb3ZlIGFsbCBsZXhpY2FsIHZhbHVlcyBvciBzZXQgYHVzZVZhbHVlc0FzRGlzY3JpbWluYXRvcnNgIHRvIGBmYWxzZWAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMXTogXCJTZW50aW5lbCBbJGhleFNlbnRpbmVsXSBtdXN0IG5vdCBiZSBwcmVzZW50IGluIGVuY29kZWQgYnl0ZXMgWyRoZXhFbmNvZGVkQnl0ZXNdLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIXTogXCJFbmNvZGVyIGFuZCBkZWNvZGVyIG11c3QgaGF2ZSB0aGUgc2FtZSBmaXhlZCBzaXplLCBnb3QgWyRlbmNvZGVyRml4ZWRTaXplXSBhbmQgWyRkZWNvZGVyRml4ZWRTaXplXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0hdOiBcIkVuY29kZXIgYW5kIGRlY29kZXIgbXVzdCBoYXZlIHRoZSBzYW1lIG1heCBzaXplLCBnb3QgWyRlbmNvZGVyTWF4U2l6ZV0gYW5kIFskZGVjb2Rlck1heFNpemVdLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0hdOiBcIkVuY29kZXIgYW5kIGRlY29kZXIgbXVzdCBlaXRoZXIgYm90aCBiZSBmaXhlZC1zaXplIG9yIHZhcmlhYmxlLXNpemUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5VTV9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRV06IFwiRW51bSBkaXNjcmltaW5hdG9yIG91dCBvZiByYW5nZS4gRXhwZWN0ZWQgYSBudW1iZXIgaW4gWyRmb3JtYXR0ZWRWYWxpZERpc2NyaW1pbmF0b3JzXSwgZ290ICRkaXNjcmltaW5hdG9yLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSF06IFwiRXhwZWN0ZWQgYSBmaXhlZC1zaXplIGNvZGVjLCBnb3QgYSB2YXJpYWJsZS1zaXplIG9uZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSF06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCBhIHBvc2l0aXZlIGJ5dGUgbGVuZ3RoLCBnb3QgJGJ5dGVzTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSF06IFwiRXhwZWN0ZWQgYSB2YXJpYWJsZS1zaXplIGNvZGVjLCBnb3QgYSBmaXhlZC1zaXplIG9uZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRV06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCB6ZXJvLXZhbHVlIFskaGV4WmVyb1ZhbHVlXSB0byBoYXZlIHRoZSBzYW1lIHNpemUgYXMgdGhlIHByb3ZpZGVkIGZpeGVkLXNpemUgaXRlbSBbJGV4cGVjdGVkU2l6ZSBieXRlc10uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSF06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCAkZXhwZWN0ZWQgYnl0ZXMsIGdvdCAkYnl0ZXNMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9DT05TVEFOVF06IFwiRXhwZWN0ZWQgYnl0ZSBhcnJheSBjb25zdGFudCBbJGhleENvbnN0YW50XSB0byBiZSBwcmVzZW50IGluIGRhdGEgWyRoZXhEYXRhXSBhdCBvZmZzZXQgWyRvZmZzZXRdLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5UXTogXCJJbnZhbGlkIGRpc2NyaW1pbmF0ZWQgdW5pb24gdmFyaWFudC4gRXhwZWN0ZWQgb25lIG9mIFskdmFyaWFudHNdLCBnb3QgJHZhbHVlLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5UXTogXCJJbnZhbGlkIGVudW0gdmFyaWFudC4gRXhwZWN0ZWQgb25lIG9mIFskc3RyaW5nVmFsdWVzXSBvciBhIG51bWJlciBpbiBbJGZvcm1hdHRlZE51bWVyaWNhbFZhbHVlc10sIGdvdCAkdmFyaWFudC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVF06IFwiSW52YWxpZCBsaXRlcmFsIHVuaW9uIHZhcmlhbnQuIEV4cGVjdGVkIG9uZSBvZiBbJHZhcmlhbnRzXSwgZ290ICR2YWx1ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNU106IFwiRXhwZWN0ZWQgWyRjb2RlY0Rlc2NyaXB0aW9uXSB0byBoYXZlICRleHBlY3RlZCBpdGVtcywgZ290ICRhY3R1YWwuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0VdOiBcIkludmFsaWQgdmFsdWUgJHZhbHVlIGZvciBiYXNlICRiYXNlIHdpdGggYWxwaGFiZXQgJGFscGhhYmV0LlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0VdOiBcIkxpdGVyYWwgdW5pb24gZGlzY3JpbWluYXRvciBvdXQgb2YgcmFuZ2UuIEV4cGVjdGVkIGEgbnVtYmVyIGJldHdlZW4gJG1pblJhbmdlIGFuZCAkbWF4UmFuZ2UsIGdvdCAkZGlzY3JpbWluYXRvci5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkIG51bWJlciB0byBiZSBpbiB0aGUgcmFuZ2UgWyRtaW4sICRtYXhdLCBnb3QgJHZhbHVlLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0VdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgb2Zmc2V0IHRvIGJlIGluIHRoZSByYW5nZSBbMCwgJGJ5dGVzTGVuZ3RoXSwgZ290ICRvZmZzZXQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTXTogXCJFeHBlY3RlZCBzZW50aW5lbCBbJGhleFNlbnRpbmVsXSB0byBiZSBwcmVzZW50IGluIGRlY29kZWQgYnl0ZXMgWyRoZXhEZWNvZGVkQnl0ZXNdLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFXTogXCJVbmlvbiB2YXJpYW50IG91dCBvZiByYW5nZS4gRXhwZWN0ZWQgYW4gaW5kZXggYmV0d2VlbiAkbWluUmFuZ2UgYW5kICRtYXhSYW5nZSwgZ290ICR2YXJpYW50LlwiLFxuICBbU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8gcmFuZG9tIHZhbHVlcyBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQUxSRUFEWV9JTklUSUFMSVpFRF06IFwiaW5zdHJ1Y3Rpb24gcmVxdWlyZXMgYW4gdW5pbml0aWFsaXplZCBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19GQUlMRURdOiBcImluc3RydWN0aW9uIHRyaWVzIHRvIGJvcnJvdyByZWZlcmVuY2UgZm9yIGFuIGFjY291bnQgd2hpY2ggaXMgYWxyZWFkeSBib3Jyb3dlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkddOiBcImluc3RydWN0aW9uIGxlZnQgYWNjb3VudCB3aXRoIGFuIG91dHN0YW5kaW5nIGJvcnJvd2VkIHJlZmVyZW5jZVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1NJWkVfQ0hBTkdFRF06IFwicHJvZ3JhbSBvdGhlciB0aGFuIHRoZSBhY2NvdW50J3Mgb3duZXIgY2hhbmdlZCB0aGUgc2l6ZSBvZiB0aGUgYWNjb3VudCBkYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfVE9PX1NNQUxMXTogXCJhY2NvdW50IGRhdGEgdG9vIHNtYWxsIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRV06IFwiaW5zdHJ1Y3Rpb24gZXhwZWN0ZWQgYW4gZXhlY3V0YWJsZSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVF06IFwiQW4gYWNjb3VudCBkb2VzIG5vdCBoYXZlIGVub3VnaCBsYW1wb3J0cyB0byBiZSByZW50LWV4ZW1wdFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPV106IFwiUHJvZ3JhbSBhcml0aG1ldGljIG92ZXJmbG93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SXTogXCJGYWlsZWQgdG8gc2VyaWFsaXplIG9yIGRlc2VyaWFsaXplIGFjY291bnQgZGF0YTogJGVuY29kZWREYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTXTogXCJCdWlsdGluIHByb2dyYW1zIG11c3QgY29uc3VtZSBjb21wdXRlIHVuaXRzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRIXTogXCJDcm9zcy1wcm9ncmFtIGludm9jYXRpb24gY2FsbCBkZXB0aCB0b28gZGVlcFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERURdOiBcIkNvbXB1dGF0aW9uYWwgYnVkZ2V0IGV4Y2VlZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT01dOiBcImN1c3RvbSBwcm9ncmFtIGVycm9yOiAjJGNvZGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYXTogXCJpbnN0cnVjdGlvbiBjb250YWlucyBkdXBsaWNhdGUgYWNjb3VudHNcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DXTogXCJpbnN0cnVjdGlvbiBtb2RpZmljYXRpb25zIG9mIG11bHRpcGx5LXBhc3NlZCBhY2NvdW50IGRpZmZlclwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVF06IFwiZXhlY3V0YWJsZSBhY2NvdW50cyBtdXN0IGJlIHJlbnQgZXhlbXB0XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIGNoYW5nZWQgZXhlY3V0YWJsZSBhY2NvdW50cyBkYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0xBTVBPUlRfQ0hBTkdFXTogXCJpbnN0cnVjdGlvbiBjaGFuZ2VkIHRoZSBiYWxhbmNlIG9mIGFuIGV4ZWN1dGFibGUgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRF06IFwiaW5zdHJ1Y3Rpb24gY2hhbmdlZCBleGVjdXRhYmxlIGJpdCBvZiBhbiBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIG1vZGlmaWVkIGRhdGEgb2YgYW4gYWNjb3VudCBpdCBkb2VzIG5vdCBvd25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfTEFNUE9SVF9TUEVORF06IFwiaW5zdHJ1Y3Rpb24gc3BlbnQgZnJvbSB0aGUgYmFsYW5jZSBvZiBhbiBhY2NvdW50IGl0IGRvZXMgbm90IG93blwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUl06IFwiZ2VuZXJpYyBpbnN0cnVjdGlvbiBlcnJvclwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUl06IFwiUHJvdmlkZWQgb3duZXIgaXMgbm90IGFsbG93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRV06IFwiQWNjb3VudCBpcyBpbW11dGFibGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFldOiBcIkluY29ycmVjdCBhdXRob3JpdHkgcHJvdmlkZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lEXTogXCJpbmNvcnJlY3QgcHJvZ3JhbSBpZCBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU106IFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0RBVEFdOiBcImludmFsaWQgYWNjb3VudCBkYXRhIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSXTogXCJJbnZhbGlkIGFjY291bnQgb3duZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlRdOiBcImludmFsaWQgcHJvZ3JhbSBhcmd1bWVudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9FUlJPUl06IFwicHJvZ3JhbSByZXR1cm5lZCBpbnZhbGlkIGVycm9yIGNvZGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQV06IFwiaW52YWxpZCBpbnN0cnVjdGlvbiBkYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0NdOiBcIkZhaWxlZCB0byByZWFsbG9jYXRlIGFjY291bnQgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEU106IFwiUHJvdmlkZWQgc2VlZHMgZG8gbm90IHJlc3VsdCBpbiBhIHZhbGlkIGFkZHJlc3NcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVEXTogXCJBY2NvdW50cyBkYXRhIGFsbG9jYXRpb25zIGV4Y2VlZGVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGVyIHRyYW5zYWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERURdOiBcIk1heCBhY2NvdW50cyBleGNlZWRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRF06IFwiTWF4IGluc3RydWN0aW9uIHRyYWNlIGxlbmd0aCBleGNlZWRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX1NFRURfTEVOR1RIX0VYQ0VFREVEXTogXCJMZW5ndGggb2YgdGhlIHNlZWQgaXMgdG9vIGxvbmcgZm9yIGFkZHJlc3MgZ2VuZXJhdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5UXTogXCJBbiBhY2NvdW50IHJlcXVpcmVkIGJ5IHRoZSBpbnN0cnVjdGlvbiBpcyBtaXNzaW5nXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX1JFUVVJUkVEX1NJR05BVFVSRV06IFwibWlzc2luZyByZXF1aXJlZCBzaWduYXR1cmUgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NT0RJRklFRF9QUk9HUkFNX0lEXTogXCJpbnN0cnVjdGlvbiBpbGxlZ2FsbHkgbW9kaWZpZWQgdGhlIHByb2dyYW0gaWQgb2YgYW4gYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVNdOiBcImluc3VmZmljaWVudCBhY2NvdW50IGtleXMgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTl06IFwiQ3Jvc3MtcHJvZ3JhbSBpbnZvY2F0aW9uIHdpdGggdW5hdXRob3JpemVkIHNpZ25lciBvciB3cml0YWJsZSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0VOVklST05NRU5UX1NFVFVQX0ZBSUxVUkVdOiBcIkZhaWxlZCB0byBjcmVhdGUgcHJvZ3JhbSBleGVjdXRpb24gZW52aXJvbm1lbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEVdOiBcIlByb2dyYW0gZmFpbGVkIHRvIGNvbXBpbGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFXTogXCJQcm9ncmFtIGZhaWxlZCB0byBjb21wbGV0ZVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRF06IFwiaW5zdHJ1Y3Rpb24gbW9kaWZpZWQgZGF0YSBvZiBhIHJlYWQtb25seSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRV06IFwiaW5zdHJ1Y3Rpb24gY2hhbmdlZCB0aGUgYmFsYW5jZSBvZiBhIHJlYWQtb25seSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VEXTogXCJDcm9zcy1wcm9ncmFtIGludm9jYXRpb24gcmVlbnRyYW5jeSBub3QgYWxsb3dlZCBmb3IgdGhpcyBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVOVF9FUE9DSF9NT0RJRklFRF06IFwiaW5zdHJ1Y3Rpb24gbW9kaWZpZWQgcmVudCBlcG9jaCBvZiBhbiBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX0lOU1RSVUNUSU9OXTogXCJzdW0gb2YgYWNjb3VudCBiYWxhbmNlcyBiZWZvcmUgYW5kIGFmdGVyIGluc3RydWN0aW9uIGRvIG5vdCBtYXRjaFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5UXTogXCJpbnN0cnVjdGlvbiByZXF1aXJlcyBhbiBpbml0aWFsaXplZCBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOXTogXCJcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1BST0dSQU1fSURdOiBcIlVuc3VwcG9ydGVkIHByb2dyYW0gaWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUl06IFwiVW5zdXBwb3J0ZWQgc3lzdmFyXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTXTogXCJUaGUgaW5zdHJ1Y3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgYWNjb3VudHMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEFdOiBcIlRoZSBpbnN0cnVjdGlvbiBkb2VzIG5vdCBoYXZlIGFueSBkYXRhLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSF06IFwiRXhwZWN0ZWQgaW5zdHJ1Y3Rpb24gdG8gaGF2ZSBwcm9ncmVzcyBhZGRyZXNzICRleHBlY3RlZFByb2dyYW1BZGRyZXNzLCBnb3QgJGFjdHVhbFByb2dyYW1BZGRyZXNzLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBTElEX0JMT0NLSEFTSF9CWVRFX0xFTkdUSF06IFwiRXhwZWN0ZWQgYmFzZTU4IGVuY29kZWQgYmxvY2toYXNoIHRvIGRlY29kZSB0byBhIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoIDMyLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBTElEX05PTkNFXTogXCJUaGUgbm9uY2UgYCRleHBlY3RlZE5vbmNlVmFsdWVgIGlzIG5vIGxvbmdlciB2YWxpZC4gSXQgaGFzIGFkdmFuY2VkIHRvIGAkYWN0dWFsTm9uY2VWYWx1ZWBcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fQ0FDSEVEX0FCT1JUQUJMRV9JVEVSQUJMRV9DQUNIRV9FTlRSWV9NSVNTSU5HXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBGb3VuZCBubyBhYm9ydGFibGUgaXRlcmFibGUgY2FjaGUgZW50cnkgZm9yIGtleSBgJGNhY2hlS2V5YC4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0RBVEFfUFVCTElTSEVSX0NIQU5ORUxfVU5JTVBMRU1FTlRFRF06IFwiSW52YXJpYW50IHZpb2xhdGlvbjogVGhpcyBkYXRhIHB1Ymxpc2hlciBkb2VzIG5vdCBwdWJsaXNoIHRvIHRoZSBjaGFubmVsIG5hbWVkIGAkY2hhbm5lbE5hbWVgLiBTdXBwb3J0ZWQgY2hhbm5lbHMgaW5jbHVkZSAkc3VwcG9ydGVkQ2hhbm5lbE5hbWVzLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRV06IFwiSW52YXJpYW50IHZpb2xhdGlvbjogV2ViU29ja2V0IG1lc3NhZ2UgaXRlcmF0b3Igc3RhdGUgaXMgY29ycnVwdDsgaXRlcmF0ZWQgd2l0aG91dCBmaXJzdCByZXNvbHZpbmcgZXhpc3RpbmcgbWVzc2FnZSBwcm9taXNlLiBJdCBzaG91bGQgYmUgaW1wb3NzaWJsZSB0byBoaXQgdGhpcyBlcnJvcjsgcGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9zb2xhLm5hL3dlYjNpbnZhcmlhbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX1NUQVRFX01JU1NJTkddOiBcIkludmFyaWFudCB2aW9sYXRpb246IFdlYlNvY2tldCBtZXNzYWdlIGl0ZXJhdG9yIGlzIG1pc3Npbmcgc3RhdGUgc3RvcmFnZS4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkVdOiBcIkludmFyaWFudCB2aW9sYXRpb246IFN3aXRjaCBzdGF0ZW1lbnQgbm9uLWV4aGF1c3RpdmUuIFJlY2VpdmVkIHVuZXhwZWN0ZWQgdmFsdWUgYCR1bmV4cGVjdGVkVmFsdWVgLiBJdCBzaG91bGQgYmUgaW1wb3NzaWJsZSB0byBoaXQgdGhpcyBlcnJvcjsgcGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9zb2xhLm5hL3dlYjNpbnZhcmlhbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SXTogXCJKU09OLVJQQyBlcnJvcjogSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1BBUkFNU106IFwiSlNPTi1SUEMgZXJyb3I6IEludmFsaWQgbWV0aG9kIHBhcmFtZXRlcihzKSAoJF9fc2VydmVyTWVzc2FnZSlcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVF06IFwiSlNPTi1SUEMgZXJyb3I6IFRoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgYFJlcXVlc3RgIG9iamVjdCAoJF9fc2VydmVyTWVzc2FnZSlcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX01FVEhPRF9OT1RfRk9VTkRdOiBcIkpTT04tUlBDIGVycm9yOiBUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZSAoJF9fc2VydmVyTWVzc2FnZSlcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SXTogXCJKU09OLVJQQyBlcnJvcjogQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TQ0FOX0VSUk9SXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUF06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEVdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVRdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVhdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRURdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEXTogXCJNaW5pbXVtIGNvbnRleHQgc2xvdCBoYXMgbm90IGJlZW4gcmVhY2hlZFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZXTogXCJOb2RlIGlzIHVuaGVhbHRoeTsgYmVoaW5kIGJ5ICRudW1TbG90c0JlaGluZCBzbG90c1wiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UXTogXCJObyBzbmFwc2hvdFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkVdOiBcIlRyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFXTogXCJUcmFuc2FjdGlvbiBoaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUgZnJvbSB0aGlzIG5vZGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSF06IFwiVHJhbnNhY3Rpb24gc2lnbmF0dXJlIGxlbmd0aCBtaXNtYXRjaFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRV06IFwiVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsdXJlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTl06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RIXTogXCJLZXkgcGFpciBieXRlcyBtdXN0IGJlIG9mIGxlbmd0aCA2NCwgZ290ICRieXRlTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RIXTogXCJFeHBlY3RlZCBwcml2YXRlIGtleSBieXRlcyB3aXRoIGxlbmd0aCAzMi4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEhdOiBcIkV4cGVjdGVkIGJhc2U1OC1lbmNvZGVkIHNpZ25hdHVyZSB0byBkZWNvZGUgdG8gYSBieXRlIGFycmF5IG9mIGxlbmd0aCA2NC4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZXTogXCJUaGUgcHJvdmlkZWQgcHJpdmF0ZSBrZXkgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX1NJR05BVFVSRV9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRV06IFwiRXhwZWN0ZWQgYmFzZTU4LWVuY29kZWQgc2lnbmF0dXJlIHN0cmluZyBvZiBsZW5ndGggaW4gdGhlIHJhbmdlIFs2NCwgODhdLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19MQU1QT1JUU19PVVRfT0ZfUkFOR0VdOiBcIkxhbXBvcnRzIHZhbHVlIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswLCAyZTY0LTFdXCIsXG4gIFtTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9CSUdJTlRfU1RSSU5HXTogXCJgJHZhbHVlYCBjYW5ub3QgYmUgcGFyc2VkIGFzIGEgYEJpZ0ludGBcIixcbiAgW1NPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0pTT05fUlBDX0VSUk9SXTogXCIkbWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19NQUxGT1JNRURfTlVNQkVSX1NUUklOR106IFwiYCR2YWx1ZWAgY2Fubm90IGJlIHBhcnNlZCBhcyBhIGBOdW1iZXJgXCIsXG4gIFtTT0xBTkFfRVJST1JfX05PTkNFX0FDQ09VTlRfTk9UX0ZPVU5EXTogXCJObyBub25jZSBhY2NvdW50IGNvdWxkIGJlIGZvdW5kIGF0IGFkZHJlc3MgYCRub25jZUFjY291bnRBZGRyZXNzYFwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTl06IFwiVGhlIG5vdGlmaWNhdGlvbiBuYW1lIG11c3QgZW5kIGluICdOb3RpZmljYXRpb25zJyBhbmQgdGhlIEFQSSBtdXN0IHN1cHBseSBhIHN1YnNjcmlwdGlvbiBwbGFuIGNyZWF0b3IgZnVuY3Rpb24gZm9yIHRoZSBub3RpZmljYXRpb24gJyRub3RpZmljYXRpb25OYW1lJy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVEXTogXCJXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgcGF5bG9hZCBjb3VsZCBiZSBhZGRlZCB0byB0aGUgc2VuZCBidWZmZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ09OTkVDVElPTl9DTE9TRURdOiBcIldlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlZFwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9GQUlMRURfVE9fQ09OTkVDVF06IFwiV2ViU29ja2V0IGZhaWxlZCB0byBjb25uZWN0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19FWFBFQ1RFRF9TRVJWRVJfU1VCU0NSSVBUSU9OX0lEXTogXCJGYWlsZWQgdG8gb2J0YWluIGEgc3Vic2NyaXB0aW9uIGlkIGZyb20gdGhlIHNlcnZlclwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0RdOiBcIkNvdWxkIG5vdCBmaW5kIGFuIEFQSSBwbGFuIGZvciBSUEMgbWV0aG9kOiBgJG1ldGhvZGBcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XXTogXCJUaGUgJGFyZ3VtZW50TGFiZWwgYXJndW1lbnQgdG8gdGhlIGAkbWV0aG9kTmFtZWAgUlBDIG1ldGhvZCRvcHRpb25hbFBhdGhMYWJlbCB3YXMgYCR2YWx1ZWAuIFRoaXMgbnVtYmVyIGlzIHVuc2FmZSBmb3IgdXNlIHdpdGggdGhlIFNvbGFuYSBKU09OLVJQQyBiZWNhdXNlIGl0IGV4Y2VlZHMgYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUl06IFwiSFRUUCBlcnJvciAoJHN0YXR1c0NvZGUpOiAkbWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0hFQURFUl9GT1JCSURERU5dOiBcIkhUVFAgaGVhZGVyKHMpIGZvcmJpZGRlbjogJGhlYWRlcnMuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9HbG9zc2FyeS9Gb3JiaWRkZW5faGVhZGVyX25hbWUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fQUREUkVTU19DQU5OT1RfSEFWRV9NVUxUSVBMRV9TSUdORVJTXTogXCJNdWx0aXBsZSBkaXN0aW5jdCBzaWduZXJzIHdlcmUgaWRlbnRpZmllZCBmb3IgYWRkcmVzcyBgJGFkZHJlc3NgLiBQbGVhc2UgZW5zdXJlIHRoYXQgeW91IGFyZSB1c2luZyB0aGUgc2FtZSBzaWduZXIgaW5zdGFuY2UgZm9yIGVhY2ggYWRkcmVzcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBLZXlQYWlyU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBNZXNzYWdlTW9kaWZ5aW5nU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgTWVzc2FnZVBhcnRpYWxTaWduZXJgIGludGVyZmFjZVwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IGFueSBvZiB0aGUgYE1lc3NhZ2VTaWduZXJgIGludGVyZmFjZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgVHJhbnNhY3Rpb25Nb2RpZnlpbmdTaWduZXJgIGludGVyZmFjZVwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1BBUlRJQUxfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgVHJhbnNhY3Rpb25QYXJ0aWFsU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYFRyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IGFueSBvZiB0aGUgYFRyYW5zYWN0aW9uU2lnbmVyYCBpbnRlcmZhY2VzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTXTogXCJNb3JlIHRoYW4gb25lIGBUcmFuc2FjdGlvblNlbmRpbmdTaWduZXJgIHdhcyBpZGVudGlmaWVkLlwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkddOiBcIk5vIGBUcmFuc2FjdGlvblNlbmRpbmdTaWduZXJgIHdhcyBpZGVudGlmaWVkLiBQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIGBUcmFuc2FjdGlvbldpdGhTaW5nbGVTZW5kaW5nU2lnbmVyYCB0cmFuc2FjdGlvbi5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19XQUxMRVRfTVVMVElTSUdOX1VOSU1QTEVNRU5URURdOiBcIldhbGxldCBhY2NvdW50IHNpZ25lcnMgZG8gbm90IHN1cHBvcnQgc2lnbmluZyBtdWx0aXBsZSBtZXNzYWdlcy90cmFuc2FjdGlvbnMgaW4gYSBzaW5nbGUgb3BlcmF0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0NBTk5PVF9FWFBPUlRfTk9OX0VYVFJBQ1RBQkxFX0tFWV06IFwiQ2Fubm90IGV4cG9ydCBhIG5vbi1leHRyYWN0YWJsZSBrZXkuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVEXTogXCJObyBkaWdlc3QgaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJU0FMTE9XRURfSU5fSU5TRUNVUkVfQ09OVEVYVF06IFwiQ3J5cHRvZ3JhcGhpYyBvcGVyYXRpb25zIGFyZSBvbmx5IGFsbG93ZWQgaW4gc2VjdXJlIGJyb3dzZXIgY29udGV4dHMuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TZWN1cml0eS9TZWN1cmVfQ29udGV4dHMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URURdOiBcIlRoaXMgcnVudGltZSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBnZW5lcmF0aW9uIG9mIEVkMjU1MTkga2V5IHBhaXJzLlxcblxcbkluc3RhbGwgQHNvbGFuYS93ZWJjcnlwdG8tZWQyNTUxOS1wb2x5ZmlsbCBhbmQgY2FsbCBpdHMgYGluc3RhbGxgIGZ1bmN0aW9uIGJlZm9yZSBnZW5lcmF0aW5nIGtleXMgaW4gZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgRWQyNTUxOS5cXG5cXG5Gb3IgYSBsaXN0IG9mIHJ1bnRpbWVzIHRoYXQgY3VycmVudGx5IHN1cHBvcnQgRWQyNTUxOSBvcGVyYXRpb25zLCB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vV0lDRy93ZWJjcnlwdG8tc2VjdXJlLWN1cnZlcy9pc3N1ZXMvMjAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVEXTogXCJObyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEXTogXCJObyBrZXkgZ2VuZXJhdGlvbiBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVEXTogXCJObyBzaWduaW5nIGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8ga2V5IGV4cG9ydCBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVElNRVNUQU1QX09VVF9PRl9SQU5HRV06IFwiVGltZXN0YW1wIHZhbHVlIG11c3QgYmUgaW4gdGhlIHJhbmdlIFstKDJuICoqIDYzbiksICgybiAqKiA2M24pIC0gMV0uIGAkdmFsdWVgIGdpdmVuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElOR106IFwiVHJhbnNhY3Rpb24gcHJvY2Vzc2luZyBsZWZ0IGFuIGFjY291bnQgd2l0aCBhbiBvdXRzdGFuZGluZyBib3Jyb3dlZCByZWZlcmVuY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfSU5fVVNFXTogXCJBY2NvdW50IGluIHVzZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0VdOiBcIkFjY291bnQgbG9hZGVkIHR3aWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORF06IFwiQXR0ZW1wdCB0byBkZWJpdCBhbiBhY2NvdW50IGJ1dCBmb3VuZCBubyByZWNvcmQgb2YgYSBwcmlvciBjcmVkaXQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkRdOiBcIlRyYW5zYWN0aW9uIGxvYWRzIGFuIGFkZHJlc3MgdGFibGUgYWNjb3VudCB0aGF0IGRvZXNuJ3QgZXhpc3RcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VEXTogXCJUaGlzIHRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5EXTogXCJCbG9ja2hhc2ggbm90IGZvdW5kXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQXTogXCJMb2FkZXIgY2FsbCBjaGFpbiBpcyB0b28gZGVlcFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0xVU1RFUl9NQUlOVEVOQU5DRV06IFwiVHJhbnNhY3Rpb25zIGFyZSBjdXJyZW50bHkgZGlzYWJsZWQgZHVlIHRvIGNsdXN0ZXIgbWFpbnRlbmFuY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTl06IFwiVHJhbnNhY3Rpb24gY29udGFpbnMgYSBkdXBsaWNhdGUgaW5zdHJ1Y3Rpb24gKCRpbmRleCkgdGhhdCBpcyBub3QgYWxsb3dlZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9GRUVdOiBcIkluc3VmZmljaWVudCBmdW5kcyBmb3IgZmVlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlRdOiBcIlRyYW5zYWN0aW9uIHJlc3VsdHMgaW4gYW4gYWNjb3VudCAoJGFjY291bnRJbmRleCkgd2l0aCBpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIHJlbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9GT1JfRkVFXTogXCJUaGlzIGFjY291bnQgbWF5IG5vdCBiZSB1c2VkIHRvIHBheSB0cmFuc2FjdGlvbiBmZWVzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVhdOiBcIlRyYW5zYWN0aW9uIGNvbnRhaW5zIGFuIGludmFsaWQgYWNjb3VudCByZWZlcmVuY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfREFUQV06IFwiVHJhbnNhY3Rpb24gbG9hZHMgYW4gYWRkcmVzcyB0YWJsZSBhY2NvdW50IHdpdGggaW52YWxpZCBkYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYXTogXCJUcmFuc2FjdGlvbiBhZGRyZXNzIHRhYmxlIGxvb2t1cCB1c2VzIGFuIGludmFsaWQgaW5kZXhcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfT1dORVJdOiBcIlRyYW5zYWN0aW9uIGxvYWRzIGFuIGFkZHJlc3MgdGFibGUgYWNjb3VudCB3aXRoIGFuIGludmFsaWQgb3duZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9MSU1JVF06IFwiTG9hZGVkQWNjb3VudHNEYXRhU2l6ZUxpbWl0IHNldCBmb3IgdHJhbnNhY3Rpb24gbXVzdCBiZSBncmVhdGVyIHRoYW4gMC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUFJPR1JBTV9GT1JfRVhFQ1VUSU9OXTogXCJUaGlzIHByb2dyYW0gbWF5IG5vdCBiZSB1c2VkIGZvciBleGVjdXRpbmcgaW5zdHJ1Y3Rpb25zXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1JFTlRfUEFZSU5HX0FDQ09VTlRdOiBcIlRyYW5zYWN0aW9uIGxlYXZlcyBhbiBhY2NvdW50IHdpdGggYSBsb3dlciBiYWxhbmNlIHRoYW4gcmVudC1leGVtcHQgbWluaW11bVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9XUklUQUJMRV9BQ0NPVU5UXTogXCJUcmFuc2FjdGlvbiBsb2FkcyBhIHdyaXRhYmxlIGFjY291bnQgdGhhdCBjYW5ub3QgYmUgd3JpdHRlblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUFYX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfRVhDRUVERURdOiBcIlRyYW5zYWN0aW9uIGV4Y2VlZGVkIG1heCBsb2FkZWQgYWNjb3VudHMgZGF0YSBzaXplIGNhcFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUlTU0lOR19TSUdOQVRVUkVfRk9SX0ZFRV06IFwiVHJhbnNhY3Rpb24gcmVxdWlyZXMgYSBmZWUgYnV0IGhhcyBubyBzaWduYXR1cmUgcHJlc2VudFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9BQ0NPVU5UX05PVF9GT1VORF06IFwiQXR0ZW1wdCB0byBsb2FkIGEgcHJvZ3JhbSB0aGF0IGRvZXMgbm90IGV4aXN0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVEXTogXCJFeGVjdXRpb24gb2YgdGhlIHByb2dyYW0gcmVmZXJlbmNlZCBieSBhY2NvdW50IGF0IGluZGV4ICRhY2NvdW50SW5kZXggaXMgdGVtcG9yYXJpbHkgcmVzdHJpY3RlZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1JFU0FOSVRJWkFUSU9OX05FRURFRF06IFwiUmVzYW5pdGl6YXRpb25OZWVkZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkVdOiBcIlRyYW5zYWN0aW9uIGZhaWxlZCB0byBzYW5pdGl6ZSBhY2NvdW50cyBvZmZzZXRzIGNvcnJlY3RseVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0lHTkFUVVJFX0ZBSUxVUkVdOiBcIlRyYW5zYWN0aW9uIGRpZCBub3QgcGFzcyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19UT09fTUFOWV9BQ0NPVU5UX0xPQ0tTXTogXCJUcmFuc2FjdGlvbiBsb2NrZWQgdG9vIG1hbnkgYWNjb3VudHNcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfVFJBTlNBQ1RJT05dOiBcIlN1bSBvZiBhY2NvdW50IGJhbGFuY2VzIGJlZm9yZSBhbmQgYWZ0ZXIgdHJhbnNhY3Rpb24gZG8gbm90IG1hdGNoXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOXTogXCJUaGUgdHJhbnNhY3Rpb24gZmFpbGVkIHdpdGggdGhlIGVycm9yIGAkZXJyb3JOYW1lYFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfVkVSU0lPTl06IFwiVHJhbnNhY3Rpb24gdmVyc2lvbiBpcyB1bnN1cHBvcnRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9CTE9DS19MSU1JVF06IFwiVHJhbnNhY3Rpb24gd291bGQgZXhjZWVkIGFjY291bnQgZGF0YSBsaW1pdCB3aXRoaW4gdGhlIGJsb2NrXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX1RPVEFMX0xJTUlUXTogXCJUcmFuc2FjdGlvbiB3b3VsZCBleGNlZWQgdG90YWwgYWNjb3VudCBkYXRhIGxpbWl0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVF06IFwiVHJhbnNhY3Rpb24gd291bGQgZXhjZWVkIG1heCBhY2NvdW50IGxpbWl0IHdpdGhpbiB0aGUgYmxvY2tcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQkxPQ0tfQ09TVF9MSU1JVF06IFwiVHJhbnNhY3Rpb24gd291bGQgZXhjZWVkIG1heCBCbG9jayBDb3N0IExpbWl0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX1ZPVEVfQ09TVF9MSU1JVF06IFwiVHJhbnNhY3Rpb24gd291bGQgZXhjZWVkIG1heCBWb3RlIENvc3QgTGltaXRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTl06IFwiQXR0ZW1wdGVkIHRvIHNpZ24gYSB0cmFuc2FjdGlvbiB3aXRoIGFuIGFkZHJlc3MgdGhhdCBpcyBub3QgYSBzaWduZXIgZm9yIGl0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkddOiBcIlRyYW5zYWN0aW9uIGlzIG1pc3NpbmcgYW4gYWRkcmVzcyBhdCBpbmRleDogJGluZGV4LlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQ0FOTk9UX0VOQ09ERV9XSVRIX0VNUFRZX1NJR05BVFVSRVNdOiBcIlRyYW5zYWN0aW9uIGhhcyBubyBleHBlY3RlZCBzaWduZXJzIHRoZXJlZm9yZSBpdCBjYW5ub3QgYmUgZW5jb2RlZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhDRUVEU19TSVpFX0xJTUlUXTogXCJUcmFuc2FjdGlvbiBzaXplICR0cmFuc2FjdGlvblNpemUgZXhjZWVkcyBsaW1pdCBvZiAkdHJhbnNhY3Rpb25TaXplTGltaXQgYnl0ZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX0JMT0NLSEFTSF9MSUZFVElNRV06IFwiVHJhbnNhY3Rpb24gZG9lcyBub3QgaGF2ZSBhIGJsb2NraGFzaCBsaWZldGltZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUVdOiBcIlRyYW5zYWN0aW9uIGlzIG5vdCBhIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lOR106IFwiQ29udGVudHMgb2YgdGhlc2UgYWRkcmVzcyBsb29rdXAgdGFibGVzIHVua25vd246ICRsb29rdXBUYWJsZUFkZHJlc3Nlc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF9PVVRfT0ZfUkFOR0VdOiBcIkxvb2t1cCBvZiBhZGRyZXNzIGF0IGluZGV4ICRoaWdoZXN0UmVxdWVzdGVkSW5kZXggZmFpbGVkIGZvciBsb29rdXAgdGFibGUgYCRsb29rdXBUYWJsZUFkZHJlc3NgLiBIaWdoZXN0IGtub3duIGluZGV4IGlzICRoaWdoZXN0S25vd25JbmRleC4gVGhlIGxvb2t1cCB0YWJsZSBtYXkgaGF2ZSBiZWVuIGV4dGVuZGVkIHNpbmNlIGl0cyBjb250ZW50cyB3ZXJlIHJldHJpZXZlZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lOR106IFwiTm8gZmVlIHBheWVyIHNldCBpbiBDb21waWxlZFRyYW5zYWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0lOU1RSVUNUSU9OX1BST0dSQU1fQUREUkVTU19OT1RfRk9VTkRdOiBcIkNvdWxkIG5vdCBmaW5kIHByb2dyYW0gYWRkcmVzcyBhdCBpbmRleCAkaW5kZXhcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUXTogXCJGYWlsZWQgdG8gZXN0aW1hdGUgdGhlIGNvbXB1dGUgdW5pdCBjb25zdW1wdGlvbiBmb3IgdGhpcyB0cmFuc2FjdGlvbiBtZXNzYWdlLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIHNpbXVsYXRpbmcgdGhlIHRyYW5zYWN0aW9uIGZhaWxlZC4gSW5zcGVjdCB0aGUgYGNhdXNlYCBwcm9wZXJ0eSBvZiB0aGlzIGVycm9yIHRvIGxlYXJuIG1vcmVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVF06IFwiVHJhbnNhY3Rpb24gZmFpbGVkIHdoZW4gaXQgd2FzIHNpbXVsYXRlZCBpbiBvcmRlciB0byBlc3RpbWF0ZSB0aGUgY29tcHV0ZSB1bml0IGNvbnN1bXB0aW9uLiBUaGUgY29tcHV0ZSB1bml0IGVzdGltYXRlIHByb3ZpZGVkIGlzIGZvciBhIHRyYW5zYWN0aW9uIHRoYXQgZmFpbGVkIHdoZW4gc2ltdWxhdGVkIGFuZCBtYXkgbm90IGJlIHJlcHJlc2VudGF0aXZlIG9mIHRoZSBjb21wdXRlIHVuaXRzIHRoaXMgdHJhbnNhY3Rpb24gd291bGQgY29uc3VtZSBpZiBzdWNjZXNzZnVsLiBJbnNwZWN0IHRoZSBgY2F1c2VgIHByb3BlcnR5IG9mIHRoaXMgZXJyb3IgdG8gbGVhcm4gbW9yZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkddOiBcIlRyYW5zYWN0aW9uIGlzIG1pc3NpbmcgYSBmZWUgcGF5ZXIuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfU0lHTkFUVVJFX01JU1NJTkddOiBcIkNvdWxkIG5vdCBkZXRlcm1pbmUgdGhpcyB0cmFuc2FjdGlvbidzIHNpZ25hdHVyZS4gTWFrZSBzdXJlIHRoYXQgdGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHNpZ25lZCBieSBpdHMgZmVlIHBheWVyLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9GSVJTVF9JTlNUUlVDVElPTl9NVVNUX0JFX0FEVkFOQ0VfTk9OQ0VdOiBcIlRyYW5zYWN0aW9uIGZpcnN0IGluc3RydWN0aW9uIGlzIG5vdCBhZHZhbmNlIG5vbmNlIGFjY291bnQgaW5zdHJ1Y3Rpb24uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0lOU1RSVUNUSU9OU19NSVNTSU5HXTogXCJUcmFuc2FjdGlvbiB3aXRoIG5vIGluc3RydWN0aW9ucyBjYW5ub3QgYmUgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvbi5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTXTogXCJUaGlzIHRyYW5zYWN0aW9uIGluY2x1ZGVzIGFuIGFkZHJlc3MgKGAkcHJvZ3JhbUFkZHJlc3NgKSB3aGljaCBpcyBib3RoIGludm9rZWQgYW5kIHNldCBhcyB0aGUgZmVlIHBheWVyLiBQcm9ncmFtIGFkZHJlc3NlcyBtYXkgbm90IHBheSBmZWVzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFXTogXCJUaGlzIHRyYW5zYWN0aW9uIGluY2x1ZGVzIGFuIGFkZHJlc3MgKGAkcHJvZ3JhbUFkZHJlc3NgKSB3aGljaCBpcyBib3RoIGludm9rZWQgYW5kIG1hcmtlZCB3cml0YWJsZS4gUHJvZ3JhbSBhZGRyZXNzZXMgbWF5IG5vdCBiZSB3cml0YWJsZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIXTogXCJUaGUgdHJhbnNhY3Rpb24gbWVzc2FnZSBleHBlY3RlZCB0aGUgdHJhbnNhY3Rpb24gdG8gaGF2ZSAkc2lnbmVyQWRkcmVzc2VzTGVuZ3RoIHNpZ25hdHVyZXMsIGdvdCAkc2lnbmF0dXJlc0xlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1NJR05BVFVSRVNfTUlTU0lOR106IFwiVHJhbnNhY3Rpb24gaXMgbWlzc2luZyBzaWduYXR1cmVzIGZvciBhZGRyZXNzZXM6ICRhZGRyZXNzZXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0VdOiBcIlRyYW5zYWN0aW9uIHZlcnNpb24gbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAsIDEyN10uIGAkYWN0dWFsVmVyc2lvbmAgZ2l2ZW5cIlxufTtcblxuLy8gc3JjL21lc3NhZ2UtZm9ybWF0dGVyLnRzXG52YXIgU1RBUlRfSU5ERVggPSBcImlcIjtcbnZhciBUWVBFID0gXCJ0XCI7XG5mdW5jdGlvbiBnZXRIdW1hblJlYWRhYmxlRXJyb3JNZXNzYWdlKGNvZGUsIGNvbnRleHQgPSB7fSkge1xuICBjb25zdCBtZXNzYWdlRm9ybWF0U3RyaW5nID0gU29sYW5hRXJyb3JNZXNzYWdlc1tjb2RlXTtcbiAgaWYgKG1lc3NhZ2VGb3JtYXRTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgbGV0IHN0YXRlO1xuICBmdW5jdGlvbiBjb21taXRTdGF0ZVVwVG8oZW5kSW5kZXgpIHtcbiAgICBpZiAoc3RhdGVbVFlQRV0gPT09IDIgLyogVmFyaWFibGUgKi8pIHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IG1lc3NhZ2VGb3JtYXRTdHJpbmcuc2xpY2Uoc3RhdGVbU1RBUlRfSU5ERVhdICsgMSwgZW5kSW5kZXgpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goXG4gICAgICAgIHZhcmlhYmxlTmFtZSBpbiBjb250ZXh0ID8gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICBgJHtjb250ZXh0W3ZhcmlhYmxlTmFtZV19YFxuICAgICAgICApIDogYCQke3ZhcmlhYmxlTmFtZX1gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoc3RhdGVbVFlQRV0gPT09IDEgLyogVGV4dCAqLykge1xuICAgICAgZnJhZ21lbnRzLnB1c2gobWVzc2FnZUZvcm1hdFN0cmluZy5zbGljZShzdGF0ZVtTVEFSVF9JTkRFWF0sIGVuZEluZGV4KSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZyYWdtZW50cyA9IFtdO1xuICBtZXNzYWdlRm9ybWF0U3RyaW5nLnNwbGl0KFwiXCIpLmZvckVhY2goKGNoYXIsIGlpKSA9PiB7XG4gICAgaWYgKGlpID09PSAwKSB7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgW1NUQVJUX0lOREVYXTogMCxcbiAgICAgICAgW1RZUEVdOiBtZXNzYWdlRm9ybWF0U3RyaW5nWzBdID09PSBcIlxcXFxcIiA/IDAgLyogRXNjYXBlU2VxdWVuY2UgKi8gOiBtZXNzYWdlRm9ybWF0U3RyaW5nWzBdID09PSBcIiRcIiA/IDIgLyogVmFyaWFibGUgKi8gOiAxIC8qIFRleHQgKi9cbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZXh0U3RhdGU7XG4gICAgc3dpdGNoIChzdGF0ZVtUWVBFXSkge1xuICAgICAgY2FzZSAwIC8qIEVzY2FwZVNlcXVlbmNlICovOlxuICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDEgLyogVGV4dCAqLyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBUZXh0ICovOlxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDAgLyogRXNjYXBlU2VxdWVuY2UgKi8gfTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIiRcIikge1xuICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMiAvKiBWYXJpYWJsZSAqLyB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyIC8qIFZhcmlhYmxlICovOlxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDAgLyogRXNjYXBlU2VxdWVuY2UgKi8gfTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIiRcIikge1xuICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMiAvKiBWYXJpYWJsZSAqLyB9O1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGFyLm1hdGNoKC9cXHcvKSkge1xuICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMSAvKiBUZXh0ICovIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgIGNvbW1pdFN0YXRlVXBUbyhpaSk7XG4gICAgICB9XG4gICAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICB9XG4gIH0pO1xuICBjb21taXRTdGF0ZVVwVG8oKTtcbiAgcmV0dXJuIGZyYWdtZW50cy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGNvZGUsIGNvbnRleHQgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIGdldEh1bWFuUmVhZGFibGVFcnJvck1lc3NhZ2UoY29kZSwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGRlY29kaW5nQWR2aWNlTWVzc2FnZSA9IGBTb2xhbmEgZXJyb3IgIyR7Y29kZX07IERlY29kZSB0aGlzIGVycm9yIGJ5IHJ1bm5pbmcgXFxgbnB4IEBzb2xhbmEvZXJyb3JzIGRlY29kZSAtLSAke2NvZGV9YDtcbiAgICBpZiAoT2JqZWN0LmtleXMoY29udGV4dCkubGVuZ3RoKSB7XG4gICAgICBkZWNvZGluZ0FkdmljZU1lc3NhZ2UgKz0gYCAnJHtlbmNvZGVDb250ZXh0T2JqZWN0KGNvbnRleHQpfSdgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZGVjb2RpbmdBZHZpY2VNZXNzYWdlfVxcYGA7XG4gIH1cbn1cblxuLy8gc3JjL2Vycm9yLnRzXG5mdW5jdGlvbiBpc1NvbGFuYUVycm9yKGUsIGNvZGUpIHtcbiAgY29uc3QgaXNTb2xhbmFFcnJvcjIgPSBlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5uYW1lID09PSBcIlNvbGFuYUVycm9yXCI7XG4gIGlmIChpc1NvbGFuYUVycm9yMikge1xuICAgIGlmIChjb2RlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBlLmNvbnRleHQuX19jb2RlID09PSBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgU29sYW5hRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgcm9vdCBjYXVzZSBvZiB0aGlzIHtAbGluayBTb2xhbmFFcnJvcn0sIGlmIGFueS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGEgdHJhbnNhY3Rpb24gZXJyb3IgbWlnaHQgaGF2ZSBhbiBpbnN0cnVjdGlvbiBlcnJvciBhcyBpdHMgcm9vdCBjYXVzZS4gSW4gdGhpc1xuICAgKiBjYXNlLCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgaW5zdHJ1Y3Rpb24gZXJyb3Igb24gdGhlIHRyYW5zYWN0aW9uIGVycm9yIGFzIGBjYXVzZWAuXG4gICAqL1xuICBjYXVzZSA9IHRoaXMuY2F1c2U7XG4gIC8qKlxuICAgKiBDb250YWlucyBjb250ZXh0IHRoYXQgY2FuIGFzc2lzdCBpbiB1bmRlcnN0YW5kaW5nIG9yIHJlY292ZXJpbmcgZnJvbSBhIHtAbGluayBTb2xhbmFFcnJvcn0uXG4gICAqL1xuICBjb250ZXh0O1xuICBjb25zdHJ1Y3RvciguLi5bY29kZSwgY29udGV4dEFuZEVycm9yT3B0aW9uc10pIHtcbiAgICBsZXQgY29udGV4dDtcbiAgICBsZXQgZXJyb3JPcHRpb25zO1xuICAgIGlmIChjb250ZXh0QW5kRXJyb3JPcHRpb25zKSB7XG4gICAgICBjb25zdCB7IGNhdXNlLCAuLi5jb250ZXh0UmVzdCB9ID0gY29udGV4dEFuZEVycm9yT3B0aW9ucztcbiAgICAgIGlmIChjYXVzZSkge1xuICAgICAgICBlcnJvck9wdGlvbnMgPSB7IGNhdXNlIH07XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMoY29udGV4dFJlc3QpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHRSZXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGNvZGUsIGNvbnRleHQpO1xuICAgIHN1cGVyKG1lc3NhZ2UsIGVycm9yT3B0aW9ucyk7XG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgX19jb2RlOiBjb2RlLFxuICAgICAgLi4uY29udGV4dFxuICAgIH07XG4gICAgdGhpcy5uYW1lID0gXCJTb2xhbmFFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvc3RhY2stdHJhY2UudHNcbmZ1bmN0aW9uIHNhZmVDYXB0dXJlU3RhY2tUcmFjZSguLi5hcmdzKSB7XG4gIGlmIChcImNhcHR1cmVTdGFja1RyYWNlXCIgaW4gRXJyb3IgJiYgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSguLi5hcmdzKTtcbiAgfVxufVxuXG4vLyBzcmMvcnBjLWVudW0tZXJyb3JzLnRzXG5mdW5jdGlvbiBnZXRTb2xhbmFFcnJvckZyb21ScGNFcnJvcih7IGVycm9yQ29kZUJhc2VPZmZzZXQsIGdldEVycm9yQ29udGV4dCwgb3JkZXJlZEVycm9yTmFtZXMsIHJwY0VudW1FcnJvciB9LCBjb25zdHJ1Y3Rvck9wdCkge1xuICBsZXQgcnBjRXJyb3JOYW1lO1xuICBsZXQgcnBjRXJyb3JDb250ZXh0O1xuICBpZiAodHlwZW9mIHJwY0VudW1FcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJwY0Vycm9yTmFtZSA9IHJwY0VudW1FcnJvcjtcbiAgfSBlbHNlIHtcbiAgICBycGNFcnJvck5hbWUgPSBPYmplY3Qua2V5cyhycGNFbnVtRXJyb3IpWzBdO1xuICAgIHJwY0Vycm9yQ29udGV4dCA9IHJwY0VudW1FcnJvcltycGNFcnJvck5hbWVdO1xuICB9XG4gIGNvbnN0IGNvZGVPZmZzZXQgPSBvcmRlcmVkRXJyb3JOYW1lcy5pbmRleE9mKHJwY0Vycm9yTmFtZSk7XG4gIGNvbnN0IGVycm9yQ29kZSA9IGVycm9yQ29kZUJhc2VPZmZzZXQgKyBjb2RlT2Zmc2V0O1xuICBjb25zdCBlcnJvckNvbnRleHQgPSBnZXRFcnJvckNvbnRleHQoZXJyb3JDb2RlLCBycGNFcnJvck5hbWUsIHJwY0Vycm9yQ29udGV4dCk7XG4gIGNvbnN0IGVyciA9IG5ldyBTb2xhbmFFcnJvcihlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gIHNhZmVDYXB0dXJlU3RhY2tUcmFjZShlcnIsIGNvbnN0cnVjdG9yT3B0KTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLy8gc3JjL2luc3RydWN0aW9uLWVycm9yLnRzXG52YXIgT1JERVJFRF9FUlJPUl9OQU1FUyA9IFtcbiAgLy8gS2VlcCBzeW5jZWQgd2l0aCBSUEMgc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvYmxvYi9tYXN0ZXIvc2RrL3Byb2dyYW0vc3JjL2luc3RydWN0aW9uLnJzXG4gIC8vIElmIHRoaXMgbGlzdCBldmVyIGdldHMgdG9vIGxhcmdlLCBjb25zaWRlciBpbXBsZW1lbnRpbmcgYSBjb21wcmVzc2lvbiBzdHJhdGVneSBsaWtlIHRoaXM6XG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXZlbHVzY2hlci9hYWE3Y2JiYjU0MzNiMTE5Nzk4MzkwOGE0MDg2MGM0N1xuICBcIkdlbmVyaWNFcnJvclwiLFxuICBcIkludmFsaWRBcmd1bWVudFwiLFxuICBcIkludmFsaWRJbnN0cnVjdGlvbkRhdGFcIixcbiAgXCJJbnZhbGlkQWNjb3VudERhdGFcIixcbiAgXCJBY2NvdW50RGF0YVRvb1NtYWxsXCIsXG4gIFwiSW5zdWZmaWNpZW50RnVuZHNcIixcbiAgXCJJbmNvcnJlY3RQcm9ncmFtSWRcIixcbiAgXCJNaXNzaW5nUmVxdWlyZWRTaWduYXR1cmVcIixcbiAgXCJBY2NvdW50QWxyZWFkeUluaXRpYWxpemVkXCIsXG4gIFwiVW5pbml0aWFsaXplZEFjY291bnRcIixcbiAgXCJVbmJhbGFuY2VkSW5zdHJ1Y3Rpb25cIixcbiAgXCJNb2RpZmllZFByb2dyYW1JZFwiLFxuICBcIkV4dGVybmFsQWNjb3VudExhbXBvcnRTcGVuZFwiLFxuICBcIkV4dGVybmFsQWNjb3VudERhdGFNb2RpZmllZFwiLFxuICBcIlJlYWRvbmx5TGFtcG9ydENoYW5nZVwiLFxuICBcIlJlYWRvbmx5RGF0YU1vZGlmaWVkXCIsXG4gIFwiRHVwbGljYXRlQWNjb3VudEluZGV4XCIsXG4gIFwiRXhlY3V0YWJsZU1vZGlmaWVkXCIsXG4gIFwiUmVudEVwb2NoTW9kaWZpZWRcIixcbiAgXCJOb3RFbm91Z2hBY2NvdW50S2V5c1wiLFxuICBcIkFjY291bnREYXRhU2l6ZUNoYW5nZWRcIixcbiAgXCJBY2NvdW50Tm90RXhlY3V0YWJsZVwiLFxuICBcIkFjY291bnRCb3Jyb3dGYWlsZWRcIixcbiAgXCJBY2NvdW50Qm9ycm93T3V0c3RhbmRpbmdcIixcbiAgXCJEdXBsaWNhdGVBY2NvdW50T3V0T2ZTeW5jXCIsXG4gIFwiQ3VzdG9tXCIsXG4gIFwiSW52YWxpZEVycm9yXCIsXG4gIFwiRXhlY3V0YWJsZURhdGFNb2RpZmllZFwiLFxuICBcIkV4ZWN1dGFibGVMYW1wb3J0Q2hhbmdlXCIsXG4gIFwiRXhlY3V0YWJsZUFjY291bnROb3RSZW50RXhlbXB0XCIsXG4gIFwiVW5zdXBwb3J0ZWRQcm9ncmFtSWRcIixcbiAgXCJDYWxsRGVwdGhcIixcbiAgXCJNaXNzaW5nQWNjb3VudFwiLFxuICBcIlJlZW50cmFuY3lOb3RBbGxvd2VkXCIsXG4gIFwiTWF4U2VlZExlbmd0aEV4Y2VlZGVkXCIsXG4gIFwiSW52YWxpZFNlZWRzXCIsXG4gIFwiSW52YWxpZFJlYWxsb2NcIixcbiAgXCJDb21wdXRhdGlvbmFsQnVkZ2V0RXhjZWVkZWRcIixcbiAgXCJQcml2aWxlZ2VFc2NhbGF0aW9uXCIsXG4gIFwiUHJvZ3JhbUVudmlyb25tZW50U2V0dXBGYWlsdXJlXCIsXG4gIFwiUHJvZ3JhbUZhaWxlZFRvQ29tcGxldGVcIixcbiAgXCJQcm9ncmFtRmFpbGVkVG9Db21waWxlXCIsXG4gIFwiSW1tdXRhYmxlXCIsXG4gIFwiSW5jb3JyZWN0QXV0aG9yaXR5XCIsXG4gIFwiQm9yc2hJb0Vycm9yXCIsXG4gIFwiQWNjb3VudE5vdFJlbnRFeGVtcHRcIixcbiAgXCJJbnZhbGlkQWNjb3VudE93bmVyXCIsXG4gIFwiQXJpdGhtZXRpY092ZXJmbG93XCIsXG4gIFwiVW5zdXBwb3J0ZWRTeXN2YXJcIixcbiAgXCJJbGxlZ2FsT3duZXJcIixcbiAgXCJNYXhBY2NvdW50c0RhdGFBbGxvY2F0aW9uc0V4Y2VlZGVkXCIsXG4gIFwiTWF4QWNjb3VudHNFeGNlZWRlZFwiLFxuICBcIk1heEluc3RydWN0aW9uVHJhY2VMZW5ndGhFeGNlZWRlZFwiLFxuICBcIkJ1aWx0aW5Qcm9ncmFtc011c3RDb25zdW1lQ29tcHV0ZVVuaXRzXCJcbl07XG5mdW5jdGlvbiBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yKGluZGV4LCBpbnN0cnVjdGlvbkVycm9yKSB7XG4gIGNvbnN0IG51bWJlckluZGV4ID0gTnVtYmVyKGluZGV4KTtcbiAgcmV0dXJuIGdldFNvbGFuYUVycm9yRnJvbVJwY0Vycm9yKFxuICAgIHtcbiAgICAgIGVycm9yQ29kZUJhc2VPZmZzZXQ6IDQ2MTUwMDEsXG4gICAgICBnZXRFcnJvckNvbnRleHQoZXJyb3JDb2RlLCBycGNFcnJvck5hbWUsIHJwY0Vycm9yQ29udGV4dCkge1xuICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yTmFtZTogcnBjRXJyb3JOYW1lLFxuICAgICAgICAgICAgaW5kZXg6IG51bWJlckluZGV4LFxuICAgICAgICAgICAgLi4ucnBjRXJyb3JDb250ZXh0ICE9PSB2b2lkIDAgPyB7IGluc3RydWN0aW9uRXJyb3JDb250ZXh0OiBycGNFcnJvckNvbnRleHQgfSA6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IE51bWJlcihycGNFcnJvckNvbnRleHQpLFxuICAgICAgICAgICAgaW5kZXg6IG51bWJlckluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY29kZWREYXRhOiBycGNFcnJvckNvbnRleHQsXG4gICAgICAgICAgICBpbmRleDogbnVtYmVySW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGluZGV4OiBudW1iZXJJbmRleCB9O1xuICAgICAgfSxcbiAgICAgIG9yZGVyZWRFcnJvck5hbWVzOiBPUkRFUkVEX0VSUk9SX05BTUVTLFxuICAgICAgcnBjRW51bUVycm9yOiBpbnN0cnVjdGlvbkVycm9yXG4gICAgfSxcbiAgICBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yXG4gICk7XG59XG5cbi8vIHNyYy90cmFuc2FjdGlvbi1lcnJvci50c1xudmFyIE9SREVSRURfRVJST1JfTkFNRVMyID0gW1xuICAvLyBLZWVwIHN5bmNlZCB3aXRoIFJQQyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbnphLXh5ei9hZ2F2ZS9ibG9iL21hc3Rlci9zZGsvc3JjL3RyYW5zYWN0aW9uL2Vycm9yLnJzXG4gIC8vIElmIHRoaXMgbGlzdCBldmVyIGdldHMgdG9vIGxhcmdlLCBjb25zaWRlciBpbXBsZW1lbnRpbmcgYSBjb21wcmVzc2lvbiBzdHJhdGVneSBsaWtlIHRoaXM6XG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXZlbHVzY2hlci9hYWE3Y2JiYjU0MzNiMTE5Nzk4MzkwOGE0MDg2MGM0N1xuICBcIkFjY291bnRJblVzZVwiLFxuICBcIkFjY291bnRMb2FkZWRUd2ljZVwiLFxuICBcIkFjY291bnROb3RGb3VuZFwiLFxuICBcIlByb2dyYW1BY2NvdW50Tm90Rm91bmRcIixcbiAgXCJJbnN1ZmZpY2llbnRGdW5kc0ZvckZlZVwiLFxuICBcIkludmFsaWRBY2NvdW50Rm9yRmVlXCIsXG4gIFwiQWxyZWFkeVByb2Nlc3NlZFwiLFxuICBcIkJsb2NraGFzaE5vdEZvdW5kXCIsXG4gIC8vIGBJbnN0cnVjdGlvbkVycm9yYCBpbnRlbnRpb25hbGx5IG9taXR0ZWQ7IGRlbGVnYXRlZCB0byBgZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvcmBcbiAgXCJDYWxsQ2hhaW5Ub29EZWVwXCIsXG4gIFwiTWlzc2luZ1NpZ25hdHVyZUZvckZlZVwiLFxuICBcIkludmFsaWRBY2NvdW50SW5kZXhcIixcbiAgXCJTaWduYXR1cmVGYWlsdXJlXCIsXG4gIFwiSW52YWxpZFByb2dyYW1Gb3JFeGVjdXRpb25cIixcbiAgXCJTYW5pdGl6ZUZhaWx1cmVcIixcbiAgXCJDbHVzdGVyTWFpbnRlbmFuY2VcIixcbiAgXCJBY2NvdW50Qm9ycm93T3V0c3RhbmRpbmdcIixcbiAgXCJXb3VsZEV4Y2VlZE1heEJsb2NrQ29zdExpbWl0XCIsXG4gIFwiVW5zdXBwb3J0ZWRWZXJzaW9uXCIsXG4gIFwiSW52YWxpZFdyaXRhYmxlQWNjb3VudFwiLFxuICBcIldvdWxkRXhjZWVkTWF4QWNjb3VudENvc3RMaW1pdFwiLFxuICBcIldvdWxkRXhjZWVkQWNjb3VudERhdGFCbG9ja0xpbWl0XCIsXG4gIFwiVG9vTWFueUFjY291bnRMb2Nrc1wiLFxuICBcIkFkZHJlc3NMb29rdXBUYWJsZU5vdEZvdW5kXCIsXG4gIFwiSW52YWxpZEFkZHJlc3NMb29rdXBUYWJsZU93bmVyXCIsXG4gIFwiSW52YWxpZEFkZHJlc3NMb29rdXBUYWJsZURhdGFcIixcbiAgXCJJbnZhbGlkQWRkcmVzc0xvb2t1cFRhYmxlSW5kZXhcIixcbiAgXCJJbnZhbGlkUmVudFBheWluZ0FjY291bnRcIixcbiAgXCJXb3VsZEV4Y2VlZE1heFZvdGVDb3N0TGltaXRcIixcbiAgXCJXb3VsZEV4Y2VlZEFjY291bnREYXRhVG90YWxMaW1pdFwiLFxuICBcIkR1cGxpY2F0ZUluc3RydWN0aW9uXCIsXG4gIFwiSW5zdWZmaWNpZW50RnVuZHNGb3JSZW50XCIsXG4gIFwiTWF4TG9hZGVkQWNjb3VudHNEYXRhU2l6ZUV4Y2VlZGVkXCIsXG4gIFwiSW52YWxpZExvYWRlZEFjY291bnRzRGF0YVNpemVMaW1pdFwiLFxuICBcIlJlc2FuaXRpemF0aW9uTmVlZGVkXCIsXG4gIFwiUHJvZ3JhbUV4ZWN1dGlvblRlbXBvcmFyaWx5UmVzdHJpY3RlZFwiLFxuICBcIlVuYmFsYW5jZWRUcmFuc2FjdGlvblwiXG5dO1xuZnVuY3Rpb24gZ2V0U29sYW5hRXJyb3JGcm9tVHJhbnNhY3Rpb25FcnJvcih0cmFuc2FjdGlvbkVycm9yKSB7XG4gIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25FcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcIkluc3RydWN0aW9uRXJyb3JcIiBpbiB0cmFuc2FjdGlvbkVycm9yKSB7XG4gICAgcmV0dXJuIGdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3IoXG4gICAgICAuLi50cmFuc2FjdGlvbkVycm9yLkluc3RydWN0aW9uRXJyb3JcbiAgICApO1xuICB9XG4gIHJldHVybiBnZXRTb2xhbmFFcnJvckZyb21ScGNFcnJvcihcbiAgICB7XG4gICAgICBlcnJvckNvZGVCYXNlT2Zmc2V0OiA3MDUwMDAxLFxuICAgICAgZ2V0RXJyb3JDb250ZXh0KGVycm9yQ29kZSwgcnBjRXJyb3JOYW1lLCBycGNFcnJvckNvbnRleHQpIHtcbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvck5hbWU6IHJwY0Vycm9yTmFtZSxcbiAgICAgICAgICAgIC4uLnJwY0Vycm9yQ29udGV4dCAhPT0gdm9pZCAwID8geyB0cmFuc2FjdGlvbkVycm9yQ29udGV4dDogcnBjRXJyb3JDb250ZXh0IH0gOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogTnVtYmVyKHJwY0Vycm9yQ29udGV4dClcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5UIHx8IGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvdW50SW5kZXg6IE51bWJlcihycGNFcnJvckNvbnRleHQuYWNjb3VudF9pbmRleClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3JkZXJlZEVycm9yTmFtZXM6IE9SREVSRURfRVJST1JfTkFNRVMyLFxuICAgICAgcnBjRW51bUVycm9yOiB0cmFuc2FjdGlvbkVycm9yXG4gICAgfSxcbiAgICBnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yXG4gICk7XG59XG5cbi8vIHNyYy9qc29uLXJwYy1lcnJvci50c1xuZnVuY3Rpb24gZ2V0U29sYW5hRXJyb3JGcm9tSnNvblJwY0Vycm9yKHB1dGF0aXZlRXJyb3JSZXNwb25zZSkge1xuICBsZXQgb3V0O1xuICBpZiAoaXNScGNFcnJvclJlc3BvbnNlKHB1dGF0aXZlRXJyb3JSZXNwb25zZSkpIHtcbiAgICBjb25zdCB7IGNvZGU6IHJhd0NvZGUsIGRhdGEsIG1lc3NhZ2UgfSA9IHB1dGF0aXZlRXJyb3JSZXNwb25zZTtcbiAgICBjb25zdCBjb2RlID0gTnVtYmVyKHJhd0NvZGUpO1xuICAgIGlmIChjb2RlID09PSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSkge1xuICAgICAgY29uc3QgeyBlcnIsIC4uLnByZWZsaWdodEVycm9yQ29udGV4dCB9ID0gZGF0YTtcbiAgICAgIGNvbnN0IGNhdXNlT2JqZWN0ID0gZXJyID8geyBjYXVzZTogZ2V0U29sYW5hRXJyb3JGcm9tVHJhbnNhY3Rpb25FcnJvcihlcnIpIH0gOiBudWxsO1xuICAgICAgb3V0ID0gbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFLCB7XG4gICAgICAgIC4uLnByZWZsaWdodEVycm9yQ29udGV4dCxcbiAgICAgICAgLi4uY2F1c2VPYmplY3RcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZXJyb3JDb250ZXh0O1xuICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5URVJOQUxfRVJST1I6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVM6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9SRVFVRVNUOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX01FVEhPRF9OT1RfRk9VTkQ6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1I6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUjpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRTpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVg6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OOlxuICAgICAgICAgIGVycm9yQ29udGV4dCA9IHsgX19zZXJ2ZXJNZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBlcnJvckNvbnRleHQgPSBkYXRhO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCA9IG5ldyBTb2xhbmFFcnJvcihjb2RlLCBlcnJvckNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIHB1dGF0aXZlRXJyb3JSZXNwb25zZSA9PT0gXCJvYmplY3RcIiAmJiBwdXRhdGl2ZUVycm9yUmVzcG9uc2UgIT09IG51bGwgJiYgXCJtZXNzYWdlXCIgaW4gcHV0YXRpdmVFcnJvclJlc3BvbnNlICYmIHR5cGVvZiBwdXRhdGl2ZUVycm9yUmVzcG9uc2UubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHB1dGF0aXZlRXJyb3JSZXNwb25zZS5tZXNzYWdlIDogXCJNYWxmb3JtZWQgSlNPTi1SUEMgZXJyb3Igd2l0aCBubyBtZXNzYWdlIGF0dHJpYnV0ZVwiO1xuICAgIG91dCA9IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUiwgeyBlcnJvcjogcHV0YXRpdmVFcnJvclJlc3BvbnNlLCBtZXNzYWdlIH0pO1xuICB9XG4gIHNhZmVDYXB0dXJlU3RhY2tUcmFjZShvdXQsIGdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvcik7XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpc1JwY0Vycm9yUmVzcG9uc2UodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcImNvZGVcIiBpbiB2YWx1ZSAmJiBcIm1lc3NhZ2VcIiBpbiB2YWx1ZSAmJiAodHlwZW9mIHZhbHVlLmNvZGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlLmNvZGUgPT09IFwiYmlnaW50XCIpICYmIHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09PSBcInN0cmluZ1wiO1xufVxuXG5leHBvcnQgeyBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERUQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRkFJTEVEX1RPX0RFQ09ERV9BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19GQUlMRURfVE9fRklORF9WSUFCTEVfUERBX0JVTVBfU0VFRCwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQkFTRTU4X0VOQ09ERURfQUREUkVTUywgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0VEMjU1MTlfUFVCTElDX0tFWSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfT0ZGX0NVUlZFX0FERFJFU1MsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFMRk9STUVEX1BEQSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9OVU1CRVJfT0ZfUERBX1NFRURTX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRCwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9CVU1QX1NFRURfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SUywgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1pFUk9fVkFMVUVfVE9fTUFUQ0hfSVRFTV9GSVhFRF9TSVpFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0RJU0NSSU1JTkFURURfVU5JT05fVkFSSUFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5ULCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNUywgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLCBTT0xBTkFfRVJST1JfX0NPREVDU19fVU5JT05fVkFSSUFOVF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ1JZUFRPX19SQU5ET01fVkFMVUVTX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQUxSRUFEWV9JTklUSUFMSVpFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1NJWkVfQ0hBTkdFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1RPT19TTUFMTCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FSSVRITUVUSUNfT1ZFUkZMT1csIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRILCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DT01QVVRBVElPTkFMX0JVREdFVF9FWENFRURFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9JTkRFWCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfT1VUX09GX1NZTkMsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfREFUQV9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9EQVRBX01PRElGSUVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0dFTkVSSUNfRVJST1IsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lMTEVHQUxfT1dORVIsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX0FVVEhPUklUWSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX1BST0dSQU1fSUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0RBVEEsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9PV05FUiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BUkdVTUVOVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9FUlJPUiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9JTlNUUlVDVElPTl9EQVRBLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0MsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfU0VFRFMsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9JTlNUUlVDVElPTl9UUkFDRV9MRU5HVEhfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9TRUVEX0xFTkdUSF9FWENFRURFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX1JFUVVJUkVEX1NJR05BVFVSRSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTU9ESUZJRURfUFJPR1JBTV9JRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVMsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BSSVZJTEVHRV9FU0NBTEFUSU9OLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0VOVklST05NRU5UX1NFVFVQX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9EQVRBX01PRElGSUVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVFTlRSQU5DWV9OT1RfQUxMT1dFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVOVF9FUE9DSF9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9TWVNWQVIsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfQUNDT1VOVFMsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfREFUQSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19JTlZBTElEX0JMT0NLSEFTSF9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19JTlZBTElEX05PTkNFLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lORywgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX01VU1RfTk9UX1BPTExfQkVGT1JFX1JFU09MVklOR19FWElTVElOR19NRVNTQUdFX1BST01JU0UsIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX1NUQVRFX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1dJVENIX01VU1RfQkVfRVhIQVVTVElWRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5URVJOQUxfRVJST1IsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1QsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX01FVEhPRF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TQ0FOX0VSUk9SLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVgsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVELCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFksIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04sIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWSwgU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9CSUdJTlRfU1RSSU5HLCBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUiwgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfTlVNQkVSX1NUUklORywgU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTiwgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DTE9TRURfQkVGT1JFX01FU1NBR0VfQlVGRkVSRUQsIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ09OTkVDVElPTl9DTE9TRUQsIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1QsIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0VYUEVDVEVEX1NFUlZFUl9TVUJTQ1JJUFRJT05fSUQsIFNPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9ELCBTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPVywgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SLCBTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUywgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX0tFWV9QQUlSX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfTU9ESUZZSU5HX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJfTUlTU0lORywgU09MQU5BX0VSUk9SX19TSUdORVJfX1dBTExFVF9NVUxUSVNJR05fVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVksIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElHRVNUX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElTQUxMT1dFRF9JTl9JTlNFQ1VSRV9DT05URVhULCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRVhQT1JUX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fR0VORVJBVEVfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fVkVSSUZZX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fVElNRVNUQU1QX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfSU5fVVNFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0xPQURFRF9UV0lDRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FERFJFU1NfTE9PS1VQX1RBQkxFX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUxSRUFEWV9QUk9DRVNTRUQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0JMT0NLSEFTSF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NBTExfQ0hBSU5fVE9PX0RFRVAsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9GRUUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0ZPUl9GRUUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9JTkRFWCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUFJPR1JBTV9GT1JfRVhFQ1VUSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1JFTlRfUEFZSU5HX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUFYX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01JU1NJTkdfU0lHTkFUVVJFX0ZPUl9GRUUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fQUNDT1VOVF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1JFU0FOSVRJWkFUSU9OX05FRURFRCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0FOSVRJWkVfRkFJTFVSRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0lHTkFUVVJFX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1MsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfVFJBTlNBQ1RJT04sIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV04sIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT04sIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfVE9UQUxfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQUNDT1VOVF9DT1NUX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfVk9URV9DT1NUX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fVFJBTlNBQ1RJT04sIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQ0FOTk9UX0VOQ09ERV9XSVRIX0VNUFRZX1NJR05BVFVSRVMsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYQ0VFRFNfU0laRV9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9DT05URU5UU19NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1dIRU5fU0lNVUxBVElOR19UT19FU1RJTUFURV9DT01QVVRFX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9JTlNUUlVDVElPTlNfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0UsIFNvbGFuYUVycm9yLCBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yLCBnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IsIGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IsIGlzU29sYW5hRXJyb3IsIHNhZmVDYXB0dXJlU3RhY2tUcmFjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0UiLCJTT0xBTkFfRVJST1JfX05PTkNFX0FDQ09VTlRfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19CTE9DS0hBU0hfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19MQU1QT1JUU19PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9CSUdJTlRfU1RSSU5HIiwiU09MQU5BX0VSUk9SX19NQUxGT1JNRURfTlVNQkVSX1NUUklORyIsIlNPTEFOQV9FUlJPUl9fVElNRVNUQU1QX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0pTT05fUlBDX0VSUk9SIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1IiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04iLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TQ0FOX0VSUk9SIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVgiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQkFTRTU4X0VOQ09ERURfQUREUkVTUyIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0VEMjU1MTlfUFVCTElDX0tFWSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9CVU1QX1NFRURfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9OVU1CRVJfT0ZfUERBX1NFRURTX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19GQUlMRURfVE9fRklORF9WSUFCTEVfUERBX0JVTVBfU0VFRCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVIiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTUyIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRkFJTEVEX1RPX0RFQ09ERV9BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfREVDT0RFRF9BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJU0FMTE9XRURfSU5fSU5TRUNVUkVfQ09OVEVYVCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElHRVNUX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVkiLCJTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVkiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04iLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19HRU5FUklDX0VSUk9SIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BUkdVTUVOVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1RPT19TTUFMTCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EUyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX0lOU1RSVUNUSU9OIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTU9ESUZJRURfUFJPR1JBTV9JRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfTEFNUE9SVF9TUEVORCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0xBTVBPUlRfQ0hBTkdFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19OT1RfRU5PVUdIX0FDQ09VTlRfS0VZUyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9FWEVDVVRBQkxFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkciLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9PVVRfT0ZfU1lOQyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1IiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0xBTVBPUlRfQ0hBTkdFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1BST0dSQU1fSUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRIIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVFTlRSQU5DWV9OT1RfQUxMT1dFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9TRUVEX0xFTkdUSF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfU0VFRFMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0MiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DT01QVVRBVElPTkFMX0JVREdFVF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BSSVZJTEVHRV9FU0NBTEFUSU9OIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU1NVVRBQkxFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX0FVVEhPUklUWSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVIiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfU1lTVkFSIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFMiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fQUREUkVTU19DQU5OT1RfSEFWRV9NVUxUSVBMRV9TSUdORVJTIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX0tFWV9QQUlSX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9DQU5OT1RfSEFWRV9NVUxUSVBMRV9TRU5ESU5HX1NJR05FUlMiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19XQUxMRVRfTVVMVElTSUdOX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX0NBTk5PVF9QQVlfRkVFUyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1ZFUlNJT05fTlVNQkVSX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1NJR05BVFVSRVNfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9JTlNUUlVDVElPTlNfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fRklSU1RfSU5TVFJVQ1RJT05fTVVTVF9CRV9BRFZBTkNFX05PTkNFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQ0FOTk9UX0VOQ09ERV9XSVRIX0VNUFRZX1NJR05BVFVSRVMiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYQ0VFRFNfU0laRV9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTE9BREVEX1RXSUNFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9GRUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfRk9SX0ZFRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NBTExfQ0hBSU5fVE9PX0RFRVAiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0lOREVYIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0lHTkFUVVJFX0ZBSUxVUkUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DTFVTVEVSX01BSU5URU5BTkNFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9WRVJTSU9OIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9XUklUQUJMRV9BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9BQ0NPVU5UX0NPU1RfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX0JMT0NLX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVE9PX01BTllfQUNDT1VOVF9MT0NLUyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FERFJFU1NfTE9PS1VQX1RBQkxFX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfT1dORVIiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0RBVEEiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX1RPVEFMX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5UIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUFYX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERUQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9UUkFOU0FDVElPTiIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVkiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9FTlVNX1ZBUklBTlQiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fVU5JT05fVkFSSUFOVF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9DT05TVEFOVCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SUyIsIlNPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XIiwiU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0hFQURFUl9GT1JCSURERU4iLCJTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfRVJST1IiLCJTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRCIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU4iLCJTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19FWFBFQ1RFRF9TRVJWRVJfU1VCU0NSSVBUSU9OX0lEIiwiU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DTE9TRURfQkVGT1JFX01FU1NBR0VfQlVGRkVSRUQiLCJTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VEIiwiU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9GQUlMRURfVE9fQ09OTkVDVCIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX1NUQVRFX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9NVVNUX05PVF9QT0xMX0JFRk9SRV9SRVNPTFZJTkdfRVhJU1RJTkdfTUVTU0FHRV9QUk9NSVNFIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19DQUNIRURfQUJPUlRBQkxFX0lURVJBQkxFX0NBQ0hFX0VOVFJZX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUiLCJTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0RBVEFfUFVCTElTSEVSX0NIQU5ORUxfVU5JTVBMRU1FTlRFRCIsImVuY29kZVZhbHVlIiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJjb21tYVNlcGFyYXRlZFZhbHVlcyIsIm1hcCIsImpvaW4iLCJlbmNvZGVVUklDb21wb25lbnQiLCJTdHJpbmciLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImVuY29kZU9iamVjdENvbnRleHRFbnRyeSIsImtleSIsImVuY29kZUNvbnRleHRPYmplY3QiLCJjb250ZXh0Iiwic2VhcmNoUGFyYW1zU3RyaW5nIiwiZW50cmllcyIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIlNvbGFuYUVycm9yTWVzc2FnZXMiLCJTVEFSVF9JTkRFWCIsIlRZUEUiLCJnZXRIdW1hblJlYWRhYmxlRXJyb3JNZXNzYWdlIiwiY29kZSIsIm1lc3NhZ2VGb3JtYXRTdHJpbmciLCJsZW5ndGgiLCJzdGF0ZSIsImNvbW1pdFN0YXRlVXBUbyIsImVuZEluZGV4IiwidmFyaWFibGVOYW1lIiwic2xpY2UiLCJmcmFnbWVudHMiLCJwdXNoIiwic3BsaXQiLCJmb3JFYWNoIiwiY2hhciIsImlpIiwibmV4dFN0YXRlIiwibWF0Y2giLCJnZXRFcnJvck1lc3NhZ2UiLCJwcm9jZXNzIiwiZGVjb2RpbmdBZHZpY2VNZXNzYWdlIiwia2V5cyIsImlzU29sYW5hRXJyb3IiLCJlIiwiaXNTb2xhbmFFcnJvcjIiLCJFcnJvciIsIm5hbWUiLCJfX2NvZGUiLCJTb2xhbmFFcnJvciIsImNvbnN0cnVjdG9yIiwiY29udGV4dEFuZEVycm9yT3B0aW9ucyIsImVycm9yT3B0aW9ucyIsImNhdXNlIiwiY29udGV4dFJlc3QiLCJtZXNzYWdlIiwic2FmZUNhcHR1cmVTdGFja1RyYWNlIiwiYXJncyIsImNhcHR1cmVTdGFja1RyYWNlIiwiZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IiLCJlcnJvckNvZGVCYXNlT2Zmc2V0IiwiZ2V0RXJyb3JDb250ZXh0Iiwib3JkZXJlZEVycm9yTmFtZXMiLCJycGNFbnVtRXJyb3IiLCJjb25zdHJ1Y3Rvck9wdCIsInJwY0Vycm9yTmFtZSIsInJwY0Vycm9yQ29udGV4dCIsImNvZGVPZmZzZXQiLCJpbmRleE9mIiwiZXJyb3JDb2RlIiwiZXJyb3JDb250ZXh0IiwiZXJyIiwiT1JERVJFRF9FUlJPUl9OQU1FUyIsImdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3IiLCJpbmRleCIsImluc3RydWN0aW9uRXJyb3IiLCJudW1iZXJJbmRleCIsIk51bWJlciIsImVycm9yTmFtZSIsImluc3RydWN0aW9uRXJyb3JDb250ZXh0IiwiZW5jb2RlZERhdGEiLCJPUkRFUkVEX0VSUk9SX05BTUVTMiIsImdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IiLCJ0cmFuc2FjdGlvbkVycm9yIiwiSW5zdHJ1Y3Rpb25FcnJvciIsInRyYW5zYWN0aW9uRXJyb3JDb250ZXh0IiwiYWNjb3VudEluZGV4IiwiYWNjb3VudF9pbmRleCIsImdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvciIsInB1dGF0aXZlRXJyb3JSZXNwb25zZSIsIm91dCIsImlzUnBjRXJyb3JSZXNwb25zZSIsInJhd0NvZGUiLCJkYXRhIiwicHJlZmxpZ2h0RXJyb3JDb250ZXh0IiwiY2F1c2VPYmplY3QiLCJfX3NlcnZlck1lc3NhZ2UiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs\n");

/***/ })

};
;