"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@adraffy";
exports.ids = ["vendor-chunks/@adraffy"];
exports.modules = {

/***/ "(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: () => (/* binding */ ens_beautify),\n/* harmony export */   ens_emoji: () => (/* binding */ ens_emoji),\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_fragment: () => (/* binding */ ens_normalize_fragment),\n/* harmony export */   ens_split: () => (/* binding */ ens_split),\n/* harmony export */   ens_tokenize: () => (/* binding */ ens_tokenize),\n/* harmony export */   is_combining_mark: () => (/* binding */ is_combining_mark),\n/* harmony export */   nfc: () => (/* binding */ nfc),\n/* harmony export */   nfd: () => (/* binding */ nfd),\n/* harmony export */   safe_str_from_cps: () => (/* binding */ safe_str_from_cps),\n/* harmony export */   should_escape: () => (/* binding */ should_escape)\n/* harmony export */ });\n// created 2025-09-14T17:56:24.099Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 92cbf3a1af3c3c0a91aee0dc542072775f4ebbbc526a84189a12da2d56f5accd\nvar COMPRESSED$1 = \"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\";\nconst FENCED = new Map([\n    [\n        8217,\n        \"apostrophe\"\n    ],\n    [\n        8260,\n        \"fraction slash\"\n    ],\n    [\n        12539,\n        \"middle dot\"\n    ]\n]);\nconst NSM_MAX = 4;\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = 2 ** N;\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(s) {\n    return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n    let lookup = [];\n    [\n        ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    ].forEach((c, i)=>lookup[c.charCodeAt(0)] = i);\n    let n = s.length;\n    let ret = new Uint8Array(6 * n >> 3);\n    for(let i = 0, pos = 0, width = 0, carry = 0; i < n; i++){\n        carry = carry << 6 | lookup[s.charCodeAt(i)];\n        width += 6;\n        if (width >= 8) {\n            ret[pos++] = carry >> (width -= 8);\n        }\n    }\n    return ret;\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next, prev = 0) {\n    let ret = [];\n    while(true){\n        let x = next();\n        let n = next();\n        if (!n) break;\n        prev += x;\n        for(let i = 0; i < n; i++){\n            ret.push(prev + i);\n        }\n        prev += n + 1;\n    }\n    return ret;\n}\nfunction read_sorted_arrays(next) {\n    return read_array_while(()=>{\n        let v = read_sorted(next);\n        if (v.length) return v;\n    });\n}\n// returns map of x => ys\nfunction read_mapped(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return ret.flat();\n}\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n    let v = [];\n    while(true){\n        let x = next(v.length);\n        if (!x) break;\n        v.push(x);\n    }\n    return v;\n}\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill().map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_array_while(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return m.flatMap((v, i)=>{\n        let [x, ...ys] = v;\n        return Array(vN[i]).fill().map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    });\n}\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\nfunction read_trie(next) {\n    let ret = [];\n    let sorted = read_sorted(next);\n    expand(decode([]), []);\n    return ret; // not sorted\n    function decode(Q) {\n        let S = next(); // state: valid, save, check\n        let B = read_array_while(()=>{\n            let cps = read_sorted(next).map((i)=>sorted[i]);\n            if (cps.length) return decode(cps);\n        });\n        return {\n            S,\n            B,\n            Q\n        };\n    }\n    function expand({ S, B }, cps, saved) {\n        if (S & 4 && saved === cps[cps.length - 1]) return;\n        if (S & 2) saved = cps[cps.length - 1];\n        if (S & 1) ret.push(cps);\n        for (let br of B){\n            for (let cp of br.Q){\n                expand(br, [\n                    ...cps,\n                    cp\n                ], saved);\n            }\n        }\n    }\n}\nfunction hex_cp(cp) {\n    return cp.toString(16).toUpperCase().padStart(2, \"0\");\n}\nfunction quote_cp(cp) {\n    return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/ function explode_cp(s) {\n    let cps = [];\n    for(let pos = 0, len = s.length; pos < len;){\n        let cp = s.codePointAt(pos);\n        pos += cp < 0x10000 ? 1 : 2;\n        cps.push(cp);\n    }\n    return cps;\n}\nfunction str_from_cps(cps) {\n    const chunk = 4096;\n    let len = cps.length;\n    if (len < chunk) return String.fromCodePoint(...cps);\n    let buf = [];\n    for(let i = 0; i < len;){\n        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n    }\n    return buf.join(\"\");\n}\nfunction compare_arrays(a, b) {\n    let n = a.length;\n    let c = n - b.length;\n    for(let i = 0; c == 0 && i < n; i++)c = a[i] - b[i];\n    return c;\n}\nfunction array_replace(v, a, b) {\n    let prev = 0;\n    while(true){\n        let next = v.indexOf(a, prev);\n        if (next < 0) break;\n        v[next] = b;\n        prev = next + 1;\n    }\n}\n// created 2025-09-14T17:56:24.099Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 9ef43cc7215aa7a53e4ed9afa3b4f2f8ce00a2c708b9eb96aa409ae6fa3fb6af\nvar COMPRESSED = \"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\";\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction unpack_cc(packed) {\n    return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n    return packed & 0xFFFFFF;\n}\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\n// export function nf_deinit() {\n// \tif (!SHIFTED_RANK) return;\n// \tSHIFTED_RANK = EXCLUSIONS = DECOMP = RECOMP = undefined;\n// }\nfunction init$1() {\n    //console.time('nf');\n    let r = read_compressed_payload(COMPRESSED);\n    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i)=>v.map((x)=>[\n                x,\n                i + 1 << 24\n            ]))); // pre-shifted\n    EXCLUSIONS = new Set(read_sorted(r));\n    DECOMP = new Map();\n    RECOMP = new Map();\n    for (let [cp, cps] of read_mapped(r)){\n        if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n            let [a, b] = cps;\n            let bucket = RECOMP.get(a);\n            if (!bucket) {\n                bucket = new Map();\n                RECOMP.set(a, bucket);\n            }\n            bucket.set(b, cp);\n        }\n        DECOMP.set(cp, cps.reverse()); // stored reversed\n    }\n//console.timeEnd('nf');\n// 20230905: 11ms\n}\nfunction is_hangul(cp) {\n    return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n    if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n    } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n        return a + (b - T0);\n    } else {\n        let recomp = RECOMP.get(a);\n        if (recomp) {\n            recomp = recomp.get(b);\n            if (recomp) {\n                return recomp;\n            }\n        }\n        return -1;\n    }\n}\nfunction decomposed(cps) {\n    if (!SHIFTED_RANK) init$1();\n    let ret = [];\n    let buf = [];\n    let check_order = false;\n    function add(cp) {\n        let cc = SHIFTED_RANK.get(cp);\n        if (cc) {\n            check_order = true;\n            cp |= cc;\n        }\n        ret.push(cp);\n    }\n    for (let cp of cps){\n        while(true){\n            if (cp < 0x80) {\n                ret.push(cp);\n            } else if (is_hangul(cp)) {\n                let s_index = cp - S0;\n                let l_index = s_index / N_COUNT | 0;\n                let v_index = s_index % N_COUNT / T_COUNT | 0;\n                let t_index = s_index % T_COUNT;\n                add(L0 + l_index);\n                add(V0 + v_index);\n                if (t_index > 0) add(T0 + t_index);\n            } else {\n                let mapped = DECOMP.get(cp);\n                if (mapped) {\n                    buf.push(...mapped);\n                } else {\n                    add(cp);\n                }\n            }\n            if (!buf.length) break;\n            cp = buf.pop();\n        }\n    }\n    if (check_order && ret.length > 1) {\n        let prev_cc = unpack_cc(ret[0]);\n        for(let i = 1; i < ret.length; i++){\n            let cc = unpack_cc(ret[i]);\n            if (cc == 0 || prev_cc <= cc) {\n                prev_cc = cc;\n                continue;\n            }\n            let j = i - 1;\n            while(true){\n                let tmp = ret[j + 1];\n                ret[j + 1] = ret[j];\n                ret[j] = tmp;\n                if (!j) break;\n                prev_cc = unpack_cc(ret[--j]);\n                if (prev_cc <= cc) break;\n            }\n            prev_cc = unpack_cc(ret[i]);\n        }\n    }\n    return ret;\n}\nfunction composed_from_decomposed(v) {\n    let ret = [];\n    let stack = [];\n    let prev_cp = -1;\n    let prev_cc = 0;\n    for (let packed of v){\n        let cc = unpack_cc(packed);\n        let cp = unpack_cp(packed);\n        if (prev_cp == -1) {\n            if (cc == 0) {\n                prev_cp = cp;\n            } else {\n                ret.push(cp);\n            }\n        } else if (prev_cc > 0 && prev_cc >= cc) {\n            if (cc == 0) {\n                ret.push(prev_cp, ...stack);\n                stack.length = 0;\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n            }\n            prev_cc = cc;\n        } else {\n            let composed = compose_pair(prev_cp, cp);\n            if (composed >= 0) {\n                prev_cp = composed;\n            } else if (prev_cc == 0 && cc == 0) {\n                ret.push(prev_cp);\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n                prev_cc = cc;\n            }\n        }\n    }\n    if (prev_cp >= 0) {\n        ret.push(prev_cp, ...stack);\n    }\n    return ret;\n}\n// note: cps can be iterable\nfunction nfd(cps) {\n    return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n    return composed_from_decomposed(decomposed(cps));\n}\nconst HYPHEN = 0x2D;\nconst STOP = 0x2E;\nconst STOP_CH = \".\";\nconst FE0F = 0xFE0F;\nconst UNIQUE_PH = 1;\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\nconst Array_from = (x)=>Array.from(x); // Array.from.bind(Array);\nfunction group_has_cp(g, cp) {\n    // 20230913: keep primary and secondary distinct instead of creating valid union\n    return g.P.has(cp) || g.Q.has(cp);\n}\nclass Emoji extends Array {\n    get is_emoji() {\n        return true;\n    }\n}\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\n// export function ens_deinit() {\n// \tnf_deinit();\n// \tif (!MAPPED) return;\n// \tMAPPED = IGNORED = CM = NSM = ESCAPE = NFC_CHECK = GROUPS = WHOLE_VALID = WHOLE_MAP = VALID = EMOJI_LIST = EMOJI_ROOT = undefined;\n// }\nfunction init() {\n    if (MAPPED) return;\n    let r = read_compressed_payload(COMPRESSED$1);\n    const read_sorted_array = ()=>read_sorted(r);\n    const read_sorted_set = ()=>new Set(read_sorted_array());\n    const set_add_many = (set, v)=>v.forEach((x)=>set.add(x));\n    MAPPED = new Map(read_mapped(r));\n    IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\n    /*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/ // 20230217: we still need all CM for proper error formatting\n    // but norm only needs NSM subset that are potentially-valid\n    CM = read_sorted_array();\n    NSM = new Set(read_sorted_array().map((i)=>CM[i]));\n    CM = new Set(CM);\n    ESCAPE = read_sorted_set(); // characters that should not be printed\n    NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\n    let chunks = read_sorted_arrays(r);\n    let unrestricted = r();\n    //const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\n    const read_chunked = ()=>{\n        // 20230921: build set in parts, 2x faster\n        let set = new Set();\n        read_sorted_array().forEach((i)=>set_add_many(set, chunks[i]));\n        set_add_many(set, read_sorted_array());\n        return set;\n    };\n    GROUPS = read_array_while((i)=>{\n        // minifier property mangling seems unsafe\n        // so these are manually renamed to single chars\n        let N = read_array_while(r).map((x)=>x + 0x60);\n        if (N.length) {\n            let R = i >= unrestricted; // unrestricted then restricted\n            N[0] -= 32; // capitalize\n            N = str_from_cps(N);\n            if (R) N = `Restricted[${N}]`;\n            let P = read_chunked(); // primary\n            let Q = read_chunked(); // secondary\n            let M = !r(); // not-whitelisted, check for NSM\n            // *** this code currently isn't needed ***\n            /*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/ return {\n                N,\n                P,\n                Q,\n                M,\n                R\n            };\n        }\n    });\n    // decode compressed wholes\n    WHOLE_VALID = read_sorted_set();\n    WHOLE_MAP = new Map();\n    let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b)=>a - b); // must be sorted\n    wholes.forEach((cp, i)=>{\n        let d = r();\n        let w = wholes[i] = d ? wholes[i - d] : {\n            V: [],\n            M: new Map()\n        };\n        w.V.push(cp); // add to member set\n        if (!WHOLE_VALID.has(cp)) {\n            WHOLE_MAP.set(cp, w); // register with whole map\n        }\n    });\n    // compute confusable-extent complements\n    // usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\n    for (let { V, M } of new Set(WHOLE_MAP.values())){\n        // connect all groups that have each whole character\n        let recs = [];\n        for (let cp of V){\n            let gs = GROUPS.filter((g)=>group_has_cp(g, cp));\n            let rec = recs.find(({ G })=>gs.some((g)=>G.has(g)));\n            if (!rec) {\n                rec = {\n                    G: new Set(),\n                    V: []\n                };\n                recs.push(rec);\n            }\n            rec.V.push(cp);\n            set_add_many(rec.G, gs);\n        }\n        // per character cache groups which are not a member of the extent\n        let union = recs.flatMap((x)=>Array_from(x.G)); // all of the groups used by this whole\n        for (let { G, V } of recs){\n            let complement = new Set(union.filter((g)=>!G.has(g))); // groups not covered by the extent\n            for (let cp of V){\n                M.set(cp, complement); // this is the same reference\n            }\n        }\n    }\n    // compute valid set\n    // 20230924: VALID was union but can be re-used\n    VALID = new Set(); // exists in 1+ groups\n    let multi = new Set(); // exists in 2+ groups\n    const add_to_union = (cp)=>VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\n    for (let g of GROUPS){\n        for (let cp of g.P)add_to_union(cp);\n        for (let cp of g.Q)add_to_union(cp);\n    }\n    // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n    for (let cp of VALID){\n        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n            WHOLE_MAP.set(cp, UNIQUE_PH);\n        }\n    }\n    // add all decomposed parts\n    // see derive: \"Valid is Closed (via Brute-force)\"\n    set_add_many(VALID, nfd(VALID));\n    // decode emoji\n    // 20230719: emoji are now fully-expanded to avoid quirk logic \n    EMOJI_LIST = read_trie(r).map((v)=>Emoji.from(v)).sort(compare_arrays);\n    EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\n    for (let cps of EMOJI_LIST){\n        // 20230719: change to *slightly* stricter algorithm which disallows \n        // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n        // example: beautified [A B] (eg. flag emoji) \n        //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n        //   after: error: both\n        // note: this code now matches ENSNormalize.{cs,java} logic\n        let prev = [\n            EMOJI_ROOT\n        ];\n        for (let cp of cps){\n            let next = prev.map((node)=>{\n                let child = node.get(cp);\n                if (!child) {\n                    // should this be object? \n                    // (most have 1-2 items, few have many)\n                    // 20230719: no, v8 default map is 4?\n                    child = new Map();\n                    node.set(cp, child);\n                }\n                return child;\n            });\n            if (cp === FE0F) {\n                prev.push(...next); // less than 20 elements\n            } else {\n                prev = next;\n            }\n        }\n        for (let x of prev){\n            x.V = cps;\n        }\n    }\n}\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n    return (should_escape(cp) ? \"\" : `${bidi_qq(safe_str_from_cps([\n        cp\n    ]))} `) + quote_cp(cp);\n}\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n    return `\"${s}\"\\u200E`; // strong LTR\n}\nfunction check_label_extension(cps) {\n    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n        throw new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\n    }\n}\nfunction check_leading_underscore(cps) {\n    const UNDERSCORE = 0x5F;\n    for(let i = cps.lastIndexOf(UNDERSCORE); i > 0;){\n        if (cps[--i] !== UNDERSCORE) {\n            throw new Error(\"underscore allowed only at start\");\n        }\n    }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n    let cp = cps[0];\n    let prev = FENCED.get(cp);\n    if (prev) throw error_placement(`leading ${prev}`);\n    let n = cps.length;\n    let last = -1; // prevents trailing from throwing\n    for(let i = 1; i < n; i++){\n        cp = cps[i];\n        let match = FENCED.get(cp);\n        if (match) {\n            // since cps[0] isn't fenced, cps[1] cannot throw\n            if (last == i) throw error_placement(`${prev} + ${match}`);\n            last = i + 1;\n            prev = match;\n        }\n    }\n    if (last == n) throw error_placement(`trailing ${prev}`);\n}\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// if cps exceed max, middle truncate with ellipsis\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\n    //if (Number.isInteger(cps)) cps = [cps];\n    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n    let buf = [];\n    if (is_combining_mark(cps[0])) buf.push(\"\");\n    if (cps.length > max) {\n        max >>= 1;\n        cps = [\n            ...cps.slice(0, max),\n            0x2026,\n            ...cps.slice(-max)\n        ];\n    }\n    let prev = 0;\n    let n = cps.length;\n    for(let i = 0; i < n; i++){\n        let cp = cps[i];\n        if (should_escape(cp)) {\n            buf.push(str_from_cps(cps.slice(prev, i)));\n            buf.push(quoter(cp));\n            prev = i + 1;\n        }\n    }\n    buf.push(str_from_cps(cps.slice(prev, n)));\n    return buf.join(\"\");\n}\n// note: set(s) cannot be exposed because they can be modified\n// note: Object.freeze() doesn't work\nfunction is_combining_mark(cp, only_nsm) {\n    init();\n    return only_nsm ? NSM.has(cp) : CM.has(cp);\n}\nfunction should_escape(cp) {\n    init();\n    return ESCAPE.has(cp);\n}\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n    init();\n    return EMOJI_LIST.map((x)=>x.slice()); // emoji are exposed so copy\n}\nfunction ens_normalize_fragment(frag, decompose) {\n    init();\n    let nf = decompose ? nfd : nfc;\n    return frag.split(STOP_CH).map((label)=>str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n    return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n    let labels = split(name, nfc, (x)=>x); // emoji not exposed\n    for (let { type, output, error } of labels){\n        if (error) break; // flatten will throw\n        // replace leading/trailing hyphen\n        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n        // not exactly the same in every font, but very similar: \"-\" vs \"\"\n        /*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/ // 20230123: WHATWG URL uses \"CheckHyphens\" false\n        // https://url.spec.whatwg.org/#idna\n        // update ethereum symbol\n        //  =>  if not greek\n        if (type !== \"Greek\") array_replace(output, 0x3BE, 0x39E);\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\n    //output.splice(0, 0, 0x200E);\n    }\n    return flatten(labels);\n}\nfunction ens_split(name, preserve_emoji) {\n    return split(name, nfc, preserve_emoji ? (x)=>x.slice() : filter_fe0f); // emoji are exposed so copy\n}\nfunction split(name, nf, ef) {\n    if (!name) return []; // 20230719: empty name allowance\n    init();\n    let offset = 0;\n    // https://unicode.org/reports/tr46/#Validity_Criteria\n    // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n    return name.split(STOP_CH).map((label)=>{\n        let input = explode_cp(label);\n        let info = {\n            input,\n            offset\n        };\n        offset += input.length + 1; // + stop\n        try {\n            // 1.) \"The label must be in Unicode Normalization Form NFC\"\n            let tokens = info.tokens = tokens_from_str(input, nf, ef);\n            let token_count = tokens.length;\n            let type;\n            if (!token_count) {\n                //norm = [];\n                //type = 'None'; // use this instead of next match, \"ASCII\"\n                // 20230120: change to strict\n                // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n                throw new Error(`empty label`);\n            }\n            let norm = info.output = tokens.flat();\n            check_leading_underscore(norm);\n            let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\n            if (!emoji && norm.every((cp)=>cp < 0x80)) {\n                // 20230123: matches matches WHATWG, see note 3.3\n                check_label_extension(norm); // only needed for ascii\n                // cant have fenced\n                // cant have cm\n                // cant have wholes\n                // see derive: \"Fastpath ASCII\"\n                type = \"ASCII\";\n            } else {\n                let chars = tokens.flatMap((x)=>x.is_emoji ? [] : x); // all of the nfc tokens concat together\n                if (!chars.length) {\n                    type = \"Emoji\";\n                } else {\n                    // 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n                    if (CM.has(norm[0])) throw error_placement(\"leading combining mark\");\n                    for(let i = 1; i < token_count; i++){\n                        let cps = tokens[i];\n                        if (!cps.is_emoji && CM.has(cps[0])) {\n                            // bidi_qq() not needed since emoji is LTR and cps is a CM\n                            throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([\n                                cps[0]\n                            ])}\"`);\n                        }\n                    }\n                    check_fenced(norm);\n                    let unique = Array_from(new Set(chars));\n                    let [g] = determine_group(unique); // take the first match\n                    // see derive: \"Matching Groups have Same CM Style\"\n                    // alternative: could form a hybrid type: Latin/Japanese/...\t\n                    check_group(g, chars); // need text in order\n                    check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n                    type = g.N;\n                // 20230121: consider exposing restricted flag\n                // it's simpler to just check for 'Restricted'\n                // or even better: type.endsWith(']')\n                //if (g.R) info.restricted = true;\n                }\n            }\n            info.type = type;\n        } catch (err) {\n            info.error = err; // use full error object\n        }\n        return info;\n    });\n}\nfunction check_whole(group, unique) {\n    let maker;\n    let shared = [];\n    for (let cp of unique){\n        let whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return; // unique, non-confusable\n        if (whole) {\n            let set = whole.M.get(cp); // groups which have a character that look-like this character\n            maker = maker ? maker.filter((g)=>set.has(g)) : Array_from(set);\n            if (!maker.length) return; // confusable intersection is empty\n        } else {\n            shared.push(cp);\n        }\n    }\n    if (maker) {\n        // we have 1+ confusable\n        // check if any of the remaining groups\n        // contain the shared characters too\n        for (let g of maker){\n            if (shared.every((cp)=>group_has_cp(g, cp))) {\n                throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n            }\n        }\n    }\n}\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n    let groups = GROUPS;\n    for (let cp of unique){\n        // note: we need to dodge CM that are whitelisted\n        // but that code isn't currently necessary\n        let gs = groups.filter((g)=>group_has_cp(g, cp));\n        if (!gs.length) {\n            if (!GROUPS.some((g)=>group_has_cp(g, cp))) {\n                // the character was composed of valid parts\n                // but it's NFC form is invalid\n                // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n                // note: this doesn't have to be a composition\n                // 20230720: change to full check\n                throw error_disallowed(cp); // this should be rare\n            } else {\n                // there is no group that contains all these characters\n                // throw using the highest priority group that matched\n                // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n                throw error_group_member(groups[0], cp);\n            }\n        }\n        groups = gs;\n        if (gs.length == 1) break; // there is only one group left\n    }\n    // there are at least 1 group(s) with all of these characters\n    return groups;\n}\n// throw on first error\nfunction flatten(split) {\n    return split.map(({ input, error, output })=>{\n        if (error) {\n            // don't print label again if just a single label\n            let msg = error.message;\n            // bidi_qq() only necessary if msg is digits\n            throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);\n        }\n        return str_from_cps(output);\n    }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n    // TODO: add cp to error?\n    return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n    let quoted = quoted_cp(cp);\n    let gg = GROUPS.find((g)=>g.P.has(cp)); // only check primary\n    if (gg) {\n        quoted = `${gg.N} ${quoted}`;\n    }\n    return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n    return new Error(`illegal placement: ${where}`);\n}\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n    for (let cp of cps){\n        if (!group_has_cp(g, cp)) {\n            // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n            // at the moment, it's unnecessary to introduce an extra error type\n            // until there exists a whitelisted multi-character\n            //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n            // there are 3 cases:\n            //   1. illegal cm for wrong group => mixture error\n            //   2. illegal cm for same group => cm error\n            //       requires set of whitelist cm per group: \n            //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\n            //   3. wrong group => mixture error\n            throw error_group_member(g, cp);\n        }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n    if (g.M) {\n        let decomposed = nfd(cps);\n        for(let i = 1, e = decomposed.length; i < e; i++){\n            // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n            /*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/ // 20230217: switch to NSM counting\n            // https://www.unicode.org/reports/tr39/#Optional_Detection\n            if (NSM.has(decomposed[i])) {\n                let j = i + 1;\n                for(let cp; j < e && NSM.has(cp = decomposed[j]); j++){\n                    // a. Forbid sequences of the same nonspacing mark.\n                    for(let k = i; k < j; k++){\n                        if (decomposed[k] == cp) {\n                            throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\n                        }\n                    }\n                }\n                // parse to end so we have full nsm count\n                // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n                if (j - i > NSM_MAX) {\n                    // note: this slice starts with a base char or spacing-mark cm\n                    throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);\n                }\n                i = j;\n            }\n        }\n    }\n// *** this code currently isn't needed ***\n/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/ }\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abcd\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\n// 20230818: rename for 'process' name collision h/t Javarome\n// https://github.com/adraffy/ens-normalize.js/issues/23\nfunction tokens_from_str(input, nf, ef) {\n    let ret = [];\n    let chars = [];\n    input = input.slice().reverse(); // flip so we can pop\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            if (chars.length) {\n                ret.push(nf(chars));\n                chars = [];\n            }\n            ret.push(ef(emoji));\n        } else {\n            let cp = input.pop();\n            if (VALID.has(cp)) {\n                chars.push(cp);\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    chars.push(...cps); // less than 10 elements\n                } else if (!IGNORED.has(cp)) {\n                    // 20230912: unicode 15.1 changed the order of processing such that\n                    // disallowed parts are only rejected after NFC\n                    // https://unicode.org/reports/tr46/#Validity_Criteria\n                    // this doesn't impact normalization as of today\n                    // technically, this error can be removed as the group logic will apply similar logic\n                    // however the error type might be less clear\n                    throw error_disallowed(cp);\n                }\n            }\n        }\n    }\n    if (chars.length) {\n        ret.push(nf(chars));\n    }\n    return ret;\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != FE0F);\n}\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n    let node = EMOJI_ROOT;\n    let emoji;\n    let pos = cps.length;\n    while(pos){\n        node = node.get(cps[--pos]);\n        if (!node) break;\n        let { V } = node;\n        if (V) {\n            emoji = V;\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n// ************************************************************\n// tokenizer \nconst TY_VALID = \"valid\";\nconst TY_MAPPED = \"mapped\";\nconst TY_IGNORED = \"ignored\";\nconst TY_DISALLOWED = \"disallowed\";\nconst TY_EMOJI = \"emoji\";\nconst TY_NFC = \"nfc\";\nconst TY_STOP = \"stop\";\nfunction ens_tokenize(name, { nf = true } = {}) {\n    init();\n    let input = explode_cp(name).reverse();\n    let eaten = [];\n    let tokens = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input, eaten);\n        if (emoji) {\n            tokens.push({\n                type: TY_EMOJI,\n                emoji: emoji.slice(),\n                input: eaten,\n                cps: filter_fe0f(emoji)\n            });\n            eaten = []; // reset buffer\n        } else {\n            let cp = input.pop();\n            if (cp == STOP) {\n                tokens.push({\n                    type: TY_STOP,\n                    cp\n                });\n            } else if (VALID.has(cp)) {\n                tokens.push({\n                    type: TY_VALID,\n                    cps: [\n                        cp\n                    ]\n                });\n            } else if (IGNORED.has(cp)) {\n                tokens.push({\n                    type: TY_IGNORED,\n                    cp\n                });\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    tokens.push({\n                        type: TY_MAPPED,\n                        cp,\n                        cps: cps.slice()\n                    });\n                } else {\n                    tokens.push({\n                        type: TY_DISALLOWED,\n                        cp\n                    });\n                }\n            }\n        }\n    }\n    if (nf) {\n        for(let i = 0, start = -1; i < tokens.length; i++){\n            let token = tokens[i];\n            if (is_valid_or_mapped(token.type)) {\n                if (requires_check(token.cps)) {\n                    let end = i + 1;\n                    for(let pos = end; pos < tokens.length; pos++){\n                        let { type, cps } = tokens[pos];\n                        if (is_valid_or_mapped(type)) {\n                            if (!requires_check(cps)) break;\n                            end = pos + 1;\n                        } else if (type !== TY_IGNORED) {\n                            break;\n                        }\n                    }\n                    if (start < 0) start = i;\n                    let slice = tokens.slice(start, end);\n                    let cps0 = slice.flatMap((x)=>is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n                    let cps = nfc(cps0);\n                    if (compare_arrays(cps, cps0)) {\n                        tokens.splice(start, end - start, {\n                            type: TY_NFC,\n                            input: cps0,\n                            cps,\n                            tokens0: collapse_valid_tokens(slice),\n                            tokens: ens_tokenize(str_from_cps(cps), {\n                                nf: false\n                            })\n                        });\n                        i = start;\n                    } else {\n                        i = end - 1; // skip to end of slice\n                    }\n                    start = -1; // reset\n                } else {\n                    start = i; // remember last\n                }\n            } else if (token.type !== TY_IGNORED) {\n                start = -1; // reset\n            }\n        }\n    }\n    return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n    return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n    return cps.some((cp)=>NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n    for(let i = 0; i < tokens.length; i++){\n        if (tokens[i].type == TY_VALID) {\n            let j = i + 1;\n            while(j < tokens.length && tokens[j].type == TY_VALID)j++;\n            tokens.splice(i, j - i, {\n                type: TY_VALID,\n                cps: tokens.slice(i, j).flatMap((x)=>x.cps)\n            });\n        }\n    }\n    return tokens;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLG1DQUFtQztBQUNuQyxzREFBc0Q7QUFDdEQsNEVBQTRFO0FBQzVFLDREQUE0RDtBQUM1RCw0RUFBNEU7QUFDNUUsSUFBSUEsZUFBZTtBQUNuQixNQUFNQyxTQUFTLElBQUlDLElBQUk7SUFBQztRQUFDO1FBQUs7S0FBYTtJQUFDO1FBQUM7UUFBSztLQUFpQjtJQUFDO1FBQUM7UUFBTTtLQUFhO0NBQUM7QUFDekYsTUFBTUMsVUFBVTtBQUVoQixTQUFTQyxrQkFBa0JDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTTtJQUNWLFNBQVNDO1FBQVEsT0FBTyxLQUFNLENBQUNELE1BQU0sSUFBSSxJQUFLRCxLQUFLLENBQUNDLE1BQU07SUFBRTtJQUU1RCw2QkFBNkI7SUFDN0IsSUFBSUUsZUFBZUQ7SUFDbkIsSUFBSUUsUUFBUTtJQUNaLElBQUlDLE1BQU07UUFBQztRQUFHO0tBQUUsRUFBRSwrQkFBK0I7SUFDakQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILGNBQWNHLElBQUs7UUFDdENELElBQUlFLElBQUksQ0FBQ0gsU0FBU0Y7SUFDbkI7SUFFQSw0REFBNEQ7SUFDNUQsSUFBSU0sT0FBT047SUFDWCxJQUFJTyxjQUFjUjtJQUNsQkEsT0FBT087SUFFUCxJQUFJRSxhQUFhO0lBQ2pCLElBQUlDLGNBQWM7SUFDbEIsU0FBU0M7UUFDUixJQUFJRixjQUFjLEdBQUc7WUFDcEIsc0NBQXNDO1lBQ3RDLGdDQUFnQztZQUNoQ0MsY0FBYyxlQUFnQixJQUFLWCxLQUFLLENBQUNDLE1BQU07WUFDL0NTLGFBQWE7UUFDZDtRQUNBLE9BQU8sZUFBZ0IsRUFBRUEsYUFBYztJQUN4QztJQUVBLE1BQU1HLElBQUk7SUFDVixNQUFNQyxPQUFPLEtBQUdEO0lBQ2hCLE1BQU1FLE9BQU9ELFNBQVM7SUFDdEIsTUFBTUUsT0FBT0QsUUFBUTtJQUNyQixNQUFNRSxPQUFPSCxPQUFPO0lBRXBCLGdCQUFnQjtJQUNoQixJQUFJSSxXQUFXO0lBQ2YsSUFBSyxJQUFJWixJQUFJLEdBQUdBLElBQUlPLEdBQUdQLElBQUtZLFdBQVcsWUFBYSxJQUFLTjtJQUV6RCxJQUFJTyxVQUFVLEVBQUU7SUFDaEIsSUFBSUMsTUFBTTtJQUNWLElBQUlDLFFBQVFQLE1BQU0scUJBQXFCO0lBQ3ZDLE1BQU8sS0FBTTtRQUNaLElBQUlRLFFBQVFDLEtBQUtDLEtBQUssQ0FBQyxDQUFDLENBQUVOLFdBQVdFLE1BQU0sS0FBS2hCLFFBQVMsS0FBS2lCO1FBQzlELElBQUlJLFFBQVE7UUFDWixJQUFJQyxNQUFNdkI7UUFDVixNQUFPdUIsTUFBTUQsUUFBUSxFQUFHO1lBQ3ZCLElBQUlFLE1BQU0sUUFBU0QsUUFBUztZQUM1QixJQUFJSixRQUFRakIsR0FBRyxDQUFDc0IsSUFBSSxFQUFFO2dCQUNyQkQsTUFBTUM7WUFDUCxPQUFPO2dCQUNORixRQUFRRTtZQUNUO1FBQ0Q7UUFDQSxJQUFJRixTQUFTLEdBQUcsT0FBTywyQkFBMkI7UUFDbEROLFFBQVFaLElBQUksQ0FBQ2tCO1FBQ2IsSUFBSUcsSUFBSVIsTUFBTUcsS0FBS0MsS0FBSyxDQUFDSCxRQUFRaEIsR0FBRyxDQUFDb0IsTUFBTSxHQUFLckI7UUFDaEQsSUFBSXlCLElBQUlULE1BQU1HLEtBQUtDLEtBQUssQ0FBQ0gsUUFBUWhCLEdBQUcsQ0FBQ29CLFFBQU0sRUFBRSxHQUFHckIsU0FBUztRQUN6RCxNQUFPLENBQUMsQ0FBQ3dCLElBQUlDLENBQUFBLElBQUtkLElBQUcsS0FBTSxFQUFHO1lBQzdCRyxXQUFXLFlBQWEsSUFBS0QsT0FBT0w7WUFDcENnQixJQUFJLEtBQU0sSUFBS1g7WUFDZlksSUFBSSxLQUFNLElBQUtaLE9BQU87UUFDdkI7UUFDQSxNQUFPVyxJQUFJLENBQUNDLElBQUliLEtBQU07WUFDckJFLFdBQVcsV0FBWUgsT0FBUyxZQUFhLElBQU1FLFNBQVMsSUFBTUw7WUFDbEVnQixJQUFJLEtBQU0sSUFBS2I7WUFDZmMsSUFBSSxDQUFFQSxJQUFJZCxJQUFHLEtBQU0sSUFBS0EsT0FBTztRQUNoQztRQUNBSyxNQUFNUTtRQUNOUCxRQUFRLElBQUlRLElBQUlEO0lBQ2pCO0lBQ0EsSUFBSUUsU0FBUzNCLGVBQWU7SUFDNUIsT0FBT2dCLFFBQVFZLEdBQUcsQ0FBQ0MsQ0FBQUE7UUFDbEIsT0FBUUEsSUFBSUY7WUFDWCxLQUFLO2dCQUFHLE9BQU9BLFNBQVMsVUFBVyxNQUFNLENBQUNyQixjQUFjLElBQUksS0FBT1QsS0FBSyxDQUFDUyxjQUFjLElBQUksSUFBS1QsS0FBSyxDQUFDUyxjQUFjO1lBQ3BILEtBQUs7Z0JBQUcsT0FBT3FCLFNBQVMsUUFBUyxNQUFNLENBQUNyQixjQUFjLElBQUksSUFBS1QsS0FBSyxDQUFDUyxjQUFjO1lBQ25GLEtBQUs7Z0JBQUcsT0FBT3FCLFNBQVM5QixLQUFLLENBQUNTLGNBQWM7WUFDNUM7Z0JBQVMsT0FBT3VCLElBQUk7UUFDckI7SUFDRDtBQUNEO0FBRUEsb0RBQW9EO0FBQ3BELFNBQVNDLGFBQWFDLENBQUM7SUFDdEIsSUFBSWpDLE1BQU07SUFDVixPQUFPLElBQU1pQyxDQUFDLENBQUNqQyxNQUFNO0FBQ3RCO0FBQ0EsU0FBU2tDLHdCQUF3QkMsQ0FBQztJQUNqQyxPQUFPSCxhQUFhbEMsa0JBQWtCc0MsWUFBWUQ7QUFDbkQ7QUFFQSx1QkFBdUI7QUFDdkIsMkNBQTJDO0FBQzNDLDJFQUEyRTtBQUMzRSxTQUFTQyxZQUFZRCxDQUFDO0lBQ3JCLElBQUlFLFNBQVMsRUFBRTtJQUNmO1dBQUk7S0FBbUUsQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLEdBQUdsQyxJQUFNZ0MsTUFBTSxDQUFDRSxFQUFFQyxVQUFVLENBQUMsR0FBRyxHQUFHbkM7SUFDcEgsSUFBSW9DLElBQUlOLEVBQUVPLE1BQU07SUFDaEIsSUFBSUMsTUFBTSxJQUFJQyxXQUFXLElBQUtILEtBQU07SUFDcEMsSUFBSyxJQUFJcEMsSUFBSSxHQUFHTCxNQUFNLEdBQUc2QyxRQUFRLEdBQUdDLFFBQVEsR0FBR3pDLElBQUlvQyxHQUFHcEMsSUFBSztRQUMxRHlDLFFBQVEsU0FBVSxJQUFLVCxNQUFNLENBQUNGLEVBQUVLLFVBQVUsQ0FBQ25DLEdBQUc7UUFDOUN3QyxTQUFTO1FBQ1QsSUFBSUEsU0FBUyxHQUFHO1lBQ2ZGLEdBQUcsQ0FBQzNDLE1BQU0sR0FBSThDLFNBQVVELENBQUFBLFNBQVM7UUFDbEM7SUFDRDtJQUNBLE9BQU9GO0FBQ1I7QUFFQSxzQ0FBc0M7QUFDdEMsU0FBU0ksT0FBTzFDLENBQUM7SUFDaEIsT0FBTyxJQUFLLElBQU0sQ0FBQ0EsS0FBSyxJQUFNQSxLQUFLO0FBQ3BDO0FBRUEsU0FBUzJDLFlBQVlQLENBQUMsRUFBRVEsSUFBSTtJQUMzQixJQUFJaEIsSUFBSWlCLE1BQU1UO0lBQ2QsSUFBSyxJQUFJcEMsSUFBSSxHQUFHMEIsSUFBSSxHQUFHMUIsSUFBSW9DLEdBQUdwQyxJQUFLNEIsQ0FBQyxDQUFDNUIsRUFBRSxHQUFHMEIsS0FBS2dCLE9BQU9FO0lBQ3RELE9BQU9oQjtBQUNSO0FBRUEsZ0NBQWdDO0FBQ2hDLFNBQVNrQixZQUFZRixJQUFJLEVBQUVHLE9BQU8sQ0FBQztJQUNsQyxJQUFJVCxNQUFNLEVBQUU7SUFDWixNQUFPLEtBQU07UUFDWixJQUFJWixJQUFJa0I7UUFDUixJQUFJUixJQUFJUTtRQUNSLElBQUksQ0FBQ1IsR0FBRztRQUNSVyxRQUFRckI7UUFDUixJQUFLLElBQUkxQixJQUFJLEdBQUdBLElBQUlvQyxHQUFHcEMsSUFBSztZQUMzQnNDLElBQUlyQyxJQUFJLENBQUM4QyxPQUFPL0M7UUFDakI7UUFDQStDLFFBQVFYLElBQUk7SUFDYjtJQUNBLE9BQU9FO0FBQ1I7QUFFQSxTQUFTVSxtQkFBbUJKLElBQUk7SUFDL0IsT0FBT0ssaUJBQWlCO1FBQ3ZCLElBQUlyQixJQUFJa0IsWUFBWUY7UUFDcEIsSUFBSWhCLEVBQUVTLE1BQU0sRUFBRSxPQUFPVDtJQUN0QjtBQUNEO0FBRUEseUJBQXlCO0FBQ3pCLFNBQVNzQixZQUFZTixJQUFJO0lBQ3hCLElBQUlOLE1BQU0sRUFBRTtJQUNaLE1BQU8sS0FBTTtRQUNaLElBQUlhLElBQUlQO1FBQ1IsSUFBSU8sS0FBSyxHQUFHO1FBQ1piLElBQUlyQyxJQUFJLENBQUNtRCxrQkFBa0JELEdBQUdQO0lBQy9CO0lBQ0EsTUFBTyxLQUFNO1FBQ1osSUFBSU8sSUFBSVAsU0FBUztRQUNqQixJQUFJTyxJQUFJLEdBQUc7UUFDWGIsSUFBSXJDLElBQUksQ0FBQ29ELHVCQUF1QkYsR0FBR1A7SUFDcEM7SUFDQSxPQUFPTixJQUFJZ0IsSUFBSTtBQUNoQjtBQUVBLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsU0FBU0wsaUJBQWlCTCxJQUFJO0lBQzdCLElBQUloQixJQUFJLEVBQUU7SUFDVixNQUFPLEtBQU07UUFDWixJQUFJRixJQUFJa0IsS0FBS2hCLEVBQUVTLE1BQU07UUFDckIsSUFBSSxDQUFDWCxHQUFHO1FBQ1JFLEVBQUUzQixJQUFJLENBQUN5QjtJQUNSO0lBQ0EsT0FBT0U7QUFDUjtBQUVBLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0IsU0FBUzJCLGdCQUFnQm5CLENBQUMsRUFBRWUsQ0FBQyxFQUFFUCxJQUFJO0lBQ2xDLElBQUlZLElBQUlYLE1BQU1ULEdBQUdxQixJQUFJLEdBQUdoQyxHQUFHLENBQUMsSUFBTSxFQUFFO0lBQ3BDLElBQUssSUFBSXpCLElBQUksR0FBR0EsSUFBSW1ELEdBQUduRCxJQUFLO1FBQzNCMkMsWUFBWVAsR0FBR1EsTUFBTVgsT0FBTyxDQUFDLENBQUNQLEdBQUdnQyxJQUFNRixDQUFDLENBQUNFLEVBQUUsQ0FBQ3pELElBQUksQ0FBQ3lCO0lBQ2xEO0lBQ0EsT0FBTzhCO0FBQ1I7QUFFQSwyREFBMkQ7QUFDM0QscURBQXFEO0FBQ3JELFNBQVNKLGtCQUFrQkQsQ0FBQyxFQUFFUCxJQUFJO0lBQ2pDLElBQUllLEtBQUssSUFBSWY7SUFDYixJQUFJZ0IsS0FBS2hCO0lBQ1QsSUFBSWlCLEtBQUtaLGlCQUFpQkw7SUFDMUIsSUFBSVksSUFBSUQsZ0JBQWdCTSxHQUFHeEIsTUFBTSxFQUFFLElBQUVjLEdBQUdQO0lBQ3hDLE9BQU9ZLEVBQUVNLE9BQU8sQ0FBQyxDQUFDbEMsR0FBRzVCO1FBQ3BCLElBQUksQ0FBQzBCLEdBQUcsR0FBR3FDLEdBQUcsR0FBR25DO1FBQ2pCLE9BQU9pQixNQUFNZ0IsRUFBRSxDQUFDN0QsRUFBRSxFQUFFeUQsSUFBSSxHQUFHaEMsR0FBRyxDQUFDLENBQUN1QyxHQUFHTjtZQUNsQyxJQUFJTyxPQUFPUCxJQUFJRTtZQUNmLE9BQU87Z0JBQUNsQyxJQUFJZ0MsSUFBSUM7Z0JBQUlJLEdBQUd0QyxHQUFHLENBQUN5QyxDQUFBQSxJQUFLQSxJQUFJRDthQUFNO1FBQzNDO0lBQ0Q7QUFDRDtBQUVBLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsU0FBU1osdUJBQXVCRixDQUFDLEVBQUVQLElBQUk7SUFDdEMsSUFBSVIsSUFBSSxJQUFJUTtJQUNaLElBQUlZLElBQUlELGdCQUFnQm5CLEdBQUcsSUFBRWUsR0FBR1A7SUFDaEMsT0FBT1ksRUFBRS9CLEdBQUcsQ0FBQ0csQ0FBQUEsSUFBSztZQUFDQSxDQUFDLENBQUMsRUFBRTtZQUFFQSxFQUFFdUMsS0FBSyxDQUFDO1NBQUc7QUFDckM7QUFHQSxTQUFTQyxVQUFVeEIsSUFBSTtJQUN0QixJQUFJTixNQUFNLEVBQUU7SUFDWixJQUFJK0IsU0FBU3ZCLFlBQVlGO0lBQ3pCMEIsT0FBT0MsT0FBTyxFQUFFLEdBQUcsRUFBRTtJQUNyQixPQUFPakMsS0FBSyxhQUFhO0lBQ3pCLFNBQVNpQyxPQUFPQyxDQUFDO1FBQ2hCLElBQUlDLElBQUk3QixRQUFRLDRCQUE0QjtRQUM1QyxJQUFJOEIsSUFBSXpCLGlCQUFpQjtZQUN4QixJQUFJMEIsTUFBTTdCLFlBQVlGLE1BQU1uQixHQUFHLENBQUN6QixDQUFBQSxJQUFLcUUsTUFBTSxDQUFDckUsRUFBRTtZQUM5QyxJQUFJMkUsSUFBSXRDLE1BQU0sRUFBRSxPQUFPa0MsT0FBT0k7UUFDL0I7UUFDQSxPQUFPO1lBQUNGO1lBQUdDO1lBQUdGO1FBQUM7SUFDaEI7SUFDQSxTQUFTRixPQUFPLEVBQUNHLENBQUMsRUFBRUMsQ0FBQyxFQUFDLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztRQUNqQyxJQUFJSCxJQUFJLEtBQUtHLFVBQVVELEdBQUcsQ0FBQ0EsSUFBSXRDLE1BQU0sR0FBQyxFQUFFLEVBQUU7UUFDMUMsSUFBSW9DLElBQUksR0FBR0csUUFBUUQsR0FBRyxDQUFDQSxJQUFJdEMsTUFBTSxHQUFDLEVBQUU7UUFDcEMsSUFBSW9DLElBQUksR0FBR25DLElBQUlyQyxJQUFJLENBQUMwRTtRQUNwQixLQUFLLElBQUlFLE1BQU1ILEVBQUc7WUFDakIsS0FBSyxJQUFJSSxNQUFNRCxHQUFHTCxDQUFDLENBQUU7Z0JBQ3BCRixPQUFPTyxJQUFJO3VCQUFJRjtvQkFBS0c7aUJBQUcsRUFBRUY7WUFDMUI7UUFDRDtJQUNEO0FBQ0Q7QUFFQSxTQUFTRyxPQUFPRCxFQUFFO0lBQ2pCLE9BQU9BLEdBQUdFLFFBQVEsQ0FBQyxJQUFJQyxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO0FBQ2xEO0FBRUEsU0FBU0MsU0FBU0wsRUFBRTtJQUNuQixPQUFPLENBQUMsQ0FBQyxFQUFFQyxPQUFPRCxJQUFJLENBQUMsQ0FBQyxFQUFFLDhDQUE4QztBQUN6RTtBQUVBOzs7O0FBSUEsR0FDQSxTQUFTTSxXQUFXdEQsQ0FBQztJQUNwQixJQUFJNkMsTUFBTSxFQUFFO0lBQ1osSUFBSyxJQUFJaEYsTUFBTSxHQUFHMEYsTUFBTXZELEVBQUVPLE1BQU0sRUFBRTFDLE1BQU0wRixLQUFPO1FBQzlDLElBQUlQLEtBQUtoRCxFQUFFd0QsV0FBVyxDQUFDM0Y7UUFDdkJBLE9BQU9tRixLQUFLLFVBQVUsSUFBSTtRQUMxQkgsSUFBSTFFLElBQUksQ0FBQzZFO0lBQ1Y7SUFDQSxPQUFPSDtBQUNSO0FBRUEsU0FBU1ksYUFBYVosR0FBRztJQUN4QixNQUFNYSxRQUFRO0lBQ2QsSUFBSUgsTUFBTVYsSUFBSXRDLE1BQU07SUFDcEIsSUFBSWdELE1BQU1HLE9BQU8sT0FBT0MsT0FBT0MsYUFBYSxJQUFJZjtJQUNoRCxJQUFJZ0IsTUFBTSxFQUFFO0lBQ1osSUFBSyxJQUFJM0YsSUFBSSxHQUFHQSxJQUFJcUYsS0FBTztRQUMxQk0sSUFBSTFGLElBQUksQ0FBQ3dGLE9BQU9DLGFBQWEsSUFBSWYsSUFBSVIsS0FBSyxDQUFDbkUsR0FBR0EsS0FBS3dGO0lBQ3BEO0lBQ0EsT0FBT0csSUFBSUMsSUFBSSxDQUFDO0FBQ2pCO0FBRUEsU0FBU0MsZUFBZXZFLENBQUMsRUFBRUMsQ0FBQztJQUMzQixJQUFJYSxJQUFJZCxFQUFFZSxNQUFNO0lBQ2hCLElBQUlILElBQUlFLElBQUliLEVBQUVjLE1BQU07SUFDcEIsSUFBSyxJQUFJckMsSUFBSSxHQUFHa0MsS0FBSyxLQUFLbEMsSUFBSW9DLEdBQUdwQyxJQUFLa0MsSUFBSVosQ0FBQyxDQUFDdEIsRUFBRSxHQUFHdUIsQ0FBQyxDQUFDdkIsRUFBRTtJQUNyRCxPQUFPa0M7QUFDUjtBQUVBLFNBQVM0RCxjQUFjbEUsQ0FBQyxFQUFFTixDQUFDLEVBQUVDLENBQUM7SUFDN0IsSUFBSXdCLE9BQU87SUFDWCxNQUFPLEtBQU07UUFDWixJQUFJSCxPQUFPaEIsRUFBRW1FLE9BQU8sQ0FBQ3pFLEdBQUd5QjtRQUN4QixJQUFJSCxPQUFPLEdBQUc7UUFDZGhCLENBQUMsQ0FBQ2dCLEtBQUssR0FBR3JCO1FBQ1Z3QixPQUFPSCxPQUFPO0lBQ2Y7QUFDRDtBQUVBLG1DQUFtQztBQUNuQyxxREFBcUQ7QUFDckQsNEVBQTRFO0FBQzVFLDREQUE0RDtBQUM1RCw0RUFBNEU7QUFDNUUsSUFBSW9ELGFBQWE7QUFFakIsb0NBQW9DO0FBQ3BDLCtCQUErQjtBQUMvQixxQkFBcUI7QUFHckIscUJBQXFCO0FBQ3JCLHFFQUFxRTtBQUNyRSxNQUFNQyxLQUFLO0FBQ1gsTUFBTUMsS0FBSztBQUNYLE1BQU1DLEtBQUs7QUFDWCxNQUFNQyxLQUFLO0FBQ1gsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsVUFBVUYsVUFBVUM7QUFDMUIsTUFBTUUsVUFBVUosVUFBVUc7QUFDMUIsTUFBTUUsS0FBS1QsS0FBS1E7QUFDaEIsTUFBTUUsS0FBS1QsS0FBS0c7QUFDaEIsTUFBTU8sS0FBS1QsS0FBS0c7QUFDaEIsTUFBTU8sS0FBS1QsS0FBS0c7QUFFaEIsU0FBU08sVUFBVUMsTUFBTTtJQUN4QixPQUFPLFVBQVcsS0FBTTtBQUN6QjtBQUNBLFNBQVNDLFVBQVVELE1BQU07SUFDeEIsT0FBT0EsU0FBUztBQUNqQjtBQUVBLElBQUlFLGNBQWNDLFlBQVlDLFFBQVFDO0FBRXRDLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNERBQTREO0FBQzVELElBQUk7QUFFSixTQUFTQztJQUNSLHFCQUFxQjtJQUNyQixJQUFJQyxJQUFJekYsd0JBQXdCbUU7SUFDaENpQixlQUFlLElBQUkxSCxJQUFJeUQsbUJBQW1Cc0UsR0FBR3hELE9BQU8sQ0FBQyxDQUFDbEMsR0FBRzVCLElBQU00QixFQUFFSCxHQUFHLENBQUNDLENBQUFBLElBQUs7Z0JBQUNBO2dCQUFJMUIsSUFBRSxLQUFNO2FBQUcsS0FBSyxjQUFjO0lBQzdHa0gsYUFBYSxJQUFJSyxJQUFJekUsWUFBWXdFO0lBQ2pDSCxTQUFTLElBQUk1SDtJQUNiNkgsU0FBUyxJQUFJN0g7SUFDYixLQUFLLElBQUksQ0FBQ3VGLElBQUlILElBQUksSUFBSXpCLFlBQVlvRSxHQUFJO1FBQ3JDLElBQUksQ0FBQ0osV0FBV00sR0FBRyxDQUFDMUMsT0FBT0gsSUFBSXRDLE1BQU0sSUFBSSxHQUFHO1lBQzNDLElBQUksQ0FBQ2YsR0FBR0MsRUFBRSxHQUFHb0Q7WUFDYixJQUFJOEMsU0FBU0wsT0FBT00sR0FBRyxDQUFDcEc7WUFDeEIsSUFBSSxDQUFDbUcsUUFBUTtnQkFDWkEsU0FBUyxJQUFJbEk7Z0JBQ2I2SCxPQUFPTyxHQUFHLENBQUNyRyxHQUFHbUc7WUFDZjtZQUNBQSxPQUFPRSxHQUFHLENBQUNwRyxHQUFHdUQ7UUFDZjtRQUNBcUMsT0FBT1EsR0FBRyxDQUFDN0MsSUFBSUgsSUFBSWlELE9BQU8sS0FBSyxrQkFBa0I7SUFDbEQ7QUFDQSx3QkFBd0I7QUFDeEIsaUJBQWlCO0FBQ2xCO0FBRUEsU0FBU0MsVUFBVS9DLEVBQUU7SUFDcEIsT0FBT0EsTUFBTW1CLE1BQU1uQixLQUFLNEI7QUFDekI7QUFFQSxTQUFTb0IsYUFBYXhHLENBQUMsRUFBRUMsQ0FBQztJQUN6QixJQUFJRCxLQUFLNEUsTUFBTTVFLElBQUlxRixNQUFNcEYsS0FBSzRFLE1BQU01RSxJQUFJcUYsSUFBSTtRQUMzQyxPQUFPWCxLQUFLLENBQUMzRSxJQUFJNEUsRUFBQyxJQUFLTSxVQUFVLENBQUNqRixJQUFJNEUsRUFBQyxJQUFLSTtJQUM3QyxPQUFPLElBQUlzQixVQUFVdkcsTUFBTUMsSUFBSTZFLE1BQU03RSxJQUFJc0YsTUFBTSxDQUFDdkYsSUFBSTJFLEVBQUMsSUFBS00sV0FBVyxHQUFHO1FBQ3ZFLE9BQU9qRixJQUFLQyxDQUFBQSxJQUFJNkUsRUFBQztJQUNsQixPQUFPO1FBQ04sSUFBSTJCLFNBQVNYLE9BQU9NLEdBQUcsQ0FBQ3BHO1FBQ3hCLElBQUl5RyxRQUFRO1lBQ1hBLFNBQVNBLE9BQU9MLEdBQUcsQ0FBQ25HO1lBQ3BCLElBQUl3RyxRQUFRO2dCQUNYLE9BQU9BO1lBQ1I7UUFDRDtRQUNBLE9BQU8sQ0FBQztJQUNUO0FBQ0Q7QUFFQSxTQUFTQyxXQUFXckQsR0FBRztJQUN0QixJQUFJLENBQUNzQyxjQUFjSTtJQUNuQixJQUFJL0UsTUFBTSxFQUFFO0lBQ1osSUFBSXFELE1BQU0sRUFBRTtJQUNaLElBQUlzQyxjQUFjO0lBQ2xCLFNBQVNDLElBQUlwRCxFQUFFO1FBQ2QsSUFBSXFELEtBQUtsQixhQUFhUyxHQUFHLENBQUM1QztRQUMxQixJQUFJcUQsSUFBSTtZQUNQRixjQUFjO1lBQ2RuRCxNQUFNcUQ7UUFDUDtRQUNBN0YsSUFBSXJDLElBQUksQ0FBQzZFO0lBQ1Y7SUFDQSxLQUFLLElBQUlBLE1BQU1ILElBQUs7UUFDbkIsTUFBTyxLQUFNO1lBQ1osSUFBSUcsS0FBSyxNQUFNO2dCQUNkeEMsSUFBSXJDLElBQUksQ0FBQzZFO1lBQ1YsT0FBTyxJQUFJK0MsVUFBVS9DLEtBQUs7Z0JBQ3pCLElBQUlzRCxVQUFVdEQsS0FBS21CO2dCQUNuQixJQUFJb0MsVUFBVUQsVUFBVTVCLFVBQVU7Z0JBQ2xDLElBQUk4QixVQUFVLFVBQVc5QixVQUFXRCxVQUFVO2dCQUM5QyxJQUFJZ0MsVUFBVUgsVUFBVTdCO2dCQUN4QjJCLElBQUloQyxLQUFLbUM7Z0JBQ1RILElBQUkvQixLQUFLbUM7Z0JBQ1QsSUFBSUMsVUFBVSxHQUFHTCxJQUFJOUIsS0FBS21DO1lBQzNCLE9BQU87Z0JBQ04sSUFBSUMsU0FBU3JCLE9BQU9PLEdBQUcsQ0FBQzVDO2dCQUN4QixJQUFJMEQsUUFBUTtvQkFDWDdDLElBQUkxRixJQUFJLElBQUl1STtnQkFDYixPQUFPO29CQUNOTixJQUFJcEQ7Z0JBQ0w7WUFDRDtZQUNBLElBQUksQ0FBQ2EsSUFBSXRELE1BQU0sRUFBRTtZQUNqQnlDLEtBQUthLElBQUk4QyxHQUFHO1FBQ2I7SUFDRDtJQUNBLElBQUlSLGVBQWUzRixJQUFJRCxNQUFNLEdBQUcsR0FBRztRQUNsQyxJQUFJcUcsVUFBVTVCLFVBQVV4RSxHQUFHLENBQUMsRUFBRTtRQUM5QixJQUFLLElBQUl0QyxJQUFJLEdBQUdBLElBQUlzQyxJQUFJRCxNQUFNLEVBQUVyQyxJQUFLO1lBQ3BDLElBQUltSSxLQUFLckIsVUFBVXhFLEdBQUcsQ0FBQ3RDLEVBQUU7WUFDekIsSUFBSW1JLE1BQU0sS0FBS08sV0FBV1AsSUFBSTtnQkFDN0JPLFVBQVVQO2dCQUNWO1lBQ0Q7WUFDQSxJQUFJekUsSUFBSTFELElBQUU7WUFDVixNQUFPLEtBQU07Z0JBQ1osSUFBSTJJLE1BQU1yRyxHQUFHLENBQUNvQixJQUFFLEVBQUU7Z0JBQ2xCcEIsR0FBRyxDQUFDb0IsSUFBRSxFQUFFLEdBQUdwQixHQUFHLENBQUNvQixFQUFFO2dCQUNqQnBCLEdBQUcsQ0FBQ29CLEVBQUUsR0FBR2lGO2dCQUNULElBQUksQ0FBQ2pGLEdBQUc7Z0JBQ1JnRixVQUFVNUIsVUFBVXhFLEdBQUcsQ0FBQyxFQUFFb0IsRUFBRTtnQkFDNUIsSUFBSWdGLFdBQVdQLElBQUk7WUFDcEI7WUFDQU8sVUFBVTVCLFVBQVV4RSxHQUFHLENBQUN0QyxFQUFFO1FBQzNCO0lBQ0Q7SUFDQSxPQUFPc0M7QUFDUjtBQUVBLFNBQVNzRyx5QkFBeUJoSCxDQUFDO0lBQ2xDLElBQUlVLE1BQU0sRUFBRTtJQUNaLElBQUl1RyxRQUFRLEVBQUU7SUFDZCxJQUFJQyxVQUFVLENBQUM7SUFDZixJQUFJSixVQUFVO0lBQ2QsS0FBSyxJQUFJM0IsVUFBVW5GLEVBQUc7UUFDckIsSUFBSXVHLEtBQUtyQixVQUFVQztRQUNuQixJQUFJakMsS0FBS2tDLFVBQVVEO1FBQ25CLElBQUkrQixXQUFXLENBQUMsR0FBRztZQUNsQixJQUFJWCxNQUFNLEdBQUc7Z0JBQ1pXLFVBQVVoRTtZQUNYLE9BQU87Z0JBQ054QyxJQUFJckMsSUFBSSxDQUFDNkU7WUFDVjtRQUNELE9BQU8sSUFBSTRELFVBQVUsS0FBS0EsV0FBV1AsSUFBSTtZQUN4QyxJQUFJQSxNQUFNLEdBQUc7Z0JBQ1o3RixJQUFJckMsSUFBSSxDQUFDNkksWUFBWUQ7Z0JBQ3JCQSxNQUFNeEcsTUFBTSxHQUFHO2dCQUNmeUcsVUFBVWhFO1lBQ1gsT0FBTztnQkFDTitELE1BQU01SSxJQUFJLENBQUM2RTtZQUNaO1lBQ0E0RCxVQUFVUDtRQUNYLE9BQU87WUFDTixJQUFJWSxXQUFXakIsYUFBYWdCLFNBQVNoRTtZQUNyQyxJQUFJaUUsWUFBWSxHQUFHO2dCQUNsQkQsVUFBVUM7WUFDWCxPQUFPLElBQUlMLFdBQVcsS0FBS1AsTUFBTSxHQUFHO2dCQUNuQzdGLElBQUlyQyxJQUFJLENBQUM2STtnQkFDVEEsVUFBVWhFO1lBQ1gsT0FBTztnQkFDTitELE1BQU01SSxJQUFJLENBQUM2RTtnQkFDWDRELFVBQVVQO1lBQ1g7UUFDRDtJQUNEO0lBQ0EsSUFBSVcsV0FBVyxHQUFHO1FBQ2pCeEcsSUFBSXJDLElBQUksQ0FBQzZJLFlBQVlEO0lBQ3RCO0lBQ0EsT0FBT3ZHO0FBQ1I7QUFFQSw0QkFBNEI7QUFDNUIsU0FBUzBHLElBQUlyRSxHQUFHO0lBQ2YsT0FBT3FELFdBQVdyRCxLQUFLbEQsR0FBRyxDQUFDdUY7QUFDNUI7QUFDQSxTQUFTaUMsSUFBSXRFLEdBQUc7SUFDZixPQUFPaUUseUJBQXlCWixXQUFXckQ7QUFDNUM7QUFFQSxNQUFNdUUsU0FBUztBQUNmLE1BQU1DLE9BQU87QUFDYixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLE9BQU87QUFDYixNQUFNQyxZQUFZO0FBRWxCLHFFQUFxRTtBQUNyRSxNQUFNQyxhQUFhN0gsQ0FBQUEsSUFBS21CLE1BQU0yRyxJQUFJLENBQUM5SCxJQUFJLDBCQUEwQjtBQUVqRSxTQUFTK0gsYUFBYUMsQ0FBQyxFQUFFNUUsRUFBRTtJQUMxQixnRkFBZ0Y7SUFDaEYsT0FBTzRFLEVBQUVDLENBQUMsQ0FBQ25DLEdBQUcsQ0FBQzFDLE9BQU80RSxFQUFFbEYsQ0FBQyxDQUFDZ0QsR0FBRyxDQUFDMUM7QUFDL0I7QUFFQSxNQUFNOEUsY0FBYy9HO0lBQ25CLElBQUlnSCxXQUFXO1FBQUUsT0FBTztJQUFNO0FBQy9CO0FBRUEsSUFBSUMsUUFBUUMsU0FBU0MsSUFBSUMsS0FBS0MsUUFBUUMsV0FBV0MsUUFBUUMsYUFBYUMsV0FBV0MsT0FBT0MsWUFBWUM7QUFFcEcsaUNBQWlDO0FBQ2pDLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEIsc0lBQXNJO0FBQ3RJLElBQUk7QUFFSixTQUFTQztJQUNSLElBQUlaLFFBQVE7SUFFWixJQUFJeEMsSUFBSXpGLHdCQUF3QnhDO0lBQ2hDLE1BQU1zTCxvQkFBb0IsSUFBTTdILFlBQVl3RTtJQUM1QyxNQUFNc0Qsa0JBQWtCLElBQU0sSUFBSXJELElBQUlvRDtJQUN0QyxNQUFNRSxlQUFlLENBQUNsRCxLQUFLL0YsSUFBTUEsRUFBRUssT0FBTyxDQUFDUCxDQUFBQSxJQUFLaUcsSUFBSU8sR0FBRyxDQUFDeEc7SUFFeERvSSxTQUFTLElBQUl2SyxJQUFJMkQsWUFBWW9FO0lBQzdCeUMsVUFBVWEsbUJBQW1CLGdFQUFnRTtJQUU3Rjs7Ozs7O0NBTUEsR0FDQSw2REFBNkQ7SUFDN0QsNERBQTREO0lBQzVEWixLQUFLVztJQUNMVixNQUFNLElBQUkxQyxJQUFJb0Qsb0JBQW9CbEosR0FBRyxDQUFDekIsQ0FBQUEsSUFBS2dLLEVBQUUsQ0FBQ2hLLEVBQUU7SUFDaERnSyxLQUFLLElBQUl6QyxJQUFJeUM7SUFFYkUsU0FBU1UsbUJBQW1CLHdDQUF3QztJQUNwRVQsWUFBWVMsbUJBQW1CLDJEQUEyRDtJQUUxRixJQUFJRSxTQUFTOUgsbUJBQW1Cc0U7SUFDaEMsSUFBSXlELGVBQWV6RDtJQUNuQiw4R0FBOEc7SUFDOUcsTUFBTTBELGVBQWU7UUFDcEIsMENBQTBDO1FBQzFDLElBQUlyRCxNQUFNLElBQUlKO1FBQ2RvRCxvQkFBb0IxSSxPQUFPLENBQUNqQyxDQUFBQSxJQUFLNkssYUFBYWxELEtBQUttRCxNQUFNLENBQUM5SyxFQUFFO1FBQzVENkssYUFBYWxELEtBQUtnRDtRQUNsQixPQUFPaEQ7SUFDUjtJQUNBeUMsU0FBU25ILGlCQUFpQmpELENBQUFBO1FBQ3pCLDBDQUEwQztRQUMxQyxnREFBZ0Q7UUFDaEQsSUFBSU8sSUFBSTBDLGlCQUFpQnFFLEdBQUc3RixHQUFHLENBQUNDLENBQUFBLElBQUtBLElBQUU7UUFDdkMsSUFBSW5CLEVBQUU4QixNQUFNLEVBQUU7WUFDYixJQUFJNEksSUFBSWpMLEtBQUsrSyxjQUFjLCtCQUErQjtZQUMxRHhLLENBQUMsQ0FBQyxFQUFFLElBQUksSUFBSSxhQUFhO1lBQ3pCQSxJQUFJZ0YsYUFBYWhGO1lBQ2pCLElBQUkwSyxHQUFHMUssSUFBRSxDQUFDLFdBQVcsRUFBRUEsRUFBRSxDQUFDLENBQUM7WUFDM0IsSUFBSW9KLElBQUlxQixnQkFBZ0IsVUFBVTtZQUNsQyxJQUFJeEcsSUFBSXdHLGdCQUFnQixZQUFZO1lBQ3BDLElBQUlFLElBQUksQ0FBQzVELEtBQUssaUNBQWlDO1lBQy9DLDJDQUEyQztZQUMzQzs7Ozs7Ozs7Ozs7SUFXQyxHQUNELE9BQU87Z0JBQUMvRztnQkFBR29KO2dCQUFHbkY7Z0JBQUcwRztnQkFBR0Q7WUFBQztRQUN0QjtJQUNEO0lBRUEsMkJBQTJCO0lBQzNCWixjQUFjTztJQUNkTixZQUFZLElBQUkvSztJQUNoQixJQUFJNEwsU0FBU1Isb0JBQW9CUyxNQUFNLENBQUM3QixXQUFXYyxjQUFjZ0IsSUFBSSxDQUFDLENBQUMvSixHQUFHQyxJQUFNRCxJQUFFQyxJQUFJLGlCQUFpQjtJQUN2RzRKLE9BQU9sSixPQUFPLENBQUMsQ0FBQzZDLElBQUk5RTtRQUNuQixJQUFJc0wsSUFBSWhFO1FBQ1IsSUFBSW5FLElBQUlnSSxNQUFNLENBQUNuTCxFQUFFLEdBQUdzTCxJQUFJSCxNQUFNLENBQUNuTCxJQUFFc0wsRUFBRSxHQUFHO1lBQUNDLEdBQUcsRUFBRTtZQUFFTCxHQUFHLElBQUkzTDtRQUFLO1FBQzFENEQsRUFBRW9JLENBQUMsQ0FBQ3RMLElBQUksQ0FBQzZFLEtBQUssb0JBQW9CO1FBQ2xDLElBQUksQ0FBQ3VGLFlBQVk3QyxHQUFHLENBQUMxQyxLQUFLO1lBQ3pCd0YsVUFBVTNDLEdBQUcsQ0FBQzdDLElBQUkzQixJQUFLLDBCQUEwQjtRQUNsRDtJQUNEO0lBRUEsd0NBQXdDO0lBQ3hDLHNEQUFzRDtJQUN0RCxLQUFLLElBQUksRUFBQ29JLENBQUMsRUFBRUwsQ0FBQyxFQUFDLElBQUksSUFBSTNELElBQUkrQyxVQUFVa0IsTUFBTSxJQUFLO1FBQy9DLG9EQUFvRDtRQUNwRCxJQUFJQyxPQUFPLEVBQUU7UUFDYixLQUFLLElBQUkzRyxNQUFNeUcsRUFBRztZQUNqQixJQUFJRyxLQUFLdEIsT0FBT3VCLE1BQU0sQ0FBQ2pDLENBQUFBLElBQUtELGFBQWFDLEdBQUc1RTtZQUM1QyxJQUFJOEcsTUFBTUgsS0FBS0ksSUFBSSxDQUFDLENBQUMsRUFBQ0MsQ0FBQyxFQUFDLEdBQUtKLEdBQUdLLElBQUksQ0FBQ3JDLENBQUFBLElBQUtvQyxFQUFFdEUsR0FBRyxDQUFDa0M7WUFDaEQsSUFBSSxDQUFDa0MsS0FBSztnQkFDVEEsTUFBTTtvQkFBQ0UsR0FBRyxJQUFJdkU7b0JBQU9nRSxHQUFHLEVBQUU7Z0JBQUE7Z0JBQzFCRSxLQUFLeEwsSUFBSSxDQUFDMkw7WUFDWDtZQUNBQSxJQUFJTCxDQUFDLENBQUN0TCxJQUFJLENBQUM2RTtZQUNYK0YsYUFBYWUsSUFBSUUsQ0FBQyxFQUFFSjtRQUNyQjtRQUNBLGtFQUFrRTtRQUNsRSxJQUFJTSxRQUFRUCxLQUFLM0gsT0FBTyxDQUFDcEMsQ0FBQUEsSUFBSzZILFdBQVc3SCxFQUFFb0ssQ0FBQyxJQUFJLHVDQUF1QztRQUN2RixLQUFLLElBQUksRUFBQ0EsQ0FBQyxFQUFFUCxDQUFDLEVBQUMsSUFBSUUsS0FBTTtZQUN4QixJQUFJUSxhQUFhLElBQUkxRSxJQUFJeUUsTUFBTUwsTUFBTSxDQUFDakMsQ0FBQUEsSUFBSyxDQUFDb0MsRUFBRXRFLEdBQUcsQ0FBQ2tDLE1BQU0sbUNBQW1DO1lBQzNGLEtBQUssSUFBSTVFLE1BQU15RyxFQUFHO2dCQUNqQkwsRUFBRXZELEdBQUcsQ0FBQzdDLElBQUltSCxhQUFhLDZCQUE2QjtZQUNyRDtRQUNEO0lBQ0Q7SUFFQSxvQkFBb0I7SUFDcEIsK0NBQStDO0lBQy9DMUIsUUFBUSxJQUFJaEQsT0FBTyxzQkFBc0I7SUFDekMsSUFBSTJFLFFBQVEsSUFBSTNFLE9BQU8sc0JBQXNCO0lBQzdDLE1BQU00RSxlQUFlckgsQ0FBQUEsS0FBTXlGLE1BQU0vQyxHQUFHLENBQUMxQyxNQUFNb0gsTUFBTWhFLEdBQUcsQ0FBQ3BELE1BQU15RixNQUFNckMsR0FBRyxDQUFDcEQ7SUFDckUsS0FBSyxJQUFJNEUsS0FBS1UsT0FBUTtRQUNyQixLQUFLLElBQUl0RixNQUFNNEUsRUFBRUMsQ0FBQyxDQUFFd0MsYUFBYXJIO1FBQ2pDLEtBQUssSUFBSUEsTUFBTTRFLEVBQUVsRixDQUFDLENBQUUySCxhQUFhckg7SUFDbEM7SUFDQSxzRUFBc0U7SUFDdEUsS0FBSyxJQUFJQSxNQUFNeUYsTUFBTztRQUNyQixJQUFJLENBQUNELFVBQVU5QyxHQUFHLENBQUMxQyxPQUFPLENBQUNvSCxNQUFNMUUsR0FBRyxDQUFDMUMsS0FBSztZQUN6Q3dGLFVBQVUzQyxHQUFHLENBQUM3QyxJQUFJd0U7UUFDbkI7SUFDRDtJQUNBLDJCQUEyQjtJQUMzQixrREFBa0Q7SUFDbER1QixhQUFhTixPQUFPdkIsSUFBSXVCO0lBRXhCLGVBQWU7SUFDZiwrREFBK0Q7SUFDL0RDLGFBQWFwRyxVQUFVa0QsR0FBRzdGLEdBQUcsQ0FBQ0csQ0FBQUEsSUFBS2dJLE1BQU1KLElBQUksQ0FBQzVILElBQUl5SixJQUFJLENBQUN4RjtJQUN2RDRFLGFBQWEsSUFBSWxMLE9BQU8sMENBQTBDO0lBQ2xFLEtBQUssSUFBSW9GLE9BQU82RixXQUFZO1FBQzNCLHFFQUFxRTtRQUNyRSxxRUFBcUU7UUFDckUsOENBQThDO1FBQzlDLHNEQUFzRDtRQUN0RCx1QkFBdUI7UUFDdkIsMkRBQTJEO1FBQzNELElBQUl6SCxPQUFPO1lBQUMwSDtTQUFXO1FBQ3ZCLEtBQUssSUFBSTNGLE1BQU1ILElBQUs7WUFDbkIsSUFBSS9CLE9BQU9HLEtBQUt0QixHQUFHLENBQUMySyxDQUFBQTtnQkFDbkIsSUFBSUMsUUFBUUQsS0FBSzFFLEdBQUcsQ0FBQzVDO2dCQUNyQixJQUFJLENBQUN1SCxPQUFPO29CQUNYLDBCQUEwQjtvQkFDMUIsdUNBQXVDO29CQUN2QyxxQ0FBcUM7b0JBQ3JDQSxRQUFRLElBQUk5TTtvQkFDWjZNLEtBQUt6RSxHQUFHLENBQUM3QyxJQUFJdUg7Z0JBQ2Q7Z0JBQ0EsT0FBT0E7WUFDUjtZQUNBLElBQUl2SCxPQUFPdUUsTUFBTTtnQkFDaEJ0RyxLQUFLOUMsSUFBSSxJQUFJMkMsT0FBTyx3QkFBd0I7WUFDN0MsT0FBTztnQkFDTkcsT0FBT0g7WUFDUjtRQUNEO1FBQ0EsS0FBSyxJQUFJbEIsS0FBS3FCLEtBQU07WUFDbkJyQixFQUFFNkosQ0FBQyxHQUFHNUc7UUFDUDtJQUNEO0FBQ0Q7QUFFQSxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLFNBQVMySCxVQUFVeEgsRUFBRTtJQUNwQixPQUFPLENBQUN5SCxjQUFjekgsTUFBTSxLQUFLLENBQUMsRUFBRTBILFFBQVFDLGtCQUFrQjtRQUFDM0g7S0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJSyxTQUFTTDtBQUNyRjtBQUVBLDJFQUEyRTtBQUMzRSwwRUFBMEU7QUFDMUUsc0NBQXNDO0FBQ3RDLGlGQUFpRjtBQUNqRixTQUFTMEgsUUFBUTFLLENBQUM7SUFDakIsT0FBTyxDQUFDLENBQUMsRUFBRUEsRUFBRSxPQUFPLENBQUMsRUFBRSxhQUFhO0FBQ3JDO0FBRUEsU0FBUzRLLHNCQUFzQi9ILEdBQUc7SUFDakMsSUFBSUEsSUFBSXRDLE1BQU0sSUFBSSxLQUFLc0MsR0FBRyxDQUFDLEVBQUUsSUFBSXVFLFVBQVV2RSxHQUFHLENBQUMsRUFBRSxJQUFJdUUsUUFBUTtRQUM1RCxNQUFNLElBQUl5RCxNQUFNLENBQUMsMEJBQTBCLEVBQUVwSCxhQUFhWixJQUFJUixLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLHlDQUF5QztJQUMxSDtBQUNEO0FBQ0EsU0FBU3lJLHlCQUF5QmpJLEdBQUc7SUFDcEMsTUFBTWtJLGFBQWE7SUFDbkIsSUFBSyxJQUFJN00sSUFBSTJFLElBQUltSSxXQUFXLENBQUNELGFBQWE3TSxJQUFJLEdBQUs7UUFDbEQsSUFBSTJFLEdBQUcsQ0FBQyxFQUFFM0UsRUFBRSxLQUFLNk0sWUFBWTtZQUM1QixNQUFNLElBQUlGLE1BQU07UUFDakI7SUFDRDtBQUNEO0FBQ0EsaUZBQWlGO0FBQ2pGLFNBQVNJLGFBQWFwSSxHQUFHO0lBQ3hCLElBQUlHLEtBQUtILEdBQUcsQ0FBQyxFQUFFO0lBQ2YsSUFBSTVCLE9BQU96RCxPQUFPb0ksR0FBRyxDQUFDNUM7SUFDdEIsSUFBSS9CLE1BQU0sTUFBTWlLLGdCQUFnQixDQUFDLFFBQVEsRUFBRWpLLEtBQUssQ0FBQztJQUNqRCxJQUFJWCxJQUFJdUMsSUFBSXRDLE1BQU07SUFDbEIsSUFBSTRLLE9BQU8sQ0FBQyxHQUFHLGtDQUFrQztJQUNqRCxJQUFLLElBQUlqTixJQUFJLEdBQUdBLElBQUlvQyxHQUFHcEMsSUFBSztRQUMzQjhFLEtBQUtILEdBQUcsQ0FBQzNFLEVBQUU7UUFDWCxJQUFJa04sUUFBUTVOLE9BQU9vSSxHQUFHLENBQUM1QztRQUN2QixJQUFJb0ksT0FBTztZQUNWLGlEQUFpRDtZQUNqRCxJQUFJRCxRQUFRak4sR0FBRyxNQUFNZ04sZ0JBQWdCLENBQUMsRUFBRWpLLEtBQUssR0FBRyxFQUFFbUssTUFBTSxDQUFDO1lBQ3pERCxPQUFPak4sSUFBSTtZQUNYK0MsT0FBT21LO1FBQ1I7SUFDRDtJQUNBLElBQUlELFFBQVE3SyxHQUFHLE1BQU00SyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUVqSyxLQUFLLENBQUM7QUFDeEQ7QUFFQSxpQ0FBaUM7QUFDakMseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QixtREFBbUQ7QUFDbkQsNkNBQTZDO0FBQzdDLDJFQUEyRTtBQUMzRSxTQUFTMEosa0JBQWtCOUgsR0FBRyxFQUFFd0ksTUFBTUMsUUFBUSxFQUFFQyxTQUFTbEksUUFBUTtJQUNoRSx5Q0FBeUM7SUFDekMsc0VBQXNFO0lBQ3RFLElBQUlRLE1BQU0sRUFBRTtJQUNaLElBQUkySCxrQkFBa0IzSSxHQUFHLENBQUMsRUFBRSxHQUFHZ0IsSUFBSTFGLElBQUksQ0FBQztJQUN4QyxJQUFJMEUsSUFBSXRDLE1BQU0sR0FBRzhLLEtBQUs7UUFDckJBLFFBQVE7UUFDUnhJLE1BQU07ZUFBSUEsSUFBSVIsS0FBSyxDQUFDLEdBQUdnSjtZQUFNO2VBQVd4SSxJQUFJUixLQUFLLENBQUMsQ0FBQ2dKO1NBQUs7SUFDekQ7SUFDQSxJQUFJcEssT0FBTztJQUNYLElBQUlYLElBQUl1QyxJQUFJdEMsTUFBTTtJQUNsQixJQUFLLElBQUlyQyxJQUFJLEdBQUdBLElBQUlvQyxHQUFHcEMsSUFBSztRQUMzQixJQUFJOEUsS0FBS0gsR0FBRyxDQUFDM0UsRUFBRTtRQUNmLElBQUl1TSxjQUFjekgsS0FBSztZQUN0QmEsSUFBSTFGLElBQUksQ0FBQ3NGLGFBQWFaLElBQUlSLEtBQUssQ0FBQ3BCLE1BQU0vQztZQUN0QzJGLElBQUkxRixJQUFJLENBQUNvTixPQUFPdkk7WUFDaEIvQixPQUFPL0MsSUFBSTtRQUNaO0lBQ0Q7SUFDQTJGLElBQUkxRixJQUFJLENBQUNzRixhQUFhWixJQUFJUixLQUFLLENBQUNwQixNQUFNWDtJQUN0QyxPQUFPdUQsSUFBSUMsSUFBSSxDQUFDO0FBQ2pCO0FBRUEsOERBQThEO0FBQzlELHFDQUFxQztBQUNyQyxTQUFTMEgsa0JBQWtCeEksRUFBRSxFQUFFeUksUUFBUTtJQUN0QzdDO0lBQ0EsT0FBTzZDLFdBQVd0RCxJQUFJekMsR0FBRyxDQUFDMUMsTUFBTWtGLEdBQUd4QyxHQUFHLENBQUMxQztBQUN4QztBQUNBLFNBQVN5SCxjQUFjekgsRUFBRTtJQUN4QjRGO0lBQ0EsT0FBT1IsT0FBTzFDLEdBQUcsQ0FBQzFDO0FBQ25CO0FBRUEsdURBQXVEO0FBQ3ZELHdDQUF3QztBQUN4QyxTQUFTMEk7SUFDUjlDO0lBQ0EsT0FBT0YsV0FBVy9JLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXlDLEtBQUssS0FBSyw0QkFBNEI7QUFDcEU7QUFFQSxTQUFTc0osdUJBQXVCQyxJQUFJLEVBQUVDLFNBQVM7SUFDOUNqRDtJQUNBLElBQUlrRCxLQUFLRCxZQUFZM0UsTUFBTUM7SUFDM0IsT0FBT3lFLEtBQUtHLEtBQUssQ0FBQ3pFLFNBQVMzSCxHQUFHLENBQUNxTSxDQUFBQSxRQUFTdkksYUFBYXdJLGdCQUFnQjNJLFdBQVcwSSxRQUFRRixJQUFJSSxhQUFhMUssSUFBSSxLQUFLc0MsSUFBSSxDQUFDd0Q7QUFDeEg7QUFFQSxTQUFTNkUsY0FBY0MsSUFBSTtJQUMxQixPQUFPQyxRQUFRTixNQUFNSyxNQUFNakYsS0FBSytFO0FBQ2pDO0FBRUEsU0FBU0ksYUFBYUYsSUFBSTtJQUN6QixJQUFJRyxTQUFTUixNQUFNSyxNQUFNakYsS0FBS3ZILENBQUFBLElBQUtBLElBQUksb0JBQW9CO0lBQzNELEtBQUssSUFBSSxFQUFDNE0sSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBQyxJQUFJSCxPQUFRO1FBQ3pDLElBQUlHLE9BQU8sT0FBTyxxQkFBcUI7UUFFdkMsa0NBQWtDO1FBQ2xDLGtGQUFrRjtRQUNsRixtRUFBbUU7UUFDbkU7Ozs7Ozs7O0VBUUEsR0FDQSxpREFBaUQ7UUFDakQsb0NBQW9DO1FBRXBDLHlCQUF5QjtRQUN6QixzQkFBc0I7UUFDdEIsSUFBSUYsU0FBUyxTQUFTeEksY0FBY3lJLFFBQVEsT0FBTztJQUVuRCxrRkFBa0Y7SUFDbEYsNERBQTREO0lBQzVELGdFQUFnRTtJQUNoRSw4QkFBOEI7SUFDL0I7SUFDQSxPQUFPSixRQUFRRTtBQUNoQjtBQUVBLFNBQVNJLFVBQVVQLElBQUksRUFBRVEsY0FBYztJQUN0QyxPQUFPYixNQUFNSyxNQUFNakYsS0FBS3lGLGlCQUFpQmhOLENBQUFBLElBQUtBLEVBQUV5QyxLQUFLLEtBQUs2SixjQUFjLDRCQUE0QjtBQUNyRztBQUVBLFNBQVNILE1BQU1LLElBQUksRUFBRU4sRUFBRSxFQUFFZSxFQUFFO0lBQzFCLElBQUksQ0FBQ1QsTUFBTSxPQUFPLEVBQUUsRUFBRSxpQ0FBaUM7SUFDdkR4RDtJQUNBLElBQUlsSixTQUFTO0lBQ2Isc0RBQXNEO0lBQ3RELDZEQUE2RDtJQUM3RCxPQUFPME0sS0FBS0wsS0FBSyxDQUFDekUsU0FBUzNILEdBQUcsQ0FBQ3FNLENBQUFBO1FBQzlCLElBQUljLFFBQVF4SixXQUFXMEk7UUFDdkIsSUFBSWUsT0FBTztZQUNWRDtZQUNBcE47UUFDRDtRQUNBQSxVQUFVb04sTUFBTXZNLE1BQU0sR0FBRyxHQUFHLFNBQVM7UUFDckMsSUFBSTtZQUNILDREQUE0RDtZQUM1RCxJQUFJeU0sU0FBU0QsS0FBS0MsTUFBTSxHQUFHZixnQkFBZ0JhLE9BQU9oQixJQUFJZTtZQUN0RCxJQUFJSSxjQUFjRCxPQUFPek0sTUFBTTtZQUMvQixJQUFJaU07WUFDSixJQUFJLENBQUNTLGFBQWE7Z0JBQ2pCLFlBQVk7Z0JBQ1osMkRBQTJEO2dCQUMzRCw2QkFBNkI7Z0JBQzdCLG9FQUFvRTtnQkFDcEUsTUFBTSxJQUFJcEMsTUFBTSxDQUFDLFdBQVcsQ0FBQztZQUM5QjtZQUNBLElBQUlxQyxPQUFPSCxLQUFLTixNQUFNLEdBQUdPLE9BQU94TCxJQUFJO1lBQ3BDc0oseUJBQXlCb0M7WUFDekIsSUFBSUMsUUFBUUosS0FBS0ksS0FBSyxHQUFHRixjQUFjLEtBQUtELE1BQU0sQ0FBQyxFQUFFLENBQUNqRixRQUFRLEVBQUUseUNBQXlDO1lBQ3pHLElBQUksQ0FBQ29GLFNBQVNELEtBQUtFLEtBQUssQ0FBQ3BLLENBQUFBLEtBQU1BLEtBQUssT0FBTztnQkFDMUMsaURBQWlEO2dCQUNqRDRILHNCQUFzQnNDLE9BQU8sd0JBQXdCO2dCQUNyRCxtQkFBbUI7Z0JBQ25CLGVBQWU7Z0JBQ2YsbUJBQW1CO2dCQUNuQiwrQkFBK0I7Z0JBQy9CVixPQUFPO1lBQ1IsT0FBTztnQkFDTixJQUFJYSxRQUFRTCxPQUFPaEwsT0FBTyxDQUFDcEMsQ0FBQUEsSUFBS0EsRUFBRW1JLFFBQVEsR0FBRyxFQUFFLEdBQUduSSxJQUFJLHdDQUF3QztnQkFDOUYsSUFBSSxDQUFDeU4sTUFBTTlNLE1BQU0sRUFBRTtvQkFDbEJpTSxPQUFPO2dCQUNSLE9BQU87b0JBQ04sd0ZBQXdGO29CQUN4RixJQUFJdEUsR0FBR3hDLEdBQUcsQ0FBQ3dILElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTWhDLGdCQUFnQjtvQkFDM0MsSUFBSyxJQUFJaE4sSUFBSSxHQUFHQSxJQUFJK08sYUFBYS9PLElBQUs7d0JBQ3JDLElBQUkyRSxNQUFNbUssTUFBTSxDQUFDOU8sRUFBRTt3QkFDbkIsSUFBSSxDQUFDMkUsSUFBSWtGLFFBQVEsSUFBSUcsR0FBR3hDLEdBQUcsQ0FBQzdDLEdBQUcsQ0FBQyxFQUFFLEdBQUc7NEJBQ3BDLDBEQUEwRDs0QkFDMUQsTUFBTXFJLGdCQUFnQixDQUFDLHlCQUF5QixFQUFFekgsYUFBYXVKLE1BQU0sQ0FBQzlPLElBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRXlNLGtCQUFrQjtnQ0FBQzlILEdBQUcsQ0FBQyxFQUFFOzZCQUFDLEVBQUUsQ0FBQyxDQUFDO3dCQUNoSDtvQkFDRDtvQkFDQW9JLGFBQWFpQztvQkFDYixJQUFJSSxTQUFTN0YsV0FBVyxJQUFJaEMsSUFBSTRIO29CQUNoQyxJQUFJLENBQUN6RixFQUFFLEdBQUcyRixnQkFBZ0JELFNBQVMsdUJBQXVCO29CQUMxRCxtREFBbUQ7b0JBQ25ELDZEQUE2RDtvQkFDN0RFLFlBQVk1RixHQUFHeUYsUUFBUSxxQkFBcUI7b0JBQzVDSSxZQUFZN0YsR0FBRzBGLFNBQVMsZ0ZBQWdGO29CQUN4R2QsT0FBTzVFLEVBQUVuSixDQUFDO2dCQUNWLDhDQUE4QztnQkFDOUMsOENBQThDO2dCQUM5QyxxQ0FBcUM7Z0JBQ3JDLGtDQUFrQztnQkFDbkM7WUFDRDtZQUNBc08sS0FBS1AsSUFBSSxHQUFHQTtRQUNiLEVBQUUsT0FBT2tCLEtBQUs7WUFDYlgsS0FBS0wsS0FBSyxHQUFHZ0IsS0FBSyx3QkFBd0I7UUFDM0M7UUFDQSxPQUFPWDtJQUNSO0FBQ0Q7QUFFQSxTQUFTVSxZQUFZRSxLQUFLLEVBQUVMLE1BQU07SUFDakMsSUFBSU07SUFDSixJQUFJQyxTQUFTLEVBQUU7SUFDZixLQUFLLElBQUk3SyxNQUFNc0ssT0FBUTtRQUN0QixJQUFJUSxRQUFRdEYsVUFBVTVDLEdBQUcsQ0FBQzVDO1FBQzFCLElBQUk4SyxVQUFVdEcsV0FBVyxRQUFRLHlCQUF5QjtRQUMxRCxJQUFJc0csT0FBTztZQUNWLElBQUlqSSxNQUFNaUksTUFBTTFFLENBQUMsQ0FBQ3hELEdBQUcsQ0FBQzVDLEtBQUssOERBQThEO1lBQ3pGNEssUUFBUUEsUUFBUUEsTUFBTS9ELE1BQU0sQ0FBQ2pDLENBQUFBLElBQUsvQixJQUFJSCxHQUFHLENBQUNrQyxNQUFNSCxXQUFXNUI7WUFDM0QsSUFBSSxDQUFDK0gsTUFBTXJOLE1BQU0sRUFBRSxRQUFRLG1DQUFtQztRQUMvRCxPQUFPO1lBQ05zTixPQUFPMVAsSUFBSSxDQUFDNkU7UUFDYjtJQUNEO0lBQ0EsSUFBSTRLLE9BQU87UUFDVix3QkFBd0I7UUFDeEIsdUNBQXVDO1FBQ3ZDLG9DQUFvQztRQUNwQyxLQUFLLElBQUloRyxLQUFLZ0csTUFBTztZQUNwQixJQUFJQyxPQUFPVCxLQUFLLENBQUNwSyxDQUFBQSxLQUFNMkUsYUFBYUMsR0FBRzVFLE1BQU07Z0JBQzVDLE1BQU0sSUFBSTZILE1BQU0sQ0FBQyx5QkFBeUIsRUFBRThDLE1BQU1sUCxDQUFDLENBQUMsQ0FBQyxFQUFFbUosRUFBRW5KLENBQUMsQ0FBQyxDQUFDO1lBQzdEO1FBQ0Q7SUFDRDtBQUNEO0FBRUEsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyxTQUFTOE8sZ0JBQWdCRCxNQUFNO0lBQzlCLElBQUlTLFNBQVN6RjtJQUNiLEtBQUssSUFBSXRGLE1BQU1zSyxPQUFRO1FBQ3RCLGlEQUFpRDtRQUNqRCwwQ0FBMEM7UUFDMUMsSUFBSTFELEtBQUttRSxPQUFPbEUsTUFBTSxDQUFDakMsQ0FBQUEsSUFBS0QsYUFBYUMsR0FBRzVFO1FBQzVDLElBQUksQ0FBQzRHLEdBQUdySixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMrSCxPQUFPMkIsSUFBSSxDQUFDckMsQ0FBQUEsSUFBS0QsYUFBYUMsR0FBRzVFLE1BQU07Z0JBQzNDLDRDQUE0QztnQkFDNUMsK0JBQStCO2dCQUMvQix3RUFBd0U7Z0JBQ3hFLDhDQUE4QztnQkFDOUMsaUNBQWlDO2dCQUNqQyxNQUFNZ0wsaUJBQWlCaEwsS0FBSyxzQkFBc0I7WUFDbkQsT0FBTztnQkFDTix1REFBdUQ7Z0JBQ3ZELHNEQUFzRDtnQkFDdEQsaUVBQWlFO2dCQUNqRSxNQUFNaUwsbUJBQW1CRixNQUFNLENBQUMsRUFBRSxFQUFFL0s7WUFDckM7UUFDRDtRQUNBK0ssU0FBU25FO1FBQ1QsSUFBSUEsR0FBR3JKLE1BQU0sSUFBSSxHQUFHLE9BQU8sK0JBQStCO0lBQzNEO0lBQ0EsNkRBQTZEO0lBQzdELE9BQU93TjtBQUNSO0FBRUEsdUJBQXVCO0FBQ3ZCLFNBQVMxQixRQUFRTixLQUFLO0lBQ3JCLE9BQU9BLE1BQU1wTSxHQUFHLENBQUMsQ0FBQyxFQUFDbU4sS0FBSyxFQUFFSixLQUFLLEVBQUVELE1BQU0sRUFBQztRQUN2QyxJQUFJQyxPQUFPO1lBQ1YsaURBQWlEO1lBQ2pELElBQUl3QixNQUFNeEIsTUFBTXlCLE9BQU87WUFDdkIsNENBQTRDO1lBQzVDLE1BQU0sSUFBSXRELE1BQU1rQixNQUFNeEwsTUFBTSxJQUFJLElBQUkyTixNQUFNLENBQUMsY0FBYyxFQUFFeEQsUUFBUUMsa0JBQWtCbUMsT0FBTyxLQUFLLEVBQUUsRUFBRW9CLElBQUksQ0FBQztRQUMzRztRQUNBLE9BQU96SyxhQUFhZ0o7SUFDckIsR0FBRzNJLElBQUksQ0FBQ3dEO0FBQ1Q7QUFFQSxTQUFTMEcsaUJBQWlCaEwsRUFBRTtJQUMzQix5QkFBeUI7SUFDekIsT0FBTyxJQUFJNkgsTUFBTSxDQUFDLHNCQUFzQixFQUFFTCxVQUFVeEgsSUFBSSxDQUFDO0FBQzFEO0FBQ0EsU0FBU2lMLG1CQUFtQnJHLENBQUMsRUFBRTVFLEVBQUU7SUFDaEMsSUFBSW9MLFNBQVM1RCxVQUFVeEg7SUFDdkIsSUFBSXFMLEtBQUsvRixPQUFPeUIsSUFBSSxDQUFDbkMsQ0FBQUEsSUFBS0EsRUFBRUMsQ0FBQyxDQUFDbkMsR0FBRyxDQUFDMUMsTUFBTSxxQkFBcUI7SUFDN0QsSUFBSXFMLElBQUk7UUFDUEQsU0FBUyxDQUFDLEVBQUVDLEdBQUc1UCxDQUFDLENBQUMsQ0FBQyxFQUFFMlAsT0FBTyxDQUFDO0lBQzdCO0lBQ0EsT0FBTyxJQUFJdkQsTUFBTSxDQUFDLGlCQUFpQixFQUFFakQsRUFBRW5KLENBQUMsQ0FBQyxHQUFHLEVBQUUyUCxPQUFPLENBQUM7QUFDdkQ7QUFDQSxTQUFTbEQsZ0JBQWdCb0QsS0FBSztJQUM3QixPQUFPLElBQUl6RCxNQUFNLENBQUMsbUJBQW1CLEVBQUV5RCxNQUFNLENBQUM7QUFDL0M7QUFFQSw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLG9EQUFvRDtBQUNwRCxTQUFTZCxZQUFZNUYsQ0FBQyxFQUFFL0UsR0FBRztJQUMxQixLQUFLLElBQUlHLE1BQU1ILElBQUs7UUFDbkIsSUFBSSxDQUFDOEUsYUFBYUMsR0FBRzVFLEtBQUs7WUFDekIsNEZBQTRGO1lBQzVGLG1FQUFtRTtZQUNuRSxtREFBbUQ7WUFDbkQsb0RBQW9EO1lBQ3BELHFCQUFxQjtZQUNyQixtREFBbUQ7WUFDbkQsNkNBQTZDO1lBQzdDLGlEQUFpRDtZQUNqRCw2RUFBNkU7WUFDN0Usb0NBQW9DO1lBQ3BDLE1BQU1pTCxtQkFBbUJyRyxHQUFHNUU7UUFDN0I7SUFDRDtJQUNBLGlEQUFpRDtJQUNqRCxJQUFJNEUsRUFBRXdCLENBQUMsRUFBRTtRQUNSLElBQUlsRCxhQUFhZ0IsSUFBSXJFO1FBQ3JCLElBQUssSUFBSTNFLElBQUksR0FBR3FRLElBQUlySSxXQUFXM0YsTUFBTSxFQUFFckMsSUFBSXFRLEdBQUdyUSxJQUFLO1lBQ2xELGtFQUFrRTtZQUNsRTs7Ozs7Ozs7O0dBU0EsR0FDQSxtQ0FBbUM7WUFDbkMsMkRBQTJEO1lBQzNELElBQUlpSyxJQUFJekMsR0FBRyxDQUFDUSxVQUFVLENBQUNoSSxFQUFFLEdBQUc7Z0JBQzNCLElBQUkwRCxJQUFJMUQsSUFBSTtnQkFDWixJQUFLLElBQUk4RSxJQUFJcEIsSUFBSTJNLEtBQUtwRyxJQUFJekMsR0FBRyxDQUFDMUMsS0FBS2tELFVBQVUsQ0FBQ3RFLEVBQUUsR0FBR0EsSUFBSztvQkFDdkQsbURBQW1EO29CQUNuRCxJQUFLLElBQUk0TSxJQUFJdFEsR0FBR3NRLElBQUk1TSxHQUFHNE0sSUFBSzt3QkFDM0IsSUFBSXRJLFVBQVUsQ0FBQ3NJLEVBQUUsSUFBSXhMLElBQUk7NEJBQ3hCLE1BQU0sSUFBSTZILE1BQU0sQ0FBQyw2QkFBNkIsRUFBRUwsVUFBVXhILElBQUksQ0FBQzt3QkFDaEU7b0JBQ0Q7Z0JBQ0Q7Z0JBQ0EseUNBQXlDO2dCQUN6Qyx3RUFBd0U7Z0JBQ3hFLElBQUlwQixJQUFJMUQsSUFBSVIsU0FBUztvQkFDcEIsOERBQThEO29CQUM5RCxNQUFNLElBQUltTixNQUFNLENBQUMsNkJBQTZCLEVBQUVILFFBQVFDLGtCQUFrQnpFLFdBQVc3RCxLQUFLLENBQUNuRSxJQUFFLEdBQUcwRCxLQUFLLEVBQUUsRUFBRUEsSUFBRTFELEVBQUUsQ0FBQyxFQUFFUixRQUFRLENBQUMsQ0FBQztnQkFDM0g7Z0JBQ0FRLElBQUkwRDtZQUNMO1FBQ0Q7SUFDRDtBQUNBLDJDQUEyQztBQUMzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0Q0EsR0FDRDtBQUVBLDZCQUE2QjtBQUM3QixpRkFBaUY7QUFDakYsdUVBQXVFO0FBQ3ZFLDZEQUE2RDtBQUM3RCx3REFBd0Q7QUFDeEQsU0FBU3FLLGdCQUFnQmEsS0FBSyxFQUFFaEIsRUFBRSxFQUFFZSxFQUFFO0lBQ3JDLElBQUlyTSxNQUFNLEVBQUU7SUFDWixJQUFJNk0sUUFBUSxFQUFFO0lBQ2RQLFFBQVFBLE1BQU16SyxLQUFLLEdBQUd5RCxPQUFPLElBQUkscUJBQXFCO0lBQ3RELE1BQU9nSCxNQUFNdk0sTUFBTSxDQUFFO1FBQ3BCLElBQUk0TSxRQUFRc0IsdUJBQXVCM0I7UUFDbkMsSUFBSUssT0FBTztZQUNWLElBQUlFLE1BQU05TSxNQUFNLEVBQUU7Z0JBQ2pCQyxJQUFJckMsSUFBSSxDQUFDMk4sR0FBR3VCO2dCQUNaQSxRQUFRLEVBQUU7WUFDWDtZQUNBN00sSUFBSXJDLElBQUksQ0FBQzBPLEdBQUdNO1FBQ2IsT0FBTztZQUNOLElBQUluSyxLQUFLOEosTUFBTW5HLEdBQUc7WUFDbEIsSUFBSThCLE1BQU0vQyxHQUFHLENBQUMxQyxLQUFLO2dCQUNsQnFLLE1BQU1sUCxJQUFJLENBQUM2RTtZQUNaLE9BQU87Z0JBQ04sSUFBSUgsTUFBTW1GLE9BQU9wQyxHQUFHLENBQUM1QztnQkFDckIsSUFBSUgsS0FBSztvQkFDUndLLE1BQU1sUCxJQUFJLElBQUkwRSxNQUFNLHdCQUF3QjtnQkFDN0MsT0FBTyxJQUFJLENBQUNvRixRQUFRdkMsR0FBRyxDQUFDMUMsS0FBSztvQkFDNUIsbUVBQW1FO29CQUNuRSwrQ0FBK0M7b0JBQy9DLHNEQUFzRDtvQkFDdEQsZ0RBQWdEO29CQUNoRCxxRkFBcUY7b0JBQ3JGLDZDQUE2QztvQkFDN0MsTUFBTWdMLGlCQUFpQmhMO2dCQUN4QjtZQUNEO1FBQ0Q7SUFDRDtJQUNBLElBQUlxSyxNQUFNOU0sTUFBTSxFQUFFO1FBQ2pCQyxJQUFJckMsSUFBSSxDQUFDMk4sR0FBR3VCO0lBQ2I7SUFDQSxPQUFPN007QUFDUjtBQUVBLFNBQVMwTCxZQUFZckosR0FBRztJQUN2QixPQUFPQSxJQUFJZ0gsTUFBTSxDQUFDN0csQ0FBQUEsS0FBTUEsTUFBTXVFO0FBQy9CO0FBRUEsNEJBQTRCO0FBQzVCLHNFQUFzRTtBQUN0RSwrQkFBK0I7QUFDL0IsMkNBQTJDO0FBQzNDLHVEQUF1RDtBQUN2RCxTQUFTa0gsdUJBQXVCNUwsR0FBRyxFQUFFNkwsS0FBSztJQUN6QyxJQUFJcEUsT0FBTzNCO0lBQ1gsSUFBSXdFO0lBQ0osSUFBSXRQLE1BQU1nRixJQUFJdEMsTUFBTTtJQUNwQixNQUFPMUMsSUFBSztRQUNYeU0sT0FBT0EsS0FBSzFFLEdBQUcsQ0FBQy9DLEdBQUcsQ0FBQyxFQUFFaEYsSUFBSTtRQUMxQixJQUFJLENBQUN5TSxNQUFNO1FBQ1gsSUFBSSxFQUFDYixDQUFDLEVBQUMsR0FBR2E7UUFDVixJQUFJYixHQUFHO1lBQ04wRCxRQUFRMUQ7WUFDUixJQUFJaUYsT0FBT0EsTUFBTXZRLElBQUksSUFBSTBFLElBQUlSLEtBQUssQ0FBQ3hFLEtBQUtpSSxPQUFPLEtBQUssaURBQWlEO1lBQ3JHakQsSUFBSXRDLE1BQU0sR0FBRzFDLEtBQUssV0FBVztRQUM5QjtJQUNEO0lBQ0EsT0FBT3NQO0FBQ1I7QUFFQSwrREFBK0Q7QUFDL0QsYUFBYTtBQUViLE1BQU13QixXQUFXO0FBQ2pCLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxnQkFBZ0I7QUFDdEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsVUFBVTtBQUVoQixTQUFTQyxhQUFhOUMsSUFBSSxFQUFFLEVBQzNCTixLQUFLLElBQUksRUFDVCxHQUFHLENBQUMsQ0FBQztJQUNMbEQ7SUFDQSxJQUFJa0UsUUFBUXhKLFdBQVc4SSxNQUFNdEcsT0FBTztJQUNwQyxJQUFJNEksUUFBUSxFQUFFO0lBQ2QsSUFBSTFCLFNBQVMsRUFBRTtJQUNmLE1BQU9GLE1BQU12TSxNQUFNLENBQUU7UUFDcEIsSUFBSTRNLFFBQVFzQix1QkFBdUIzQixPQUFPNEI7UUFDMUMsSUFBSXZCLE9BQU87WUFDVkgsT0FBTzdPLElBQUksQ0FBQztnQkFDWHFPLE1BQU11QztnQkFDTjVCLE9BQU9BLE1BQU05SyxLQUFLO2dCQUNsQnlLLE9BQU80QjtnQkFDUDdMLEtBQUtxSixZQUFZaUI7WUFDbEI7WUFDQXVCLFFBQVEsRUFBRSxFQUFFLGVBQWU7UUFDNUIsT0FBTztZQUNOLElBQUkxTCxLQUFLOEosTUFBTW5HLEdBQUc7WUFDbEIsSUFBSTNELE1BQU1xRSxNQUFNO2dCQUNmMkYsT0FBTzdPLElBQUksQ0FBQztvQkFBQ3FPLE1BQU15QztvQkFBU2pNO2dCQUFFO1lBQy9CLE9BQU8sSUFBSXlGLE1BQU0vQyxHQUFHLENBQUMxQyxLQUFLO2dCQUN6QmdLLE9BQU83TyxJQUFJLENBQUM7b0JBQUNxTyxNQUFNbUM7b0JBQVU5TCxLQUFLO3dCQUFDRztxQkFBRztnQkFBQTtZQUN2QyxPQUFPLElBQUlpRixRQUFRdkMsR0FBRyxDQUFDMUMsS0FBSztnQkFDM0JnSyxPQUFPN08sSUFBSSxDQUFDO29CQUFDcU8sTUFBTXFDO29CQUFZN0w7Z0JBQUU7WUFDbEMsT0FBTztnQkFDTixJQUFJSCxNQUFNbUYsT0FBT3BDLEdBQUcsQ0FBQzVDO2dCQUNyQixJQUFJSCxLQUFLO29CQUNSbUssT0FBTzdPLElBQUksQ0FBQzt3QkFBQ3FPLE1BQU1vQzt3QkFBVzVMO3dCQUFJSCxLQUFLQSxJQUFJUixLQUFLO29CQUFFO2dCQUNuRCxPQUFPO29CQUNOMkssT0FBTzdPLElBQUksQ0FBQzt3QkFBQ3FPLE1BQU1zQzt3QkFBZTlMO29CQUFFO2dCQUNyQztZQUNEO1FBQ0Q7SUFDRDtJQUNBLElBQUk4SSxJQUFJO1FBQ1AsSUFBSyxJQUFJNU4sSUFBSSxHQUFHbUIsUUFBUSxDQUFDLEdBQUduQixJQUFJOE8sT0FBT3pNLE1BQU0sRUFBRXJDLElBQUs7WUFDbkQsSUFBSWlSLFFBQVFuQyxNQUFNLENBQUM5TyxFQUFFO1lBQ3JCLElBQUlrUixtQkFBbUJELE1BQU0zQyxJQUFJLEdBQUc7Z0JBQ25DLElBQUk2QyxlQUFlRixNQUFNdE0sR0FBRyxHQUFHO29CQUM5QixJQUFJdkQsTUFBTXBCLElBQUk7b0JBQ2QsSUFBSyxJQUFJTCxNQUFNeUIsS0FBS3pCLE1BQU1tUCxPQUFPek0sTUFBTSxFQUFFMUMsTUFBTzt3QkFDL0MsSUFBSSxFQUFDMk8sSUFBSSxFQUFFM0osR0FBRyxFQUFDLEdBQUdtSyxNQUFNLENBQUNuUCxJQUFJO3dCQUM3QixJQUFJdVIsbUJBQW1CNUMsT0FBTzs0QkFDN0IsSUFBSSxDQUFDNkMsZUFBZXhNLE1BQU07NEJBQzFCdkQsTUFBTXpCLE1BQU07d0JBQ2IsT0FBTyxJQUFJMk8sU0FBU3FDLFlBQVk7NEJBQy9CO3dCQUNEO29CQUNEO29CQUNBLElBQUl4UCxRQUFRLEdBQUdBLFFBQVFuQjtvQkFDdkIsSUFBSW1FLFFBQVEySyxPQUFPM0ssS0FBSyxDQUFDaEQsT0FBT0M7b0JBQ2hDLElBQUlnUSxPQUFPak4sTUFBTUwsT0FBTyxDQUFDcEMsQ0FBQUEsSUFBS3dQLG1CQUFtQnhQLEVBQUU0TSxJQUFJLElBQUk1TSxFQUFFaUQsR0FBRyxHQUFHLEVBQUUsR0FBRyxvQkFBb0I7b0JBQzVGLElBQUlBLE1BQU1zRSxJQUFJbUk7b0JBQ2QsSUFBSXZMLGVBQWVsQixLQUFLeU0sT0FBTzt3QkFDOUJ0QyxPQUFPdUMsTUFBTSxDQUFDbFEsT0FBT0MsTUFBTUQsT0FBTzs0QkFDakNtTixNQUFNd0M7NEJBQ05sQyxPQUFPd0M7NEJBQ1B6TTs0QkFDQTJNLFNBQVNDLHNCQUFzQnBOOzRCQUMvQjJLLFFBQVFrQyxhQUFhekwsYUFBYVosTUFBTTtnQ0FBQ2lKLElBQUk7NEJBQUs7d0JBQ25EO3dCQUNBNU4sSUFBSW1CO29CQUNMLE9BQU87d0JBQ05uQixJQUFJb0IsTUFBTSxHQUFHLHVCQUF1QjtvQkFDckM7b0JBQ0FELFFBQVEsQ0FBQyxHQUFHLFFBQVE7Z0JBQ3JCLE9BQU87b0JBQ05BLFFBQVFuQixHQUFHLGdCQUFnQjtnQkFDNUI7WUFDRCxPQUFPLElBQUlpUixNQUFNM0MsSUFBSSxLQUFLcUMsWUFBWTtnQkFDckN4UCxRQUFRLENBQUMsR0FBRyxRQUFRO1lBQ3JCO1FBQ0Q7SUFDRDtJQUNBLE9BQU9vUSxzQkFBc0J6QztBQUM5QjtBQUVBLFNBQVNvQyxtQkFBbUI1QyxJQUFJO0lBQy9CLE9BQU9BLFFBQVFtQyxZQUFZbkMsUUFBUW9DO0FBQ3BDO0FBRUEsU0FBU1MsZUFBZXhNLEdBQUc7SUFDMUIsT0FBT0EsSUFBSW9ILElBQUksQ0FBQ2pILENBQUFBLEtBQU1xRixVQUFVM0MsR0FBRyxDQUFDMUM7QUFDckM7QUFFQSxTQUFTeU0sc0JBQXNCekMsTUFBTTtJQUNwQyxJQUFLLElBQUk5TyxJQUFJLEdBQUdBLElBQUk4TyxPQUFPek0sTUFBTSxFQUFFckMsSUFBSztRQUN2QyxJQUFJOE8sTUFBTSxDQUFDOU8sRUFBRSxDQUFDc08sSUFBSSxJQUFJbUMsVUFBVTtZQUMvQixJQUFJL00sSUFBSTFELElBQUk7WUFDWixNQUFPMEQsSUFBSW9MLE9BQU96TSxNQUFNLElBQUl5TSxNQUFNLENBQUNwTCxFQUFFLENBQUM0SyxJQUFJLElBQUltQyxTQUFVL007WUFDeERvTCxPQUFPdUMsTUFBTSxDQUFDclIsR0FBRzBELElBQUkxRCxHQUFHO2dCQUFDc08sTUFBTW1DO2dCQUFVOUwsS0FBS21LLE9BQU8zSyxLQUFLLENBQUNuRSxHQUFHMEQsR0FBR0ksT0FBTyxDQUFDcEMsQ0FBQUEsSUFBS0EsRUFBRWlELEdBQUc7WUFBQztRQUNyRjtJQUNEO0lBQ0EsT0FBT21LO0FBQ1I7QUFFa0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4Lm1qcz85NTg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNyZWF0ZWQgMjAyNS0wOS0xNFQxNzo1NjoyNC4wOTlaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogOTJjYmYzYTFhZjNjM2MwYTkxYWVlMGRjNTQyMDcyNzc1ZjRlYmJiYzUyNmE4NDE4OWExMmRhMmQ1NmY1YWNjZFxudmFyIENPTVBSRVNTRUQkMSA9ICdBRWtWTVFudkRWMEIwd0tXQVFZQlFnRHBBVFFBb1FEY0FJVUFwd0JzQU9NQWNBQ1RBRVVBaWdCUkFIa0FQZ0EvQUN3QU53QW9BR0lBSGdBdkFDc0FKUUFYQUM4QUhBQWhBQ0lBTHdBVkFDc0FFUUFpQUFzQUd3QVJBQmdBRndBN0FDb0FLd0FzQURRQUZnQXRBQklBSEFBaEFBNEFIUUFkQUJVQUZnQVpBQTBBRGdBWEFCQUFHUUFVQUJJRXRBWVFBU0lVT2pmREJkTUFzUUN1UHdGbkFLVUJBMTBqQUs1L0x5OHZMd0UvcHdVSjYvMEhQd2JrTVFWWEJWZ0FQU3M1QVBhMkVRYkl3UXVVQ2tFRHlKNHpBc1VLTHdLT29RS0cyRCtPYjRrQ3hjc0NnL0lCSDk4SkFQS3RBVUVDTFkwS1A0OEE0d0RpQ2hVQUY5UzV5QXdMUFowRUczY0EvUUk1R0wwUDZ3a0dLZWtGQklGbkRSc0hMUUNyQUdtUjc2V2Nmd0JiQnBNakJ1a0FHd0E3REpNQVd4VmJxZnQ3dXljTTJ5RFBDTHNwQTdFVU93RDNMV3VqQUtGOUdBQVhCQ1hYRmdFZEFMa1p6UVQ2Q1NCTU53bVhDWWdlRzFaWlRPT0RRZ0FUQUF3QUZRQU9hMVFBSVFBT0FFZnVGZGc5OHpsWXlwWG1MZ29RSFY5TldEM3NBQk1BREFBVkFBNXJJRnhBbHdERDZ3QWJBRGtNeFFBYkZWdXArM0VCMjI0Y0hRVmJCZUlDMEo4Q3hMQUtUQnlrWlJSekdtMU05UUM3RFdjQzRRQUxMVFNKRjhtUkFvRjdBUk1iQUwwTlp3TGhBQXN0QVVoUUpaRk1DZ010K3dVeUNkZHBGNjBCMTBNQVNTc1Nkd0l4RmlFQzZ5ZTVOMnNBT2VFQjlTVUF4dzdMdFFFYlk0RUFzUVVBQlFDSzAwa0ZHOE1mQnhjQXFDZlJBYUVyTFFPYkFHY0JDaGsrN1RkMEJCZ1hBS29CeHdJaEFOTXJFbk02ODFDd0JaQTZkeWMxU0FYNkp3VlpCVml2dUFWcE8xMUNFanBZUVpkN2syWmZvZmdMRXdQRkJ5WHhkeU1FbzBzQ1UxTUNkUnVySndHUG82VTFXd05GRndTRFlRa0EwUWFyUHk4akJ5a0NPVjBBYXdGaEgzRUFneDBaQUpVQlNiY0FKMmtYQWEvRkF6Y3RJVU5UQVc5WkJtVUNaUUR4U1JjREtRRUZBRWxCQUtzQVhRQnpBQ3UxQmdmejd4bU5md0FKSVFBcEFMTWJSd0hSQWRzSEN6R1hlSUhvQUFvQUVRQTBBRDBBT0ROM2VkUEFFRjhRWEFGTkNVeHNPaFVMQXF3UHBndmxFUlVNMFNyTDA5Z0FOS2tINndOVEIrc0RVd05UQitzSDZ3TlRCK3NEVXdOVEExTURVeHdLOEJyVHdCQmZEMGdFYlFXT0JZc0UxZ2lESmtrUmdRY29DTkpVRFhRZUhFY0RSUUQ4SXlWSkhEdVRNd3NsUWt3TVRRTUgvRFpDYktkOU9BTkhNYXRVOVpDaUE4c3lUemxzQVI1eEVxQUFLZzl6SERXMVRuNTZSM0dnQ2t0UHJyVi9TV0pPWndLK09xZy8rQW9oQ1pOdnUzZE9CajBRRnllaEVQTU1Md0d4QVRjTjZVdlVCTzBHTndURkgza1pGUS9KbFpnSW9TM1pET2ttM3k2ZGdGWWo4U3AvQmVsTDhEelpDMGxSWkE5VkMyRUozenBmZ1VvREhRRUpJb2NLMlEwMUNHa1E3d3JGWnczaEVVRUhOUVBSU1pZQW9RYjlDdzBkTVJXeEpneGlxQXNGT1hNRzl4cnlDNHNtcXhNbGV2Z0Z6eG9kQmtrQkpScjdBTXN1NDRXc1dpMWNHRTliQmY4TElTUERGS1JRSEEwaFFMTjRSQm9YQnhFbHBRS05RMnhLZzFFeUhvOGg4anc1RFdJdUQxRjRCL0U4QVJsTEMzMDhta2FuUlFvUnpqNkpQVVFpUlV3b0JERjdMQ3NuaHduTEQ0RU10WHh1QVZVSkhRbXRERzBUTFJFVE44RUlOUWNWS1pjZ0p4RUlIVWFSWUpZRTg1c0Q3eFBOQXdjRk93azlCdzhEc1J3cEV5b1ZKUVVKZ1NEVEF1ODIwUzZ2QW90V2ZBRVRCY2NQSVIvYkVFeEgzQTdsQ0pjQ1lRTi9KZWNBS1JVZEFCTWlsd2cvWHdCYmo5UlRBUzdIQ01OcWFDTndBMk1VNDEwUmJ3ZU5EbE1Ib3h3dkZic2MzWERFWGdlR0JDaWZxd2xYQVhFSmxRRmJCTjhJQlRWWGpKd2dQV2RQaTFRWWx5QmRRVHRkK0FJdERHRVZtMFM1aDNRQ2h3OW5FaGNCTVFGdkJ6VU0vUUp6RWVrUlp4Q1JDT2VHQURXeE0vUTZJUVJMSVg4Z0RRb2pBMHRzeWdzakp2VU05R1VCbnhKZUF3ZzBPWGZxWjZkZ3NpQVgrUWNWTXNGQlhDSHRDNDVQeVF5WUdyMFlQbFFxR2VBSHV3UHZHdThuNWtGVEJmc0Rudzg2U1RQcUJMa0xaUWlIQ1RzQVJRNmZFd2ZUR0dZS2JZek1BUzJIQWJPVkExT05md0pyaXdZekJ3Y0FZd2VEQlhYaEFCa0Nvd2lmQUFFQXl3TlRBRFVDcVFlWkFCVUFnVDBCT1FNakt3RWQ0UUtMQTQ4SUxjY0JrU3NCN3lVRUY3OE1FUUR6TTI1R0FzT3RBb0JtWnA0RjJWUUNpZ0pGTVFGSklRUUJTa05OQTZ0dDNRRFhBRWNHRDl0REFSR25Sc2NXM3o4QjIyc25BTU1BOXdBQk1RY0JQUUhKQWU5cEFMTUJXd3N0Q1o2dnNRRko1U1VBZndBUlp3SFRBb1VBMlFBeEFIdnRBVThBU1FWVjlRWFBBa3RGQVEwdEZDZFRYUUczQXhzQkx3RUpBSFVHeDRtaHhRTWJCR2tIendJUUZ4WGRBdThxQjdFREl0c1R5VUxCQXIzYVVRQXlFZ28wQ3JVS3RCOWY4MXd2QWkxdVBVd0FDaCtrUHNNL1NnVk5PMDg3VkR0UE8xUTdUenRVTzA4N1ZEdFBPMVFEazd2ZXU5NEthRjlCWWVjTW9nM1FSTVE2UlJQWFlFMWdMaFBFTGJNVXZSWEtKVklaT1JxNEp3RWw0RlVGRHdBdHoyWXNDQ2cwY1JlNEFEc3BaSU05WTRJZUxBcEhIT05UalZUMExSY0FyVXVlTTZzTnFCc1JSRHdGUTNYcFlpWVdDZ29lQW1SOUFtSStWMG1yVnpjY0FxSHpBbWlVQW1ZRkFwK0FPQmNIQW1ZM0FtWWlCR29FZXdOL0R3TitqamtDT1hNVE9YNDZIeDhDYkJrQ01qSTRCZ0p0d3dKdHF1dUdMMk5CSndGakFOb0EzUUJHQVFlVURJa0ErZ2UrQUFteEFuY3JBbmFlT3dKNVJ6OENlTFlaV05kRnFrYlRBbnc3QW5yRUFuMEZBbnpzQlZVRkhFZjhTSGxmSUFBbkVVbFVTbGNSRTBySUF0RDlBdERJU3lNRGlFc0RoK0pFd1pFdUF2S2RYUDhEQTZwTHlrd3BJY3ROU0UyckFvczdBb3JVdlJjREdUOWpBYk1DampNQ2psZzhrMzBDanRVQ2psaDBVYkJUTVFaUzBGU0JBcFAzQXBNSUFPVUFHRlVhVmF0VnpBSXNGeW1SZ2pMZGVHSkZOelVDbDVzQzc2NVlIYVFBVlNFQ2xvc0NsbmlZQUtWWnFGb0ZmVWtBTndLV3NRS1dTbHhBWE0wQ21jY0NtV0JjeGwwREZRS2Nsem0rT3BrQ25CSUNuNWNDbnJTR0FCa0xMU1lMQXAzdEFwNk9BTEU1WVRCaDZ3S2V6d0tnYWdHbEFwNmJHd0tlU3FGanhHUWpJU2NDSjZzQ0pub0NvUGNDb0VnQ290a0NvY0FDcGlzQ3Bjb0NwL3NBZVFLbjdtaDRhSzMvUldvWWFzMENyTjhDcktvQ3JXTUNyUDRDVnhrQ1ZkZ0NzZDNUQXg5S2JKTUNzcmtKQXJMa0UyemNiVjl0UkZzREpja0N0bGczTzI2TUF5bEJBcmhhQXJsREVRSzVKbk53TW5EZEFyMFZBcnZXY0pJRE1nMEN2b1J4L2dNemJRSytGbk1lYzBzQ3c4Y0N3d0J6Zm5SSE1VRjAzQU04b3dNOGxnTTl1d0xGZUFMR1F3TEdESVVDeUdWTkFzaEFBc2xMQXNrcUFtU1pBdDNPZUhWZGVLcDVJVXZNQXhpZlp2NENZZkFaNzVVZ2V3ZGVqbDYzRFFMUFp3TFBhQ3RIVDg3dkQ1c0F3cWtDejI4QkplWURUZzUrUndFQzNDTUMyNFlDMGtzRFVsZ0RVMXNBL1FOVmlJQ0ZPOGNTNlZ4QmdoaUN6NExLZzRrQzJzTUMyZHFFRElSRnB6Z0RocUVBS3dOa0NvWnRWZlVBVVFMZllRTGV0Rzl6QXVJcjdSQUI4eXdqQWZTWEFmTE9nd0xyN3dMcGJIVUM2dlVDNnVBQTlVTUJ0UUx1aFFMcm1KYW1sdjhDN2pzRGhkeVlkWERjY1owQzh2OEFaUU9PRXBtUEF2Y1BBNUZxQTVLREF2ZVVBdm5WQXZoaW1oaWFwN2N6bXhvRG5YOEMvdllCRndBMW54aWZyd01GaVFPbVpnT20xUUROd1FNR1pxR0VvZ0VGQXd4RkFRc0JHd2RwQmwyMVl3RUF0d1JudXcySEhxOEpBQk54TlFBZkF5OFNTUU9GZXdGZkl4MEFqT3NBSFFEbW53T2JqUWl6Qmh1ZndRQ25CUkc3NlIwOVBoWjRCV2czUGtBclFpRkN0Rjl4RVYrOEFKYkZCVElBa0V3Wm03azdKbUF5RWJyUERpOFl4aGlKeWZZRlZ3VllCVmNGV0FWakJWZ0ZWd1ZZQlZjRldBVlhCVmdGVndWWVJoVUkxNFZuQWdJQ0NtUmU2U3NFeVFPeEJpKzd1d0M3QktlN0FPZEFLUmF5QlVZK2FUNXdRajlDdGw5MU4xL29BRmdSTTZzQWpQN01hOHY4cHVkR2VqMG1Jd1FyRmljMk5YNXQzMnJCOFJuQ0xHa0JhOWR1TUJjRlh3VnF5Y0hKdUFqUFNWc0FBQUFLZkY1OWk3NEFNeitCQUFNVzBRYmxyU01GQUl6REN3TUJEUURsWlIwOUpCOUtRckZDdkVFNEkxOG5ZRFluT0NNSndUMEtSRDlEUG5nK2dUNXdQbkVDaVVLOFNVSTdYOHRPVDJwTkNpeHJWQzlxQzI0ZlgrQXpPaHNKWjVzS1lpTXJQQjBtUXF0Q3ZDdk1BY3Y4WDhrT0h5NEpDQWtpZnAzZmFqb3RTaGZKcThtc0NXWEJ5OHdLWUVGZkQrVVFveEVBazQwZFJVSWxHNmx0T2M0NENqTS9RejV3UWo4Y0J3b2RURWRzV3l3dFd1RzhFZ3A5N1IwclFqOGNYUWhLQ1E0elZFTkNOd1E3UTV3c0NvRWJMVUkvRy9VSVV5SWpHREF4QUFXUFlmQmVDbkZreVdBTFlDMGpia05nR1RrQ0d4NWdzd1lDYXhCbFRtQk5FUUZrNTJBVllKVmdmV0N6WUV0Z2tXZ1dGd2ExRHR4VnFieGFDME1XcXdHN0s4M0JBaDhWQUJ3REhnRjVBbXd2TUpWU2dBR0tDcmhIR2dEa0kzU09Dc29OcGszcUFac0NoNXhQQlVCZkFQZjNCd0EwRmxjTUM2VU1KQis2cjBlQWdRdzBBQlVUbnl1Q0NIb0MwZ3RMWlJFYkFOaE9CblVFQ2g1YUFERUF0cml0QUpRbkN4WnZxeVE0bnhrQld3R0dDZndEMmUwUEJxb0dTZ2E1QUIzTFZhbGFDYnRoRTRrTExUOE91d0c3QVNJQ1Ixb29LQ2dnSGg4aExCSW1CaUVNalFCVUFtNVhrRW1WQVc0ZkQzRkhBZE4xRDg1UklCbXBzRTNxQnhFRlRGOEE5L2NIQUhvR0pHd0tLd3VsT0RBdHg2OVdEUXNBWDd3TEFHTkFsUWg2QU9wTjd5SWJ2d0F4QUxhNHJRQ1VKeTA3RHM0Q2tCaDdVTHRZeUhSeWpzT2xtdy9aRlVrYjdBRXBFRndTQmgvbEFjY0pPaENUQlE4ckREWUxBQkVBcytBaUFRSUFwQURoQUppQ0NySnJPUzhBRkFCYkc4WXViSFlxRGNFUUFqc2tITlBoSEI0TEczMENld1RCQ3FyeGJBQW5MUTZtTHM2aEhBZTdDUUFRT2crN0drY2N6YUYzSGdFOUtsOGNMczRSR1FCOXE5b2NBdXVnQ0FIQ0FVTHo1QjlsQWI0SnR3ejZDRHdLUGdBRndBczlBa3NOdXdpOERUd0t2QWs4RHJzRm1BRWJhd291enFFcUQ0c2E0UUhEQVJFV093Q2dDenNMdXhDN0JCaXFlOXdBTzJzTVBBQUNwZ204QlJ2UTlRVUJ2Z0g2YnNvR2V3RzdEMDBSRXJ3QkFRRHFBUUFBZEJWYkJoYkxGUHh2RjdzWU94amJMN1p0dmdOSXFMc0FCN3NBTHJzQzZ3NVdBQXE3QkFBZXV3SlZJQ3AvRlR3VnV3RytKK1FBc2xvQnZTamdvN3ZJQUFGYkFBRzdBQUpiQUFMakFBZzdBQTY3QWdBYnU2VmJEci9FQVBRQWFQdW9Pd01CdTVVblN3RG4zUm03Q0JwN0NLRUZDdjl3QU4rN3A3c2F1Nk9MZVhJRys2bWJnd0FTdXdZYkN3RzhBQUNHQUcyN0JnQUx1NmM3QVJvN3VnaWhuTW9CdXd2dEI4Q3BPd0RoZXdHL0FBRGxBQlc3QUFiN0FBbTdBR21MQUJxN0dMdU9hUlg3QUE1ckFDNUxIZ0FHdXdBWHV3Z2hBQTFLQWNJQXQ2OG1BY0FBQUxRQURwc0FIQnNCdi83aENxRUFCY1lMRlJYYkFBZWJBRUs3QVFJQWFic0FDM3NBSGJzQUNMc0pvUUFGeWdCdW54blZBSkVJSVFBRnlnQUJPd0FIMndBZG13Z2hBQWFhQUFsN0FCc3JBRzBiQU9hN2dBQUlXd0FVdXdraEFBYktBT09MQUFrN0M2RU94UHRmQUFjN0FHNmNRRWdBUndBRE93QUpyUU0zQUFjYkFCbDdBYnYvQWFiN0FBb2JBQW83QUFuN3Arc0d1d0FKR3dBREN3QVFPd0FJUEFBVU93QVJhd0FQaXdBTjZ3QU51d0FaQ3dZV0d3QVZPd0J1bXhtN0FMb2JMZ0FUT3dNQWFTc0tBT0ZMQUFJN0FBUlNBQmQ3QlJzQUJ0QUFHTHNBQy9zQVg3c0FhL3NBNUlzQnV3QVhkZ0c4QUFGeUM2RUFCVW9BYlhZQUIvc0E1WHNBSEdzZUFYc29VZ0E1UlFEK0J3ME1jZ0FvS25BQnBBVUlYZ0c4WGlNTUNRZHZTMnhmS29rZlBCUmlMVFlEb1FxMEFkZ0FGZ0xSQTI0QmRuSkhVaFFoQTA4Q0ZUNEJMQVlEYzBhOGUxSjZRQUFwQURFQit3QlRDdHNBZTVBc0FTc0FkdVVORVRKR0FVb0FWd1VBQVZBQkI0ck1BSGc3QkNDbEFGb0ExaFVBbFdnM0g0c0F6V3V4QU0vVUZnakNkWE1iR0ZZZENkRUJpSkNySWxOVFRVZ1NQTUtKK1FCL0hEZEFLU3ZnRVpkUEFISUJLU3d3S1VJWkR3TXdWUVQzeGU0QVMyWGNBR29DY1FJL0VYbzZ4M2d1TmRVR0JRQVFHeDBLQ0F3cUJCOGRLVTVUVGdpNXVnQUtFczBBSmdBQkdnQ0dBSWtBampVQTdnQzBBT0FBblR3QXV3Q3JBS1lBb1FEeUFKOEEwd0NjQU9zQkRBRUhBTUFBZVFCYUFNc0F6UUVIQU5jQTZ3Q0lBS0lCTlFEakFOZ0ExUU1CQnlvejFOVFUxTGJBM00zUXprTXlGd0ZOQVZjdlJ3RlZBV1FCWXdGV0FVZExRMFZvRFFGT0ZRY0lBekkyREFjQUlnMGtKaWtzT0RvNlBUMDlQajhPUUI1UlVWRlJVMU5TVXlsVVZWZFdWaHhkWVdGZ1ltRWpabWh3YjNKeWNuSnljblIwZEhSMGRIUjBkSFIwZG5aM2RuVmJBRURzQUVVQWxnQjBBQzRBWXZJQWlnQlRBRk1BTXdKejZRQ0gvL0x5QUdBQWord0Ftd0JMQUY0QVlQbjVxZ0NCQUlFQVpRQlNBSzBBSGdDeUFIOENQQUkvQVBnQTR3RDZBUG9BNUFEN0FPVUE1UURrQU9JQUtRSjNBVTBCUEFFNkFWQUJPZ0U2QVRvQk5RRTBBVFFCTkFFWUFWUVBBQ3NJQUFCTkZ3b1dBeFVXRGdDS0FKSUFvZ0JMQUdRWUFpMEFjQUJwQUpFREVnTWtLZ01lUVQ1SEtRQ0xBa3NBd3dKVEFxQUF1Z0tTQXBJQ2tnS1NBcElDa2dLSEFwSUNrZ0tTQXBJQ2tnS1NBcEVDa1FLVUFwd0Nrd0tTQXBJQ2tBS1FBcEFDa0FLT0FwRUNjUUhRQXBNQ213S1NBcElDa1JaNUN3RDZCUU9uQWwwQ05oY0JVQkExQXQ0UkNpc1RBVW8zRTAyUkFYZWtQQUZsV1FEL0F6MUhBUUFBa3lrZUdJOXFBQ2xnQUdrQUxnQ0pBNVRNaS9DdWhGb0Z1aXNPd2hFQm5kVjBLZ3NFSXpGc0FUTmFiQUd5QU41K2dIOStnSDZCZ29KK2c0YUVmb1dJaG9DSGdvaUNpWDZLZm90K2pJcU5mbzUrajRLUWZwRitrbjZUZnBTRGxZaVdncGQrMmdMYWJPRUMyR3dBZ213a2JLQUFnMnhzQkVrRVJnUklCRXNFU1FSUEJFd0VSd1JOQkU4RVRnUktCRXdFVHdDV1ptd0Fvd09JYkFDMFpnRUZiQURKVVd4c0FNOXNBZ3hzQVBaYWJBRDJBUmtBOWdEMEFQUUE5UUQwQTMxZWJOU0VJMlhBQVBZQTlBRDBBUFVBOUJ4c2JBQ0pXbXdBOWdDSkFSa0E5Z0NKQUw0QTZBQUlBUFlBaVFOOVhtelVoQ05sd0J4c0FQZGFiQUVaQVBZQTlnRDBBUFFBOVFEMEFQY0E5QUQwQVBVQTlBTjlYbXpVaENObHdCeHNiQUNKV213QkdRRDJBSWtBOWdDSkF1MEE5Z0NKQUw0Q053RDNBSWtEZlY1czFJUWpaY0FjYkFKREFUWnNBa29CT1d3Q1M4RnNiQUpYYkd3RG53THRBNThEbndPZ0E2QURvQU9nMUlRalpjQUdBMzFlYkJ4c2JBQ0pXbXdCR1FPZkFJa0Rud0NKQXUwRG53Q0pBTDRDTndPZkFJblVoQ05sd0FZRGZWNXNIR3dFUG13QWlRUS9BSWtHalRGdElERnMxbTRES0d3RHJBSnNiQUJWV3Y0Vk1nSnNiQUNKQW13QVZBRUF1bDVzQW14ZWJHd0FpVjVzQW14ZWJEM1lBRWxzMWdKc2JFYkN4eFAveDVCQXBBMEtZRkE4OUFzalR4OTdFSG1KUVB5b2NJdEMySm5ORlJDRW5GVTZTRlREb0kwUHhlUk5Sb05SV2twelZuV1c4cFRhZ2tObWdmK2pHdXBxWjNldTUwTEFGbmMrT3pmSndkdWIxQWRwT3k3NlZuaWpXTlIvQ01FZXZpa1FrRnlRdUx1UGFqeFdpOWNocU9vTUo3cXBDTjRzeDNMSkc0TXl1OGtENjh3QzYraUF3dCtwVTFKRWVZMTNycENWa1hTWmZpblZLbjR4WnB4c0kzTHA4YkpMcko5dWprcklhbE1SQkFjdi9HU0tFdG93emNFbjVYbUp3MkJhZ0I4VjJVV0pvSkhaMTRTWGhNN3AwWGVHRk91dzZtbHZ5cTk5V1lwNVh4ck82cnU5bm40UkhjT2tKN2h4NVVxV3RtYW43eVZNTHpZWFFlZlFSVWRJWTcwUllRRTgrYUF6Q05TR1FrWGlIZm5IWVJNaSt4Y3pLRGRaTGszQVYxZ3p4a2tTSExqQnd1cThzaElKKy9SQWJxanFRYnVnRmhlMHJxa2x1NDMyRUVSa001azl5MURYemRzNDZvTHFLQXg2T2hQVDJXaXFFZmhhSVRuN09GOVk2OTRBbUttVXZicFdwMHhKcURhZjNqZU5KWG5LNk5wbkdjRk9tYmNsYkFSQys1KzVVNTJ1Znc1YjBIaCsyTHJyTmltdlplNGVZbUFwUnNabkpFMzEwU3FCKzF4QjZyU0pmblYxZjJEMGF3QjE4T2Mwc1hBRnFJbGdIZ1dpYVpHZHZQNUNKVVNzQ1RDUVVDMzM1K2lTa3dQbExKSjVsd2pUU245THcyMk5iSzFUdTh3K2JVcEh0RFJEUGhvN0d1bjhhdzJKenU5aStOME90L2tQTWJMQWIvclVRODJrZnBrODVxTERrZnhMbDM5UVBEbmdvNzJHWWgvWGlnYnBjbTFwQTIzRDJ5d3QzRDhHZ01PYW8wNDB3RHFrSHhPRXgwT2hDK1ptSGlJZGpLN3lSYmZKRDJvdVpiQWVkaEQzcDdzOFdEbUNKZk5mb3JnRFlQR0FYU0kwOGZUalBaNUIzN2xjNVZYR3pjMXZKbWliRHdCTlZ6WHVhVXpnN041SDRCeHFqaEora3o5SExVSnlzN2JwQkRZQVB2YnV0MTNBd0pDV2QwNTl0UzhZVFlnQzhId3JrZXdCZmExTFNTcG1Ncjl1UjJFZWtUaUFNSCtNeDRBR3pnYnF1Y2N3QkRsTG1SaGdYTC9ZaUxQQ0ViNmQyazVxSjZvODAwcWRkQUJrcHF0N05HK3NjMnV2SFp3WnM1N1cxQUhURk0xS2tNU2hhc0FEQWgyRnZ6YnpKT3pWRE1TM1psVDJCU0ZLZG5rWkZCNkp5cUpiaG02WEFOaXM5VHJ0ekpkbFBWcCtybDh2M25Ja2U2Sm91N20yVEt1NTNWb3VudXBna3oyTHpyUVBoaGF0TElHN3JmRi9nVUtXcDE1WDNMS3QrWnZ1Q0RTcVBVaWdGOXlKbnRpbUMxSEpSN1lqL2RVckxBWFdyVCsxdG53UEpKTEdLQWxRNVZlTkRXUktDVHQydnozckp1bzQrZ0l0NzUvTWtmbC9nU1pibFo5ci9TRWVlb3NaWG5lbGkveE5oMVdWQ3ZrUnQyUm55eWp0TWtNcWh6WGgxUFZPQ2JJTHF2MHI3ckdZbTBDSEl5S2RoSEw5MGNsOUUxSTZlRXRRVEN0NlJYajhNMEhIckhDSExWUnBOTTZXSWJUNUJDTUdWbkwwbzU4OTVxU1JiQ0p6KzVJOFBHTWhBTi9Ycmo0QmdJZGxLcWxIdEJIcVRKd21LMTY5dG9aMklXeE56ckFiSUc3emg4NVEvTEcyQTR5QmNhQmVsNTJ6ZHVub2tCMGx2M0E3a1huVEk3TTZabmZaN253dWo1bGtHaHFTcFcrdzVDSS9GbVJscGxCRWJuWnkxWnhTM0RMOHJmMVlXaE81WGl2V1pCU1JoMWdGc2pqeWozcVJHMWNtLzZvcnM3V3NFaWY2V1J4bnMxTUtEWmE2S3JiZk1RL3N3SWIrMm5iMHRxeEhlaWk2RmNnVmVBakUvWHdhYzFvd3gwNGRKS0c4UjVZUWdITm5FZkhmMHFiOFdPblUwZVFTamF6cStJSzdjU3VDcVl6UEVVQi94K1FnR1pxTTNkQm9Zdk52WlZPSERrYmdkaWxXZGFncU81Ymt5YlhmTHB5TVB1R3E4bXZBQUVaR2JSNlJ3WEdsVzlFck9XVGZuamZ4NmRYRkpxQmowT0JTR0Z6NGxXUWFzTk9tVkplTjRTRldTTGZPR0IvN2VoVjVZdW9OTlJPSFpFRzlFbFZ1TW5xYkRNTXVEbGVPdC9jTi9nc1d4R3cxMjhtd1U4L0h4a09LcWRUWm5JN2RIa2E2N1dDVGYvRm1CcnhwTkNhS0oxR3hCVENTUzdNTmZoTmo4UzRHdG90ZzZaM0FNOWNBZVZST25wcFVNYWlWNWpqdWRMbk5xb1ZyS08xL0ZpakxsQWM3NGt4eWR4S1gxUlF1TXFIUjYzZWVjWXI1bzZNSitCNzhWc0xsQ3JwZWxXaDZHT3JDT0JJb1FtSWNkcEpMMXB3RTJ6elpxQmtlY0dUZEs4S01PQjZyMWVOUlVSeXJ6Nk04OTlUWmFvUy92Tk94SGYrNWdPUlUrT3lZSWNJVzZkaVAyNUdIRjZ1OFROanVML0dKekNuTExYZDAxS3JzalJhNTF2NCtPL1ZJQVdYRVNKeGZ4V2p2NjI4SitjV1VRcG9EK1l5dHpzM2pTTVJKMjMvWFQrdlVkdFVNTERRcTF2bklvZWcvR2pXaDg4TVQ2azlkUnFEYVErdm9kaWxGZ3ZqdU53NXBKcElkOW1md3lZZUxDR2IzQm1IWGRmUWZoZlBSUWF1cGUvZjhURzRCazNlREtsWUJhRUsza1pZTk4yU2R4ejQ3bS92WUJ4dklPS3RucXBsQjFwZWJ6dVhtQXIvTXV6UUNrbktlNjUzZHphV1FRN01VaFdZV3Z6SVp3TGUxdjByWHhJbUxheitBa0F1K3NZaWtob3VORjNFVzZ3NGNyWjZNdVVpRGJJQXg4WGhBZmVnY3ZXNng5QlBiMy9zQ3hHV3U5WXlhdHFFeEIrVFNtNjlxSWtJOUl3aGpyY256TUUraldCeDRtTlFtNVd3THpValN5WTRGWjBhTUY1WUZsWFVENGhMNFhmT2VZdjVyRGUyczJEL0NuKzI4Zlo5VUNuT1F2WEZNblFxZmMwRytacU9XV0Q5bC9saXFVUGFOUXpaanhDSHBVQUQ4UmNjOTBNbmlRMDJ1Z0hXc1V1cEZVdmhDOXVzWTd6TlB0NUYyak83cWd6aGFmc1FTZDUwamdMckM2UXg2YnBIYlhSM1dOQXUxQnpHbXdieitlYkdtd1RqZHkwMDZZNnppcFA3bi9PSmx2U21icStTWStuZWZBVktLNkVCTVBiY2U1bjNJZFJJOCt2YnhDcE41M3J3M1R2Z05kczFTdU1pdUxHeHQ4OUw3MW14UERlYW5HaHlIdk9qbU81NnRuVnBvSGFsUW5MNlRxTnVxS3NIakhDSUtCNHBDZ2o0V3lZUHZSdll2cWk1RU1yN2xOM01vdFBSL0tIN0pVRDFsWmJVMFF6ZmJyRUJKbnVRaVZBeUFDOXZ3WFdwMlRSVTEvMGFhcHlBSDJjYmdsRUhWQWRsKzFyYjF1MTQ3dVYwdGQxZU5vUVpzcUhySU1JWVZQWHRMazJUSVUzY0pFMDhQam9ZTkRwZkYvSWNKbllRSGw2bnNwbGN6WDNSZ2FoNE5iSkpIbC8vNXNjVXVmcXNTZC8va2JJUzQwNlpXb01QLy8ramhHVXN3WC81blZOei9qQWo5S21YUHRBbU1pSytraGhibjF3L21FTHpaTVQvV3hjVy8veS9qc0hhT00vNjFvQVcvQ2pZaEp0WTYyMi9UdE1ZdVA3YmlsQnZiaVQzdkI5bjhJY0ZQbndNNzhIMEtmaFlEUmRZNVBoV0o0aldSUXpCK0hUNU5WWlY1NkxHODJoY1FtcytqT1RUL2M5WTlzeDVyUGkxL3dCN2YvK2M1VWZVQ0trM2l3d0N1eXdVYzJNR25Bd3NYZjFFNWhvSTU1eDFRL1FieStzV0g4TlJqYXZaOFZhRHNkaTFOVVZoSDg2QkpIWDF5YUZ0MXcxT1llTDVMVm1kTis1UStLdVR2WEVQRHpVQ2c2eHAwSGhzVWhUV1NlN01aTU0vNnJzVFViMC9uYlVFM1lRbEdHdDQ4a1QxLzZjbmY2eUhudkh0UXg5RW9zT1hOMDc3eXlFcS9qRTNZVGlHLzVTRUptWEZlb2NKSjFFQWQ2dktlSzZWRWRKTE9aMWttL0V3T25aV0NRcHpDTEtQSHhyZmg0eUpoR3EvLzJkb3MyRS8zK01PY2RXNUVzZ0lkbVRRVVFldHpSeTVmUUhoREJsMzdYYld6c3FPL2NBU0VEanlzdDEvOE5FUk9xVkF4V25kZFFWK3VtSjhJcktWZ0t2R2FUYzBHc1E0czhoME9zcWw1UUt3bGRkUERqSmhLSW55V3FZVUttbWxJdHMrRkljWFo2eU02Y2xqYnNqVUcya3NTT2t1SXc0c1lIZmZSTmdCT0xBcHZENlhyUjZSdDByVjJVZjhJcG5JVVZuYjlUd3Q5MVFqQWFEL2RTdFNXRHhnN2FZWStWWElnbnVvd1lkT2tqeXdhMmhsZ3JuSTZQamFVM2UzVWpRNVlrNW1kSUpHeUhudjMvUCsxRWtNYXYxeUZ5RitGZUpFL1JYbldCdytOaDBhT282VEdsS1g3ZCtka1A5K2JydnI3OVNkdFhKdGNEL2FYQkdpTU5mRzYvTlFuaVFIWVFsSzc4RkVIRHFPaCtiREkwbysyVWIwaDUzRUwvdmx6anJCY3pWRVp6MmJPdHZJTCtESXpEa2s5bkNXdDd0bHFzcTNsOUpNdEprM3I1SEcyaUo5Yi9YMTFURzZ3d01BakhMUTJvYXNhTUVzeWRoODhRUHZJK2htcUlIaHZhbHBLb0tPdWVKUjBlWjlKOEcyYWxOT0lPeTk4and2YmM4N0V3azlkKzVHL3RVaWpUbWxiakZsREtYVjA1SGFsS3hhUlRydWNjNzNPbjd5ekFQUzZmMnY0b2dpYVd5V2VWNzNkdi9Nc1FUNUhqUnJzWVY5ZExBY0kzVCt6QzJxRVZJTnlOcEVob0tWK3hWU3VXdFQ0QWhCZnBuWjd1bklNK0hYM21zSTBIaUkrUCt6MlBGZ2tqR2k1UHFFYkcvd05JV2VSVWpQdERFZ2JidWJOK0k0SmFETHJXOWJvclJCRG9iN1pGeCtKZEtlRlZVS1ZlV3FiL2M4OE9sN0RoTTBzdUx0dUVkOHRrRFNNVEQzREZ4OFVwaFBJTkhNSGk1MWhBUHR0WEw0RWt0dC9sS0VVRy9SNHFaS29oSGpWcEFjUElNaUh5V3I2eFI4L0VXbk5KdkJGRVQ3NnlDZGs1ZXI3QURCLzFiZ29JbWhwU2laL29tWmpQS1BDRWVac093dlBtWEwrMXZsSk5lR08zVHp5U21HQTFYNmU1OGdMcmF6RE03MWp5d00xWEw4ektITjZHM2tCMzFZOHZMdFA5ODJOOTc1U1pYazJKd0R2bXY3QVkvYURzRkZrMXYrbkU3L2hidnVPV2hCSDRrdWVtZVlvelBrMksyMlZ4L1lHaURUTFU3WWlscE90Mjl1M1JaTUJoNFVKamxUUDVJdHhUeld2NmViTDliK0dTVTFWc20yUzhMTWZWZkpjemFCU3FFOEoxQTRZVWpwc0FMTDcrK2J3Q1BYRmhhdWZkcERGdEJsSGI5bWFrZVlicWRnOWx0dksvSHdGL3JORTZLcnRXVWtFY3htVEI3SXl1NVRpVmFJZ1cvWXh6UWhwQXJsaUlNa09vSzVMN1NoVnRGK0RZcVYwMW1rN2Z3b3AwNGhRUndnNEtGbXI1ejluWWYwNVZWcWtTZTdnZm54NWJ4eGxRMHFFVjBqaXd6ZjA2NHFHMTFpRXFqSGNVZ0RXV3NEcy9MRUdselgzMVQ1S1ZMKzdENEVvS2ltN0hCYWdpcVJvNUpJM1dmREJncEtJcnVXejlqL0o2SHA1US9FSmJNV0I4TmVTTXVGYXJOdzNBRVlQQkp0WVFPLzRvRC9aZ1BUU1EwNmRpMEVldW1YNUVicmRUaE8rZnZZRVZTeEx0WjNBSmtlZTBYbjBzRHdOdGlpWmhKakpSRHVHMVlSS0Ixdk91bGZkOUpqSGV5dStVSFRtcnRyYS9wbSs4Uml4aDRXS2lMYUxPQ3hJYlpOb1dSWlN5eVVHTFBqQWFBbytTUUJwZk8ydXJ1V3J6RnhMbHB2clhKTk1DV3RsSkRLR0FubFdLNXhwVTJ0Y3hYYmVEK3NiZGZ3WVh0L3FUd0RrNlVxWFIvYVV0MDk5RGhTTmw0Tms4bVh3cHcrYjBudmpLT0c2TWcxUFJYanJNVU1BTnZOZ0VBcnY4bk1KczN2ajFhSGk4TUh6L1VmSldXemtjclNwWlROQmhkdVhsR1I3aStpcC9USERwNVI5S1JOY0RLRUNndHdnWGc0RUZONUhIZmlrUC9YdnNvQ2tIVGcrTmJzRDhHbDZla25rNEFyd24vQldHSjBoZ1cwL2dVS3J6dUdaaHViN2lnUlAzYWJldHBJbSsyNHhFT2xXbDNZS3BtMnFUQkZ2WDhkZERSdm0xTGN3bkNKdUVmWngxMnFQWTlUcm50TUlRc3YzMTZ6dnB5V255U3RYOFZVNGo2dFFrK0NXbExCVUNKUjZNZEg5Q3A3ZzJxZG4yV005cUZiUkVtZWpIMDlkbFdFUG04aFBGMEw3Unh3UlJkaUNzMERQOGV3azZBcG9FTGtLVTloY2tTZGJuWG04VUhKbWFOWGp4di9xMGZUVHB1OHJubDlsTjB2UUNwRFJiQ3RjejEyckdSRkVBN0NmZzdGaFpuNVFGa05tdjFaVVJLRXNpWmNlMW5TOUs3SHJ3cEM3eUpWNFh0M2VBVmJMSmZvWEhydHdHNjBaOGd3YVNubXhvTDNzMlpsUnFnZ1pOL01IbzFvVVM0TCtHd09iRkk1OTZMZDRNdmk4bCtjUW1GMWdKcGtwbkRpbzdUdU8zNW5wYU1IaVd6RnFQU1gzcU5na0lQR3VYMHFHWW5QSVZzTTkwMVl1OG9abk9aT1kxVGJ0SWRGVU5LTnEyZFA4U0o0Ri9WQ0V6SWpGMC9SaCs3VXJaajgwdEM2cm9nblZIM21xYThlQ3MvbGNRVTFQamo5OGtCbUFLRGJaVVR3b3N2MDJVdW5SUjNuMFg2YytmNzNtdHdCNy9XYlExNmdPNDMxRXR3WmJORzFTTTRUWlBCbnNRU0VTbHNmRzJKTFFYeDV4V2Y0Ym1RL3hjVkNQSVNBWDU4OTdKeEhLTEQvWGtndTU3K0FCUjIrTU10RWJYNjQrTU5sQkhwS0M3c2psV1ZFU2hmNXFBK2RHYzU5TEZWbFpyWC9FbnE5ei92K3duWjFIRXJteG1qSmp4T0EraEFqVlVXZ3RxNnlnQWkvOGV3SkRqVU1GdzN6aFFGdGJ5VExEUEZkMjFKaTVTNVFQWm85bk1TeGRnMStER0ZTTjB3bFd0N1hlWVBiSHFMZmxpVjBKMWtPaFFOcDBWYlVQeTBNUzJNczY2T3h0U1d2YVVMYVdIbmZBQStzaWVWVmd0akR3TjNuS29uV2Fwa1NLUk44QktLSlFwQ2ZxbzhSUUk1dWRoZnU1czUrN3Z3c3BwbUFKRGd6MkdOQTdkNDNWZGJWMmwvU3J2RXU0UllzbG1OSm1mU09WYnNzeEFoU1l5Nld4cElRZERCMEZWQnBaNklNOHlyODFRTitYTFozbi93ZWQvUitzNkxzbGt4S2J6enN0L0drUmJlNnJGbXR2SkN3cjFUNDRFVE0rSU1nT25qVU8wZUc2YTFuMnc3bHdNMW9GQnZ6TVVXUmtORk92S2N4M29TYjVYZGVuWjVkWHN1dGU2bmtSeXBCaVNkQXRBMmZ4QWQ4VWRMT1pXL01CN2Zab0V1RmhlUVhpamRhRjhrdWFSWm9TZVdkS09rS3NHWUVHYVhmYURLVHUwV01UY0xuaVFzN0tSQ3o5aUszU1ArWTJ4SWprZlZHcUZMU1E2dmgrQTF1NkZkZndYc3YxVlBNZmkyY3htZE0rL3hUZ01YRXlvMlpHY1EyWW1Qc2dobllkdjIrejQ4SnBHWkE0dFVLMXAxcTJWZFZ4eWZ5cFhFWGNyeEtLdG10OFVkVzdzSFdtS01xRHVCQk0zSi9KVVF4OGVVWU40cEo1b1JxdmRpUEhVMW8vV1BqaUt2bmxDcU9keXhseEY1NEw5UHJ0TEQxTmVqWjlhWkRpdlZyNlpmTUZLMS9wc1Z5Z29QSUFucGhjSldXYjkrNUlLTUttZ1JRVUxzVFBaaTZCdzR3UDMyelZFb0tjSHBQNzNDa0ZBcVM5OG5TYUdvV0RqREppYUFDSm40cDVvMWpxOVI0UTRWY2liaFhGLy9MSFAwYmRmNjNrUlZaZFJiYmhHZTdzRFFjeVdTNXRwa2ZlWUhuZmYyNVdLKzRGcHpMbEFjYmFLbUhkSUJxT3czZklteDF1cVFJQURIMFR5SHpGbHFURzZuTW9ZODFzdlAwVDZCSXlFTE1TOHRNZStFMXA2VEZQNnNWcFphNlZOYVR1bXVmRDVhajlnb1JhOVNBbWRKVDRIaEkycjBlZ2o4VXJnRmI4TDU5d0dMbllsemtMQWlVZDNtL1dXSUlFVTYxa1BvRWpkM2dJVnkvZmlCY2dxUXFIbm9YcEwwU3FMR2RHR2duN0RRZVZNU1lXSGZqbm8xRm5nSUtQOWNqWWFUbGNSUDZiWnVuakhQMTMvbGJWbTRhd3RpODk0cFRmL1pOTnFyNE9SK3REVmllL20rckM4UXBWblJic0NNUHVrT0g4N0Iyak00QUc2cEh1WGwxeDlTaUtkaFlKVk9oZm8vK1NDYUdqVVcyQ29vZ0wxRkZoRkdOOW8rYWNvVkxsMFNYcy8zdnJTY2NtWmVBRjNOZXdGdU9nL1AxMlFZS1FGK1NIK0tZY05uc0FoSUFFTFBCVWdyZS9LUlVKRUErS1BEME1IUmp2KzNKL2oyWjIzTXVKbWtmeTdsZVdjTXN0aTh3WExTSGdYRkpUYWtzeDFXb2k2b2xqd3hGVklKRzEyU0JTWkxOSkRiWE1ZUGVrbWlYVDRGY2xLSTM1QkZncW5ZcEtmY3NyK2Y4SFVYUW9ISjlVWVo0SjVZTWlISHlBeGc2ZWlkaG9kZ3FKMkh0Zi94WUV4K0cwelhjaHV6bHQ4aGNBbCtBVDhOQ1E0b3JGYzREZXJhYkYxZW5BN05UTG52dFpoM0ZVd3FJT3ZZN1E0RFltb0RId1hUU3c1VU5OaDZyN2owQi9lek1ZSk1EY3c0KzZnQ1RaWDRZUSs3WHM4ZGU3MnZzUjNjbWZweElYNjQvNktSMXAzVlg0RjZ2ZkhFenh6YXJoOGFESDRHMURGb0JCTTZucFhGcEsrUmgrV3JjRmNsQWVBeGkwUG9hUjlDcE94eEdMU2R2eEtWU3c4b09PYW5HL3NvS0ltUm9wTjM4QWRjVWhoTTJHVC9QZ1FlU1FyRzEybmp1SkpENVo3dldmQVptRnliWUxkU0E5MWtCNGFvQmhvajFaLy9LTklWVnVqcWFMTFJ3Q2tieW40dmgwNzM5QzlWOWlTanliZU9JZVNPdk5zN0xXMWE3RVV0Tm9LQW5PR01MNFU4S0JYcGZydzczV2pBc3pKRzRRc2NxK1hyM2taV1I0T21tMHhUNnFFOXk2Rk5TcHN0VjRvbk1aU3FDRUorM1ZYOXFqdmR4NVFWck0wV1h4bVBaeGVqZGZuaWhjRkFqenY1UGpsVGw2aWNrRGJIZTYrTGNoNTJwak9QcWsrbTNSWitiaDJKU01HdEZCdU9EYk1jaHJwUlZsdDE2TlRRMDVQczBJRHRXbFVtV2ZQMnZYOE00WUR5bkl1T1o0Q2s5MSs1OTFCOThHdzlmdyt5UW9nVFI4Q1NnMHphSnUrcmxCby9tcjNBKzFOemlGK2tkdWJ6K3doYzg1N0FadDZEd0lCSUY1KzV5aWFhZjNCeVFwMUZtM3NPa1pEQXp3c1lTUVRNL0t2Nmlka3VnRjYzRkRvYkRkVVkzaHVydVUrc0NhQnVSUitIbU9vd3ZtWm9CalpITmg3N1NYRnRtWS9vT1VFN2lmTjduQkhBbzgzUy94dmNTNkg0Q2kydS85SWQ2Mld2NlVpK3pNTkxBemhma1RrVmNXMkJ3cm5ZdnB1cjBaRGx6cytaTHNtR1RXdmQxODkydDc4Z3gxWWpFSnVzR2N4cGhqTGtWMFVmQUtsZWtmU0JWV0hFMmFoazRBYmJSbUh5TDdHWWR0S2ZkbElOd3JjZEp1ZjNDZWUxbmZVb2pEUW4vWW1JdEVTT0ZodEx6cmtFdjRrMlhwTVU5b2FKUTNWVUMrMUlOaDZCRTY4cGtIYW1lR0ptNEd2ZGIyNFEwZlhXeGQ5VHAzQTltekZTZTRxWERHR0RJVjRBQUdWMWpJRGZ2ZWtuSDFUd1dwVVQ2SGlReEtQM0FBSEpOa0plUmxqL21YQm1TNFMxajhGSzZZbXBLN2p5eUFpUmJzTUNDTG9KY3gwMWZ2Z3BNdktRUnh1OUlPd3ltY29uUWpENTZnN2tzT3JjT2VvVGJpdXM0Sm5HZXNBUzFEdGdkYW9waFlzdzF3R0lzTVMzUDdLNmRvRTNLNWN6em5xUFFMU1JSRi9ZbHpiNU50U0tzTDMzU2dza0ZOQ0Y0a2huNUxXYUR4STIzWlJpMmh6cU44dVc4VXpaRUJZeTY4K1Z0R0xTeW1RclhHVWxyMm5PMkJiQklUNVZoMVJtR0F5RFhhVzBGUHJweDN3djJVWWRGazl0U2wrOTA2Yk14Q3VYUWFLRFFQL1UxOVVFY1ZHSzRnbWtzTDhsQW9yeFFTQU93cGVZWDl4clpzaDZ5b0dhTC9YNU8zdGdRQzhPTSsvR3Z4blc5WHZBdHUvSnhBaWd5ZGZTbVpmcVpmZzFYT2NITk9wTGxOOGo2NE9aMzZsNXFhd0RCSjYyWWFUdnhlTm1tNWdvd0NkQm9zZ2NwSE9nTmd3QStza25OOFhtc1IySVlDaGNhZmw5YkdOTVovbkI1Z3VXdXZFeml2NlFJMmJQMkR0eUtXRy9xVWpaTWF4eSt3QVNra1ZHdHV3R3R5d2tUWUc2TVlyWkJvMTh2WWN3dzQ4Ry8rZitlSVRBL3FNd2JMbEpDMFMzKy9haTJwUHZrT2hSUlZtR1R1U3VwYXhoSWsweG9YTHRpeEN4U0FuNFozT25VUzN3QnFWc2NMSTRQM0dQN2kvNmd4WXNzd3NWbWt2RFhGTGhPL09LY3VyOGZsZWdDU0tpcW1WcElSdkN6Z2JqRUEwbVhQbitSRXhYWS8yT0UxZi9CWXVXcFJRWThnQ0RwTU9ZQng5R240dEwzaGloU0lSMWl4aDJQSUlUN2NyMmdVSmJmczc2RUtZRzUySmswVVpGL1BRa0J4R3VGQ0VXWG5HNnVlL2hUSXFqVFJxMXNvdFZyS3J3SUdIRHJJVHl1YW5VemJJWWRnZEVlVjg4SzFWRDgyVFlCMkI2MUZ0K3RCMUtxSFBtVDkraFdvYVYraUYzU3V2dEpxdm5vTGFBOHd4ckQ1NkFVTVVMRWd6TzlTdkJjQkFmcXovZHpNWXp3TXQvWUxzekRibUdlMWJjSEhmRk1jdkdxbDliZi90cCtIcmo0cTE4YU5uZnRHam1YVGZ3czM5ZW1uNy81SUJ4b2c5TXJtZnRBQTVPcTRhd2VubThIaW1XTzcyZHdWbEhjSG11dFZNZHJNSHcrcDJ2enB6VCtCMGlJWitJRXBwbHdXaENsY1hseGh4QXNGM0NIUm5uYVVFcXEzQnlRK2NxaGU1U3ZSNFNGeGgvTFpvUXd0ajhRWlFHVDFCelkyRU1wWW5VY1pXUUVQbHdGWncrN1VyeUs5cVY4S2dydVlzdnlNb0sxNktJMnNONFNPYmxyVndoeWlMOCtJQlo4Y3BVaHNKUVNVN1RGSEFpK0wyRjBzbjB5K0Z0RE9EbG51aWYyTWJhOFFkZFBaWVl4alRzSWdrTWUzTTYrN2tYeFVmWnZiQ1VseXE3MUoxZU5jekdrNlZxdzZyU3gySzN2TStEakx4RFJHeldlcFRPMnFUVC9XOFM3dTBRWGN5RlVhaGNCNHZxOHhDWVRweThpc3d0bnl6N0t4NmxnVEVRSjlScWtnRUlONkRPVXFCMHVSZGVZdURhN0FQN1p5OXorWmxUc21WUjV2dFY3MW0zZG1kdE5lV2doYnI1UG5QSnRqWEF6Y3Zaanh5Vjk2VkV4L0IxVEEwSUVRU0k1MHl3R3VJYm1BWWRRZy9sL3J4aFFMWCs2dU9MeUZzYVV0Nm10anBBSmtMZmVobkI2TWxPSG5OT3JXTHZDQnFWQlMwN2pjTSs0UnpMRWVkM2YzLzBYd3A5MlUrbmF0YU5IeUVnbm51WVI2UFhFalJMRVR6MHhydDNVZ2xmSzdCbjRhTmxYRzdjWmNvNGxNemlMdjUrTWgySkN3dzNtejY5WjlaTVJSL3h2NUVLSjM4SUZ4S2Q5ZHc1Q2dQSVhqYS9nekFzaE1iRjE0L3FCSWdOa2RVUWVQOFlFN1NySUNHdGlUbkFLVHlBOWNYYTNPYXVESHhaT2RUUDd5dVlCekQxVWNIc3RJTzE2RnhGMWJSVUFsU2tzekk4M1l1ZlRjaFU4T1Bubm96RGw5YlMweTZDbm5qR3dnajlNNjFjWGNac2xqamhMZVQvVnErMzBTY04yUGNUL2RPb3hVRHFEUzM4K09wQ0N6TERkbndIUWMzRUNRVklrYXhtZFBhWlRTZGZwMmpqR3pTZE5MTTV5UFFzZ0pEbCtabmhjbERRaThsdFVua3FXSjMyM0l2VFpQTjhybjArRXNoTDFjeDlQaWFMVHpVc3J5bjlacDJOdC9kZXRVQWg0Ti8ySTNkbE1RcWpIRnhTaWh2MHV5a3pmbHE1Y2xNeTJaQmF4b0ViMC9RTXAwM0lRUXVzM3ZuWmQvTk9tU3NtZ3FYcUtGUDNvenlEZ1k3UlFTK25wYWJlL2hORys1c2E1RnR2TDh2MHVZdWFnMk5ld1lrY29sM1RPVGFkcHVuY0NuRGdPR3BtTG5UUTFQRVBVTjJjTnNyVzhMWWZJditoemZiN3ZvZCtpcFhIem1iZ2o1RnpjNlJjVC81UEQ3VlE4blRKQk5qMXVya1ZVeDl1SnZUV21xWTA4T0M4MHJHRExhV1h2MjQzVkIxNmdqdDRYdHdwNUgyVURSMExpS1cyNEVkL3NPTzhqbDF5RVUvWEFiM2g3U2NLbkNGeS9WM3NJQ3JrWTFEMEs5ZlNva0hJTDBzNS83RExTaExBUFhSYlY3ZmJ2NHFqNk93SEM5ZDVQbEVPWDNMUnBRM1A3aGNTQUtsSUtQRE04M3lwejU2VTUrckplbzBjeVV0Qzd3bHRMOHdxRWlOU2dac0RXekFDYzdSRm9acWhsRDArc2loSUJRbGtRVFhtdlV5SU9aaGtRWDJ6cU1FNVZSQzdtczFzYTNDWStvZE1uM21NQmlUdkNNS25uQ3hnNVpQTHE0R1VEQjRqRjhCcjJLNHg0c3hmV2pHWFFhdEoyNUkxSnlySXYyWjRiUDFqS3c1QytCMi9zMHY0ZEdVT3NhUzZJUElRVjNFVFErRjJmU2wyQlBCWEh6eVlOOFZtd1dJcktlTVg5cHlHV3VBT1ZYd2t4SnNSQmFCVnpMaFpEUDhPTkduY2tuTDVEcFR4SE4zMkdnRldNd3NjMEdtTDBvUkRtUlQ4dTJsdmpBS1VJaTBNbVhoSUhTbEZlaDNRaDVwUDZhcDRZVWQ2YjU2OVpJYUhneWEyQXlEMTJjUHhZMEluL1BCanpEY3RUYUtKQ1UreGM2bTlSa05MREVFOGd1dnh0SlA4c2w4TjliTHF3MEYvcWVqYUJsY0hZcXczMXpZcHN1dFFwMDdoc1AxdmhHZGw0aEoxd0E3T0NzQUhuS2o5ODc5dVNISUxFbXVaNnZJMWxUNHR2bldDVktaaGhZcldIVzlvUEtQS3BiT0M2RlRqZi9PdFV2d21pWHIyeWt2eUx6SEdRZXlTN0JlblpwTDNOL0NhRjVUN0drbWw3SlhONWNqMFBLYURwWlZJbUQ2MUZ1TWdGSFBxU0h2dDRFajRLQmRBZmRjb08zQWpRUEx3d3RLc2dHTSt0eTRsTlpNQkVJdEpTUkx1bkc1Y2tyTS9CZW9YV29QWlZ2RW9JekxnRlFZUHVwTXdaQ1hpczRXMlNDSjJ6c2VmWnFDaithVGZTcTFGWWRVajJVZUpBTHZWVGY3dnV1aWtPRTFIaXQzVUlBR1VpL3NxZ011bTl2dzIxOHkxRmxZLzlYbk9qaTlucWhHQWNNWUlDYzdCaXFMWmo1TitjS0V1U0F1aXlXYk1nODFaRDFsSG92eS93ZTJlYUNjQ3Y0TXpFVzNPMG1WQS90MnhkQTBjeFRWYlhtRmhuK3RBUkRwdkR6NWZ0THIxNU9BQW12bzJRaUFreStmZVZPNGJHaWJ2Mm5sQm1CenF4MGxFRGZFbTRVbkVzMTFwYm53WmxKLzBZNzMvd0JQWWZUTlppSktSNzNUemRDVzFCZmZpSnE5YkxqUW1hS25VMCtnTjhzZmUyNUlLU1VDb29Rd3hlUERyRm4zYS96VWdXeHZQb1RZVlhmb2JZL0dWMnFxVGtlVkRWOUQ4NjU3ZmhZMC93aWFKNU5mTHhoWGJFL25heHMzNE4waGQ2dnhOZmRtMVRDbm96bS9OS1NDVGhjaG9ZZ01GN1oydHpYRm92UmZzTlZrZjg2SmpyTTYwcjdVSXVWM2JzbWZyTU9xempYak42SFBCRzI1ekNKM1FMdWV5U2JqOW9GdlgvSHhXQnFoMzFQQlB4ZHVDVkF4TXFDOUhLK1lMM29CWnFCcnVvaDZMS3ZkTXFvejBQWVhVQnJ3Ymlpb3lFOFRqNUltakptaU9PV0xiQVp2SVovbDlySVBsangzVDVnbEoyZXdsZnVJVDVHbG9kUXNBZi9JRXRtWWtNTDVTUlFHeHh3VytybFprRDhiZWxKTnUwOUl0d3g5eERVTFRuZW1WRGVvamRiZ2NkMmdLR005YU8wMEppdnRiczdaeU9TRThJUGg5OEdmdmF0RDhVZDV1SGNaZkFmTWlQU2xJeGQ0VXFlU0R6dU5mYktEdUZlcGt5Qy9zM2o5ZmF3bWhZMWI5TnFEaTBaUzVlUDM1bDdyTDJlSzVRbFdMbHlDbXh4OEFGYUZpVHVEMnBNVXhaVjVtQlNKdUpkdU9hcTJacldwdTI4REU4amwvaGlzQno3YkdXSDZxTEYwYXlXTnExU2VqdGNzOEtRclFxSms1UDlRSERZSE9Jb2xnTnNNRG1FYVdjVGVsZ2hiZkZDRHFXcnE2WUx3RFd5K202OGVjNW5TaGdxMmZkdVVCcFFVdUtLS2dudHRhVVg5UFJmTW14cUp5VTdlMFJMcjFiZXYrZ2UxS0swYlp5aEhLS0RFOGdRWDlWZjdyTkhXT3hCdFpjeHd3R3VzeU1wSDc3cVdaeFhzUW1iZ0lHaHRpTytnU1NSQ3l1L2VrK09Gc3oxSE1pUUgwSUhWN1BqSmkzZHN6WWZGcDh1ZTloNCtBZkt0ZTRNVGllaFB2eE5jbS9UMXQ5dnNGWng4ckhONWllNzdyMmp6Wk9xL0VtNFErSDlzTmNaYWtmOUhuekNjMWZKaXhwcHhQOEZRQUJtVm5xYTZHYkpod2FrYTdXSDdXZG96MVd4T2pTTlY4TjlzZ1c1UzNQcGdrdXQrVFRDa2pBK0FvZFVPazFLSVIrOEc4UzNXclNaRzRueXFmSjZGRWpYbDZhL0xFb1JNSFpVcWZQUld2d3FydFhZeTlJVXNtVUd6a3FpNzZpYjROQU5DZTVEbnlPeG5GUlo5ZDhGZEJWQmpyYTNpTnVaaEp1V1c1T21pL2hCaWdxRHNnMG11MkFoZkpEWGR3eU1JSjMzSEhIUGZTMkp0amVnUmVqWDExbTQxVGJOTCtRcDdtUjBnOUNQS1RqOVBJanVTeWNHTi9ZUG96WEk0emFyWHVBZUx2NUNIS3RLY0pLUmJkNlIyb0xOaUV0MFQ4K1FJVkpIN3p0OW5jS01nZDQ5dlYyUDFBeVNjWjlRemJ1M20zTEJudXU2ZHc3YUUwYjZyNGt6VmtJL0dVUzg4bUE1M0wvckx0bnRrRmxaWEd0SW9xTlAybUQzZVZ2MDhBVlZQVDN3Sm44MXpwYkpWOVN1cVo2UGQxZ2UwWnoyUkZIZUNkVjVDTFBmdEg5VjVvOStWekZ1NFIwUWV1bXFEd1VoWG4zSXlZb3RkSm54cjFsM0JxV25RVkFlREJFT3RQeUpReDFxNSttT0RpQ2xYdFllQkxUV3RzSjQyQU1CY2YvSUZJaHBmaFlPMDhoc2cwSWsrRHBRRk5PS1JlSzNvM2N1ZGt4V1gwc29QdEk1ZVNGT0E2eU55bFMrSVFqclF0WVEvNXM0VWNpeEpmb2t1bUJVanBIOW9mU2pVVHdQQ2FwR0ZuZGZxcUc1SUhlTU12ZmcrODhTWG03Yk55ams2cEdLekwrV3hEQWRxS3RRNzJXV1ZiT2szSSt1ZUd1YW1tbUIycHZGWnZxSWNVL2x2VzNuOStyMmx5Y25RTEU0T1g5UjFqSWdXNGNEakozdjhkQWE2Nm1WY2ZDN3B0Q3I1aW82bUNhQTlxSTlUOUZGV3FvMVpBYU14Z3hBdThhWHFtYU9ZcnlNTkQyc1RVZm9IdnhjWUs3aEVpSmhDTFlGRHgzUEJoRTk3YzJhMHViMS9lUEpjeUpPcXI3VWFUQVBUSit4dlp0amIvNDBzbG9ZMWx0Um5Ua1dJTG1JUDJiN1MzQWRYQ1IrWWlBck1VSHdkbmNwanB5REdmenFHT1VvQXVhYW1XekFNYWNRdGIzNC9NMzJGRWdSNWxVRWY4ZlJ6RnJaVWh6UWowZlI3LzZnZHpkblZWdmNTbmVMbXRxSjkzMFZDQ0RPUlk4Q1ZkUVdkby9TM1BOa1gzcFFzUFZLV0lZR0FNckZab3E4YlEvT0pCRFNYUDdLU0JkTDNRTjBacWQzOTNwNlZGYzdEbmxuRmlOMDBTWTVOdXg3eWFkZUlNMFVwbDJyVnN1OC9WQUknO1xuY29uc3QgRkVOQ0VEID0gbmV3IE1hcChbWzgyMTcsXCJhcG9zdHJvcGhlXCJdLFs4MjYwLFwiZnJhY3Rpb24gc2xhc2hcIl0sWzEyNTM5LFwibWlkZGxlIGRvdFwiXV0pO1xuY29uc3QgTlNNX01BWCA9IDQ7XG5cbmZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0ZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxyXG5cdFxyXG5cdC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXHJcblx0bGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xyXG5cdGxldCB0b3RhbCA9IDE7XHJcblx0bGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcclxuXHRcdGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcclxuXHR9XHJcblxyXG5cdC8vIHNraXAgdGhlIHNpemVkLXBheWxvYWQgdGhhdCB0aGUgbGFzdCAzIHN5bWJvbHMgaW5kZXggaW50b1xyXG5cdGxldCBza2lwID0gdTE2KCk7XHJcblx0bGV0IHBvc19wYXlsb2FkID0gcG9zO1xyXG5cdHBvcyArPSBza2lwO1xyXG5cclxuXHRsZXQgcmVhZF93aWR0aCA9IDA7XHJcblx0bGV0IHJlYWRfYnVmZmVyID0gMDsgXHJcblx0ZnVuY3Rpb24gcmVhZF9iaXQoKSB7XHJcblx0XHRpZiAocmVhZF93aWR0aCA9PSAwKSB7XHJcblx0XHRcdC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXHJcblx0XHRcdC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXHJcblx0XHRcdHJlYWRfYnVmZmVyID0gKHJlYWRfYnVmZmVyIDw8IDgpIHwgYnl0ZXNbcG9zKytdO1xyXG5cdFx0XHRyZWFkX3dpZHRoID0gODtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XHJcblx0fVxyXG5cclxuXHRjb25zdCBOID0gMzE7XHJcblx0Y29uc3QgRlVMTCA9IDIqKk47XHJcblx0Y29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XHJcblx0Y29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcclxuXHRjb25zdCBNQVNLID0gRlVMTCAtIDE7XHJcblxyXG5cdC8vIGZpbGwgcmVnaXN0ZXJcclxuXHRsZXQgcmVnaXN0ZXIgPSAwO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XHJcblxyXG5cdGxldCBzeW1ib2xzID0gW107XHJcblx0bGV0IGxvdyA9IDA7XHJcblx0bGV0IHJhbmdlID0gRlVMTDsgLy8gdHJlYXQgbGlrZSBhIGZsb2F0XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xyXG5cdFx0bGV0IHN0YXJ0ID0gMDtcclxuXHRcdGxldCBlbmQgPSBzeW1ib2xfY291bnQ7XHJcblx0XHR3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcclxuXHRcdFx0bGV0IG1pZCA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcblx0XHRcdGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XHJcblx0XHRcdFx0ZW5kID0gbWlkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXJ0ID0gbWlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoc3RhcnQgPT0gMCkgYnJlYWs7IC8vIGZpcnN0IHN5bWJvbCBpcyBlbmQgbWFya1xyXG5cdFx0c3ltYm9scy5wdXNoKHN0YXJ0KTtcclxuXHRcdGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gICAvIHRvdGFsKTtcclxuXHRcdGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCsxXSAvIHRvdGFsKSAtIDE7XHJcblx0XHR3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpICYgTUFTSyB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSAmIE1BU0s7XHJcblx0XHRcdGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKGEgJiB+YiAmIFFSVFIpIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpIF4gSEFMRjtcclxuXHRcdFx0YiA9ICgoYiBeIEhBTEYpIDw8IDEpIHwgSEFMRiB8IDE7XHJcblx0XHR9XHJcblx0XHRsb3cgPSBhO1xyXG5cdFx0cmFuZ2UgPSAxICsgYiAtIGE7XHJcblx0fVxyXG5cdGxldCBvZmZzZXQgPSBzeW1ib2xfY291bnQgLSA0O1xyXG5cdHJldHVybiBzeW1ib2xzLm1hcCh4ID0+IHsgLy8gaW5kZXggaW50byBwYXlsb2FkXHJcblx0XHRzd2l0Y2ggKHggLSBvZmZzZXQpIHtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiBvZmZzZXQgKyAweDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xyXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4geCAtIDE7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cdFxyXG5cclxuLy8gcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBuZXh0IHN5bWJvbFxyXG5mdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdHJldHVybiAoKSA9PiB2W3BvcysrXTtcclxufVxyXG5mdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChzKSB7XHJcblx0cmV0dXJuIHJlYWRfcGF5bG9hZChkZWNvZGVfYXJpdGhtZXRpYyh1bnNhZmVfYXRvYihzKSkpO1xyXG59XHJcblxyXG4vLyB1bnNhZmUgaW4gdGhlIHNlbnNlOlxyXG4vLyBleHBlY3RlZCB3ZWxsLWZvcm1lZCBCYXNlNjQgdy9vIHBhZGRpbmcgXHJcbi8vIDIwMjIwOTIyOiBhZGRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvNFxyXG5mdW5jdGlvbiB1bnNhZmVfYXRvYihzKSB7XHJcblx0bGV0IGxvb2t1cCA9IFtdO1xyXG5cdFsuLi4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLmZvckVhY2goKGMsIGkpID0+IGxvb2t1cFtjLmNoYXJDb2RlQXQoMCldID0gaSk7XHJcblx0bGV0IG4gPSBzLmxlbmd0aDtcclxuXHRsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoKDYgKiBuKSA+PiAzKTtcclxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgd2lkdGggPSAwLCBjYXJyeSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNhcnJ5ID0gKGNhcnJ5IDw8IDYpIHwgbG9va3VwW3MuY2hhckNvZGVBdChpKV07XHJcblx0XHR3aWR0aCArPSA2O1xyXG5cdFx0aWYgKHdpZHRoID49IDgpIHtcclxuXHRcdFx0cmV0W3BvcysrXSA9IChjYXJyeSA+PiAod2lkdGggLT0gOCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxyXG5mdW5jdGlvbiBzaWduZWQoaSkgeyBcclxuXHRyZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XHJcblx0bGV0IHYgPSBBcnJheShuKTtcclxuXHRmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyBbMTIzXVs1XSA9PiBbMCAzXSBbMSAxXSBbMCAwXVxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZChuZXh0LCBwcmV2ID0gMCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KCk7XHJcblx0XHRsZXQgbiA9IG5leHQoKTtcclxuXHRcdGlmICghbikgYnJlYWs7XHJcblx0XHRwcmV2ICs9IHg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRyZXQucHVzaChwcmV2ICsgaSk7XHJcblx0XHR9XHJcblx0XHRwcmV2ICs9IG4gKyAxO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZF9hcnJheXMobmV4dCkge1xyXG5cdHJldHVybiByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgXHJcblx0XHRsZXQgdiA9IHJlYWRfc29ydGVkKG5leHQpO1xyXG5cdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdjtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBtYXAgb2YgeCA9PiB5c1xyXG5mdW5jdGlvbiByZWFkX21hcHBlZChuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKTtcclxuXHRcdGlmICh3ID09IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCkgLSAxO1xyXG5cdFx0aWYgKHcgPCAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0LmZsYXQoKTtcclxufVxyXG5cclxuLy8gcmVhZCB1bnRpbCBuZXh0IGlzIGZhbHN5XHJcbi8vIHJldHVybiBhcnJheSBvZiByZWFkIHZhbHVlc1xyXG5mdW5jdGlvbiByZWFkX2FycmF5X3doaWxlKG5leHQpIHtcclxuXHRsZXQgdiA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQodi5sZW5ndGgpO1xyXG5cdFx0aWYgKCF4KSBicmVhaztcclxuXHRcdHYucHVzaCh4KTtcclxuXHR9XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIHJlYWQgdyBjb2x1bW5zIG9mIGxlbmd0aCBuXHJcbi8vIHJldHVybiBhcyBuIHJvd3Mgb2YgbGVuZ3RoIHdcclxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcclxuXHRsZXQgbSA9IEFycmF5KG4pLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcblx0XHRyZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufVxyXG4gXHJcbi8vIHJldHVybnMgW1t4LCB5c10sIFt4K2R4LCB5cytkeV0sIFt4KzIqZHgsIHlzKzIqZHldLCAuLi5dXHJcbi8vIHdoZXJlIGR4L2R5ID0gc3RlcHMsIG4gPSBydW4gc2l6ZSwgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcclxuXHRsZXQgZHggPSAxICsgbmV4dCgpO1xyXG5cdGxldCBkeSA9IG5leHQoKTtcclxuXHRsZXQgdk4gPSByZWFkX2FycmF5X3doaWxlKG5leHQpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5mbGF0TWFwKCh2LCBpKSA9PiB7XHJcblx0XHRsZXQgW3gsIC4uLnlzXSA9IHY7XHJcblx0XHRyZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcclxuXHRcdFx0bGV0IGpfZHkgPSBqICogZHk7XHJcblx0XHRcdHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm4gW1t4LCB5cy4uLl0sIC4uLl1cclxuLy8gd2hlcmUgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkgeyBcclxuXHRsZXQgbiA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVhZF90cmllKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHNvcnRlZCA9IHJlYWRfc29ydGVkKG5leHQpOyBcclxuXHRleHBhbmQoZGVjb2RlKFtdKSwgW10pO1xyXG5cdHJldHVybiByZXQ7IC8vIG5vdCBzb3J0ZWRcclxuXHRmdW5jdGlvbiBkZWNvZGUoUSkgeyAvLyBjaGFyYWN0ZXJzIHRoYXQgbGVhZCBpbnRvIHRoaXMgbm9kZVxyXG5cdFx0bGV0IFMgPSBuZXh0KCk7IC8vIHN0YXRlOiB2YWxpZCwgc2F2ZSwgY2hlY2tcclxuXHRcdGxldCBCID0gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IC8vIGJ1Y2tldHMgbGVhZGluZyB0byBuZXcgbm9kZXNcclxuXHRcdFx0bGV0IGNwcyA9IHJlYWRfc29ydGVkKG5leHQpLm1hcChpID0+IHNvcnRlZFtpXSk7XHJcblx0XHRcdGlmIChjcHMubGVuZ3RoKSByZXR1cm4gZGVjb2RlKGNwcyk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB7UywgQiwgUX07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGV4cGFuZCh7UywgQn0sIGNwcywgc2F2ZWQpIHtcclxuXHRcdGlmIChTICYgNCAmJiBzYXZlZCA9PT0gY3BzW2Nwcy5sZW5ndGgtMV0pIHJldHVybjtcclxuXHRcdGlmIChTICYgMikgc2F2ZWQgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdGlmIChTICYgMSkgcmV0LnB1c2goY3BzKTsgXHJcblx0XHRmb3IgKGxldCBiciBvZiBCKSB7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGJyLlEpIHtcclxuXHRcdFx0XHRleHBhbmQoYnIsIFsuLi5jcHMsIGNwXSwgc2F2ZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XG5cbmZ1bmN0aW9uIGhleF9jcChjcCkge1xyXG5cdHJldHVybiBjcC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdW90ZV9jcChjcCkge1xyXG5cdHJldHVybiBgeyR7aGV4X2NwKGNwKX19YDsgLy8gcmFmZnkgY29udmVudGlvbjogbGlrZSBcIlxcdXtYfVwiIHcvbyB0aGUgXCJcXHVcIlxyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7XHJcblx0cmV0dXJuIFsuLi5zXS5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApKTtcclxufVxyXG4qL1xyXG5mdW5jdGlvbiBleHBsb2RlX2NwKHMpIHsgLy8gdGhpcyBpcyBhYm91dCAyeCBmYXN0ZXJcclxuXHRsZXQgY3BzID0gW107XHJcblx0Zm9yIChsZXQgcG9zID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XHJcblx0XHRsZXQgY3AgPSBzLmNvZGVQb2ludEF0KHBvcyk7XHJcblx0XHRwb3MgKz0gY3AgPCAweDEwMDAwID8gMSA6IDI7XHJcblx0XHRjcHMucHVzaChjcCk7XHJcblx0fVxyXG5cdHJldHVybiBjcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cl9mcm9tX2NwcyhjcHMpIHtcclxuXHRjb25zdCBjaHVuayA9IDQwOTY7XHJcblx0bGV0IGxlbiA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGxlbiA8IGNodW5rKSByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xyXG5cdFx0YnVmLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzLnNsaWNlKGksIGkgKz0gY2h1bmspKSk7XHJcblx0fVxyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVfYXJyYXlzKGEsIGIpIHtcclxuXHRsZXQgbiA9IGEubGVuZ3RoO1xyXG5cdGxldCBjID0gbiAtIGIubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBjID09IDAgJiYgaSA8IG47IGkrKykgYyA9IGFbaV0gLSBiW2ldO1xyXG5cdHJldHVybiBjO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheV9yZXBsYWNlKHYsIGEsIGIpIHtcclxuXHRsZXQgcHJldiA9IDA7XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCBuZXh0ID0gdi5pbmRleE9mKGEsIHByZXYpO1xyXG5cdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdHZbbmV4dF0gPSBiOyBcclxuXHRcdHByZXYgPSBuZXh0ICsgMTtcclxuXHR9XHJcbn1cblxuLy8gY3JlYXRlZCAyMDI1LTA5LTE0VDE3OjU2OjI0LjA5OVpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1uZiBkYXRhXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcbi8vIFNIQS0yNTY6IDllZjQzY2M3MjE1YWE3YTUzZTRlZDlhZmEzYjRmMmY4Y2UwMGEyYzcwOGI5ZWI5NmFhNDA5YWU2ZmEzZmI2YWZcbnZhciBDT01QUkVTU0VEID0gJ0FFVURXQUhTQ0dZQVR3RFZBRElBZGdBaUFEUUFGQUF0QUJRQUlRQVBBQ2NBRFFBU0FBc0FHUUFKQUJJQUNRQVJBQVVBQ3dBRkFBd0FCUUFRQUFNQUJ3QUVBQW9BQlFBSkFBSUFDZ0FCQUFRQUZBQUxBQUlBQ3dBQkFBSUFBUUFIQUFNQUF3QUVBQXNBREFBTUFBd0FDd0FOQUEwQUF3QUtBQWtBQkFBZEFBWUFad0RUQWVjRE5BQ3hDbUlCOHhoWkFxZm9DMTkwVUdjVGhnQnVyd2Y3UFQwOVBiMDlBamdKdW04T2pEbGx4SFlVS1hBUHh6cTZ0QUJBeGdLOHlzVXZXQWdNUFQwOVBUMDlQU3M2TFQySGNnV1hXd0ZMb1NNRUVFbDVSRlZNS3ZPMFhROEV4RGRKTW5JZ1BpODl1ajAwTXN2Qlh4RVBBR1BDRHdCblFLb0Vid1J3QkhFRWNnUnpCSFFFZFFSMkJIY0VlQVI2QkhzRWZBUitCSUFFZ2ZuZEJRb0JZZ1VMQVdJRkRBRmlCTmNFMkFUWkJSQUZFUVV2QmRBTEZBc1ZEUGNOQncxM0RZY09NQTR4RGpNQjRCbGxISTBCMmdyYkFNRHBITGtRN1FIVkFQUk5RUUZuR1JVRWcweUVCMnVhSkVNQUpwSUJwb2I1QUVSU01BS05vQVhxYVFMUkJNQ3pFaUMrQVo0RVdSSkpGYkV1N1FEUUxBUnRFYmdFQ3hEd0FiL1J5QWsxQVY0bkQyY0VRUUtUQXpzQUdwb2JQZ0FhaEFHUENyeXNkeTBPQUt3QWZGSWNCQVFGVW1vQS9QdFpBRGtCSWFkVmoyVU1VZ3g1SWw0QU5RQzl2TElCREFIVUdWc1E4d0N6ZlFJYkdWY0NIQlpIQVo4Q0JBZ1hPaEc3QXFNWjRNNysxTTBVQVBETkFXc0MrbWNKRGU4QUFRQTk5emtFWExJQ3lRb3pBbzZsQW9iY1A1SnZqUUxGendLRDlnVS9PRDhGRVFDdEVRTDZiVytuQUtVRXZ6akRIc3VSeVV2T0ZIY2FjVXo1QXFJRlJTRTJrenNCRVFDdWFRTDVEUVRsY2dPNnR3U3BUaVVnQ3dJRkNBVVhCSFFFcVFWNnN3QVZ4VWxtVG1zQ3dqcXNQL3dLSlFtWGI3OTNVZ1pCRUJzbnBSRDNERE1CdFFFN0RlMUwyQVR4QmpzRXlSOTlHUmtQelpXY0NLVXQzUXp0SnVNdW9ZQmFJL1VxZ3dYdFMvUTgzUXROVVdnUFdRdGxDZU02WTRGT0F5RUJEU0tMQ3QwTk9RaHRFUE1LeVdzTjVSRkZCemtEMVVtYUFLVUhBUXNSSFRVVnRTWVFZcXdMQ1RsM0J2c2E5Z3VQSnE4VEtYcjhCZE1hSVFaTkFTa2Evd0RQTHVlRnNGb3hYQnhQWHdZREN5VWp4eFNvVUNBTkpVQzNlRWdhR3djVkpha0NrVU53U29kUk5oNlRJZlk4UFExbUxoTlJmQWYxUEFVWlR3dUJQSjVHcTBVT0VkSStqVDFJSWtsTUxBUTFmeXd2SjRzSnp3K0ZETGw4Y2dGWkNTRUpzUXh4RXpFUkZ6ZkZDRGtIR1MyWEpDY1ZDQ0ZHbFdDYUJQZWZBL01UMFFNTEJUOEpRUWNUQTdVY0xSTXVGU2tGRFlFazF3THpOdFV1c3dLUFZvQUJGd1hMRHlVZjN4QlFSK0FPNlFpYkFtVURneVhyQUMwVklRQVhJcHNJUTJNQVg0L1lVd1V1eXdqSGFtd2pkQU5uRk9kaEVYTUhrUTVYQjZjY014Vy9IT0Z3eUY0TGhnZ29vNjhKV3dGMUNaa0JYd1RqQ0FrMVc0eWdJRUZuVTR0WUdKc2dZVUUvWGZ3Q01ReGxGWjlFdllkNEFvc1BheEliQVRVQmN3YzVEUUVDZHhIdEVXc1FsUWpyaGdRMXRUUDRPaVVFVHlHRElCRUtKd05QYk00TEp5YjVEUGhwQWFNU1lnTU1ORDEzN21lcllMWWtGLzBIR1RMRlFXQWg4UXVTVDgwTW5CckJHRUpVTGhua0I3OEQ4eHJ6SitwQlZ3WC9BNk1ERXpwTk0rNEV2UXRwQ0lzSlB3QkpEcU1YQjljWWFncHhqTkFCTVlzQnQ1a0RWNUdEQW0rUEJqY0hDd0JuQzRjRmVlVUFIUUtuQ0tNQUJRRFBBMWNBT1FLdEI1MEFHUUNGUVFFOUF5Y3ZBU0hsQW84RGt3Z3h5d0dWTHdIektRUWJ3d3dWQVBjM2Jrb0N3N0VDZ0dwbW9nWGRXQUtPQWtrMUFVMGxCQVZPUjFFRHIzSGhBTnNBU3dZVDMwY0JGYXRLeXhyalF3SGZieXNBeHdEN0FBVTFCd1ZCQWMwQjgyMEF0d0ZmQ3pFSm9yTzFBVTNwS1FDREFCVnJBZGNDaVFEZEFEVUFmL0VCVXdCTkJWbjVCZE1DVDBrQkVURVlLMWRoQWJzREh3RXpBUTBBZVFiTGphWEpCeDhFYlFmVEFoQWJGZUVDN3k0SHRRRURJdDhUelVMRkFyM2VWYUZnQW1TQkFtSkNXMDJ2V3pjZ0FxSDNBbWlZQW1ZSkFwK0VPQnNMQW1ZN0FtWW1CRzRFZndOL0V3TitramtHT1hjWE9ZSTZJeU1DYkIwQ01qWTRDZ0p0eHdKdHJ1K0tNMmRGS3dGbkFONEE0UUJLQlFlWURJMEEvZ3ZDQUEyMUFuY3ZBbmFpUHdKNVMwTUNlTG9kWE50RnJrYlhBbncvQW5ySUFuMEpBbnp3QlZrRklFZ0FTSDFqSkFLQmJRS0FBQUtBQlFKL3JrbFlTbHNWRjByTUF0RUJBdERNU3ljRGlFOERoK1pFeFpFeUF2S2hYUU1EQTY1THprd3RKUVBQVFV4TnJ3S0xQd0tLMk1FYkJ4MURad1czQW80M0FvNWNRSmVCQW83WkFvNWNlRkcwVXpVS1V0UlVoUUtUK3dLVERBRHBBQnhWSGxXdlZkQUdMQnNwbFlZeTRYaG1SVHM1QXBlZkF1K3lXQ0dvQUZrbEFwYVBBcFo4bkFDcFdheGFDWUZOQURzQ2xyVUNsazVjUkZ6UkFwbkxBcGxrWE1wZEJ4a0NuSnM1d2pxZEFwd1dBcCtiQXA2NGlnQWREekVxRHdLZDhRS2VrZ0MxUFdFMFllOENudE1Db0c0QnFRS2VueDhDbms2bFk4aGtKeVVyQWlldkFpWitBcUQ3QXFCTUFxTGRBcUhFQXFZdkFxWE9BcWYvQUgwQ3AvSm9mR2l4QUFOSmFoeHEwUUtzNHdLc3JnS3Rad0t0QWdKWEhRSlYzQUt4NGRjREgwNXNsd0t5dlEwQ3N1Z1hiT0J0WTIxSVh3TWx6UUsyWERzL2JwQURLVVVDdUY0Q3VVY1ZBcmtxZDNBMmNPRUN2UmtDdTlwd2xnTXlFUUsraUhJQ0F6TnhBcjRhY3lKelR3TER5d0xEQkhPQ2RFczFSWFRnQXp5bkF6eWFBejIvQXNWOEFzWkhBc1lRaVFMSWFWRUN5RVFDeVU4Q3lTNENaSjBDM2RKNGVXRjRybmtsUzlBREdLTm5BZ0poOUJuemxTUjdDMTZTWHJzUkFzOXJBczlzTDB0VDB2TVRud0RHclFMUGN3RXA2Z05PRW41TEJRTGNKd0xiaWdMU1R3TlNYQU5UWHdFQkExV01nSWsvQU1zVzdXQkZnaHlDMDRMT2c0MEMyc2NDMmQ2RUVJUkpwendEaHFVQUx3TmtEb1p4V2ZrQVZRTGZaUUxldUhOM0F1SXY3UlFCOHpBbkFmU2JBZkxTaHdMcjh3THBjSGtDNnZrQzZ1UUErVWNCdVFMdWlRTHJuSmFxbHdNQzdqOERoZUNZZVhEZ2NhRUM4d01BYVFPT0ZwbVRBdmNUQTVGdUE1S0hBdmVZQXZuWkF2aG1taHlhcTdzM214NERuWU1DL3ZvQkd3QTVueHlmc3dNRmpRT21hZ09tMlFEUnhRTUdhcUdJb2dVSkF3eEpBdFFBUHdNQTRVRVhVd0VSOHdOckI1ZG5CUUNUTFN1M3I3M2JBWW1aRkg4UkJEa0IreWtGSVE2ZENaOEFrdjBUdFJRcnhRTDNMU2NBcFFDM0JibU9rUmMveHFkdFFTNFVKbzB1QVVNQmdQd0J0U1lBZFFNT0JHMEFMQUlXREtFQUFBb0NQUUpxQTkwRGZnU1JBU0JGQlNGOENnQUZBRVFBRXdBMkVnSjNBUUFGMVFOcjd3ckZBZ0QzQ3A4bnY3RzM1UUdSSVVGQ0Fla1VmeEUwd0lrQUJBQWJBRm9DUlFLRWl3QUdPbE02bEkxdEFMZzZqenJRQUkwNHdUcmNBS1VBNkFETEFUcUJPanM1L0RuNU8zYUpPbHM3bm9rNmJ6a1lBVllCTXdGc0JTODFYVFdlTmEwMVpqVjFOYlkxeFRXQ05aRTEwalhoTlo0MXJUWHVOZjAxc2pYQk5nSTJFVFhHTmRVMkZqWW5OZDQxN1RZdU5qMDJMalV0SVRZNk5qMDJQRGJKTndnRWtEeFhOamcyM1RjZ053ODJ5aUEzaVRjd0NnU3dQR2MySkRjWk4ydzZqVGNoUXRSREIwTGdRd3NjRHc4Sm15aHRLRkZWQmdEcGZ3RHBzQUQrbXhROTF3THBOU01BclFDOUJiZU9rUmRMeHB0ekJMOE1EQU1NQVFnREFBa0tDd3NMQ1FvR0JBVlZCSS9EdndEejliMjlrYVVDYjBRdHNSVE5MdDRlR0JjU0hBTVpGaFlaRWhZRUFSQUVCVUVjUVJ4QkhFRWNRUnhCSEVFYVFSeEJIRUZDU1R4QlBFbElTVWhCTmtNMlFUWWJOa2xJU1ZtQlZJZ0VMZ0VhSlprQzdhTUFvUUNqQmNHT214ZE54cnNCdndHSkFhUWNFWjBlUENrbE1BQWhNdkFJTUFMNTRnQzdCbThFZXNjanpRTXBBUlFwS2dEVUhxU3ZBajVHcXdyN1lyTVVBQ1Q5QU4zcnBGMjdIN2ZzZC90d1B0NGwrVVcxeVFZS0J0MkNneTdxSnBHaUxjZEUyUDFjUVNJbVVicUo2SUNIMjdINGtuUU1JUk1yRmtIdTNzeDZ0QzM1WStlTEloNGU0Q01LSjREZnlWKzhtZnRhNDk5UkNBSjB4ZmVaUjhQc29ZT0FwdmE5cGpHbjRQaHZ5WlM3L2g1Skx1aGF1Y2ZqdVUrWjU4NHd3cU5PNGhXWW1hQkNjamdRUGFsZTFiam9Iek1VYnV0L3pUZ3hIeEJuQXlyZEtwRjRJUk1BU0xCdEQvanZpeUxlQ2dqOHR3V2pBZDNIY2hOL3VxYWVSWWVISmdsN0pFWTkvY1RydnRmeWJ4L3IzWS9OdHhKOWRwK01UVm1pUzlid0JINzNzOERpNTYvTWErbVRQTUhxNFQxeUVHMWZXY3FyMHUraHJHbkpFdlUxSkpBbS9tYVFTcktyYXpJeXZTa0RGa2o4VVVsZkJxOGJhbmlUR1BuZzZZWlJMNjYxckROdzR3LzFnMmZpZ0cwSWhYbkw3d29zZC9zVk5vNWRZU21NQlRQNWM3cllMalJkQ3dnOHF1d2xqT01QZjYzRDhJQ0FMMHI3MVhSaXlGSGRnd0hid2ZnblBPZjRMempmMnYraitJaURIRzJpc3A1eVVuelNEeURSYjRpL1ZzMHFIU0hxOFBpRVEvSm5CUDdQeG5qTjBqNmdUNEFWQWVSeC8xbzlWbkVVbFV3dkZyekpxSGs5anhBdzRzWXhDbnJ4YWVCZENGRktibkU3eit4NTRGNVc3WlpzVTZreDhRb2N1bDZGb0FISHkwMUZHTC9ubmU2MW1uNCt1WVhmUTFVY2NuK0hNTEtFK2NaelQ4QkIxRTNGUnNrT2dKclJzcTI1cmF1TG04K3VhbVhwa1MvYlR5Nnkxd0RiQ3JXNGVENTMya1RXcnROVW1WVlpPSW4vQysvSlI5S1ZSNWlHOVRZOGlhVDY3dWJtL3doTDF4Yktab3F0WSthNmZOeE1KcmcyMTFiR1lKRFVrWU1OV0EwQk1CKys5ek9tNkVpazRyb3FzOUNDRUZXMGx5QUswUGJ2bHp2b3hyWnVZL09FaE5XL2wvNjNVMTVPZC9SU3ZtRHZYcEdMaVZtZUdpNVBEU0gyYll6NW8yZzZ3RkRRMkZiWmdZZ1RGOHJQbHZBMWlmalpEM05MdEZkWGRwU0lKdmdLUjdHcGpKV0c3R1pHYXdQb21JSDhCNXRVbXRISDlMcE0rL0tRS3VuRVBhMUdpUWtDWHY0Q25tOURMT1JvMmpvaWNIZFBEWjY0b2JRclBaNWJncWNra2owRzYvTkVpUFlCWTRiQ2tMN1c4RzVZenNVYjZHYWtGanlrU1BrVDdKR2VMZUI2dUpPR01tK3g3TjM4MUJDRGZiSkZ4MGR0TGdWOVE0NzdCZkwxZnZpdFg1YW5WL29ZZnhlWWwrZUY1eDViQjgrRXAvTDJuc21kNTZhS0Y0YUFENEdiSldzZEt5QlcyMnhFbUFEM1hkYnRzTXlBRm9SNW1PbGEwZ0VkOVUvWVZCN3p2SEdwSGJRb25heTlTdjBiUThpWjhwaWFYVnJLYzVBRzFBbXFxZ2FFdnpIU1AyV3V4N2FaVFdoNnF1VkRWVTAxSnRNSVZSZENGd2xTYmJxcWhvRmx5enNvdFF6UmV4RnZaL01xVVNGdTNPaFJJdU5CYnVmdkJwZFZnYjhYZEdKNDgvbEpQQ1o3ZHNPdWpUVGJLUFNFdkdYa09uRzJYZGk4L25NM0VNUnFJVGQ1UWVVN2lPaktxQzdVUkpZNlRuTHNIaWoyMnhBSEtuVlJENU1EdEJZbm9HRnFaR01EbVhDVzZPaitCQVd3MTRoRVNZL3hMRjZiTGt1MDZBSGtpWFRIUENGWjBmOVlTcXFvMjdlQWhoUzY3T3JBMkhldDRNOUpNM2ptL3lSWDZiWXhuZm16WWw1cVFkSHhOMDhGc051V0RyV2Q0dk1VWTJRRDNocjh2UzczU0NUa0ZvWFpSM3hOek9RdDhkLzZIZmpCbVhxdnJFNkVHa0x6SzZZSzJVMi9rc1UvaVVIK0x2VklzSkkrcmkyQUwva2xvK1NoZER5ZnM1QTgzaTJwcmtNczUxSUtSN1pjcWpaSmk1WDMrYmQ4R2x5V3Z0ZGR4S0VvRXFTZ0VPN0E4aklnZjJuSDBoOEZqTTdvQjZ5dGUzWDVtcEwwaS9FNFJ4MENvdEtuSUxKai92SnFvNFZrUFE5M2pSdFJWZmFpdFFQcWxkbDV4UllQcTgzODdaMERjblp2T2VJT04wSHQxK1AyN2tGTEdRSWNMQlg0Rkczc2ZmY2NOSGg1Y1BmenA5SU5vUnRxVnRkVmlKZmc4UmpuWGlJei9NTnFFTjZ6dnpYM2hNenlXQzdvU29YSVQxNHViYzBhYlBYOFJwOUdWYTVOSS84aXYrNmVsYTFvVG5jYmRpbVJLbnJiUmZmRFIvWDRuSCtiZ3FBdUhXbDdoT2FlWFBXVnpJZVJsN2dhK0p6RDRTeDNtbGovcTZSYS9FMkhoRGYyMWVFelRMTkdmQ1pzWSsveXhaelF6SUF1aWpHNjVpaTRPL3dhQUpDckVKYVdkL0RSQUtNUTU2NzhEdzVBVDdSQ0t6ZGFkSXdkOExzRCtEZ1BCQVNtV3NVbGY4UjBrMXcvMms0bE8yV3BiNHpNSTZFSlZKczB4ay93bjgvZlJVUHFyREtoYmpIUjQxU3FnRk14NVJHTVB1ZHVGd2x1NWxLODl0VzExc1RxaVgvNUVmR3M1bk8reTlGS3ZnWEtQT0VtZ0UwNUVLTkw2U2piM3hTNDBIM0JWUGhtMEVTT1pnQWpab3ltYzhiZTBpbkRWbzRKZEpWZitOS2QzdE4vQ2FCN0dTaGhIMjdxZjk1Tm9GWlZYLzZaa1IybFgrQ2dXclEySU5na2grYmJNejY4K3VKM0Nsc2g4SFNNUEVRdEF0K0JCRTZmWERhYjdLSWxzS3hVMWxJWFcvS1dWc3RwZFBhbkowcGRYcFFpbkR5VVFqdFk3WlZjZmllY1J4UkRNQVVoSEZVMmNFYWNpUStodGlQTVB4MWtkdnRXRzlUNDR3M3IwMzdsakhCRkpkWVIwcjU1cXZNUml4dEFFRkpBcUE0VDFFUzg3RkF4N1Vvelhhc3l0ZzhNZnRaWXQwcmpZZ0xlNkVKNWFXdnkycXNjQlNCUTd5ZWhvSklBM3dJSVo5dWtma3lCYjZxbnVlNWtvOFc1MHJwVjRrWHFXakk1bmJHUlhyTlcwdEJaSFhsWTQ4blNnY1VYQkhXVDRHY2dMWkpvTGxLSm5WOTZrQ1lwcTllV0hoN3hKemtDQXlyUXVRNUFKMHFxL3VaM3RvSmdsTnRlcmV2K1FtMEtYeFBnLytZYkZSSmRmaGJwMXdPblZPRVlkVkhUeWE2Q3RPMGFmaEVhQmh4M29Id0NiNUtxNlJ3SER6Rk1sMnZmakw4R3d6Y0NvVGo3d1plK1VGbllEVjJ5S3BQVTlkYmEyOWdZQmROcUpnL0tYb3pPK0NKVGxLbWxLaG5xVGY1ZG9lUzM1RFpGVitjWUpRVmpkK29WWS9HdGMvNlhQelV4YjFnTXFmNmNFak5Ob1JDOEFPYnJwK2Z4MGNWdEd1NGZmQzJUZ1hSQzh6UGw4bW9VSENCNUhaMjVkODdtbHNpaUswYU53QnRjRVFqUk5CVC9Rclhidy84YVZYZEtNSG45RXFZRUtFeXhTR1RwWVFPYWVzMUcxUXE4cERncWtadGxPMkhSeUNYcG1lTTdUU3JSUGtBaDAwNEJmaXNWcEY2elA0NG4ySnZ4ei9nT1ZvY05DeXk5VjZsa29kMjhRTTRwYmFNdlZKaWdEL3czQnJzalNKclhscWM0dWxCWU9DY2VpQk40Yi9nSGFqWXl1cGJoRXQ2M2E2MTlBeTR3c0w2YTZ3NkIrQTdUbm95RTdCbGlXSEpmelZ4eElLTS9XM00vSjhCeDk5T3A4NjNROGVOdUlNR1J4KytWYllmam0rVkdZQkEzQXAvS0V1L3d4Qk5CcEpKbmN3SFBHNDVWOEdoOThaSXJHQ2MyME13aWpHb3daYmNTN2QxbkVnY09XNWNkZFpwSEwyWFBBSVJiQ29saWhlWnpYVHZCeFpPWTNpTVNEU0tEcklDeUovaVFzMXZkcGxWZEgvSnJMSnNRMmp0VG5mQ3JJVElnaHEzS0ZYM3FBZ0xXQUlwOElmZk5TZFRZcHRuYkdmYzhzK3FjcjN6eXp5SHAxYUpnK2p4VEY0a0Qxcnk1V2F1djVWM3huT0d3VEZlY056WFNMSEJXMjAvcENRams0dW9yRDBwbEloTVNUYzc5Ky9yNFJLUENsUllUQllleDFPYjVjcnRmdlJRQkJ2NnJlLzZGaHRDcXRkdWFnNjdnbHFSQTc3LzN1bGJsaDlZUnRNZER4a0N5SkRlTm5BdUNMUFFGbWRSUldKdEgyMFo4RHN0ZkpmKzVvajVTU0I2NGQwaUY1L1lhNEtmVFd4Zml2ajlBcDIvemJZYVRvLzFnTzN0TTZSWXNDWmhhck1CRnI3Rm02MW1MU3JRbkVJNE9GMWdiVlM0ay9KRTlVb3RPcm5MSlp1c3dvV29kQ1NWOHpieWJrSlNWSVA3bjhVYUU5eENSMzlySlptZjI3SE9BUFZPR2M5cGRrUVVjUnJJMHF5VkY5WjNqMVJIRGJ4SWZ3Yld6bVBWandJZFBKdnRtQll3RVFJVXNJVzFTOTM5aGNWaWtLMDBvelBSSTAyY3FoelZVTnpwT3hWZHJ3UlB2bGgxYUlPZjB4RkVxRDNZa0duQ25GYWgvY0ZOM0oyZ0I3TitiWlNHYXd3a0tGdTF0cFFNcnAxVysyN1lOa3lUMFRwY0ZwVHFnT3FxTGFicmdjQ1VQeGg5N21SRU9HeTR4SXR6UTl4U2w2cnErOEJac0hjclFGUmVTK1FlTXhKM1A2Q25MOUVQL2VPTERqdW1MaHZyY1FycFBpa25zb2ZiekJ2OWdUUDBsVStUSVZ3RTZFN0NjS2ZUMzZxK1ppRU9ISjlheWYwZHlVSkxlekFiMk04YU5Id2QwK09KbXNWZ1R6UldBJztcblxuLy8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTUvXHJcbi8vIGZvciByZWZlcmVuY2UgaW1wbGVtZW50YXRpb25cclxuLy8gc2VlOiAvZGVyaXZlL25mLmpzXHJcblxyXG5cclxuLy8gYWxnb3JpdGhtaWMgaGFuZ3VsXHJcbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxNS4wLjAvY2gwMy5wZGYgKHBhZ2UgMTQ0KVxyXG5jb25zdCBTMCA9IDB4QUMwMDtcclxuY29uc3QgTDAgPSAweDExMDA7XHJcbmNvbnN0IFYwID0gMHgxMTYxO1xyXG5jb25zdCBUMCA9IDB4MTFBNztcclxuY29uc3QgTF9DT1VOVCA9IDE5O1xyXG5jb25zdCBWX0NPVU5UID0gMjE7XHJcbmNvbnN0IFRfQ09VTlQgPSAyODtcclxuY29uc3QgTl9DT1VOVCA9IFZfQ09VTlQgKiBUX0NPVU5UO1xyXG5jb25zdCBTX0NPVU5UID0gTF9DT1VOVCAqIE5fQ09VTlQ7XHJcbmNvbnN0IFMxID0gUzAgKyBTX0NPVU5UO1xyXG5jb25zdCBMMSA9IEwwICsgTF9DT1VOVDtcclxuY29uc3QgVjEgPSBWMCArIFZfQ09VTlQ7XHJcbmNvbnN0IFQxID0gVDAgKyBUX0NPVU5UO1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrX2NjKHBhY2tlZCkge1xyXG5cdHJldHVybiAocGFja2VkID4+IDI0KSAmIDB4RkY7XHJcbn1cclxuZnVuY3Rpb24gdW5wYWNrX2NwKHBhY2tlZCkge1xyXG5cdHJldHVybiBwYWNrZWQgJiAweEZGRkZGRjtcclxufVxyXG5cclxubGV0IFNISUZURURfUkFOSywgRVhDTFVTSU9OUywgREVDT01QLCBSRUNPTVA7XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gbmZfZGVpbml0KCkge1xyXG4vLyBcdGlmICghU0hJRlRFRF9SQU5LKSByZXR1cm47XHJcbi8vIFx0U0hJRlRFRF9SQU5LID0gRVhDTFVTSU9OUyA9IERFQ09NUCA9IFJFQ09NUCA9IHVuZGVmaW5lZDtcclxuLy8gfVxyXG5cclxuZnVuY3Rpb24gaW5pdCQxKCkge1xyXG5cdC8vY29uc29sZS50aW1lKCduZicpO1xyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCk7XHJcblx0U0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5cdEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuXHRERUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0UkVDT01QID0gbmV3IE1hcCgpO1xyXG5cdGZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdFx0aWYgKCFFWENMVVNJT05TLmhhcyhjcCkgJiYgY3BzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0XHR9XHJcblx0XHRERUNPTVAuc2V0KGNwLCBjcHMucmV2ZXJzZSgpKTsgLy8gc3RvcmVkIHJldmVyc2VkXHJcblx0fVxyXG5cdC8vY29uc29sZS50aW1lRW5kKCduZicpO1xyXG5cdC8vIDIwMjMwOTA1OiAxMW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX2hhbmd1bChjcCkge1xyXG5cdHJldHVybiBjcCA+PSBTMCAmJiBjcCA8IFMxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlX3BhaXIoYSwgYikge1xyXG5cdGlmIChhID49IEwwICYmIGEgPCBMMSAmJiBiID49IFYwICYmIGIgPCBWMSkge1xyXG5cdFx0cmV0dXJuIFMwICsgKGEgLSBMMCkgKiBOX0NPVU5UICsgKGIgLSBWMCkgKiBUX0NPVU5UO1xyXG5cdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGEpICYmIGIgPiBUMCAmJiBiIDwgVDEgJiYgKGEgLSBTMCkgJSBUX0NPVU5UID09IDApIHtcclxuXHRcdHJldHVybiBhICsgKGIgLSBUMCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxldCByZWNvbXAgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRyZWNvbXAgPSByZWNvbXAuZ2V0KGIpO1xyXG5cdFx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlY29tcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVjb21wb3NlZChjcHMpIHtcclxuXHRpZiAoIVNISUZURURfUkFOSykgaW5pdCQxKCk7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XG5cbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5cclxuLy8gMjAyMzA5MTM6IHJlcGxhY2UgWy4uLnZdIHdpdGggQXJyYXlfZnJvbSh2KSB0byBhdm9pZCBsYXJnZSBzcHJlYWRzXHJcbmNvbnN0IEFycmF5X2Zyb20gPSB4ID0+IEFycmF5LmZyb20oeCk7IC8vIEFycmF5LmZyb20uYmluZChBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBncm91cF9oYXNfY3AoZywgY3ApIHtcclxuXHQvLyAyMDIzMDkxMzoga2VlcCBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgZGlzdGluY3QgaW5zdGVhZCBvZiBjcmVhdGluZyB2YWxpZCB1bmlvblxyXG5cdHJldHVybiBnLlAuaGFzKGNwKSB8fCBnLlEuaGFzKGNwKTtcclxufVxyXG5cclxuY2xhc3MgRW1vamkgZXh0ZW5kcyBBcnJheSB7XHJcblx0Z2V0IGlzX2Vtb2ppKCkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbn1cclxuXHJcbmxldCBNQVBQRUQsIElHTk9SRUQsIENNLCBOU00sIEVTQ0FQRSwgTkZDX0NIRUNLLCBHUk9VUFMsIFdIT0xFX1ZBTElELCBXSE9MRV9NQVAsIFZBTElELCBFTU9KSV9MSVNULCBFTU9KSV9ST09UO1xyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIGVuc19kZWluaXQoKSB7XHJcbi8vIFx0bmZfZGVpbml0KCk7XHJcbi8vIFx0aWYgKCFNQVBQRUQpIHJldHVybjtcclxuLy8gXHRNQVBQRUQgPSBJR05PUkVEID0gQ00gPSBOU00gPSBFU0NBUEUgPSBORkNfQ0hFQ0sgPSBHUk9VUFMgPSBXSE9MRV9WQUxJRCA9IFdIT0xFX01BUCA9IFZBTElEID0gRU1PSklfTElTVCA9IEVNT0pJX1JPT1QgPSB1bmRlZmluZWQ7XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0Y29uc3Qgc2V0X2FkZF9tYW55ID0gKHNldCwgdikgPT4gdi5mb3JFYWNoKHggPT4gc2V0LmFkZCh4KSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdC8vY29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4ge1xyXG5cdFx0Ly8gMjAyMzA5MjE6IGJ1aWxkIHNldCBpbiBwYXJ0cywgMnggZmFzdGVyXHJcblx0XHRsZXQgc2V0ID0gbmV3IFNldCgpO1xyXG5cdFx0cmVhZF9zb3J0ZWRfYXJyYXkoKS5mb3JFYWNoKGkgPT4gc2V0X2FkZF9tYW55KHNldCwgY2h1bmtzW2ldKSk7XHJcblx0XHRzZXRfYWRkX21hbnkoc2V0LCByZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRcdHJldHVybiBzZXQ7IFxyXG5cdH07XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyB1bnJlc3RyaWN0ZWQgdGhlbiByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Ly8gdXNhZ2U6IFdIT0xFX01BUC5nZXQoY3ApLk0uZ2V0KGNwKSA9IGNvbXBsZW1lbnQgc2V0XHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0c2V0X2FkZF9tYW55KHJlYy5HLCBncyk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7IC8vIGFsbCBvZiB0aGUgZ3JvdXBzIHVzZWQgYnkgdGhpcyB3aG9sZVxyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpOyAvLyBncm91cHMgbm90IGNvdmVyZWQgYnkgdGhlIGV4dGVudFxyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpOyAvLyB0aGlzIGlzIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdC8vIDIwMjMwOTI0OiBWQUxJRCB3YXMgdW5pb24gYnV0IGNhbiBiZSByZS11c2VkXHJcblx0VkFMSUQgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAxKyBncm91cHNcclxuXHRsZXQgbXVsdGkgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAyKyBncm91cHNcclxuXHRjb25zdCBhZGRfdG9fdW5pb24gPSBjcCA9PiBWQUxJRC5oYXMoY3ApID8gbXVsdGkuYWRkKGNwKSA6IFZBTElELmFkZChjcCk7XHJcblx0Zm9yIChsZXQgZyBvZiBHUk9VUFMpIHtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUCkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUSkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHR9XHJcblx0Ly8gZHVhbCBwdXJwb3NlIFdIT0xFX01BUDogcmV0dXJuIHBsYWNlaG9sZGVyIGlmIHVuaXF1ZSBub24tY29uZnVzYWJsZVxyXG5cdGZvciAobGV0IGNwIG9mIFZBTElEKSB7XHJcblx0XHRpZiAoIVdIT0xFX01BUC5oYXMoY3ApICYmICFtdWx0aS5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIFVOSVFVRV9QSCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGFkZCBhbGwgZGVjb21wb3NlZCBwYXJ0c1xyXG5cdC8vIHNlZSBkZXJpdmU6IFwiVmFsaWQgaXMgQ2xvc2VkICh2aWEgQnJ1dGUtZm9yY2UpXCJcclxuXHRzZXRfYWRkX21hbnkoVkFMSUQsIG5mZChWQUxJRCkpO1xyXG5cdFxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApOyAvLyB0aGlzIGNhbiBvbmx5IGJlIGFzY2lpIHNvIGNhbnQgYmUgYmlkaVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gaWYgY3BzIGV4Y2VlZCBtYXgsIG1pZGRsZSB0cnVuY2F0ZSB3aXRoIGVsbGlwc2lzXHJcbi8vIHF1b3RlcihjcCkgPT4gc3RyaW5nLCBlZy4gMzAwMCA9PiBcInszMDAwfVwiXHJcbi8vIG5vdGU6IGluIGh0bWwsIHlvdSdkIGNhbGwgdGhpcyBmdW5jdGlvbiB0aGVuIHJlcGxhY2UgWzw+Jl0gd2l0aCBlbnRpdGllc1xyXG5mdW5jdGlvbiBzYWZlX3N0cl9mcm9tX2NwcyhjcHMsIG1heCA9IEluZmluaXR5LCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGlmIChjcHMubGVuZ3RoID4gbWF4KSB7XHJcblx0XHRtYXggPj49IDE7XHJcblx0XHRjcHMgPSBbLi4uY3BzLnNsaWNlKDAsIG1heCksIDB4MjAyNiwgLi4uY3BzLnNsaWNlKC1tYXgpXTtcclxuXHR9XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bGV0IGNwID0gY3BzW2ldO1xyXG5cdFx0aWYgKHNob3VsZF9lc2NhcGUoY3ApKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgaSkpKTtcclxuXHRcdFx0YnVmLnB1c2gocXVvdGVyKGNwKSk7XHJcblx0XHRcdHByZXYgPSBpICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBuKSkpO1xyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8vIG5vdGU6IHNldChzKSBjYW5ub3QgYmUgZXhwb3NlZCBiZWNhdXNlIHRoZXkgY2FuIGJlIG1vZGlmaWVkXHJcbi8vIG5vdGU6IE9iamVjdC5mcmVlemUoKSBkb2Vzbid0IHdvcmtcclxuZnVuY3Rpb24gaXNfY29tYmluaW5nX21hcmsoY3AsIG9ubHlfbnNtKSB7IC8vIDIwMjQwMTI3OiBhZGQgZXh0cmEgYXJndW1lbnRcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIG9ubHlfbnNtID8gTlNNLmhhcyhjcCkgOiBDTS5oYXMoY3ApO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZF9lc2NhcGUoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVTQ0FQRS5oYXMoY3ApO1xyXG59XHJcblxyXG4vLyByZXR1cm4gYWxsIHN1cHBvcnRlZCBlbW9qaSBhcyBmdWxseS1xdWFsaWZpZWQgZW1vamkgXHJcbi8vIG9yZGVyZWQgYnkgbGVuZ3RoIHRoZW4gbGV4aWNvZ3JhcGhpYyBcclxuZnVuY3Rpb24gZW5zX2Vtb2ppKCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRU1PSklfTElTVC5tYXAoeCA9PiB4LnNsaWNlKCkpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemVfZnJhZ21lbnQoZnJhZywgZGVjb21wb3NlKSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBuZiA9IGRlY29tcG9zZSA/IG5mZCA6IG5mYztcclxuXHRyZXR1cm4gZnJhZy5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4gc3RyX2Zyb21fY3BzKHRva2Vuc19mcm9tX3N0cihleHBsb2RlX2NwKGxhYmVsKSwgbmYsIGZpbHRlcl9mZTBmKS5mbGF0KCkpKS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplKG5hbWUpIHtcclxuXHRyZXR1cm4gZmxhdHRlbihzcGxpdChuYW1lLCBuZmMsIGZpbHRlcl9mZTBmKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19iZWF1dGlmeShuYW1lKSB7XHJcblx0bGV0IGxhYmVscyA9IHNwbGl0KG5hbWUsIG5mYywgeCA9PiB4KTsgLy8gZW1vamkgbm90IGV4cG9zZWRcclxuXHRmb3IgKGxldCB7dHlwZSwgb3V0cHV0LCBlcnJvcn0gb2YgbGFiZWxzKSB7XHJcblx0XHRpZiAoZXJyb3IpIGJyZWFrOyAvLyBmbGF0dGVuIHdpbGwgdGhyb3dcclxuXHJcblx0XHQvLyByZXBsYWNlIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuXHJcblx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgYmVhdXRpZmluZyBhbGwgb3IgbGVhZGluZy90cmFpbGluZyBoeXBoZW4gdG8gdW5pY29kZSB2YXJpYW50XHJcblx0XHQvLyBub3QgZXhhY3RseSB0aGUgc2FtZSBpbiBldmVyeSBmb250LCBidXQgdmVyeSBzaW1pbGFyOiBcIi1cIiB2cyBcIuKAkFwiXHJcblx0XHQvKlxyXG5cdFx0Y29uc3QgVU5JQ09ERV9IWVBIRU4gPSAweDIwMTA7XHJcblx0XHQvLyBtYXliZSB0aGlzIHNob3VsZCByZXBsYWNlIGFsbCBmb3IgdmlzdWFsIGNvbnNpc3RhbmN5P1xyXG5cdFx0Ly8gYG5vZGUgdG9vbHMvcmVnLWNvdW50LmpzIHJlZ2V4IF4tXFx7MixcXH1gID0+IDU5MlxyXG5cdFx0Ly9mb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykgaWYgKG91dHB1dFtpXSA9PSAweDJEKSBvdXRwdXRbaV0gPSAweDIwMTA7XHJcblx0XHRpZiAob3V0cHV0WzBdID09IEhZUEhFTikgb3V0cHV0WzBdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHRsZXQgZW5kID0gb3V0cHV0Lmxlbmd0aC0xO1xyXG5cdFx0aWYgKG91dHB1dFtlbmRdID09IEhZUEhFTikgb3V0cHV0W2VuZF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdCovXHJcblx0XHQvLyAyMDIzMDEyMzogV0hBVFdHIFVSTCB1c2VzIFwiQ2hlY2tIeXBoZW5zXCIgZmFsc2VcclxuXHRcdC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaWRuYVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBldGhlcmV1bSBzeW1ib2xcclxuXHRcdC8vIM6+ID0+IM6eIGlmIG5vdCBncmVla1xyXG5cdFx0aWYgKHR5cGUgIT09ICdHcmVlaycpIGFycmF5X3JlcGxhY2Uob3V0cHV0LCAweDNCRSwgMHgzOUUpO1xyXG5cclxuXHRcdC8vIDIwMjIxMjEzOiBmaXhlcyBiaWRpIHN1YmRvbWFpbiBpc3N1ZSwgYnV0IGJyZWFrcyBpbnZhcmlhbnQgKDIwMEUgaXMgZGlzYWxsb3dlZClcclxuXHRcdC8vIGNvdWxkIGJlIGZpeGVkIHdpdGggc3BlY2lhbCBjYXNlIGZvcjogMkQgKC4pICsgMjAwRSAoTFRSKVxyXG5cdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvYmlkaS1sYWJlbC1vcmRlcmluZy1zcG9vZi8xNTgyNFxyXG5cdFx0Ly9vdXRwdXQuc3BsaWNlKDAsIDAsIDB4MjAwRSk7XHJcblx0fVxyXG5cdHJldHVybiBmbGF0dGVuKGxhYmVscyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19zcGxpdChuYW1lLCBwcmVzZXJ2ZV9lbW9qaSkge1xyXG5cdHJldHVybiBzcGxpdChuYW1lLCBuZmMsIHByZXNlcnZlX2Vtb2ppID8geCA9PiB4LnNsaWNlKCkgOiBmaWx0ZXJfZmUwZik7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXQobmFtZSwgbmYsIGVmKSB7XHJcblx0aWYgKCFuYW1lKSByZXR1cm4gW107IC8vIDIwMjMwNzE5OiBlbXB0eSBuYW1lIGFsbG93YW5jZVxyXG5cdGluaXQoKTtcclxuXHRsZXQgb2Zmc2V0ID0gMDtcclxuXHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHQvLyA0LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgY29udGFpbiBhIFUrMDAyRSAoIC4gKSBGVUxMIFNUT1AuXCJcclxuXHRyZXR1cm4gbmFtZS5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4ge1xyXG5cdFx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChsYWJlbCk7XHJcblx0XHRsZXQgaW5mbyA9IHtcclxuXHRcdFx0aW5wdXQsXHJcblx0XHRcdG9mZnNldCwgLy8gY29kZXBvaW50LCBub3Qgc3Vic3RyaW5nIVxyXG5cdFx0fTtcclxuXHRcdG9mZnNldCArPSBpbnB1dC5sZW5ndGggKyAxOyAvLyArIHN0b3BcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIDEuKSBcIlRoZSBsYWJlbCBtdXN0IGJlIGluIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3JtIE5GQ1wiXHJcblx0XHRcdGxldCB0b2tlbnMgPSBpbmZvLnRva2VucyA9IHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKTtcclxuXHRcdFx0bGV0IHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuXHRcdFx0bGV0IHR5cGU7XHJcblx0XHRcdGlmICghdG9rZW5fY291bnQpIHsgLy8gdGhlIGxhYmVsIHdhcyBlZmZlY3RpdmVseSBlbXB0eSAoY291bGQgb2YgaGFkIGlnbm9yZWQgY2hhcmFjdGVycylcclxuXHRcdFx0XHQvL25vcm0gPSBbXTtcclxuXHRcdFx0XHQvL3R5cGUgPSAnTm9uZSc7IC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgbmV4dCBtYXRjaCwgXCJBU0NJSVwiXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjA6IGNoYW5nZSB0byBzdHJpY3RcclxuXHRcdFx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9lbnMtbmFtZS1ub3JtYWxpemF0aW9uLTJuZC8xNDU2NC81OVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZW1wdHkgbGFiZWxgKTtcclxuXHRcdFx0fSBcclxuXHRcdFx0bGV0IG5vcm0gPSBpbmZvLm91dHB1dCA9IHRva2Vucy5mbGF0KCk7XHJcblx0XHRcdGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShub3JtKTtcclxuXHRcdFx0bGV0IGVtb2ppID0gaW5mby5lbW9qaSA9IHRva2VuX2NvdW50ID4gMSB8fCB0b2tlbnNbMF0uaXNfZW1vamk7IC8vIHNhbWUgYXM6IHRva2Vucy5zb21lKHggPT4geC5pc19lbW9qaSk7XHJcblx0XHRcdGlmICghZW1vamkgJiYgbm9ybS5ldmVyeShjcCA9PiBjcCA8IDB4ODApKSB7IC8vIHNwZWNpYWwgY2FzZSBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyAyMDIzMDEyMzogbWF0Y2hlcyBtYXRjaGVzIFdIQVRXRywgc2VlIG5vdGUgMy4zXHJcblx0XHRcdFx0Y2hlY2tfbGFiZWxfZXh0ZW5zaW9uKG5vcm0pOyAvLyBvbmx5IG5lZWRlZCBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgZmVuY2VkXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGNtXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIHdob2xlc1xyXG5cdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiRmFzdHBhdGggQVNDSUlcIlxyXG5cdFx0XHRcdHR5cGUgPSAnQVNDSUknO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjaGFycyA9IHRva2Vucy5mbGF0TWFwKHggPT4geC5pc19lbW9qaSA/IFtdIDogeCk7IC8vIGFsbCBvZiB0aGUgbmZjIHRva2VucyBjb25jYXQgdG9nZXRoZXJcclxuXHRcdFx0XHRpZiAoIWNoYXJzLmxlbmd0aCkgeyAvLyB0aGVyZXMgbm8gdGV4dCwganVzdCBlbW9qaVxyXG5cdFx0XHRcdFx0dHlwZSA9ICdFbW9qaSc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIDUuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgY29tYmluaW5nIG1hcmssIHRoYXQgaXM6IEdlbmVyYWxfQ2F0ZWdvcnk9TWFyay5cIlxyXG5cdFx0XHRcdFx0aWYgKENNLmhhcyhub3JtWzBdKSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KCdsZWFkaW5nIGNvbWJpbmluZyBtYXJrJyk7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRva2VuX2NvdW50OyBpKyspIHsgLy8gd2UndmUgYWxyZWFkeSBjaGVja2VkIHRoZSBmaXJzdCB0b2tlblxyXG5cdFx0XHRcdFx0XHRsZXQgY3BzID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdFx0XHRpZiAoIWNwcy5pc19lbW9qaSAmJiBDTS5oYXMoY3BzWzBdKSkgeyAvLyBldmVyeSB0ZXh0IHRva2VuIGhhcyBlbW9qaSBuZWlnaGJvcnMsIGVnLiBFdEVFRXRFdC4uLlxyXG5cdFx0XHRcdFx0XHRcdC8vIGJpZGlfcXEoKSBub3QgbmVlZGVkIHNpbmNlIGVtb2ppIGlzIExUUiBhbmQgY3BzIGlzIGEgQ01cclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGVtb2ppICsgY29tYmluaW5nIG1hcms6IFwiJHtzdHJfZnJvbV9jcHModG9rZW5zW2ktMV0pfSArICR7c2FmZV9zdHJfZnJvbV9jcHMoW2Nwc1swXV0pfVwiYCk7IFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjaGVja19mZW5jZWQobm9ybSk7XHJcblx0XHRcdFx0XHRsZXQgdW5pcXVlID0gQXJyYXlfZnJvbShuZXcgU2V0KGNoYXJzKSk7XHJcblx0XHRcdFx0XHRsZXQgW2ddID0gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSk7IC8vIHRha2UgdGhlIGZpcnN0IG1hdGNoXHJcblx0XHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIk1hdGNoaW5nIEdyb3VwcyBoYXZlIFNhbWUgQ00gU3R5bGVcIlxyXG5cdFx0XHRcdFx0Ly8gYWx0ZXJuYXRpdmU6IGNvdWxkIGZvcm0gYSBoeWJyaWQgdHlwZTogTGF0aW4vSmFwYW5lc2UvLi4uXHRcclxuXHRcdFx0XHRcdGNoZWNrX2dyb3VwKGcsIGNoYXJzKTsgLy8gbmVlZCB0ZXh0IGluIG9yZGVyXHJcblx0XHRcdFx0XHRjaGVja193aG9sZShnLCB1bmlxdWUpOyAvLyBvbmx5IG5lZWQgdW5pcXVlIHRleHQgKG9yZGVyIHdvdWxkIGJlIHJlcXVpcmVkIGZvciBtdWx0aXBsZS1jaGFyIGNvbmZ1c2FibGVzKVxyXG5cdFx0XHRcdFx0dHlwZSA9IGcuTjtcclxuXHRcdFx0XHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBleHBvc2luZyByZXN0cmljdGVkIGZsYWdcclxuXHRcdFx0XHRcdC8vIGl0J3Mgc2ltcGxlciB0byBqdXN0IGNoZWNrIGZvciAnUmVzdHJpY3RlZCdcclxuXHRcdFx0XHRcdC8vIG9yIGV2ZW4gYmV0dGVyOiB0eXBlLmVuZHNXaXRoKCddJylcclxuXHRcdFx0XHRcdC8vaWYgKGcuUikgaW5mby5yZXN0cmljdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aW5mby50eXBlID0gdHlwZTtcclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRpbmZvLmVycm9yID0gZXJyOyAvLyB1c2UgZnVsbCBlcnJvciBvYmplY3RcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbmZvO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja193aG9sZShncm91cCwgdW5pcXVlKSB7XHJcblx0bGV0IG1ha2VyO1xyXG5cdGxldCBzaGFyZWQgPSBbXTtcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdGxldCB3aG9sZSA9IFdIT0xFX01BUC5nZXQoY3ApO1xyXG5cdFx0aWYgKHdob2xlID09PSBVTklRVUVfUEgpIHJldHVybjsgLy8gdW5pcXVlLCBub24tY29uZnVzYWJsZVxyXG5cdFx0aWYgKHdob2xlKSB7XHJcblx0XHRcdGxldCBzZXQgPSB3aG9sZS5NLmdldChjcCk7IC8vIGdyb3VwcyB3aGljaCBoYXZlIGEgY2hhcmFjdGVyIHRoYXQgbG9vay1saWtlIHRoaXMgY2hhcmFjdGVyXHJcblx0XHRcdG1ha2VyID0gbWFrZXIgPyBtYWtlci5maWx0ZXIoZyA9PiBzZXQuaGFzKGcpKSA6IEFycmF5X2Zyb20oc2V0KTtcclxuXHRcdFx0aWYgKCFtYWtlci5sZW5ndGgpIHJldHVybjsgLy8gY29uZnVzYWJsZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNoYXJlZC5wdXNoKGNwKTsgXHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChtYWtlcikge1xyXG5cdFx0Ly8gd2UgaGF2ZSAxKyBjb25mdXNhYmxlXHJcblx0XHQvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHJlbWFpbmluZyBncm91cHNcclxuXHRcdC8vIGNvbnRhaW4gdGhlIHNoYXJlZCBjaGFyYWN0ZXJzIHRvb1xyXG5cdFx0Zm9yIChsZXQgZyBvZiBtYWtlcikge1xyXG5cdFx0XHRpZiAoc2hhcmVkLmV2ZXJ5KGNwID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB3aG9sZS1zY3JpcHQgY29uZnVzYWJsZTogJHtncm91cC5OfS8ke2cuTn1gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogdW5pcXVlLnNpemUgPiAwXHJcbi8vIHJldHVybnMgbGlzdCBvZiBtYXRjaGluZyBncm91cHNcclxuZnVuY3Rpb24gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSkge1xyXG5cdGxldCBncm91cHMgPSBHUk9VUFM7XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHQvLyBub3RlOiB3ZSBuZWVkIHRvIGRvZGdlIENNIHRoYXQgYXJlIHdoaXRlbGlzdGVkXHJcblx0XHQvLyBidXQgdGhhdCBjb2RlIGlzbid0IGN1cnJlbnRseSBuZWNlc3NhcnlcclxuXHRcdGxldCBncyA9IGdyb3Vwcy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdGlmICghZ3MubGVuZ3RoKSB7XHJcblx0XHRcdGlmICghR1JPVVBTLnNvbWUoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkgeyBcclxuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIHdhcyBjb21wb3NlZCBvZiB2YWxpZCBwYXJ0c1xyXG5cdFx0XHRcdC8vIGJ1dCBpdCdzIE5GQyBmb3JtIGlzIGludmFsaWRcclxuXHRcdFx0XHQvLyAyMDIzMDcxNjogY2hhbmdlIHRvIG1vcmUgZXhhY3Qgc3RhdGVtZW50LCBzZWU6IEVOU05vcm1hbGl6ZS57Y3MsamF2YX1cclxuXHRcdFx0XHQvLyBub3RlOiB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZSBhIGNvbXBvc2l0aW9uXHJcblx0XHRcdFx0Ly8gMjAyMzA3MjA6IGNoYW5nZSB0byBmdWxsIGNoZWNrXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7IC8vIHRoaXMgc2hvdWxkIGJlIHJhcmVcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBncm91cCB0aGF0IGNvbnRhaW5zIGFsbCB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0XHRcdFx0Ly8gdGhyb3cgdXNpbmcgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgZ3JvdXAgdGhhdCBtYXRjaGVkXHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZ3JvdXBzWzBdLCBjcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGdyb3VwcyA9IGdzO1xyXG5cdFx0aWYgKGdzLmxlbmd0aCA9PSAxKSBicmVhazsgLy8gdGhlcmUgaXMgb25seSBvbmUgZ3JvdXAgbGVmdFxyXG5cdH1cclxuXHQvLyB0aGVyZSBhcmUgYXQgbGVhc3QgMSBncm91cChzKSB3aXRoIGFsbCBvZiB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0cmV0dXJuIGdyb3VwcztcclxufVxyXG5cclxuLy8gdGhyb3cgb24gZmlyc3QgZXJyb3JcclxuZnVuY3Rpb24gZmxhdHRlbihzcGxpdCkge1xyXG5cdHJldHVybiBzcGxpdC5tYXAoKHtpbnB1dCwgZXJyb3IsIG91dHB1dH0pID0+IHtcclxuXHRcdGlmIChlcnJvcikge1xyXG5cdFx0XHQvLyBkb24ndCBwcmludCBsYWJlbCBhZ2FpbiBpZiBqdXN0IGEgc2luZ2xlIGxhYmVsXHJcblx0XHRcdGxldCBtc2cgPSBlcnJvci5tZXNzYWdlO1xyXG5cdFx0XHQvLyBiaWRpX3FxKCkgb25seSBuZWNlc3NhcnkgaWYgbXNnIGlzIGRpZ2l0c1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3BsaXQubGVuZ3RoID09IDEgPyBtc2cgOiBgSW52YWxpZCBsYWJlbCAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoaW5wdXQsIDYzKSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTsgLy8gb25seSBjaGVjayBwcmltYXJ5XHJcblx0aWYgKGdnKSB7XHJcblx0XHRxdW90ZWQgPSBgJHtnZy5OfSAke3F1b3RlZH1gO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIG1peHR1cmU6ICR7Zy5OfSArICR7cXVvdGVkfWApO1xyXG59XHJcbmZ1bmN0aW9uIGVycm9yX3BsYWNlbWVudCh3aGVyZSkge1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgcGxhY2VtZW50OiAke3doZXJlfWApO1xyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiBjcHMubGVuZ3RoID4gMFxyXG4vLyBhc3N1bXB0aW9uOiBjcHNbMF0gaXNuJ3QgYSBDTVxyXG4vLyBhc3N1bXB0aW9uOiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzbid0IGFuIGVtb2ppXHJcbmZ1bmN0aW9uIGNoZWNrX2dyb3VwKGcsIGNwcykge1xyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0aWYgKCFncm91cF9oYXNfY3AoZywgY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5QLCAuLi5nLlFdLmZsYXRNYXAobmZjKS5maWx0ZXIoY3AgPT4gQ00uaGFzKGNwKSkpXHJcblx0XHRcdC8vICAgMy4gd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2lmIChNID49IDApIHsgLy8gd2UgaGF2ZSBhIGtub3duIGZpeGVkIGNtIGNvdW50XHJcblx0aWYgKGcuTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIG5vbi1zcGFjaW5nIG1hcmtzOiAke3F1b3RlZF9jcChjcCl9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcGFyc2UgdG8gZW5kIHNvIHdlIGhhdmUgZnVsbCBuc20gY291bnRcclxuXHRcdFx0XHQvLyBiLiBGb3JiaWQgc2VxdWVuY2VzIG9mIG1vcmUgdGhhbiA0IG5vbnNwYWNpbmcgbWFya3MgKGdjPU1uIG9yIGdjPU1lKS5cclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBOU01fTUFYKSB7XHJcblx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIHNsaWNlIHN0YXJ0cyB3aXRoIGEgYmFzZSBjaGFyIG9yIHNwYWNpbmctbWFyayBjbVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleGNlc3NpdmUgbm9uLXNwYWNpbmcgbWFya3M6ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG4vLyAyMDIzMDgxODogcmVuYW1lIGZvciAncHJvY2VzcycgbmFtZSBjb2xsaXNpb24gaC90IEphdmFyb21lXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzIzXHJcbmZ1bmN0aW9uIHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBjaGFycyA9IFtdO1xyXG5cdGlucHV0ID0gaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIGZsaXAgc28gd2UgY2FuIHBvcFxyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQpO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdFx0XHRcdGNoYXJzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0LnB1c2goZWYoZW1vamkpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7IC8vIGxlc3MgdGhhbiAxMCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzA5MTI6IHVuaWNvZGUgMTUuMSBjaGFuZ2VkIHRoZSBvcmRlciBvZiBwcm9jZXNzaW5nIHN1Y2ggdGhhdFxyXG5cdFx0XHRcdFx0Ly8gZGlzYWxsb3dlZCBwYXJ0cyBhcmUgb25seSByZWplY3RlZCBhZnRlciBORkNcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2Vzbid0IGltcGFjdCBub3JtYWxpemF0aW9uIGFzIG9mIHRvZGF5XHJcblx0XHRcdFx0XHQvLyB0ZWNobmljYWxseSwgdGhpcyBlcnJvciBjYW4gYmUgcmVtb3ZlZCBhcyB0aGUgZ3JvdXAgbG9naWMgd2lsbCBhcHBseSBzaW1pbGFyIGxvZ2ljXHJcblx0XHRcdFx0XHQvLyBob3dldmVyIHRoZSBlcnJvciB0eXBlIG1pZ2h0IGJlIGxlc3MgY2xlYXJcclxuXHRcdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcclxuXHRyZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSBGRTBGKTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYXJyYXkgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIHRoZSBsb25nZXN0IHZhbGlkIGVtb2ppIHNlcXVlbmNlIChvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2gpXHJcbi8vICpNVVRBVEVTKiB0aGUgc3VwcGxpZWQgYXJyYXlcclxuLy8gZGlzYWxsb3dzIGludGVybGVhdmVkIGlnbm9yZWQgY2hhcmFjdGVyc1xyXG4vLyBmaWxscyAob3B0aW9uYWwpIGVhdGVuIGFycmF5IHdpdGggbWF0Y2hlZCBjb2RlcG9pbnRzXHJcbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xyXG5cdGxldCBub2RlID0gRU1PSklfUk9PVDtcclxuXHRsZXQgZW1vamk7XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0d2hpbGUgKHBvcykge1xyXG5cdFx0bm9kZSA9IG5vZGUuZ2V0KGNwc1stLXBvc10pO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGxldCB7Vn0gPSBub2RlO1xyXG5cdFx0aWYgKFYpIHsgLy8gdGhpcyBpcyBhIHZhbGlkIGVtb2ppIChzbyBmYXIpXHJcblx0XHRcdGVtb2ppID0gVjtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKC4uLmNwcy5zbGljZShwb3MpLnJldmVyc2UoKSk7IC8vIChvcHRpb25hbCkgY29weSBpbnB1dCwgdXNlZCBmb3IgZW5zX3Rva2VuaXplKClcclxuXHRcdFx0Y3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVtb2ppO1xyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTtcclxuXHRsZXQgZWF0ZW4gPSBbXTtcclxuXHRsZXQgdG9rZW5zID0gW107XHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHR0eXBlOiBUWV9FTU9KSSxcclxuXHRcdFx0XHRlbW9qaTogZW1vamkuc2xpY2UoKSwgLy8gY29weSBlbW9qaVxyXG5cdFx0XHRcdGlucHV0OiBlYXRlbixcclxuXHRcdFx0XHRjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0ZWF0ZW4gPSBbXTsgLy8gcmVzZXQgYnVmZmVyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cblxuZXhwb3J0IHsgZW5zX2JlYXV0aWZ5LCBlbnNfZW1vamksIGVuc19ub3JtYWxpemUsIGVuc19ub3JtYWxpemVfZnJhZ21lbnQsIGVuc19zcGxpdCwgZW5zX3Rva2VuaXplLCBpc19jb21iaW5pbmdfbWFyaywgbmZjLCBuZmQsIHNhZmVfc3RyX2Zyb21fY3BzLCBzaG91bGRfZXNjYXBlIH07XG4iXSwibmFtZXMiOlsiQ09NUFJFU1NFRCQxIiwiRkVOQ0VEIiwiTWFwIiwiTlNNX01BWCIsImRlY29kZV9hcml0aG1ldGljIiwiYnl0ZXMiLCJwb3MiLCJ1MTYiLCJzeW1ib2xfY291bnQiLCJ0b3RhbCIsImFjYyIsImkiLCJwdXNoIiwic2tpcCIsInBvc19wYXlsb2FkIiwicmVhZF93aWR0aCIsInJlYWRfYnVmZmVyIiwicmVhZF9iaXQiLCJOIiwiRlVMTCIsIkhBTEYiLCJRUlRSIiwiTUFTSyIsInJlZ2lzdGVyIiwic3ltYm9scyIsImxvdyIsInJhbmdlIiwidmFsdWUiLCJNYXRoIiwiZmxvb3IiLCJzdGFydCIsImVuZCIsIm1pZCIsImEiLCJiIiwib2Zmc2V0IiwibWFwIiwieCIsInJlYWRfcGF5bG9hZCIsInYiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsInMiLCJ1bnNhZmVfYXRvYiIsImxvb2t1cCIsImZvckVhY2giLCJjIiwiY2hhckNvZGVBdCIsIm4iLCJsZW5ndGgiLCJyZXQiLCJVaW50OEFycmF5Iiwid2lkdGgiLCJjYXJyeSIsInNpZ25lZCIsInJlYWRfZGVsdGFzIiwibmV4dCIsIkFycmF5IiwicmVhZF9zb3J0ZWQiLCJwcmV2IiwicmVhZF9zb3J0ZWRfYXJyYXlzIiwicmVhZF9hcnJheV93aGlsZSIsInJlYWRfbWFwcGVkIiwidyIsInJlYWRfbGluZWFyX3RhYmxlIiwicmVhZF9yZXBsYWNlbWVudF90YWJsZSIsImZsYXQiLCJyZWFkX3RyYW5zcG9zZWQiLCJtIiwiZmlsbCIsImoiLCJkeCIsImR5Iiwidk4iLCJmbGF0TWFwIiwieXMiLCJfIiwial9keSIsInkiLCJzbGljZSIsInJlYWRfdHJpZSIsInNvcnRlZCIsImV4cGFuZCIsImRlY29kZSIsIlEiLCJTIiwiQiIsImNwcyIsInNhdmVkIiwiYnIiLCJjcCIsImhleF9jcCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJwYWRTdGFydCIsInF1b3RlX2NwIiwiZXhwbG9kZV9jcCIsImxlbiIsImNvZGVQb2ludEF0Iiwic3RyX2Zyb21fY3BzIiwiY2h1bmsiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiYnVmIiwiam9pbiIsImNvbXBhcmVfYXJyYXlzIiwiYXJyYXlfcmVwbGFjZSIsImluZGV4T2YiLCJDT01QUkVTU0VEIiwiUzAiLCJMMCIsIlYwIiwiVDAiLCJMX0NPVU5UIiwiVl9DT1VOVCIsIlRfQ09VTlQiLCJOX0NPVU5UIiwiU19DT1VOVCIsIlMxIiwiTDEiLCJWMSIsIlQxIiwidW5wYWNrX2NjIiwicGFja2VkIiwidW5wYWNrX2NwIiwiU0hJRlRFRF9SQU5LIiwiRVhDTFVTSU9OUyIsIkRFQ09NUCIsIlJFQ09NUCIsImluaXQkMSIsInIiLCJTZXQiLCJoYXMiLCJidWNrZXQiLCJnZXQiLCJzZXQiLCJyZXZlcnNlIiwiaXNfaGFuZ3VsIiwiY29tcG9zZV9wYWlyIiwicmVjb21wIiwiZGVjb21wb3NlZCIsImNoZWNrX29yZGVyIiwiYWRkIiwiY2MiLCJzX2luZGV4IiwibF9pbmRleCIsInZfaW5kZXgiLCJ0X2luZGV4IiwibWFwcGVkIiwicG9wIiwicHJldl9jYyIsInRtcCIsImNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZCIsInN0YWNrIiwicHJldl9jcCIsImNvbXBvc2VkIiwibmZkIiwibmZjIiwiSFlQSEVOIiwiU1RPUCIsIlNUT1BfQ0giLCJGRTBGIiwiVU5JUVVFX1BIIiwiQXJyYXlfZnJvbSIsImZyb20iLCJncm91cF9oYXNfY3AiLCJnIiwiUCIsIkVtb2ppIiwiaXNfZW1vamkiLCJNQVBQRUQiLCJJR05PUkVEIiwiQ00iLCJOU00iLCJFU0NBUEUiLCJORkNfQ0hFQ0siLCJHUk9VUFMiLCJXSE9MRV9WQUxJRCIsIldIT0xFX01BUCIsIlZBTElEIiwiRU1PSklfTElTVCIsIkVNT0pJX1JPT1QiLCJpbml0IiwicmVhZF9zb3J0ZWRfYXJyYXkiLCJyZWFkX3NvcnRlZF9zZXQiLCJzZXRfYWRkX21hbnkiLCJjaHVua3MiLCJ1bnJlc3RyaWN0ZWQiLCJyZWFkX2NodW5rZWQiLCJSIiwiTSIsIndob2xlcyIsImNvbmNhdCIsInNvcnQiLCJkIiwiViIsInZhbHVlcyIsInJlY3MiLCJncyIsImZpbHRlciIsInJlYyIsImZpbmQiLCJHIiwic29tZSIsInVuaW9uIiwiY29tcGxlbWVudCIsIm11bHRpIiwiYWRkX3RvX3VuaW9uIiwibm9kZSIsImNoaWxkIiwicXVvdGVkX2NwIiwic2hvdWxkX2VzY2FwZSIsImJpZGlfcXEiLCJzYWZlX3N0cl9mcm9tX2NwcyIsImNoZWNrX2xhYmVsX2V4dGVuc2lvbiIsIkVycm9yIiwiY2hlY2tfbGVhZGluZ191bmRlcnNjb3JlIiwiVU5ERVJTQ09SRSIsImxhc3RJbmRleE9mIiwiY2hlY2tfZmVuY2VkIiwiZXJyb3JfcGxhY2VtZW50IiwibGFzdCIsIm1hdGNoIiwibWF4IiwiSW5maW5pdHkiLCJxdW90ZXIiLCJpc19jb21iaW5pbmdfbWFyayIsIm9ubHlfbnNtIiwiZW5zX2Vtb2ppIiwiZW5zX25vcm1hbGl6ZV9mcmFnbWVudCIsImZyYWciLCJkZWNvbXBvc2UiLCJuZiIsInNwbGl0IiwibGFiZWwiLCJ0b2tlbnNfZnJvbV9zdHIiLCJmaWx0ZXJfZmUwZiIsImVuc19ub3JtYWxpemUiLCJuYW1lIiwiZmxhdHRlbiIsImVuc19iZWF1dGlmeSIsImxhYmVscyIsInR5cGUiLCJvdXRwdXQiLCJlcnJvciIsImVuc19zcGxpdCIsInByZXNlcnZlX2Vtb2ppIiwiZWYiLCJpbnB1dCIsImluZm8iLCJ0b2tlbnMiLCJ0b2tlbl9jb3VudCIsIm5vcm0iLCJlbW9qaSIsImV2ZXJ5IiwiY2hhcnMiLCJ1bmlxdWUiLCJkZXRlcm1pbmVfZ3JvdXAiLCJjaGVja19ncm91cCIsImNoZWNrX3dob2xlIiwiZXJyIiwiZ3JvdXAiLCJtYWtlciIsInNoYXJlZCIsIndob2xlIiwiZ3JvdXBzIiwiZXJyb3JfZGlzYWxsb3dlZCIsImVycm9yX2dyb3VwX21lbWJlciIsIm1zZyIsIm1lc3NhZ2UiLCJxdW90ZWQiLCJnZyIsIndoZXJlIiwiZSIsImsiLCJjb25zdW1lX2Vtb2ppX3JldmVyc2VkIiwiZWF0ZW4iLCJUWV9WQUxJRCIsIlRZX01BUFBFRCIsIlRZX0lHTk9SRUQiLCJUWV9ESVNBTExPV0VEIiwiVFlfRU1PSkkiLCJUWV9ORkMiLCJUWV9TVE9QIiwiZW5zX3Rva2VuaXplIiwidG9rZW4iLCJpc192YWxpZF9vcl9tYXBwZWQiLCJyZXF1aXJlc19jaGVjayIsImNwczAiLCJzcGxpY2UiLCJ0b2tlbnMwIiwiY29sbGFwc2VfdmFsaWRfdG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\n");

/***/ })

};
;