"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/qr";
exports.ids = ["vendor-chunks/qr"];
exports.modules = {

/***/ "(ssr)/./node_modules/qr/index.js":
/*!**********************************!*\
  !*** ./node_modules/qr/index.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bitmap: () => (/* binding */ Bitmap),\n/* harmony export */   ECMode: () => (/* binding */ ECMode),\n/* harmony export */   Encoding: () => (/* binding */ Encoding),\n/* harmony export */   _tests: () => (/* binding */ _tests),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   encodeQR: () => (/* binding */ encodeQR),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*!\nCopyright (c) 2023 Paul Miller (paulmillr.com)\nThe library paulmillr-qr is dual-licensed under the Apache 2.0 OR MIT license.\nYou can select a license of your choice.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/ /**\n * Methods for encoding (generating) QR code patterns.\n * Check out decode.ts for decoding (reading).\n * @module\n * @example\n```js\nimport encodeQR from 'qr';\nconst txt = 'Hello world';\nconst ascii = encodeQR(txt, 'ascii'); // Not all fonts are supported\nconst terminalFriendly = encodeQR(txt, 'term'); // 2x larger, all fonts are OK\nconst gifBytes = encodeQR(txt, 'gif'); // Uncompressed GIF\nconst svgElement = encodeQR(txt, 'svg'); // SVG vector image element\nconst array = encodeQR(txt, 'raw'); // 2d array for canvas or other libs\n// import decodeQR from 'qr/decode.js';\n```\n */ // We do not use newline escape code directly in strings because it's not parser-friendly\nconst chCodes = {\n    newline: 10,\n    reset: 27\n};\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`integer expected: ${n}`);\n}\nfunction validateVersion(ver) {\n    if (!Number.isSafeInteger(ver) || ver < 1 || ver > 40) throw new Error(`Invalid version=${ver}. Expected number [1..40]`);\n}\nfunction bin(dec, pad) {\n    return dec.toString(2).padStart(pad, \"0\");\n}\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction fillArr(length, val) {\n    return new Array(length).fill(val);\n}\nfunction popcnt(n) {\n    n = n - (n >>> 1 & 0x55555555);\n    n = (n & 0x33333333) + (n >>> 2 & 0x33333333);\n    return (n + (n >>> 4) & 0x0f0f0f0f) * 0x01010101 >>> 24;\n}\n/**\n * Interleaves byte blocks.\n * @param blocks [[1, 2, 3], [4, 5, 6]]\n * @returns [1, 4, 2, 5, 3, 6]\n */ function interleaveBytes(blocks) {\n    let maxLen = 0;\n    let totalLen = 0;\n    for (const block of blocks){\n        maxLen = Math.max(maxLen, block.length);\n        totalLen += block.length;\n    }\n    const result = new Uint8Array(totalLen);\n    let idx = 0;\n    for(let i = 0; i < maxLen; i++){\n        for (const block of blocks){\n            if (i < block.length) result[idx++] = block[i];\n        }\n    }\n    return result;\n}\n// Optimize for minimal score/penalty\nfunction best() {\n    let best;\n    let bestScore = Infinity;\n    return {\n        add (score, value) {\n            if (score >= bestScore) return;\n            best = value;\n            bestScore = score;\n        },\n        get: ()=>best,\n        score: ()=>bestScore\n    };\n}\n// Based on https://github.com/paulmillr/scure-base/blob/main/index.ts\nfunction alphabet(alphabet) {\n    return {\n        has: (char)=>alphabet.includes(char),\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        }\n    };\n}\n// Transpose 32x32 bit matrix in-place\n// a[0..31] are 32 rows of 32 bits each; after transpose they become 32 columns.\nfunction transpose32(a) {\n    if (a.length !== 32) throw new Error(\"expects 32 element matrix\");\n    const masks = [\n        0x55555555,\n        0x33333333,\n        0x0f0f0f0f,\n        0x00ff00ff,\n        0x0000ffff\n    ];\n    // Hello again, FFT\n    for(let stage = 0; stage < 5; stage++){\n        const m = masks[stage] >>> 0;\n        const s = 1 << stage; // 1,2,4,8,16\n        const step = s << 1; // 2,4,8,16,32\n        for(let i = 0; i < 32; i += step){\n            for(let k = 0; k < s; k++){\n                const i0 = i + k;\n                const i1 = i0 + s;\n                const x = a[i0] >>> 0;\n                const y = a[i1] >>> 0;\n                const t = (x >>> s ^ y) & m;\n                a[i0] = (x ^ t << s) >>> 0;\n                a[i1] = (y ^ t) >>> 0;\n            }\n        }\n    }\n}\nconst bitMask = (x)=>1 << (x & 31) >>> 0;\nconst rangeMask = (shift, len)=>{\n    // len in [0..32], shift in [0..31]\n    if (len === 0) return 0;\n    if (len === 32) return 0xffffffff;\n    return (1 << len) - 1 << shift >>> 0;\n};\nclass Bitmap {\n    static size(size, limit) {\n        if (typeof size === \"number\") size = {\n            height: size,\n            width: size\n        };\n        if (!Number.isSafeInteger(size.height) && size.height !== Infinity) throw new Error(`Bitmap: invalid height=${size.height} (${typeof size.height})`);\n        if (!Number.isSafeInteger(size.width) && size.width !== Infinity) throw new Error(`Bitmap: invalid width=${size.width} (${typeof size.width})`);\n        if (limit !== undefined) {\n            // Clamp length, so it won't overflow, also allows to use Infinity, so we draw until end\n            size = {\n                width: Math.min(size.width, limit.width),\n                height: Math.min(size.height, limit.height)\n            };\n        }\n        return size;\n    }\n    static fromString(s) {\n        // Remove linebreaks on start and end, so we draw in `` section\n        s = s.replace(/^\\n+/g, \"\").replace(/\\n+$/g, \"\");\n        const lines = s.split(String.fromCharCode(chCodes.newline));\n        const height = lines.length;\n        let width;\n        const rows = [];\n        for (const line of lines){\n            const row = line.split(\"\").map((i)=>{\n                if (i === \"X\") return true;\n                if (i === \" \") return false;\n                if (i === \"?\") return undefined;\n                throw new Error(`Bitmap.fromString: unknown symbol=${i}`);\n            });\n            if (width !== undefined && row.length !== width) throw new Error(`Bitmap.fromString different row sizes: width=${width} cur=${row.length}`);\n            width = row.length;\n            rows.push(row);\n        }\n        if (width === undefined) width = 0;\n        return new Bitmap({\n            height,\n            width\n        }, rows);\n    }\n    constructor(size, data){\n        const { height, width } = Bitmap.size(size);\n        this.height = height;\n        this.width = width;\n        this.tailMask = rangeMask(0, width & 31 || 32);\n        this.words = Math.ceil(width / 32) | 0;\n        this.fullWords = Math.floor(width / 32) | 0;\n        this.value = new Uint32Array(this.words * height);\n        this.defined = new Uint32Array(this.value.length);\n        if (data) {\n            // accept same semantics as old version\n            if (data.length !== height) throw new Error(`Bitmap: data height mismatch: exp=${height} got=${data.length}`);\n            for(let y = 0; y < height; y++){\n                const row = data[y];\n                if (!row || row.length !== width) throw new Error(`Bitmap: data width mismatch at y=${y}: exp=${width} got=${row?.length}`);\n                for(let x = 0; x < width; x++)this.set(x, y, row[x]);\n            }\n        }\n    }\n    point(p) {\n        return this.get(p.x, p.y);\n    }\n    isInside(p) {\n        return 0 <= p.x && p.x < this.width && 0 <= p.y && p.y < this.height;\n    }\n    size(offset) {\n        if (!offset) return {\n            height: this.height,\n            width: this.width\n        };\n        const { x, y } = this.xy(offset);\n        return {\n            height: this.height - y,\n            width: this.width - x\n        };\n    }\n    xy(c) {\n        if (typeof c === \"number\") c = {\n            x: c,\n            y: c\n        };\n        if (!Number.isSafeInteger(c.x)) throw new Error(`Bitmap: invalid x=${c.x}`);\n        if (!Number.isSafeInteger(c.y)) throw new Error(`Bitmap: invalid y=${c.y}`);\n        // Do modulo, so we can use negative positions\n        c.x = mod(c.x, this.width);\n        c.y = mod(c.y, this.height);\n        return c;\n    }\n    /**\n     * Return pixel bit index\n     */ wordIndex(x, y) {\n        return y * this.words + (x >>> 5);\n    }\n    bitIndex(x, y) {\n        return {\n            word: this.wordIndex(x, y),\n            bit: x & 31\n        };\n    }\n    isDefined(x, y) {\n        const wi = this.wordIndex(x, y);\n        const m = bitMask(x);\n        return (this.defined[wi] & m) !== 0;\n    }\n    get(x, y) {\n        const wi = this.wordIndex(x, y);\n        const m = bitMask(x);\n        return (this.value[wi] & m) !== 0;\n    }\n    maskWord(wi, mask, v) {\n        const { defined, value } = this;\n        defined[wi] |= mask;\n        value[wi] = value[wi] & ~mask | -v & mask;\n    }\n    set(x, y, v) {\n        if (v === undefined) return;\n        this.maskWord(this.wordIndex(x, y), bitMask(x), v);\n    }\n    // word-span fill for constant values (fast path)\n    fillRectConst(x0, y0, w, h, v) {\n        if (w <= 0 || h <= 0) return;\n        if (v === undefined) return;\n        const { value, defined, words } = this;\n        const startWord = x0 >>> 5;\n        const endWord = x0 + w - 1 >>> 5;\n        const startBit = x0 & 31;\n        const endBit = x0 + w - 1 & 31;\n        for(let ry = 0; ry < h; ry++){\n            const rowBase = (y0 + ry) * words;\n            if (startWord === endWord) {\n                const mask = rangeMask(startBit, endBit - startBit + 1);\n                this.maskWord(rowBase + startWord, mask, v);\n                continue;\n            }\n            this.maskWord(rowBase + startWord, rangeMask(startBit, 32 - startBit), v);\n            for(let i = startWord + 1; i < endWord; i++){\n                defined[rowBase + i] = 0xffffffff;\n                value[rowBase + i] = v ? 0xffffffff : 0;\n            }\n            this.maskWord(rowBase + endWord, rangeMask(0, endBit + 1), v);\n        }\n    }\n    rectWords(x, y, width, height, cb) {\n        for(let yPos = 0; yPos < height; yPos++){\n            const Py = y + yPos;\n            for(let xPos = 0; xPos < width;){\n                const bitX = x + xPos;\n                const { bit, word } = this.bitIndex(bitX, Py);\n                const bitsPerWord = Math.min(32 - bit, width - xPos);\n                cb(word, bitX, xPos, yPos, bitsPerWord);\n                xPos += bitsPerWord;\n            }\n        }\n    }\n    // Basically every operation can be represented as rect\n    rect(c, size, fn) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(size, this.size({\n            x,\n            y\n        }));\n        if (typeof fn !== \"function\") {\n            this.fillRectConst(x, y, width, height, fn);\n            return this;\n        }\n        const { defined, value } = this;\n        this.rectWords(x, y, width, height, (wi, bitX, xPos, yPos, n)=>{\n            let defWord = 0;\n            let valWord = value[wi];\n            for(let b = 0; b < n; b++){\n                const mask = bitMask(bitX + b);\n                const res = fn({\n                    x: xPos + b,\n                    y: yPos\n                }, (valWord & mask) !== 0);\n                if (res === undefined) continue;\n                defWord |= mask;\n                valWord = valWord & ~mask | -res & mask;\n            }\n            defined[wi] |= defWord;\n            value[wi] = valWord;\n        });\n        return this;\n    }\n    // returns rectangular part of bitmap\n    rectRead(c, size, fn) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(size, this.size({\n            x,\n            y\n        }));\n        const { value } = this;\n        this.rectWords(x, y, width, height, (wi, bitX, xPos, yPos, n)=>{\n            const valWord = value[wi];\n            for(let b = 0; b < n; b++){\n                const mask = bitMask(bitX + b);\n                fn({\n                    x: xPos + b,\n                    y: yPos\n                }, (valWord & mask) !== 0);\n            }\n        });\n        return this;\n    }\n    // Horizontal & vertical lines\n    hLine(c, len, value) {\n        return this.rect(c, {\n            width: len,\n            height: 1\n        }, value);\n    }\n    vLine(c, len, value) {\n        return this.rect(c, {\n            width: 1,\n            height: len\n        }, value);\n    }\n    // add border\n    border(border = 2, value) {\n        const height = this.height + 2 * border;\n        const width = this.width + 2 * border;\n        const out = new Bitmap({\n            height,\n            width\n        });\n        // fill everything with border value, then embed original\n        out.rect(0, Infinity, value);\n        out.embed({\n            x: border,\n            y: border\n        }, this);\n        return out;\n    }\n    // Embed another bitmap on coordinates\n    embed(c, src) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(src.size(), this.size({\n            x,\n            y\n        }));\n        if (width <= 0 || height <= 0) return this;\n        const { value, defined } = this;\n        const { words: srcStride, value: srcValue } = src;\n        for(let yPos = 0; yPos < height; yPos++){\n            const srcRow = yPos * srcStride;\n            for(let xPos = 0; xPos < width;){\n                const dstX = x + xPos;\n                const { word: dstWord, bit: dstBit } = this.bitIndex(dstX, y + yPos);\n                const { word: srcWord, bit: srcBit } = src.bitIndex(xPos, yPos);\n                const len = Math.min(32 - dstBit, width - xPos);\n                const w0 = srcValue[srcWord];\n                const w1 = srcBit && srcWord + 1 < srcRow + srcStride ? srcValue[srcWord + 1] : 0;\n                const sVal = srcBit ? (w0 >>> srcBit | w1 << 32 - srcBit) >>> 0 : w0;\n                const dstMask = rangeMask(dstBit, len);\n                const valBits = (sVal & rangeMask(0, len)) << dstBit >>> 0;\n                defined[dstWord] |= dstMask;\n                value[dstWord] = value[dstWord] & ~dstMask | valBits;\n                xPos += len;\n            }\n        }\n        return this;\n    }\n    // returns rectangular part of bitmap\n    rectSlice(c, size = this.size()) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(size, this.size({\n            x,\n            y\n        }));\n        const rect = new Bitmap({\n            height,\n            width\n        });\n        this.rectRead({\n            x,\n            y\n        }, {\n            height,\n            width\n        }, (p, cur)=>{\n            if (this.isDefined(x + p.x, y + p.y)) {\n                rect.set(p.x, p.y, cur);\n            }\n        });\n        return rect;\n    }\n    // Change shape, replace rows with columns (data[y][x] -> data[x][y])\n    transpose() {\n        const { height, width, value, defined, words } = this;\n        const dst = new Bitmap({\n            height: width,\n            width: height\n        });\n        const { words: dstStride, value: dstValue, defined: dstDefined, tailMask: dstTail } = dst;\n        const tmpV = new Uint32Array(32);\n        const tmpD = new Uint32Array(32);\n        // Process src in blocks: y in [by..by+31], x in 32-bit words\n        for(let by = 0; by < height; by += 32){\n            for(let bx = 0; bx < words; bx++){\n                const rows = Math.min(32, height - by);\n                for(let r = 0; r < rows; r++){\n                    const wi = this.wordIndex(32 * bx, by + r);\n                    tmpV[r] = value[wi];\n                    tmpD[r] = defined[wi];\n                }\n                // zero-pad remainder\n                tmpV.fill(0, rows);\n                tmpD.fill(0, rows);\n                transpose32(tmpV);\n                transpose32(tmpD);\n                for(let i = 0; i < 32; i++){\n                    const dstY = bx * 32 + i;\n                    if (dstY >= width) break;\n                    const dstPos = dst.wordIndex(by, dstY);\n                    const curMask = by >>> 5 === dstStride - 1 ? dstTail : 0xffffffff;\n                    dstValue[dstPos] = tmpV[i] & curMask;\n                    dstDefined[dstPos] = tmpD[i] & curMask;\n                }\n            }\n        }\n        return dst;\n    }\n    // black <-> white (inplace)\n    negate() {\n        const n = this.defined.length;\n        for(let i = 0; i < n; i++){\n            this.value[i] = ~this.value[i];\n            this.defined[i] = 0xffffffff;\n        }\n        return this;\n    }\n    // Each pixel size is multiplied by factor\n    scale(factor) {\n        if (!Number.isSafeInteger(factor) || factor > 1024) throw new Error(`invalid scale factor: ${factor}`);\n        const { height, width } = this;\n        const res = new Bitmap({\n            height: factor * height,\n            width: factor * width\n        });\n        return res.rect({\n            x: 0,\n            y: 0\n        }, Infinity, ({ x, y })=>this.get(x / factor | 0, y / factor | 0));\n    }\n    clone() {\n        const res = new Bitmap(this.size());\n        res.defined.set(this.defined);\n        res.value.set(this.value);\n        return res;\n    }\n    // Ensure that there is no undefined values left\n    assertDrawn() {\n        const { height, width, defined, tailMask, fullWords, words } = this;\n        if (!height || !width) return;\n        for(let y = 0; y < height; y++){\n            const rowBase = y * words;\n            for(let wi = 0; wi < fullWords; wi++){\n                if (defined[rowBase + wi] !== 0xffffffff) throw new Error(`Invalid color type=undefined`);\n            }\n            if (words !== fullWords && (defined[rowBase + fullWords] & tailMask) !== tailMask) throw new Error(`Invalid color type=undefined`);\n        }\n    }\n    countPatternInRow(y, patternLen, ...patterns) {\n        if (patternLen <= 0 || patternLen >= 32) throw new Error(\"wrong patternLen\");\n        const mask = (1 << patternLen) - 1;\n        const { width, value, words } = this;\n        let count = 0;\n        const rowBase = this.wordIndex(0, y);\n        for(let i = 0, window = 0; i < words; i++){\n            const w = value[rowBase + i];\n            const bitEnd = i === words - 1 ? width & 31 || 32 : 32;\n            for(let b = 0; b < bitEnd; b++){\n                window = (window << 1 | w >>> b & 1) & mask;\n                if (i * 32 + b + 1 < patternLen) continue;\n                for (const p of patterns){\n                    if (window !== p) continue;\n                    count++;\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n    getRuns(y, fn) {\n        const { width, value, words } = this;\n        if (width === 0) return;\n        let runLen = 0;\n        let runValue;\n        const rowBase = this.wordIndex(0, y);\n        for(let i = 0; i < words; i++){\n            const word = value[rowBase + i];\n            const bitEnd = i === words - 1 ? width & 31 || 32 : 32;\n            for(let b = 0; b < bitEnd; b++){\n                const bit = (word & 1 << b) !== 0;\n                if (bit === runValue) {\n                    runLen++;\n                    continue;\n                }\n                if (runValue !== undefined) fn(runLen, runValue);\n                runValue = bit;\n                runLen = 1;\n            }\n        }\n        if (runValue !== undefined) fn(runLen, runValue);\n    }\n    popcnt() {\n        const { height, width, words, fullWords, tailMask } = this;\n        if (!height || !width) return 0;\n        let count = 0;\n        for(let y = 0; y < height; y++){\n            const rowBase = y * words;\n            for(let wi = 0; wi < fullWords; wi++)count += popcnt(this.value[rowBase + wi]);\n            if (words !== fullWords) count += popcnt(this.value[rowBase + fullWords] & tailMask);\n        }\n        return count;\n    }\n    countBoxes2x2(y) {\n        const { width, words } = this;\n        if (width < 2 || (y | 0) < 0 || y + 1 >= this.height) return 0;\n        const base0 = this.wordIndex(0, y) | 0;\n        const base1 = this.wordIndex(0, y + 1) | 0;\n        // valid \"left-edge\" positions x in [0 .. W-2]\n        const tailBits = width & 31;\n        const validLast = tailBits === 0 ? 0x7fffffff : rangeMask(0, width - 1 & 31);\n        let boxes = 0;\n        for(let wi = 0; wi < words; wi++){\n            const a0 = this.value[base0 + wi];\n            const a1 = this.value[base1 + wi];\n            // Compare bit x with bit x+1 at same bit position.\n            const eqV = ~(a0 ^ a1) >>> 0; // row0[x] == row1[x]\n            const n0 = wi + 1 < words ? this.value[base0 + wi + 1] >>> 0 : 0;\n            const eqH0 = ~(a0 ^ (a0 >>> 1 | (n0 & 1) << 31) >>> 0) >>> 0; // row0[x] == row0[x+1]\n            const n1 = wi + 1 < words ? this.value[base1 + wi + 1] >>> 0 : 0;\n            const eqH1 = ~(a1 ^ (a1 >>> 1 | (n1 & 1) << 31) >>> 0) >>> 0; // row1[x] == row1[x+1]\n            let m = (eqV & eqH0 & eqH1) >>> 0;\n            if (wi === words - 1) m &= validLast;\n            boxes += popcnt(m);\n        }\n        return boxes;\n    }\n    // Export\n    toString() {\n        const nl = String.fromCharCode(chCodes.newline);\n        let out = \"\";\n        for(let y = 0; y < this.height; y++){\n            let line = \"\";\n            for(let x = 0; x < this.width; x++){\n                const v = this.get(x, y);\n                line += !this.isDefined(x, y) ? \"?\" : v ? \"X\" : \" \";\n            }\n            out += line + (y + 1 === this.height ? \"\" : nl);\n        }\n        return out;\n    }\n    toRaw() {\n        const out = Array.from({\n            length: this.height\n        }, ()=>new Array(this.width));\n        for(let y = 0; y < this.height; y++){\n            const row = out[y];\n            for(let x = 0; x < this.width; x++)row[x] = this.get(x, y);\n        }\n        return out;\n    }\n    toASCII() {\n        const { height, width } = this;\n        let out = \"\";\n        // Terminal character height is x2 of character width, so we process two rows of bitmap\n        // to produce one row of ASCII\n        for(let y = 0; y < height; y += 2){\n            for(let x = 0; x < width; x++){\n                const first = this.get(x, y);\n                const second = y + 1 >= height ? true : this.get(x, y + 1); // if last row outside bitmap, make it black\n                if (!first && !second) out += \"█\"; // both rows white (empty)\n                else if (!first && second) out += \"▀\"; // top row white\n                else if (first && !second) out += \"▄\"; // down row white\n                else if (first && second) out += \" \"; // both rows black\n            }\n            out += String.fromCharCode(chCodes.newline);\n        }\n        return out;\n    }\n    toTerm() {\n        const cc = String.fromCharCode(chCodes.reset);\n        const reset = cc + \"[0m\";\n        const whiteBG = cc + \"[1;47m  \" + reset;\n        const darkBG = cc + `[40m  ` + reset;\n        const nl = String.fromCharCode(chCodes.newline);\n        let out = \"\";\n        for(let y = 0; y < this.height; y++){\n            for(let x = 0; x < this.width; x++){\n                const v = this.get(x, y); // undefined -> white\n                out += v ? darkBG : whiteBG;\n            }\n            out += nl;\n        }\n        return out;\n    }\n    toSVG(optimize = true) {\n        let out = `<svg viewBox=\"0 0 ${this.width} ${this.height}\" xmlns=\"http://www.w3.org/2000/svg\">`;\n        // Construct optimized SVG path data.\n        let pathData = \"\";\n        let prevPoint;\n        this.rectRead(0, Infinity, (point, val)=>{\n            if (!val) return;\n            const { x, y } = point;\n            if (!optimize) {\n                out += `<rect x=\"${x}\" y=\"${y}\" width=\"1\" height=\"1\" />`;\n                return;\n            }\n            // https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/d#path_commands\n            // Determine the shortest way to represent the initial cursor movement.\n            // M - Move cursor (without drawing) to absolute coordinate pair.\n            let m = `M${x} ${y}`;\n            // Only allow using the relative cursor move command if previous points\n            // were drawn.\n            if (prevPoint) {\n                // m - Move cursor (without drawing) to relative coordinate pair.\n                const relM = `m${x - prevPoint.x} ${y - prevPoint.y}`;\n                if (relM.length <= m.length) m = relM;\n            }\n            // Determine the shortest way to represent the cell's bottom line draw.\n            // H - Draw line from cursor position to absolute x coordinate.\n            // h - Draw line from cursor position to relative x coordinate.\n            const bH = x < 10 ? `H${x}` : \"h-1\";\n            // v - Draw line from cursor position to relative y coordinate.\n            // Z - Close path (draws line from cursor position to M coordinate).\n            pathData += `${m}h1v1${bH}Z`;\n            prevPoint = point;\n        });\n        if (optimize) out += `<path d=\"${pathData}\"/>`;\n        out += `</svg>`;\n        return out;\n    }\n    toGIF() {\n        // NOTE: Small, but inefficient implementation.\n        // Uses 1 byte per pixel.\n        const u16le = (i)=>[\n                i & 0xff,\n                i >>> 8 & 0xff\n            ];\n        const dims = [\n            ...u16le(this.width),\n            ...u16le(this.height)\n        ];\n        const data = [];\n        this.rectRead(0, Infinity, (_, cur)=>data.push(+(cur === true)));\n        const N = 126; // Block size\n        // prettier-ignore\n        const bytes = [\n            0x47,\n            0x49,\n            0x46,\n            0x38,\n            0x37,\n            0x61,\n            ...dims,\n            0xf6,\n            0x00,\n            0x00,\n            0xff,\n            0xff,\n            0xff,\n            ...fillArr(3 * 127, 0x00),\n            0x2c,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            ...dims,\n            0x00,\n            0x07\n        ];\n        const fullChunks = Math.floor(data.length / N);\n        // Full blocks\n        for(let i = 0; i < fullChunks; i++)bytes.push(N + 1, 0x80, ...data.slice(N * i, N * (i + 1)).map((i)=>+i));\n        // Remaining bytes\n        bytes.push(data.length % N + 1, 0x80, ...data.slice(fullChunks * N).map((i)=>+i));\n        bytes.push(0x01, 0x81, 0x00, 0x3b);\n        return new Uint8Array(bytes);\n    }\n    toImage(isRGB = false) {\n        const { height, width } = this.size();\n        const data = new Uint8Array(height * width * (isRGB ? 3 : 4));\n        let i = 0;\n        for(let y = 0; y < height; y++){\n            for(let x = 0; x < width; x++){\n                const value = this.get(x, y) ? 0 : 255; // undefined -> white\n                data[i++] = value;\n                data[i++] = value;\n                data[i++] = value;\n                if (!isRGB) data[i++] = 255; // alpha channel\n            }\n        }\n        return {\n            height,\n            width,\n            data\n        };\n    }\n}\n// End of utils\n// Runtime type-checking\n/** Error correction mode. low: 7%, medium: 15%, quartile: 25%, high: 30% */ const ECMode = [\n    \"low\",\n    \"medium\",\n    \"quartile\",\n    \"high\"\n];\n/** QR Code encoding */ const Encoding = [\n    \"numeric\",\n    \"alphanumeric\",\n    \"byte\",\n    \"kanji\",\n    \"eci\"\n];\n// Various constants & tables\n// prettier-ignore\nconst BYTES = [\n    // 1,  2,  3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,   20,\n    26,\n    44,\n    70,\n    100,\n    134,\n    172,\n    196,\n    242,\n    292,\n    346,\n    404,\n    466,\n    532,\n    581,\n    655,\n    733,\n    815,\n    901,\n    991,\n    1085,\n    //  21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40\n    1156,\n    1258,\n    1364,\n    1474,\n    1588,\n    1706,\n    1828,\n    1921,\n    2051,\n    2185,\n    2323,\n    2465,\n    2611,\n    2761,\n    2876,\n    3034,\n    3196,\n    3362,\n    3532,\n    3706\n];\n// prettier-ignore\nconst WORDS_PER_BLOCK = {\n    // Version 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n    low: [\n        7,\n        10,\n        15,\n        20,\n        26,\n        18,\n        20,\n        24,\n        30,\n        18,\n        20,\n        24,\n        26,\n        30,\n        22,\n        24,\n        28,\n        30,\n        28,\n        28,\n        28,\n        28,\n        30,\n        30,\n        26,\n        28,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ],\n    medium: [\n        10,\n        16,\n        26,\n        18,\n        24,\n        16,\n        18,\n        22,\n        22,\n        26,\n        30,\n        22,\n        22,\n        24,\n        24,\n        28,\n        28,\n        26,\n        26,\n        26,\n        26,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28\n    ],\n    quartile: [\n        13,\n        22,\n        18,\n        26,\n        18,\n        24,\n        18,\n        22,\n        20,\n        24,\n        28,\n        26,\n        24,\n        20,\n        30,\n        24,\n        28,\n        28,\n        26,\n        30,\n        28,\n        30,\n        30,\n        30,\n        30,\n        28,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ],\n    high: [\n        17,\n        28,\n        22,\n        16,\n        22,\n        28,\n        26,\n        26,\n        24,\n        28,\n        24,\n        28,\n        22,\n        24,\n        24,\n        30,\n        28,\n        28,\n        26,\n        28,\n        30,\n        24,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ]\n};\n// prettier-ignore\nconst ECC_BLOCKS = {\n    // Version   1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n    low: [\n        1,\n        1,\n        1,\n        1,\n        1,\n        2,\n        2,\n        2,\n        2,\n        4,\n        4,\n        4,\n        4,\n        4,\n        6,\n        6,\n        6,\n        6,\n        7,\n        8,\n        8,\n        9,\n        9,\n        10,\n        12,\n        12,\n        12,\n        13,\n        14,\n        15,\n        16,\n        17,\n        18,\n        19,\n        19,\n        20,\n        21,\n        22,\n        24,\n        25\n    ],\n    medium: [\n        1,\n        1,\n        1,\n        2,\n        2,\n        4,\n        4,\n        4,\n        5,\n        5,\n        5,\n        8,\n        9,\n        9,\n        10,\n        10,\n        11,\n        13,\n        14,\n        16,\n        17,\n        17,\n        18,\n        20,\n        21,\n        23,\n        25,\n        26,\n        28,\n        29,\n        31,\n        33,\n        35,\n        37,\n        38,\n        40,\n        43,\n        45,\n        47,\n        49\n    ],\n    quartile: [\n        1,\n        1,\n        2,\n        2,\n        4,\n        4,\n        6,\n        6,\n        8,\n        8,\n        8,\n        10,\n        12,\n        16,\n        12,\n        17,\n        16,\n        18,\n        21,\n        20,\n        23,\n        23,\n        25,\n        27,\n        29,\n        34,\n        34,\n        35,\n        38,\n        40,\n        43,\n        45,\n        48,\n        51,\n        53,\n        56,\n        59,\n        62,\n        65,\n        68\n    ],\n    high: [\n        1,\n        1,\n        2,\n        4,\n        4,\n        4,\n        5,\n        6,\n        8,\n        8,\n        11,\n        11,\n        16,\n        16,\n        18,\n        16,\n        19,\n        21,\n        25,\n        25,\n        25,\n        34,\n        30,\n        32,\n        35,\n        37,\n        40,\n        42,\n        45,\n        48,\n        51,\n        54,\n        57,\n        60,\n        63,\n        66,\n        70,\n        74,\n        77,\n        81\n    ]\n};\nconst info = {\n    size: {\n        encode: (ver)=>21 + 4 * (ver - 1),\n        decode: (size)=>(size - 17) / 4\n    },\n    sizeType: (ver)=>Math.floor((ver + 7) / 17),\n    // Based on https://codereview.stackexchange.com/questions/74925/algorithm-to-generate-this-alignment-pattern-locations-table-for-qr-codes\n    alignmentPatterns (ver) {\n        if (ver === 1) return [];\n        const first = 6;\n        const last = info.size.encode(ver) - first - 1;\n        const distance = last - first;\n        const count = Math.ceil(distance / 28);\n        let interval = Math.floor(distance / count);\n        if (interval % 2) interval += 1;\n        else if (distance % count * 2 >= count) interval += 2;\n        const res = [\n            first\n        ];\n        for(let m = 1; m < count; m++)res.push(last - (count - m) * interval);\n        res.push(last);\n        return res;\n    },\n    ECCode: {\n        low: 1,\n        medium: 0,\n        quartile: 3,\n        high: 2\n    },\n    formatMask: 21522,\n    formatBits (ecc, maskIdx) {\n        const data = info.ECCode[ecc] << 3 | maskIdx;\n        let d = data;\n        for(let i = 0; i < 10; i++)d = d << 1 ^ (d >> 9) * 1335;\n        return (data << 10 | d) ^ info.formatMask;\n    },\n    versionBits (ver) {\n        let d = ver;\n        for(let i = 0; i < 12; i++)d = d << 1 ^ (d >> 11) * 7973;\n        return ver << 12 | d;\n    },\n    alphabet: {\n        numeric: alphabet(\"0123456789\"),\n        alphanumerc: alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\")\n    },\n    lengthBits (ver, type) {\n        const table = {\n            numeric: [\n                10,\n                12,\n                14\n            ],\n            alphanumeric: [\n                9,\n                11,\n                13\n            ],\n            byte: [\n                8,\n                16,\n                16\n            ],\n            kanji: [\n                8,\n                10,\n                12\n            ],\n            eci: [\n                0,\n                0,\n                0\n            ]\n        };\n        return table[type][info.sizeType(ver)];\n    },\n    modeBits: {\n        numeric: \"0001\",\n        alphanumeric: \"0010\",\n        byte: \"0100\",\n        kanji: \"1000\",\n        eci: \"0111\"\n    },\n    capacity (ver, ecc) {\n        const bytes = BYTES[ver - 1];\n        const words = WORDS_PER_BLOCK[ecc][ver - 1];\n        const numBlocks = ECC_BLOCKS[ecc][ver - 1];\n        const blockLen = Math.floor(bytes / numBlocks) - words;\n        const shortBlocks = numBlocks - bytes % numBlocks;\n        return {\n            words,\n            numBlocks,\n            shortBlocks,\n            blockLen,\n            capacity: (bytes - words * numBlocks) * 8,\n            total: (words + blockLen) * numBlocks + numBlocks - shortBlocks\n        };\n    }\n};\nconst PATTERNS = [\n    (x, y)=>(x + y) % 2 == 0,\n    (_x, y)=>y % 2 == 0,\n    (x, _y)=>x % 3 == 0,\n    (x, y)=>(x + y) % 3 == 0,\n    (x, y)=>(Math.floor(y / 2) + Math.floor(x / 3)) % 2 == 0,\n    (x, y)=>x * y % 2 + x * y % 3 == 0,\n    (x, y)=>(x * y % 2 + x * y % 3) % 2 == 0,\n    (x, y)=>((x + y) % 2 + x * y % 3) % 2 == 0\n];\n// Galois field && reed-solomon encoding\nconst GF = {\n    tables: ((p_poly)=>{\n        const exp = fillArr(256, 0);\n        const log = fillArr(256, 0);\n        for(let i = 0, x = 1; i < 256; i++){\n            exp[i] = x;\n            log[x] = i;\n            x <<= 1;\n            if (x & 0x100) x ^= p_poly;\n        }\n        return {\n            exp,\n            log\n        };\n    })(0x11d),\n    exp: (x)=>GF.tables.exp[x],\n    log (x) {\n        if (x === 0) throw new Error(`GF.log: invalid arg=${x}`);\n        return GF.tables.log[x] % 255;\n    },\n    mul (x, y) {\n        if (x === 0 || y === 0) return 0;\n        return GF.tables.exp[(GF.tables.log[x] + GF.tables.log[y]) % 255];\n    },\n    add: (x, y)=>x ^ y,\n    pow: (x, e)=>GF.tables.exp[GF.tables.log[x] * e % 255],\n    inv (x) {\n        if (x === 0) throw new Error(`GF.inverse: invalid arg=${x}`);\n        return GF.tables.exp[255 - GF.tables.log[x]];\n    },\n    polynomial (poly) {\n        if (poly.length == 0) throw new Error(\"GF.polymomial: invalid length\");\n        if (poly[0] !== 0) return poly;\n        // Strip leading zeros\n        let i = 0;\n        for(; i < poly.length - 1 && poly[i] == 0; i++);\n        return poly.slice(i);\n    },\n    monomial (degree, coefficient) {\n        if (degree < 0) throw new Error(`GF.monomial: invalid degree=${degree}`);\n        if (coefficient == 0) return [\n            0\n        ];\n        let coefficients = fillArr(degree + 1, 0);\n        coefficients[0] = coefficient;\n        return GF.polynomial(coefficients);\n    },\n    degree: (a)=>a.length - 1,\n    coefficient: (a, degree)=>a[GF.degree(a) - degree],\n    mulPoly (a, b) {\n        if (a[0] === 0 || b[0] === 0) return [\n            0\n        ];\n        const res = fillArr(a.length + b.length - 1, 0);\n        for(let i = 0; i < a.length; i++){\n            for(let j = 0; j < b.length; j++){\n                res[i + j] = GF.add(res[i + j], GF.mul(a[i], b[j]));\n            }\n        }\n        return GF.polynomial(res);\n    },\n    mulPolyScalar (a, scalar) {\n        if (scalar == 0) return [\n            0\n        ];\n        if (scalar == 1) return a;\n        const res = fillArr(a.length, 0);\n        for(let i = 0; i < a.length; i++)res[i] = GF.mul(a[i], scalar);\n        return GF.polynomial(res);\n    },\n    mulPolyMonomial (a, degree, coefficient) {\n        if (degree < 0) throw new Error(\"GF.mulPolyMonomial: invalid degree\");\n        if (coefficient == 0) return [\n            0\n        ];\n        const res = fillArr(a.length + degree, 0);\n        for(let i = 0; i < a.length; i++)res[i] = GF.mul(a[i], coefficient);\n        return GF.polynomial(res);\n    },\n    addPoly (a, b) {\n        if (a[0] === 0) return b;\n        if (b[0] === 0) return a;\n        let smaller = a;\n        let larger = b;\n        if (smaller.length > larger.length) [smaller, larger] = [\n            larger,\n            smaller\n        ];\n        let sumDiff = fillArr(larger.length, 0);\n        let lengthDiff = larger.length - smaller.length;\n        let s = larger.slice(0, lengthDiff);\n        for(let i = 0; i < s.length; i++)sumDiff[i] = s[i];\n        for(let i = lengthDiff; i < larger.length; i++)sumDiff[i] = GF.add(smaller[i - lengthDiff], larger[i]);\n        return GF.polynomial(sumDiff);\n    },\n    remainderPoly (data, divisor) {\n        const out = Array.from(data);\n        for(let i = 0; i < data.length - divisor.length + 1; i++){\n            const elm = out[i];\n            if (elm === 0) continue;\n            for(let j = 1; j < divisor.length; j++){\n                if (divisor[j] !== 0) out[i + j] = GF.add(out[i + j], GF.mul(divisor[j], elm));\n            }\n        }\n        return out.slice(data.length - divisor.length + 1, out.length);\n    },\n    divisorPoly (degree) {\n        let g = [\n            1\n        ];\n        for(let i = 0; i < degree; i++)g = GF.mulPoly(g, [\n            1,\n            GF.pow(2, i)\n        ]);\n        return g;\n    },\n    evalPoly (poly, a) {\n        if (a == 0) return GF.coefficient(poly, 0); // Just return the x^0 coefficient\n        let res = poly[0];\n        for(let i = 1; i < poly.length; i++)res = GF.add(GF.mul(a, res), poly[i]);\n        return res;\n    },\n    // TODO: cleanup\n    euclidian (a, b, R) {\n        // Force degree(a) >= degree(b)\n        if (GF.degree(a) < GF.degree(b)) [a, b] = [\n            b,\n            a\n        ];\n        let rLast = a;\n        let r = b;\n        let tLast = [\n            0\n        ];\n        let t = [\n            1\n        ];\n        // while degree of Ri ≥ t/2\n        while(2 * GF.degree(r) >= R){\n            let rLastLast = rLast;\n            let tLastLast = tLast;\n            rLast = r;\n            tLast = t;\n            if (rLast[0] === 0) throw new Error(\"rLast[0] === 0\");\n            r = rLastLast;\n            let q = [\n                0\n            ];\n            const dltInverse = GF.inv(rLast[0]);\n            while(GF.degree(r) >= GF.degree(rLast) && r[0] !== 0){\n                const degreeDiff = GF.degree(r) - GF.degree(rLast);\n                const scale = GF.mul(r[0], dltInverse);\n                q = GF.addPoly(q, GF.monomial(degreeDiff, scale));\n                r = GF.addPoly(r, GF.mulPolyMonomial(rLast, degreeDiff, scale));\n            }\n            q = GF.mulPoly(q, tLast);\n            t = GF.addPoly(q, tLastLast);\n            if (GF.degree(r) >= GF.degree(rLast)) throw new Error(`Division failed r: ${r}, rLast: ${rLast}`);\n        }\n        const sigmaTildeAtZero = GF.coefficient(t, 0);\n        if (sigmaTildeAtZero == 0) throw new Error(\"sigmaTilde(0) was zero\");\n        const inverse = GF.inv(sigmaTildeAtZero);\n        return [\n            GF.mulPolyScalar(t, inverse),\n            GF.mulPolyScalar(r, inverse)\n        ];\n    }\n};\nfunction RS(eccWords) {\n    return {\n        encode (from) {\n            const d = GF.divisorPoly(eccWords);\n            const pol = Array.from(from);\n            pol.push(...d.slice(0, -1).fill(0));\n            return Uint8Array.from(GF.remainderPoly(pol, d));\n        },\n        decode (to) {\n            const res = to.slice();\n            const poly = GF.polynomial(Array.from(to));\n            // Find errors\n            let syndrome = fillArr(eccWords, 0);\n            let hasError = false;\n            for(let i = 0; i < eccWords; i++){\n                const evl = GF.evalPoly(poly, GF.exp(i));\n                syndrome[syndrome.length - 1 - i] = evl;\n                if (evl !== 0) hasError = true;\n            }\n            if (!hasError) return res;\n            syndrome = GF.polynomial(syndrome);\n            const monomial = GF.monomial(eccWords, 1);\n            const [errorLocator, errorEvaluator] = GF.euclidian(monomial, syndrome, eccWords);\n            // Error locations\n            const locations = fillArr(GF.degree(errorLocator), 0);\n            let e = 0;\n            for(let i = 1; i < 256 && e < locations.length; i++){\n                if (GF.evalPoly(errorLocator, i) === 0) locations[e++] = GF.inv(i);\n            }\n            if (e !== locations.length) throw new Error(\"RS.decode: invalid errors number\");\n            for(let i = 0; i < locations.length; i++){\n                const pos = res.length - 1 - GF.log(locations[i]);\n                if (pos < 0) throw new Error(\"RS.decode: invalid error location\");\n                const xiInverse = GF.inv(locations[i]);\n                let denominator = 1;\n                for(let j = 0; j < locations.length; j++){\n                    if (i === j) continue;\n                    denominator = GF.mul(denominator, GF.add(1, GF.mul(locations[j], xiInverse)));\n                }\n                res[pos] = GF.add(res[pos], GF.mul(GF.evalPoly(errorEvaluator, xiInverse), GF.inv(denominator)));\n            }\n            return res;\n        }\n    };\n}\n// Interleaves blocks\nfunction interleave(ver, ecc) {\n    const { words, shortBlocks, numBlocks, blockLen, total } = info.capacity(ver, ecc);\n    const rs = RS(words);\n    return {\n        encode (bytes) {\n            // Add error correction to bytes\n            const blocks = [];\n            const eccBlocks = [];\n            for(let i = 0; i < numBlocks; i++){\n                const isShort = i < shortBlocks;\n                const len = blockLen + (isShort ? 0 : 1);\n                blocks.push(bytes.subarray(0, len));\n                eccBlocks.push(rs.encode(bytes.subarray(0, len)));\n                bytes = bytes.subarray(len);\n            }\n            const resBlocks = interleaveBytes(blocks);\n            const resECC = interleaveBytes(eccBlocks);\n            const res = new Uint8Array(resBlocks.length + resECC.length);\n            res.set(resBlocks);\n            res.set(resECC, resBlocks.length);\n            return res;\n        },\n        decode (data) {\n            if (data.length !== total) throw new Error(`interleave.decode: len(data)=${data.length}, total=${total}`);\n            const blocks = [];\n            for(let i = 0; i < numBlocks; i++){\n                const isShort = i < shortBlocks;\n                blocks.push(new Uint8Array(words + blockLen + (isShort ? 0 : 1)));\n            }\n            // Short blocks\n            let pos = 0;\n            for(let i = 0; i < blockLen; i++){\n                for(let j = 0; j < numBlocks; j++)blocks[j][i] = data[pos++];\n            }\n            // Long blocks\n            for(let j = shortBlocks; j < numBlocks; j++)blocks[j][blockLen] = data[pos++];\n            // ECC\n            for(let i = blockLen; i < blockLen + words; i++){\n                for(let j = 0; j < numBlocks; j++){\n                    const isShort = j < shortBlocks;\n                    blocks[j][i + (isShort ? 0 : 1)] = data[pos++];\n                }\n            }\n            // Decode\n            // Error-correct and copy data blocks together into a stream of bytes\n            const res = [];\n            for (const block of blocks)res.push(...Array.from(rs.decode(block)).slice(0, -words));\n            return Uint8Array.from(res);\n        }\n    };\n}\n// Draw\n// Generic template per version+ecc+mask. Can be cached, to speedup calculations.\nfunction drawTemplate(ver, ecc, maskIdx, test = false) {\n    const size = info.size.encode(ver);\n    let b = new Bitmap(size + 2);\n    // Finder patterns\n    // We draw full pattern and later slice, since before addition of borders finder is truncated by one pixel on sides\n    const finder = new Bitmap(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);\n    b = b.embed(0, finder) // top left\n    .embed({\n        x: -finder.width,\n        y: 0\n    }, finder) // top right\n    .embed({\n        x: 0,\n        y: -finder.height\n    }, finder); // bottom left\n    b = b.rectSlice(1, size);\n    // Alignment patterns\n    const align = new Bitmap(1).rect(0, 1, true).border(1, false).border(1, true);\n    const alignPos = info.alignmentPatterns(ver);\n    for (const y of alignPos){\n        for (const x of alignPos){\n            if (b.isDefined(x, y)) continue;\n            b.embed({\n                x: x - 2,\n                y: y - 2\n            }, align); // center of pattern should be at position\n        }\n    }\n    // Timing patterns\n    b = b.hLine({\n        x: 0,\n        y: 6\n    }, Infinity, ({ x })=>b.isDefined(x, 6) ? undefined : x % 2 == 0).vLine({\n        x: 6,\n        y: 0\n    }, Infinity, ({ y })=>b.isDefined(6, y) ? undefined : y % 2 == 0);\n    // Format information\n    {\n        const bits = info.formatBits(ecc, maskIdx);\n        const getBit = (i)=>!test && (bits >> i & 1) == 1;\n        // vertical\n        for(let i = 0; i < 6; i++)b.set(8, i, getBit(i)); // right of top-left finder\n        // TODO: re-write as lines, like:\n        // b.vLine({ x: 8, y: 0 }, 6, ({ x, y }) => getBit(y));\n        for(let i = 6; i < 8; i++)b.set(8, i + 1, getBit(i)); // after timing pattern\n        for(let i = 8; i < 15; i++)b.set(8, size - 15 + i, getBit(i)); // right of bottom-left finder\n        // horizontal\n        for(let i = 0; i < 8; i++)b.set(size - i - 1, 8, getBit(i)); // under top-right finder\n        for(let i = 8; i < 9; i++)b.set(15 - i - 1 + 1, 8, getBit(i)); // VVV, after timing\n        for(let i = 9; i < 15; i++)b.set(15 - i - 1, 8, getBit(i)); // under top-left finder\n        b.set(8, size - 8, !test); // bottom-left finder, right\n    }\n    // Version information\n    if (ver >= 7) {\n        const bits = info.versionBits(ver);\n        for(let i = 0; i < 18; i += 1){\n            const bit = !test && (bits >> i & 1) == 1;\n            const x = Math.floor(i / 3);\n            const y = i % 3 + size - 8 - 3;\n            // two copies\n            b.set(y, x, bit);\n            b.set(x, y, bit);\n        }\n    }\n    return b;\n}\n// zigzag: bottom->top && top->bottom\nfunction zigzag(tpl, maskIdx, fn) {\n    const size = tpl.height;\n    const pattern = PATTERNS[maskIdx];\n    // zig-zag pattern\n    let dir = -1;\n    let y = size - 1;\n    // two columns at time\n    for(let xOffset = size - 1; xOffset > 0; xOffset -= 2){\n        if (xOffset == 6) xOffset = 5; // skip vertical timing pattern\n        for(;; y += dir){\n            for(let j = 0; j < 2; j += 1){\n                const x = xOffset - j;\n                if (tpl.isDefined(x, y)) continue; // skip already written elements\n                fn(x, y, pattern(x, y));\n            }\n            if (y + dir < 0 || y + dir >= size) break;\n        }\n        dir = -dir; // change direction\n    }\n}\n// NOTE: byte encoding is just representation, QR works with strings only. Most decoders will fail on raw byte array,\n// since they expect unicode or other text encoding inside bytes\nfunction detectType(str) {\n    let type = \"numeric\";\n    for (let x of str){\n        if (info.alphabet.numeric.has(x)) continue;\n        type = \"alphanumeric\";\n        if (!info.alphabet.alphanumerc.has(x)) return \"byte\";\n    }\n    return type;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nfunction encode(ver, ecc, data, type, encoder = utf8ToBytes) {\n    let encoded = \"\";\n    let dataLen = data.length;\n    if (type === \"numeric\") {\n        const t = info.alphabet.numeric.decode(data.split(\"\"));\n        const n = t.length;\n        for(let i = 0; i < n - 2; i += 3)encoded += bin(t[i] * 100 + t[i + 1] * 10 + t[i + 2], 10);\n        if (n % 3 === 1) {\n            encoded += bin(t[n - 1], 4);\n        } else if (n % 3 === 2) {\n            encoded += bin(t[n - 2] * 10 + t[n - 1], 7);\n        }\n    } else if (type === \"alphanumeric\") {\n        const t = info.alphabet.alphanumerc.decode(data.split(\"\"));\n        const n = t.length;\n        for(let i = 0; i < n - 1; i += 2)encoded += bin(t[i] * 45 + t[i + 1], 11);\n        if (n % 2 == 1) encoded += bin(t[n - 1], 6); // pad if odd number of chars\n    } else if (type === \"byte\") {\n        const utf8 = encoder(data);\n        dataLen = utf8.length;\n        encoded = Array.from(utf8).map((i)=>bin(i, 8)).join(\"\");\n    } else {\n        throw new Error(\"encode: unsupported type\");\n    }\n    const { capacity } = info.capacity(ver, ecc);\n    const len = bin(dataLen, info.lengthBits(ver, type));\n    let bits = info.modeBits[type] + len + encoded;\n    if (bits.length > capacity) throw new Error(\"Capacity overflow\");\n    // Terminator\n    bits += \"0\".repeat(Math.min(4, Math.max(0, capacity - bits.length)));\n    // Pad bits string untill full byte\n    if (bits.length % 8) bits += \"0\".repeat(8 - bits.length % 8);\n    // Add padding until capacity is full\n    const padding = \"1110110000010001\";\n    for(let idx = 0; bits.length !== capacity; idx++)bits += padding[idx % padding.length];\n    // Convert a bitstring to array of bytes\n    const bytes = Uint8Array.from(bits.match(/(.{8})/g).map((i)=>Number(`0b${i}`)));\n    return interleave(ver, ecc).encode(bytes);\n}\n// DRAW\nfunction drawQR(ver, ecc, data, maskIdx, test = false) {\n    const b = drawTemplate(ver, ecc, maskIdx, test);\n    let i = 0;\n    const need = 8 * data.length;\n    zigzag(b, maskIdx, (x, y, mask)=>{\n        let value = false;\n        if (i < need) {\n            value = (data[i >>> 3] >> (7 - i & 7) & 1) !== 0;\n            i++;\n        }\n        b.set(x, y, value !== mask); // !== as xor\n    });\n    if (i !== need) throw new Error(\"QR: bytes left after draw\");\n    return b;\n}\nconst mkPattern = (pattern)=>{\n    const s = pattern.map((i)=>i ? \"1\" : \"0\").join(\"\");\n    return {\n        len: s.length,\n        n: Number(`0b${s}`)\n    };\n};\n// 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column, preceded or followed by light area 4 modules wide\nconst finderPattern = [\n    true,\n    false,\n    true,\n    true,\n    true,\n    false,\n    true\n]; // dark:light:dark:light:dark\nconst lightPattern = [\n    false,\n    false,\n    false,\n    false\n]; // light area 4 modules wide\nconst P1 = mkPattern([\n    ...finderPattern,\n    ...lightPattern\n]);\nconst P2 = mkPattern([\n    ...lightPattern,\n    ...finderPattern\n]);\nfunction penalty(bm) {\n    const { width, height } = bm;\n    const transposed = bm.transpose();\n    // Adjacent modules in row/column in same | No. of modules = (5 + i) color\n    let adjacent = 0;\n    for(let y = 0; y < height; y++){\n        bm.getRuns(y, (len)=>{\n            if (len >= 5) adjacent += 3 + (len - 5);\n        });\n    }\n    for(let y = 0; y < width; y++){\n        transposed.getRuns(y, (len)=>{\n            if (len >= 5) adjacent += 3 + (len - 5);\n        });\n    }\n    // Block of modules in same color (Block size = 2x2)\n    let box = 0;\n    for(let y = 0; y < height - 1; y++)box += 3 * bm.countBoxes2x2(y);\n    let finder = 0;\n    for(let y = 0; y < height; y++)finder += 40 * bm.countPatternInRow(y, P1.len, P1.n, P2.n);\n    for(let y = 0; y < width; y++)finder += 40 * transposed.countPatternInRow(y, P1.len, P1.n, P2.n);\n    // Proportion of dark modules in entire symbol\n    // Add 10 points to a deviation of 5% increment or decrement in the proportion\n    // ratio of dark module from the referential 50%\n    let darkPixels = 0;\n    darkPixels = bm.popcnt();\n    //bm.rectRead(0, Infinity, (_c, val) => (darkPixels += val ? 1 : 0));\n    // for (let y = 0; y < height; y++) {\n    //   for (let x = 0; x < width; x++) if (bm.get(x, y)) darkPixels++;\n    // }\n    const darkPercent = darkPixels / (height * width) * 100;\n    const dark = 10 * Math.floor(Math.abs(darkPercent - 50) / 5);\n    return adjacent + box + finder + dark;\n}\n// Selects best mask according to penalty, if no mask is provided\nfunction drawQRBest(ver, ecc, data, maskIdx) {\n    if (maskIdx === undefined) {\n        const bestMask = best();\n        for(let mask = 0; mask < PATTERNS.length; mask++)bestMask.add(penalty(drawQR(ver, ecc, data, mask, true)), mask);\n        maskIdx = bestMask.get();\n    }\n    if (maskIdx === undefined) throw new Error(\"Cannot find mask\"); // Should never happen\n    return drawQR(ver, ecc, data, maskIdx);\n}\nfunction validateECC(ec) {\n    if (!ECMode.includes(ec)) throw new Error(`Invalid error correction mode=${ec}. Expected: ${ECMode}`);\n}\nfunction validateEncoding(enc) {\n    if (!Encoding.includes(enc)) throw new Error(`Encoding: invalid mode=${enc}. Expected: ${Encoding}`);\n    if (enc === \"kanji\" || enc === \"eci\") throw new Error(`Encoding: ${enc} is not supported (yet?).`);\n}\nfunction validateMask(mask) {\n    if (![\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7\n    ].includes(mask) || !PATTERNS[mask]) throw new Error(`Invalid mask=${mask}. Expected number [0..7]`);\n}\nfunction encodeQR(text, output = \"raw\", opts = {}) {\n    const ecc = opts.ecc !== undefined ? opts.ecc : \"medium\";\n    validateECC(ecc);\n    const encoding = opts.encoding !== undefined ? opts.encoding : detectType(text);\n    validateEncoding(encoding);\n    if (opts.mask !== undefined) validateMask(opts.mask);\n    let ver = opts.version;\n    let data, err = new Error(\"Unknown error\");\n    if (ver !== undefined) {\n        validateVersion(ver);\n        data = encode(ver, ecc, text, encoding, opts.textEncoder);\n    } else {\n        // If no version is provided, try to find smallest one which fits\n        // Currently just scans all version, can be significantly speedup if needed\n        for(let i = 1; i <= 40; i++){\n            try {\n                data = encode(i, ecc, text, encoding, opts.textEncoder);\n                ver = i;\n                break;\n            } catch (e) {\n                err = e;\n            }\n        }\n    }\n    if (!ver || !data) throw err;\n    let res = drawQRBest(ver, ecc, data, opts.mask);\n    res.assertDrawn();\n    const border = opts.border === undefined ? 2 : opts.border;\n    if (!Number.isSafeInteger(border)) throw new Error(`invalid border type=${typeof border}`);\n    res = res.border(border, false); // Add border\n    if (opts.scale !== undefined) res = res.scale(opts.scale); // Scale image\n    if (output === \"raw\") return res.toRaw();\n    else if (output === \"ascii\") return res.toASCII();\n    else if (output === \"svg\") return res.toSVG(opts.optimize);\n    else if (output === \"gif\") return res.toGIF();\n    else if (output === \"term\") return res.toTerm();\n    else throw new Error(`Unknown output: ${output}`);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encodeQR);\nconst utils = {\n    best,\n    bin,\n    popcnt,\n    drawTemplate,\n    fillArr,\n    info,\n    interleave,\n    validateVersion,\n    zigzag\n};\n// Unsafe API utils, exported only for tests\nconst _tests = {\n    Bitmap,\n    info,\n    detectType,\n    encode,\n    drawQR,\n    penalty,\n    PATTERNS\n}; // Type tests\n // const o1 = qr('test', 'ascii');\n // const o2 = qr('test', 'raw');\n // const o3 = qr('test', 'gif');\n // const o4 = qr('test', 'svg');\n // const o5 = qr('test', 'term');\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDeEtDLEtBQUs7UUFBQztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHO0lBQ3BLQyxRQUFRO1FBQUM7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7S0FBRztJQUN4S0MsVUFBVTtRQUFDO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO0tBQUc7SUFDMUtDLE1BQU07UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHO0FBQzFLO0FBQ0Esa0JBQWtCO0FBQ2xCLE1BQU1DLGFBQWE7SUFDZixpS0FBaUs7SUFDaktKLEtBQUs7UUFBQztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHO0lBQzlJQyxRQUFRO1FBQUM7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7S0FBRztJQUMxSkMsVUFBVTtRQUFDO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO0tBQUc7SUFDL0pDLE1BQU07UUFBQztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHO0FBQ2hLO0FBQ0EsTUFBTUUs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QUNyQyxNQUFNaUQsU0FBUztJQUNsQnhUO0lBQ0FtSztJQUNBeUc7SUFDQTlSO0lBQ0EwUztJQUNBTztJQUNBaEc7QUFDSixFQUFFLENBQ0YsYUFBYTtDQUNiLGtDQUFrQztDQUNsQyxnQ0FBZ0M7Q0FDaEMsZ0NBQWdDO0NBQ2hDLGdDQUFnQztDQUNoQyxpQ0FBaUM7Q0FDakMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3FyL2luZGV4LmpzPzAxNzciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5Db3B5cmlnaHQgKGMpIDIwMjMgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pXG5UaGUgbGlicmFyeSBwYXVsbWlsbHItcXIgaXMgZHVhbC1saWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIDIuMCBPUiBNSVQgbGljZW5zZS5cbllvdSBjYW4gc2VsZWN0IGEgbGljZW5zZSBvZiB5b3VyIGNob2ljZS5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8qKlxuICogTWV0aG9kcyBmb3IgZW5jb2RpbmcgKGdlbmVyYXRpbmcpIFFSIGNvZGUgcGF0dGVybnMuXG4gKiBDaGVjayBvdXQgZGVjb2RlLnRzIGZvciBkZWNvZGluZyAocmVhZGluZykuXG4gKiBAbW9kdWxlXG4gKiBAZXhhbXBsZVxuYGBganNcbmltcG9ydCBlbmNvZGVRUiBmcm9tICdxcic7XG5jb25zdCB0eHQgPSAnSGVsbG8gd29ybGQnO1xuY29uc3QgYXNjaWkgPSBlbmNvZGVRUih0eHQsICdhc2NpaScpOyAvLyBOb3QgYWxsIGZvbnRzIGFyZSBzdXBwb3J0ZWRcbmNvbnN0IHRlcm1pbmFsRnJpZW5kbHkgPSBlbmNvZGVRUih0eHQsICd0ZXJtJyk7IC8vIDJ4IGxhcmdlciwgYWxsIGZvbnRzIGFyZSBPS1xuY29uc3QgZ2lmQnl0ZXMgPSBlbmNvZGVRUih0eHQsICdnaWYnKTsgLy8gVW5jb21wcmVzc2VkIEdJRlxuY29uc3Qgc3ZnRWxlbWVudCA9IGVuY29kZVFSKHR4dCwgJ3N2ZycpOyAvLyBTVkcgdmVjdG9yIGltYWdlIGVsZW1lbnRcbmNvbnN0IGFycmF5ID0gZW5jb2RlUVIodHh0LCAncmF3Jyk7IC8vIDJkIGFycmF5IGZvciBjYW52YXMgb3Igb3RoZXIgbGlic1xuLy8gaW1wb3J0IGRlY29kZVFSIGZyb20gJ3FyL2RlY29kZS5qcyc7XG5gYGBcbiAqL1xuLy8gV2UgZG8gbm90IHVzZSBuZXdsaW5lIGVzY2FwZSBjb2RlIGRpcmVjdGx5IGluIHN0cmluZ3MgYmVjYXVzZSBpdCdzIG5vdCBwYXJzZXItZnJpZW5kbHlcbmNvbnN0IGNoQ29kZXMgPSB7IG5ld2xpbmU6IDEwLCByZXNldDogMjcgfTtcbmZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnRlZ2VyIGV4cGVjdGVkOiAke259YCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVZlcnNpb24odmVyKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2ZXIpIHx8IHZlciA8IDEgfHwgdmVyID4gNDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2ZXJzaW9uPSR7dmVyfS4gRXhwZWN0ZWQgbnVtYmVyIFsxLi40MF1gKTtcbn1cbmZ1bmN0aW9uIGJpbihkZWMsIHBhZCkge1xuICAgIHJldHVybiBkZWMudG9TdHJpbmcoMikucGFkU3RhcnQocGFkLCAnMCcpO1xufVxuZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IDAgPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gZmlsbEFycihsZW5ndGgsIHZhbCkge1xuICAgIHJldHVybiBuZXcgQXJyYXkobGVuZ3RoKS5maWxsKHZhbCk7XG59XG5mdW5jdGlvbiBwb3BjbnQobikge1xuICAgIG4gPSBuIC0gKChuID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICAgIG4gPSAobiAmIDB4MzMzMzMzMzMpICsgKChuID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICAgIHJldHVybiAoKChuICsgKG4gPj4+IDQpKSAmIDB4MGYwZjBmMGYpICogMHgwMTAxMDEwMSkgPj4+IDI0O1xufVxuLyoqXG4gKiBJbnRlcmxlYXZlcyBieXRlIGJsb2Nrcy5cbiAqIEBwYXJhbSBibG9ja3MgW1sxLCAyLCAzXSwgWzQsIDUsIDZdXVxuICogQHJldHVybnMgWzEsIDQsIDIsIDUsIDMsIDZdXG4gKi9cbmZ1bmN0aW9uIGludGVybGVhdmVCeXRlcyhibG9ja3MpIHtcbiAgICBsZXQgbWF4TGVuID0gMDtcbiAgICBsZXQgdG90YWxMZW4gPSAwO1xuICAgIGZvciAoY29uc3QgYmxvY2sgb2YgYmxvY2tzKSB7XG4gICAgICAgIG1heExlbiA9IE1hdGgubWF4KG1heExlbiwgYmxvY2subGVuZ3RoKTtcbiAgICAgICAgdG90YWxMZW4gKz0gYmxvY2subGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbik7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW47IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJsb2Nrcykge1xuICAgICAgICAgICAgaWYgKGkgPCBibG9jay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2lkeCsrXSA9IGJsb2NrW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBPcHRpbWl6ZSBmb3IgbWluaW1hbCBzY29yZS9wZW5hbHR5XG5mdW5jdGlvbiBiZXN0KCkge1xuICAgIGxldCBiZXN0O1xuICAgIGxldCBiZXN0U2NvcmUgPSBJbmZpbml0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQoc2NvcmUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmUgPj0gYmVzdFNjb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGJlc3QgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6ICgpID0+IGJlc3QsXG4gICAgICAgIHNjb3JlOiAoKSA9PiBiZXN0U2NvcmUsXG4gICAgfTtcbn1cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvc2N1cmUtYmFzZS9ibG9iL21haW4vaW5kZXgudHNcbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzOiAoY2hhcikgPT4gYWxwaGFiZXQuaW5jbHVkZXMoY2hhciksXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIFRyYW5zcG9zZSAzMngzMiBiaXQgbWF0cml4IGluLXBsYWNlXG4vLyBhWzAuLjMxXSBhcmUgMzIgcm93cyBvZiAzMiBiaXRzIGVhY2g7IGFmdGVyIHRyYW5zcG9zZSB0aGV5IGJlY29tZSAzMiBjb2x1bW5zLlxuZnVuY3Rpb24gdHJhbnNwb3NlMzIoYSkge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0cyAzMiBlbGVtZW50IG1hdHJpeCcpO1xuICAgIGNvbnN0IG1hc2tzID0gWzB4NTU1NTU1NTUsIDB4MzMzMzMzMzMsIDB4MGYwZjBmMGYsIDB4MDBmZjAwZmYsIDB4MDAwMGZmZmZdO1xuICAgIC8vIEhlbGxvIGFnYWluLCBGRlRcbiAgICBmb3IgKGxldCBzdGFnZSA9IDA7IHN0YWdlIDwgNTsgc3RhZ2UrKykge1xuICAgICAgICBjb25zdCBtID0gbWFza3Nbc3RhZ2VdID4+PiAwO1xuICAgICAgICBjb25zdCBzID0gMSA8PCBzdGFnZTsgLy8gMSwyLDQsOCwxNlxuICAgICAgICBjb25zdCBzdGVwID0gcyA8PCAxOyAvLyAyLDQsOCwxNiwzMlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgczsgaysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaTAgPSBpICsgaztcbiAgICAgICAgICAgICAgICBjb25zdCBpMSA9IGkwICsgcztcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gYVtpMF0gPj4+IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGFbaTFdID4+PiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSAoKHggPj4+IHMpIF4geSkgJiBtO1xuICAgICAgICAgICAgICAgIGFbaTBdID0gKHggXiAodCA8PCBzKSkgPj4+IDA7XG4gICAgICAgICAgICAgICAgYVtpMV0gPSAoeSBeIHQpID4+PiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgYml0TWFzayA9ICh4KSA9PiAoMSA8PCAoeCAmIDMxKSkgPj4+IDA7XG5jb25zdCByYW5nZU1hc2sgPSAoc2hpZnQsIGxlbikgPT4ge1xuICAgIC8vIGxlbiBpbiBbMC4uMzJdLCBzaGlmdCBpbiBbMC4uMzFdXG4gICAgaWYgKGxlbiA9PT0gMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKGxlbiA9PT0gMzIpXG4gICAgICAgIHJldHVybiAweGZmZmZmZmZmO1xuICAgIHJldHVybiAoKCgxIDw8IGxlbikgLSAxKSA8PCBzaGlmdCkgPj4+IDA7XG59O1xuZXhwb3J0IGNsYXNzIEJpdG1hcCB7XG4gICAgc3RhdGljIHNpemUoc2l6ZSwgbGltaXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHNpemUgPSB7IGhlaWdodDogc2l6ZSwgd2lkdGg6IHNpemUgfTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzaXplLmhlaWdodCkgJiYgc2l6ZS5oZWlnaHQgIT09IEluZmluaXR5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IGludmFsaWQgaGVpZ2h0PSR7c2l6ZS5oZWlnaHR9ICgke3R5cGVvZiBzaXplLmhlaWdodH0pYCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoc2l6ZS53aWR0aCkgJiYgc2l6ZS53aWR0aCAhPT0gSW5maW5pdHkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdG1hcDogaW52YWxpZCB3aWR0aD0ke3NpemUud2lkdGh9ICgke3R5cGVvZiBzaXplLndpZHRofSlgKTtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENsYW1wIGxlbmd0aCwgc28gaXQgd29uJ3Qgb3ZlcmZsb3csIGFsc28gYWxsb3dzIHRvIHVzZSBJbmZpbml0eSwgc28gd2UgZHJhdyB1bnRpbCBlbmRcbiAgICAgICAgICAgIHNpemUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgubWluKHNpemUud2lkdGgsIGxpbWl0LndpZHRoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKHNpemUuaGVpZ2h0LCBsaW1pdC5oZWlnaHQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcocykge1xuICAgICAgICAvLyBSZW1vdmUgbGluZWJyZWFrcyBvbiBzdGFydCBhbmQgZW5kLCBzbyB3ZSBkcmF3IGluIGBgIHNlY3Rpb25cbiAgICAgICAgcyA9IHMucmVwbGFjZSgvXlxcbisvZywgJycpLnJlcGxhY2UoL1xcbiskL2csICcnKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzLnNwbGl0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2hDb2Rlcy5uZXdsaW5lKSk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgbGV0IHdpZHRoO1xuICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gbGluZS5zcGxpdCgnJykubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09ICdYJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAnPycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXAuZnJvbVN0cmluZzogdW5rbm93biBzeW1ib2w9JHtpfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAod2lkdGggIT09IHVuZGVmaW5lZCAmJiByb3cubGVuZ3RoICE9PSB3aWR0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdG1hcC5mcm9tU3RyaW5nIGRpZmZlcmVudCByb3cgc2l6ZXM6IHdpZHRoPSR7d2lkdGh9IGN1cj0ke3Jvdy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB3aWR0aCA9IHJvdy5sZW5ndGg7XG4gICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRtYXAoeyBoZWlnaHQsIHdpZHRoIH0sIHJvd3MpO1xuICAgIH1cbiAgICAvLyBUd28gYml0c2V0czpcbiAgICAvLyBkZWZpbmVkPTAgLT4gdW5kZWZpbmVkXG4gICAgLy8gZGVmaW5lZD0xLHZhbHVlPTAgLT4gZmFsc2VcbiAgICAvLyBkZWZpbmVkPTEsdmFsdWU9MSAtPiB0cnVlXG4gICAgZGVmaW5lZDtcbiAgICB2YWx1ZTtcbiAgICB0YWlsTWFzaztcbiAgICB3b3JkcztcbiAgICBmdWxsV29yZHM7XG4gICAgaGVpZ2h0O1xuICAgIHdpZHRoO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBCaXRtYXAuc2l6ZShzaXplKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy50YWlsTWFzayA9IHJhbmdlTWFzaygwLCB3aWR0aCAmIDMxIHx8IDMyKTtcbiAgICAgICAgdGhpcy53b3JkcyA9IE1hdGguY2VpbCh3aWR0aCAvIDMyKSB8IDA7XG4gICAgICAgIHRoaXMuZnVsbFdvcmRzID0gTWF0aC5mbG9vcih3aWR0aCAvIDMyKSB8IDA7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgVWludDMyQXJyYXkodGhpcy53b3JkcyAqIGhlaWdodCk7XG4gICAgICAgIHRoaXMuZGVmaW5lZCA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBhY2NlcHQgc2FtZSBzZW1hbnRpY3MgYXMgb2xkIHZlcnNpb25cbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gaGVpZ2h0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bWFwOiBkYXRhIGhlaWdodCBtaXNtYXRjaDogZXhwPSR7aGVpZ2h0fSBnb3Q9JHtkYXRhLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBkYXRhW3ldO1xuICAgICAgICAgICAgICAgIGlmICghcm93IHx8IHJvdy5sZW5ndGggIT09IHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdG1hcDogZGF0YSB3aWR0aCBtaXNtYXRjaCBhdCB5PSR7eX06IGV4cD0ke3dpZHRofSBnb3Q9JHtyb3c/Lmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KHgsIHksIHJvd1t4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9pbnQocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQocC54LCBwLnkpO1xuICAgIH1cbiAgICBpc0luc2lkZShwKSB7XG4gICAgICAgIHJldHVybiAwIDw9IHAueCAmJiBwLnggPCB0aGlzLndpZHRoICYmIDAgPD0gcC55ICYmIHAueSA8IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBzaXplKG9mZnNldCkge1xuICAgICAgICBpZiAoIW9mZnNldClcbiAgICAgICAgICAgIHJldHVybiB7IGhlaWdodDogdGhpcy5oZWlnaHQsIHdpZHRoOiB0aGlzLndpZHRoIH07XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy54eShvZmZzZXQpO1xuICAgICAgICByZXR1cm4geyBoZWlnaHQ6IHRoaXMuaGVpZ2h0IC0geSwgd2lkdGg6IHRoaXMud2lkdGggLSB4IH07XG4gICAgfVxuICAgIHh5KGMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGMgPSB7IHg6IGMsIHk6IGMgfTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjLngpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IGludmFsaWQgeD0ke2MueH1gKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjLnkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IGludmFsaWQgeT0ke2MueX1gKTtcbiAgICAgICAgLy8gRG8gbW9kdWxvLCBzbyB3ZSBjYW4gdXNlIG5lZ2F0aXZlIHBvc2l0aW9uc1xuICAgICAgICBjLnggPSBtb2QoYy54LCB0aGlzLndpZHRoKTtcbiAgICAgICAgYy55ID0gbW9kKGMueSwgdGhpcy5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHBpeGVsIGJpdCBpbmRleFxuICAgICAqL1xuICAgIHdvcmRJbmRleCh4LCB5KSB7XG4gICAgICAgIHJldHVybiB5ICogdGhpcy53b3JkcyArICh4ID4+PiA1KTtcbiAgICB9XG4gICAgYml0SW5kZXgoeCwgeSkge1xuICAgICAgICByZXR1cm4geyB3b3JkOiB0aGlzLndvcmRJbmRleCh4LCB5KSwgYml0OiB4ICYgMzEgfTtcbiAgICB9XG4gICAgaXNEZWZpbmVkKHgsIHkpIHtcbiAgICAgICAgY29uc3Qgd2kgPSB0aGlzLndvcmRJbmRleCh4LCB5KTtcbiAgICAgICAgY29uc3QgbSA9IGJpdE1hc2soeCk7XG4gICAgICAgIHJldHVybiAodGhpcy5kZWZpbmVkW3dpXSAmIG0pICE9PSAwO1xuICAgIH1cbiAgICBnZXQoeCwgeSkge1xuICAgICAgICBjb25zdCB3aSA9IHRoaXMud29yZEluZGV4KHgsIHkpO1xuICAgICAgICBjb25zdCBtID0gYml0TWFzayh4KTtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlW3dpXSAmIG0pICE9PSAwO1xuICAgIH1cbiAgICBtYXNrV29yZCh3aSwgbWFzaywgdikge1xuICAgICAgICBjb25zdCB7IGRlZmluZWQsIHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICBkZWZpbmVkW3dpXSB8PSBtYXNrO1xuICAgICAgICB2YWx1ZVt3aV0gPSAodmFsdWVbd2ldICYgfm1hc2spIHwgKC12ICYgbWFzayk7XG4gICAgfVxuICAgIHNldCh4LCB5LCB2KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubWFza1dvcmQodGhpcy53b3JkSW5kZXgoeCwgeSksIGJpdE1hc2soeCksIHYpO1xuICAgIH1cbiAgICAvLyB3b3JkLXNwYW4gZmlsbCBmb3IgY29uc3RhbnQgdmFsdWVzIChmYXN0IHBhdGgpXG4gICAgZmlsbFJlY3RDb25zdCh4MCwgeTAsIHcsIGgsIHYpIHtcbiAgICAgICAgaWYgKHcgPD0gMCB8fCBoIDw9IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRlZmluZWQsIHdvcmRzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzdGFydFdvcmQgPSB4MCA+Pj4gNTtcbiAgICAgICAgY29uc3QgZW5kV29yZCA9ICh4MCArIHcgLSAxKSA+Pj4gNTtcbiAgICAgICAgY29uc3Qgc3RhcnRCaXQgPSB4MCAmIDMxO1xuICAgICAgICBjb25zdCBlbmRCaXQgPSAoeDAgKyB3IC0gMSkgJiAzMTtcbiAgICAgICAgZm9yIChsZXQgcnkgPSAwOyByeSA8IGg7IHJ5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0Jhc2UgPSAoeTAgKyByeSkgKiB3b3JkcztcbiAgICAgICAgICAgIGlmIChzdGFydFdvcmQgPT09IGVuZFdvcmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gcmFuZ2VNYXNrKHN0YXJ0Qml0LCBlbmRCaXQgLSBzdGFydEJpdCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFza1dvcmQocm93QmFzZSArIHN0YXJ0V29yZCwgbWFzaywgdik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hc2tXb3JkKHJvd0Jhc2UgKyBzdGFydFdvcmQsIHJhbmdlTWFzayhzdGFydEJpdCwgMzIgLSBzdGFydEJpdCksIHYpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0V29yZCArIDE7IGkgPCBlbmRXb3JkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkW3Jvd0Jhc2UgKyBpXSA9IDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICAgICAgdmFsdWVbcm93QmFzZSArIGldID0gdiA/IDB4ZmZmZmZmZmYgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXNrV29yZChyb3dCYXNlICsgZW5kV29yZCwgcmFuZ2VNYXNrKDAsIGVuZEJpdCArIDEpLCB2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWN0V29yZHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2IpIHtcbiAgICAgICAgZm9yIChsZXQgeVBvcyA9IDA7IHlQb3MgPCBoZWlnaHQ7IHlQb3MrKykge1xuICAgICAgICAgICAgY29uc3QgUHkgPSB5ICsgeVBvcztcbiAgICAgICAgICAgIGZvciAobGV0IHhQb3MgPSAwOyB4UG9zIDwgd2lkdGg7KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0WCA9IHggKyB4UG9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYml0LCB3b3JkIH0gPSB0aGlzLmJpdEluZGV4KGJpdFgsIFB5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzUGVyV29yZCA9IE1hdGgubWluKDMyIC0gYml0LCB3aWR0aCAtIHhQb3MpO1xuICAgICAgICAgICAgICAgIGNiKHdvcmQsIGJpdFgsIHhQb3MsIHlQb3MsIGJpdHNQZXJXb3JkKTtcbiAgICAgICAgICAgICAgICB4UG9zICs9IGJpdHNQZXJXb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJhc2ljYWxseSBldmVyeSBvcGVyYXRpb24gY2FuIGJlIHJlcHJlc2VudGVkIGFzIHJlY3RcbiAgICByZWN0KGMsIHNpemUsIGZuKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy54eShjKTtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBCaXRtYXAuc2l6ZShzaXplLCB0aGlzLnNpemUoeyB4LCB5IH0pKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5maWxsUmVjdENvbnN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGZuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZGVmaW5lZCwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVjdFdvcmRzKHgsIHksIHdpZHRoLCBoZWlnaHQsICh3aSwgYml0WCwgeFBvcywgeVBvcywgbikgPT4ge1xuICAgICAgICAgICAgbGV0IGRlZldvcmQgPSAwO1xuICAgICAgICAgICAgbGV0IHZhbFdvcmQgPSB2YWx1ZVt3aV07XG4gICAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IG47IGIrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBiaXRNYXNrKGJpdFggKyBiKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBmbih7IHg6IHhQb3MgKyBiLCB5OiB5UG9zIH0sICh2YWxXb3JkICYgbWFzaykgIT09IDApO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmV29yZCB8PSBtYXNrO1xuICAgICAgICAgICAgICAgIHZhbFdvcmQgPSAodmFsV29yZCAmIH5tYXNrKSB8ICgtcmVzICYgbWFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZpbmVkW3dpXSB8PSBkZWZXb3JkO1xuICAgICAgICAgICAgdmFsdWVbd2ldID0gdmFsV29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHJlY3Rhbmd1bGFyIHBhcnQgb2YgYml0bWFwXG4gICAgcmVjdFJlYWQoYywgc2l6ZSwgZm4pIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnh5KGMpO1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IEJpdG1hcC5zaXplKHNpemUsIHRoaXMuc2l6ZSh7IHgsIHkgfSkpO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnJlY3RXb3Jkcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCAod2ksIGJpdFgsIHhQb3MsIHlQb3MsIG4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbFdvcmQgPSB2YWx1ZVt3aV07XG4gICAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IG47IGIrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBiaXRNYXNrKGJpdFggKyBiKTtcbiAgICAgICAgICAgICAgICBmbih7IHg6IHhQb3MgKyBiLCB5OiB5UG9zIH0sICh2YWxXb3JkICYgbWFzaykgIT09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEhvcml6b250YWwgJiB2ZXJ0aWNhbCBsaW5lc1xuICAgIGhMaW5lKGMsIGxlbiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdChjLCB7IHdpZHRoOiBsZW4sIGhlaWdodDogMSB9LCB2YWx1ZSk7XG4gICAgfVxuICAgIHZMaW5lKGMsIGxlbiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdChjLCB7IHdpZHRoOiAxLCBoZWlnaHQ6IGxlbiB9LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIGFkZCBib3JkZXJcbiAgICBib3JkZXIoYm9yZGVyID0gMiwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAyICogYm9yZGVyO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKyAyICogYm9yZGVyO1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgQml0bWFwKHsgaGVpZ2h0LCB3aWR0aCB9KTtcbiAgICAgICAgLy8gZmlsbCBldmVyeXRoaW5nIHdpdGggYm9yZGVyIHZhbHVlLCB0aGVuIGVtYmVkIG9yaWdpbmFsXG4gICAgICAgIG91dC5yZWN0KDAsIEluZmluaXR5LCB2YWx1ZSk7XG4gICAgICAgIG91dC5lbWJlZCh7IHg6IGJvcmRlciwgeTogYm9yZGVyIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvLyBFbWJlZCBhbm90aGVyIGJpdG1hcCBvbiBjb29yZGluYXRlc1xuICAgIGVtYmVkKGMsIHNyYykge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMueHkoYyk7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gQml0bWFwLnNpemUoc3JjLnNpemUoKSwgdGhpcy5zaXplKHsgeCwgeSB9KSk7XG4gICAgICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRlZmluZWQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgd29yZHM6IHNyY1N0cmlkZSwgdmFsdWU6IHNyY1ZhbHVlIH0gPSBzcmM7XG4gICAgICAgIGZvciAobGV0IHlQb3MgPSAwOyB5UG9zIDwgaGVpZ2h0OyB5UG9zKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNyY1JvdyA9IHlQb3MgKiBzcmNTdHJpZGU7XG4gICAgICAgICAgICBmb3IgKGxldCB4UG9zID0gMDsgeFBvcyA8IHdpZHRoOykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRzdFggPSB4ICsgeFBvcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdvcmQ6IGRzdFdvcmQsIGJpdDogZHN0Qml0IH0gPSB0aGlzLmJpdEluZGV4KGRzdFgsIHkgKyB5UG9zKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdvcmQ6IHNyY1dvcmQsIGJpdDogc3JjQml0IH0gPSBzcmMuYml0SW5kZXgoeFBvcywgeVBvcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4oMzIgLSBkc3RCaXQsIHdpZHRoIC0geFBvcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdzAgPSBzcmNWYWx1ZVtzcmNXb3JkXTtcbiAgICAgICAgICAgICAgICBjb25zdCB3MSA9IHNyY0JpdCAmJiBzcmNXb3JkICsgMSA8IHNyY1JvdyArIHNyY1N0cmlkZSA/IHNyY1ZhbHVlW3NyY1dvcmQgKyAxXSA6IDA7XG4gICAgICAgICAgICAgICAgY29uc3Qgc1ZhbCA9IHNyY0JpdCA/ICgodzAgPj4+IHNyY0JpdCkgfCAodzEgPDwgKDMyIC0gc3JjQml0KSkpID4+PiAwIDogdzA7XG4gICAgICAgICAgICAgICAgY29uc3QgZHN0TWFzayA9IHJhbmdlTWFzayhkc3RCaXQsIGxlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsQml0cyA9ICgoc1ZhbCAmIHJhbmdlTWFzaygwLCBsZW4pKSA8PCBkc3RCaXQpID4+PiAwO1xuICAgICAgICAgICAgICAgIGRlZmluZWRbZHN0V29yZF0gfD0gZHN0TWFzaztcbiAgICAgICAgICAgICAgICB2YWx1ZVtkc3RXb3JkXSA9ICh2YWx1ZVtkc3RXb3JkXSAmIH5kc3RNYXNrKSB8IHZhbEJpdHM7XG4gICAgICAgICAgICAgICAgeFBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgcmVjdGFuZ3VsYXIgcGFydCBvZiBiaXRtYXBcbiAgICByZWN0U2xpY2UoYywgc2l6ZSA9IHRoaXMuc2l6ZSgpKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy54eShjKTtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBCaXRtYXAuc2l6ZShzaXplLCB0aGlzLnNpemUoeyB4LCB5IH0pKTtcbiAgICAgICAgY29uc3QgcmVjdCA9IG5ldyBCaXRtYXAoeyBoZWlnaHQsIHdpZHRoIH0pO1xuICAgICAgICB0aGlzLnJlY3RSZWFkKHsgeCwgeSB9LCB7IGhlaWdodCwgd2lkdGggfSwgKHAsIGN1cikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZWZpbmVkKHggKyBwLngsIHkgKyBwLnkpKSB7XG4gICAgICAgICAgICAgICAgcmVjdC5zZXQocC54LCBwLnksIGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgLy8gQ2hhbmdlIHNoYXBlLCByZXBsYWNlIHJvd3Mgd2l0aCBjb2x1bW5zIChkYXRhW3ldW3hdIC0+IGRhdGFbeF1beV0pXG4gICAgdHJhbnNwb3NlKCkge1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGgsIHZhbHVlLCBkZWZpbmVkLCB3b3JkcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZHN0ID0gbmV3IEJpdG1hcCh7IGhlaWdodDogd2lkdGgsIHdpZHRoOiBoZWlnaHQgfSk7XG4gICAgICAgIGNvbnN0IHsgd29yZHM6IGRzdFN0cmlkZSwgdmFsdWU6IGRzdFZhbHVlLCBkZWZpbmVkOiBkc3REZWZpbmVkLCB0YWlsTWFzazogZHN0VGFpbCB9ID0gZHN0O1xuICAgICAgICBjb25zdCB0bXBWID0gbmV3IFVpbnQzMkFycmF5KDMyKTtcbiAgICAgICAgY29uc3QgdG1wRCA9IG5ldyBVaW50MzJBcnJheSgzMik7XG4gICAgICAgIC8vIFByb2Nlc3Mgc3JjIGluIGJsb2NrczogeSBpbiBbYnkuLmJ5KzMxXSwgeCBpbiAzMi1iaXQgd29yZHNcbiAgICAgICAgZm9yIChsZXQgYnkgPSAwOyBieSA8IGhlaWdodDsgYnkgKz0gMzIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGJ4ID0gMDsgYnggPCB3b3JkczsgYngrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLm1pbigzMiwgaGVpZ2h0IC0gYnkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93czsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpID0gdGhpcy53b3JkSW5kZXgoMzIgKiBieCwgYnkgKyByKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wVltyXSA9IHZhbHVlW3dpXTtcbiAgICAgICAgICAgICAgICAgICAgdG1wRFtyXSA9IGRlZmluZWRbd2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB6ZXJvLXBhZCByZW1haW5kZXJcbiAgICAgICAgICAgICAgICB0bXBWLmZpbGwoMCwgcm93cyk7XG4gICAgICAgICAgICAgICAgdG1wRC5maWxsKDAsIHJvd3MpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9zZTMyKHRtcFYpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9zZTMyKHRtcEQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkc3RZID0gYnggKiAzMiArIGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkc3RZID49IHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRzdFBvcyA9IGRzdC53b3JkSW5kZXgoYnksIGRzdFkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJNYXNrID0gYnkgPj4+IDUgPT09IGRzdFN0cmlkZSAtIDEgPyBkc3RUYWlsIDogMHhmZmZmZmZmZjtcbiAgICAgICAgICAgICAgICAgICAgZHN0VmFsdWVbZHN0UG9zXSA9IHRtcFZbaV0gJiBjdXJNYXNrO1xuICAgICAgICAgICAgICAgICAgICBkc3REZWZpbmVkW2RzdFBvc10gPSB0bXBEW2ldICYgY3VyTWFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG4gICAgLy8gYmxhY2sgPC0+IHdoaXRlIChpbnBsYWNlKVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZGVmaW5lZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldID0gfnRoaXMudmFsdWVbaV07XG4gICAgICAgICAgICB0aGlzLmRlZmluZWRbaV0gPSAweGZmZmZmZmZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBFYWNoIHBpeGVsIHNpemUgaXMgbXVsdGlwbGllZCBieSBmYWN0b3JcbiAgICBzY2FsZShmYWN0b3IpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihmYWN0b3IpIHx8IGZhY3RvciA+IDEwMjQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2NhbGUgZmFjdG9yOiAke2ZhY3Rvcn1gKTtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQml0bWFwKHsgaGVpZ2h0OiBmYWN0b3IgKiBoZWlnaHQsIHdpZHRoOiBmYWN0b3IgKiB3aWR0aCB9KTtcbiAgICAgICAgcmV0dXJuIHJlcy5yZWN0KHsgeDogMCwgeTogMCB9LCBJbmZpbml0eSwgKHsgeCwgeSB9KSA9PiB0aGlzLmdldCgoeCAvIGZhY3RvcikgfCAwLCAoeSAvIGZhY3RvcikgfCAwKSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQml0bWFwKHRoaXMuc2l6ZSgpKTtcbiAgICAgICAgcmVzLmRlZmluZWQuc2V0KHRoaXMuZGVmaW5lZCk7XG4gICAgICAgIHJlcy52YWx1ZS5zZXQodGhpcy52YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIG5vIHVuZGVmaW5lZCB2YWx1ZXMgbGVmdFxuICAgIGFzc2VydERyYXduKCkge1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGgsIGRlZmluZWQsIHRhaWxNYXNrLCBmdWxsV29yZHMsIHdvcmRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWhlaWdodCB8fCAhd2lkdGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0Jhc2UgPSB5ICogd29yZHM7XG4gICAgICAgICAgICBmb3IgKGxldCB3aSA9IDA7IHdpIDwgZnVsbFdvcmRzOyB3aSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmluZWRbcm93QmFzZSArIHdpXSAhPT0gMHhmZmZmZmZmZilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbG9yIHR5cGU9dW5kZWZpbmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod29yZHMgIT09IGZ1bGxXb3JkcyAmJiAoZGVmaW5lZFtyb3dCYXNlICsgZnVsbFdvcmRzXSAmIHRhaWxNYXNrKSAhPT0gdGFpbE1hc2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbG9yIHR5cGU9dW5kZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY291bnRQYXR0ZXJuSW5Sb3coeSwgcGF0dGVybkxlbiwgLi4ucGF0dGVybnMpIHtcbiAgICAgICAgaWYgKHBhdHRlcm5MZW4gPD0gMCB8fCBwYXR0ZXJuTGVuID49IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwYXR0ZXJuTGVuJyk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoMSA8PCBwYXR0ZXJuTGVuKSAtIDE7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIHZhbHVlLCB3b3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3Qgcm93QmFzZSA9IHRoaXMud29yZEluZGV4KDAsIHkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgd2luZG93ID0gMDsgaSA8IHdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSB2YWx1ZVtyb3dCYXNlICsgaV07XG4gICAgICAgICAgICBjb25zdCBiaXRFbmQgPSBpID09PSB3b3JkcyAtIDEgPyB3aWR0aCAmIDMxIHx8IDMyIDogMzI7XG4gICAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJpdEVuZDsgYisrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93ID0gKCh3aW5kb3cgPDwgMSkgfCAoKHcgPj4+IGIpICYgMSkpICYgbWFzaztcbiAgICAgICAgICAgICAgICBpZiAoaSAqIDMyICsgYiArIDEgPCBwYXR0ZXJuTGVuKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdyAhPT0gcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBnZXRSdW5zKHksIGZuKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIHZhbHVlLCB3b3JkcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHdpZHRoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcnVuTGVuID0gMDtcbiAgICAgICAgbGV0IHJ1blZhbHVlO1xuICAgICAgICBjb25zdCByb3dCYXNlID0gdGhpcy53b3JkSW5kZXgoMCwgeSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHZhbHVlW3Jvd0Jhc2UgKyBpXTtcbiAgICAgICAgICAgIGNvbnN0IGJpdEVuZCA9IGkgPT09IHdvcmRzIC0gMSA/IHdpZHRoICYgMzEgfHwgMzIgOiAzMjtcbiAgICAgICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYml0RW5kOyBiKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXQgPSAod29yZCAmICgxIDw8IGIpKSAhPT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoYml0ID09PSBydW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBydW5MZW4rKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5WYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBmbihydW5MZW4sIHJ1blZhbHVlKTtcbiAgICAgICAgICAgICAgICBydW5WYWx1ZSA9IGJpdDtcbiAgICAgICAgICAgICAgICBydW5MZW4gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChydW5WYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZm4ocnVuTGVuLCBydW5WYWx1ZSk7XG4gICAgfVxuICAgIHBvcGNudCgpIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCB3b3JkcywgZnVsbFdvcmRzLCB0YWlsTWFzayB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFoZWlnaHQgfHwgIXdpZHRoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0Jhc2UgPSB5ICogd29yZHM7XG4gICAgICAgICAgICBmb3IgKGxldCB3aSA9IDA7IHdpIDwgZnVsbFdvcmRzOyB3aSsrKVxuICAgICAgICAgICAgICAgIGNvdW50ICs9IHBvcGNudCh0aGlzLnZhbHVlW3Jvd0Jhc2UgKyB3aV0pO1xuICAgICAgICAgICAgaWYgKHdvcmRzICE9PSBmdWxsV29yZHMpXG4gICAgICAgICAgICAgICAgY291bnQgKz0gcG9wY250KHRoaXMudmFsdWVbcm93QmFzZSArIGZ1bGxXb3Jkc10gJiB0YWlsTWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBjb3VudEJveGVzMngyKHkpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgd29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICh3aWR0aCA8IDIgfHwgKHkgfCAwKSA8IDAgfHwgeSArIDEgPj0gdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgYmFzZTAgPSB0aGlzLndvcmRJbmRleCgwLCB5KSB8IDA7XG4gICAgICAgIGNvbnN0IGJhc2UxID0gdGhpcy53b3JkSW5kZXgoMCwgeSArIDEpIHwgMDtcbiAgICAgICAgLy8gdmFsaWQgXCJsZWZ0LWVkZ2VcIiBwb3NpdGlvbnMgeCBpbiBbMCAuLiBXLTJdXG4gICAgICAgIGNvbnN0IHRhaWxCaXRzID0gd2lkdGggJiAzMTtcbiAgICAgICAgY29uc3QgdmFsaWRMYXN0ID0gdGFpbEJpdHMgPT09IDAgPyAweDdmZmZmZmZmIDogcmFuZ2VNYXNrKDAsICh3aWR0aCAtIDEpICYgMzEpO1xuICAgICAgICBsZXQgYm94ZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCB3aSA9IDA7IHdpIDwgd29yZHM7IHdpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGEwID0gdGhpcy52YWx1ZVtiYXNlMCArIHdpXTtcbiAgICAgICAgICAgIGNvbnN0IGExID0gdGhpcy52YWx1ZVtiYXNlMSArIHdpXTtcbiAgICAgICAgICAgIC8vIENvbXBhcmUgYml0IHggd2l0aCBiaXQgeCsxIGF0IHNhbWUgYml0IHBvc2l0aW9uLlxuICAgICAgICAgICAgY29uc3QgZXFWID0gfihhMCBeIGExKSA+Pj4gMDsgLy8gcm93MFt4XSA9PSByb3cxW3hdXG4gICAgICAgICAgICBjb25zdCBuMCA9IHdpICsgMSA8IHdvcmRzID8gdGhpcy52YWx1ZVtiYXNlMCArIHdpICsgMV0gPj4+IDAgOiAwO1xuICAgICAgICAgICAgY29uc3QgZXFIMCA9IH4oYTAgXiAoKChhMCA+Pj4gMSkgfCAoKG4wICYgMSkgPDwgMzEpKSA+Pj4gMCkpID4+PiAwOyAvLyByb3cwW3hdID09IHJvdzBbeCsxXVxuICAgICAgICAgICAgY29uc3QgbjEgPSB3aSArIDEgPCB3b3JkcyA/IHRoaXMudmFsdWVbYmFzZTEgKyB3aSArIDFdID4+PiAwIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGVxSDEgPSB+KGExIF4gKCgoYTEgPj4+IDEpIHwgKChuMSAmIDEpIDw8IDMxKSkgPj4+IDApKSA+Pj4gMDsgLy8gcm93MVt4XSA9PSByb3cxW3grMV1cbiAgICAgICAgICAgIGxldCBtID0gKGVxViAmIGVxSDAgJiBlcUgxKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh3aSA9PT0gd29yZHMgLSAxKVxuICAgICAgICAgICAgICAgIG0gJj0gdmFsaWRMYXN0O1xuICAgICAgICAgICAgYm94ZXMgKz0gcG9wY250KG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3hlcztcbiAgICB9XG4gICAgLy8gRXhwb3J0XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG5sID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaENvZGVzLm5ld2xpbmUpO1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuZ2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gIXRoaXMuaXNEZWZpbmVkKHgsIHkpID8gJz8nIDogdiA/ICdYJyA6ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBsaW5lICsgKHkgKyAxID09PSB0aGlzLmhlaWdodCA/ICcnIDogbmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHRvUmF3KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0aGlzLmhlaWdodCB9LCAoKSA9PiBuZXcgQXJyYXkodGhpcy53aWR0aCkpO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IG91dFt5XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKVxuICAgICAgICAgICAgICAgIHJvd1t4XSA9IHRoaXMuZ2V0KHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHRvQVNDSUkoKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gdGhpcztcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICAvLyBUZXJtaW5hbCBjaGFyYWN0ZXIgaGVpZ2h0IGlzIHgyIG9mIGNoYXJhY3RlciB3aWR0aCwgc28gd2UgcHJvY2VzcyB0d28gcm93cyBvZiBiaXRtYXBcbiAgICAgICAgLy8gdG8gcHJvZHVjZSBvbmUgcm93IG9mIEFTQ0lJXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5nZXQoeCwgeSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kID0geSArIDEgPj0gaGVpZ2h0ID8gdHJ1ZSA6IHRoaXMuZ2V0KHgsIHkgKyAxKTsgLy8gaWYgbGFzdCByb3cgb3V0c2lkZSBiaXRtYXAsIG1ha2UgaXQgYmxhY2tcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0ICYmICFzZWNvbmQpXG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAn4paIJzsgLy8gYm90aCByb3dzIHdoaXRlIChlbXB0eSlcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZmlyc3QgJiYgc2Vjb25kKVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ+KWgCc7IC8vIHRvcCByb3cgd2hpdGVcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdCAmJiAhc2Vjb25kKVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ+KWhCc7IC8vIGRvd24gcm93IHdoaXRlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgJiYgc2Vjb25kKVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJyAnOyAvLyBib3RoIHJvd3MgYmxhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoQ29kZXMubmV3bGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdG9UZXJtKCkge1xuICAgICAgICBjb25zdCBjYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hDb2Rlcy5yZXNldCk7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gY2MgKyAnWzBtJztcbiAgICAgICAgY29uc3Qgd2hpdGVCRyA9IGNjICsgJ1sxOzQ3bSAgJyArIHJlc2V0O1xuICAgICAgICBjb25zdCBkYXJrQkcgPSBjYyArIGBbNDBtICBgICsgcmVzZXQ7XG4gICAgICAgIGNvbnN0IG5sID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaENvZGVzLm5ld2xpbmUpO1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5nZXQoeCwgeSk7IC8vIHVuZGVmaW5lZCAtPiB3aGl0ZVxuICAgICAgICAgICAgICAgIG91dCArPSB2ID8gZGFya0JHIDogd2hpdGVCRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBubDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB0b1NWRyhvcHRpbWl6ZSA9IHRydWUpIHtcbiAgICAgICAgbGV0IG91dCA9IGA8c3ZnIHZpZXdCb3g9XCIwIDAgJHt0aGlzLndpZHRofSAke3RoaXMuaGVpZ2h0fVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5gO1xuICAgICAgICAvLyBDb25zdHJ1Y3Qgb3B0aW1pemVkIFNWRyBwYXRoIGRhdGEuXG4gICAgICAgIGxldCBwYXRoRGF0YSA9ICcnO1xuICAgICAgICBsZXQgcHJldlBvaW50O1xuICAgICAgICB0aGlzLnJlY3RSZWFkKDAsIEluZmluaXR5LCAocG9pbnQsIHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF2YWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICAgICAgICAgIGlmICghb3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gYDxyZWN0IHg9XCIke3h9XCIgeT1cIiR7eX1cIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgLz5gO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9SZWZlcmVuY2UvQXR0cmlidXRlL2QjcGF0aF9jb21tYW5kc1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzaG9ydGVzdCB3YXkgdG8gcmVwcmVzZW50IHRoZSBpbml0aWFsIGN1cnNvciBtb3ZlbWVudC5cbiAgICAgICAgICAgIC8vIE0gLSBNb3ZlIGN1cnNvciAod2l0aG91dCBkcmF3aW5nKSB0byBhYnNvbHV0ZSBjb29yZGluYXRlIHBhaXIuXG4gICAgICAgICAgICBsZXQgbSA9IGBNJHt4fSAke3l9YDtcbiAgICAgICAgICAgIC8vIE9ubHkgYWxsb3cgdXNpbmcgdGhlIHJlbGF0aXZlIGN1cnNvciBtb3ZlIGNvbW1hbmQgaWYgcHJldmlvdXMgcG9pbnRzXG4gICAgICAgICAgICAvLyB3ZXJlIGRyYXduLlxuICAgICAgICAgICAgaWYgKHByZXZQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIG0gLSBNb3ZlIGN1cnNvciAod2l0aG91dCBkcmF3aW5nKSB0byByZWxhdGl2ZSBjb29yZGluYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsTSA9IGBtJHt4IC0gcHJldlBvaW50Lnh9ICR7eSAtIHByZXZQb2ludC55fWA7XG4gICAgICAgICAgICAgICAgaWYgKHJlbE0ubGVuZ3RoIDw9IG0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtID0gcmVsTTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgc2hvcnRlc3Qgd2F5IHRvIHJlcHJlc2VudCB0aGUgY2VsbCdzIGJvdHRvbSBsaW5lIGRyYXcuXG4gICAgICAgICAgICAvLyBIIC0gRHJhdyBsaW5lIGZyb20gY3Vyc29yIHBvc2l0aW9uIHRvIGFic29sdXRlIHggY29vcmRpbmF0ZS5cbiAgICAgICAgICAgIC8vIGggLSBEcmF3IGxpbmUgZnJvbSBjdXJzb3IgcG9zaXRpb24gdG8gcmVsYXRpdmUgeCBjb29yZGluYXRlLlxuICAgICAgICAgICAgY29uc3QgYkggPSB4IDwgMTAgPyBgSCR7eH1gIDogJ2gtMSc7XG4gICAgICAgICAgICAvLyB2IC0gRHJhdyBsaW5lIGZyb20gY3Vyc29yIHBvc2l0aW9uIHRvIHJlbGF0aXZlIHkgY29vcmRpbmF0ZS5cbiAgICAgICAgICAgIC8vIFogLSBDbG9zZSBwYXRoIChkcmF3cyBsaW5lIGZyb20gY3Vyc29yIHBvc2l0aW9uIHRvIE0gY29vcmRpbmF0ZSkuXG4gICAgICAgICAgICBwYXRoRGF0YSArPSBgJHttfWgxdjEke2JIfVpgO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW1pemUpXG4gICAgICAgICAgICBvdXQgKz0gYDxwYXRoIGQ9XCIke3BhdGhEYXRhfVwiLz5gO1xuICAgICAgICBvdXQgKz0gYDwvc3ZnPmA7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHRvR0lGKCkge1xuICAgICAgICAvLyBOT1RFOiBTbWFsbCwgYnV0IGluZWZmaWNpZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAvLyBVc2VzIDEgYnl0ZSBwZXIgcGl4ZWwuXG4gICAgICAgIGNvbnN0IHUxNmxlID0gKGkpID0+IFtpICYgMHhmZiwgKGkgPj4+IDgpICYgMHhmZl07XG4gICAgICAgIGNvbnN0IGRpbXMgPSBbLi4udTE2bGUodGhpcy53aWR0aCksIC4uLnUxNmxlKHRoaXMuaGVpZ2h0KV07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5yZWN0UmVhZCgwLCBJbmZpbml0eSwgKF8sIGN1cikgPT4gZGF0YS5wdXNoKCsoY3VyID09PSB0cnVlKSkpO1xuICAgICAgICBjb25zdCBOID0gMTI2OyAvLyBCbG9jayBzaXplXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBieXRlcyA9IFtcbiAgICAgICAgICAgIDB4NDcsIDB4NDksIDB4NDYsIDB4MzgsIDB4MzcsIDB4NjEsIC4uLmRpbXMsIDB4ZjYsIDB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gICAgICAgICAgICAuLi5maWxsQXJyKDMgKiAxMjcsIDB4MDApLCAweDJjLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAuLi5kaW1zLCAweDAwLCAweDA3XG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGZ1bGxDaHVua3MgPSBNYXRoLmZsb29yKGRhdGEubGVuZ3RoIC8gTik7XG4gICAgICAgIC8vIEZ1bGwgYmxvY2tzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKVxuICAgICAgICAgICAgYnl0ZXMucHVzaChOICsgMSwgMHg4MCwgLi4uZGF0YS5zbGljZShOICogaSwgTiAqIChpICsgMSkpLm1hcCgoaSkgPT4gK2kpKTtcbiAgICAgICAgLy8gUmVtYWluaW5nIGJ5dGVzXG4gICAgICAgIGJ5dGVzLnB1c2goKGRhdGEubGVuZ3RoICUgTikgKyAxLCAweDgwLCAuLi5kYXRhLnNsaWNlKGZ1bGxDaHVua3MgKiBOKS5tYXAoKGkpID0+ICtpKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHgwMSwgMHg4MSwgMHgwMCwgMHgzYik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgfVxuICAgIHRvSW1hZ2UoaXNSR0IgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IHRoaXMuc2l6ZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaGVpZ2h0ICogd2lkdGggKiAoaXNSR0IgPyAzIDogNCkpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoeCwgeSkgPyAwIDogMjU1OyAvLyB1bmRlZmluZWQgLT4gd2hpdGVcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUkdCKVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gPSAyNTU7IC8vIGFscGhhIGNoYW5uZWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoZWlnaHQsIHdpZHRoLCBkYXRhIH07XG4gICAgfVxufVxuLy8gRW5kIG9mIHV0aWxzXG4vLyBSdW50aW1lIHR5cGUtY2hlY2tpbmdcbi8qKiBFcnJvciBjb3JyZWN0aW9uIG1vZGUuIGxvdzogNyUsIG1lZGl1bTogMTUlLCBxdWFydGlsZTogMjUlLCBoaWdoOiAzMCUgKi9cbmV4cG9ydCBjb25zdCBFQ01vZGUgPSBbJ2xvdycsICdtZWRpdW0nLCAncXVhcnRpbGUnLCAnaGlnaCddO1xuLyoqIFFSIENvZGUgZW5jb2RpbmcgKi9cbmV4cG9ydCBjb25zdCBFbmNvZGluZyA9IFsnbnVtZXJpYycsICdhbHBoYW51bWVyaWMnLCAnYnl0ZScsICdrYW5qaScsICdlY2knXTtcbi8vIFZhcmlvdXMgY29uc3RhbnRzICYgdGFibGVzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEJZVEVTID0gW1xuICAgIC8vIDEsICAyLCAgMywgICA0LCAgIDUsICAgNiwgICA3LCAgIDgsICAgOSwgIDEwLCAgMTEsICAxMiwgIDEzLCAgMTQsICAxNSwgIDE2LCAgMTcsICAxOCwgIDE5LCAgIDIwLFxuICAgIDI2LCA0NCwgNzAsIDEwMCwgMTM0LCAxNzIsIDE5NiwgMjQyLCAyOTIsIDM0NiwgNDA0LCA0NjYsIDUzMiwgNTgxLCA2NTUsIDczMywgODE1LCA5MDEsIDk5MSwgMTA4NSxcbiAgICAvLyAgMjEsICAgMjIsICAgMjMsICAgMjQsICAgMjUsICAgMjYsICAgMjcsICAgMjgsICAgMjksICAgMzAsICAgMzEsICAgMzIsICAgMzMsICAgMzQsICAgMzUsICAgMzYsICAgMzcsICAgMzgsICAgMzksICAgNDBcbiAgICAxMTU2LCAxMjU4LCAxMzY0LCAxNDc0LCAxNTg4LCAxNzA2LCAxODI4LCAxOTIxLCAyMDUxLCAyMTg1LCAyMzIzLCAyNDY1LCAyNjExLCAyNzYxLCAyODc2LCAzMDM0LCAzMTk2LCAzMzYyLCAzNTMyLCAzNzA2LFxuXTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgV09SRFNfUEVSX0JMT0NLID0ge1xuICAgIC8vIFZlcnNpb24gMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MFxuICAgIGxvdzogWzcsIDEwLCAxNSwgMjAsIDI2LCAxOCwgMjAsIDI0LCAzMCwgMTgsIDIwLCAyNCwgMjYsIDMwLCAyMiwgMjQsIDI4LCAzMCwgMjgsIDI4LCAyOCwgMjgsIDMwLCAzMCwgMjYsIDI4LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzBdLFxuICAgIG1lZGl1bTogWzEwLCAxNiwgMjYsIDE4LCAyNCwgMTYsIDE4LCAyMiwgMjIsIDI2LCAzMCwgMjIsIDIyLCAyNCwgMjQsIDI4LCAyOCwgMjYsIDI2LCAyNiwgMjYsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4XSxcbiAgICBxdWFydGlsZTogWzEzLCAyMiwgMTgsIDI2LCAxOCwgMjQsIDE4LCAyMiwgMjAsIDI0LCAyOCwgMjYsIDI0LCAyMCwgMzAsIDI0LCAyOCwgMjgsIDI2LCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBoaWdoOiBbMTcsIDI4LCAyMiwgMTYsIDIyLCAyOCwgMjYsIDI2LCAyNCwgMjgsIDI0LCAyOCwgMjIsIDI0LCAyNCwgMzAsIDI4LCAyOCwgMjYsIDI4LCAzMCwgMjQsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzBdLFxufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRUNDX0JMT0NLUyA9IHtcbiAgICAvLyBWZXJzaW9uICAgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MFxuICAgIGxvdzogWzEsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDQsIDQsIDQsIDQsIDQsIDYsIDYsIDYsIDYsIDcsIDgsIDgsIDksIDksIDEwLCAxMiwgMTIsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMTksIDIwLCAyMSwgMjIsIDI0LCAyNV0sXG4gICAgbWVkaXVtOiBbMSwgMSwgMSwgMiwgMiwgNCwgNCwgNCwgNSwgNSwgNSwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTMsIDE0LCAxNiwgMTcsIDE3LCAxOCwgMjAsIDIxLCAyMywgMjUsIDI2LCAyOCwgMjksIDMxLCAzMywgMzUsIDM3LCAzOCwgNDAsIDQzLCA0NSwgNDcsIDQ5XSxcbiAgICBxdWFydGlsZTogWzEsIDEsIDIsIDIsIDQsIDQsIDYsIDYsIDgsIDgsIDgsIDEwLCAxMiwgMTYsIDEyLCAxNywgMTYsIDE4LCAyMSwgMjAsIDIzLCAyMywgMjUsIDI3LCAyOSwgMzQsIDM0LCAzNSwgMzgsIDQwLCA0MywgNDUsIDQ4LCA1MSwgNTMsIDU2LCA1OSwgNjIsIDY1LCA2OF0sXG4gICAgaGlnaDogWzEsIDEsIDIsIDQsIDQsIDQsIDUsIDYsIDgsIDgsIDExLCAxMSwgMTYsIDE2LCAxOCwgMTYsIDE5LCAyMSwgMjUsIDI1LCAyNSwgMzQsIDMwLCAzMiwgMzUsIDM3LCA0MCwgNDIsIDQ1LCA0OCwgNTEsIDU0LCA1NywgNjAsIDYzLCA2NiwgNzAsIDc0LCA3NywgODFdLFxufTtcbmNvbnN0IGluZm8gPSB7XG4gICAgc2l6ZToge1xuICAgICAgICBlbmNvZGU6ICh2ZXIpID0+IDIxICsgNCAqICh2ZXIgLSAxKSwgLy8gdmVyMSA9IDIxLCB2ZXI0MD0xNzcgYmxvY2tzXG4gICAgICAgIGRlY29kZTogKHNpemUpID0+IChzaXplIC0gMTcpIC8gNCxcbiAgICB9LFxuICAgIHNpemVUeXBlOiAodmVyKSA9PiBNYXRoLmZsb29yKCh2ZXIgKyA3KSAvIDE3KSxcbiAgICAvLyBCYXNlZCBvbiBodHRwczovL2NvZGVyZXZpZXcuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc0OTI1L2FsZ29yaXRobS10by1nZW5lcmF0ZS10aGlzLWFsaWdubWVudC1wYXR0ZXJuLWxvY2F0aW9ucy10YWJsZS1mb3ItcXItY29kZXNcbiAgICBhbGlnbm1lbnRQYXR0ZXJucyh2ZXIpIHtcbiAgICAgICAgaWYgKHZlciA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgZmlyc3QgPSA2O1xuICAgICAgICBjb25zdCBsYXN0ID0gaW5mby5zaXplLmVuY29kZSh2ZXIpIC0gZmlyc3QgLSAxO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGxhc3QgLSBmaXJzdDtcbiAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLmNlaWwoZGlzdGFuY2UgLyAyOCk7XG4gICAgICAgIGxldCBpbnRlcnZhbCA9IE1hdGguZmxvb3IoZGlzdGFuY2UgLyBjb3VudCk7XG4gICAgICAgIGlmIChpbnRlcnZhbCAlIDIpXG4gICAgICAgICAgICBpbnRlcnZhbCArPSAxO1xuICAgICAgICBlbHNlIGlmICgoZGlzdGFuY2UgJSBjb3VudCkgKiAyID49IGNvdW50KVxuICAgICAgICAgICAgaW50ZXJ2YWwgKz0gMjtcbiAgICAgICAgY29uc3QgcmVzID0gW2ZpcnN0XTtcbiAgICAgICAgZm9yIChsZXQgbSA9IDE7IG0gPCBjb3VudDsgbSsrKVxuICAgICAgICAgICAgcmVzLnB1c2gobGFzdCAtIChjb3VudCAtIG0pICogaW50ZXJ2YWwpO1xuICAgICAgICByZXMucHVzaChsYXN0KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIEVDQ29kZToge1xuICAgICAgICBsb3c6IDBiMDEsXG4gICAgICAgIG1lZGl1bTogMGIwMCxcbiAgICAgICAgcXVhcnRpbGU6IDBiMTEsXG4gICAgICAgIGhpZ2g6IDBiMTAsXG4gICAgfSxcbiAgICBmb3JtYXRNYXNrOiAwYjEwMTAxMDAwMDAxMDAxMCxcbiAgICBmb3JtYXRCaXRzKGVjYywgbWFza0lkeCkge1xuICAgICAgICBjb25zdCBkYXRhID0gKGluZm8uRUNDb2RlW2VjY10gPDwgMykgfCBtYXNrSWR4O1xuICAgICAgICBsZXQgZCA9IGRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcbiAgICAgICAgICAgIGQgPSAoZCA8PCAxKSBeICgoZCA+PiA5KSAqIDBiMTAxMDAxMTAxMTEpO1xuICAgICAgICByZXR1cm4gKChkYXRhIDw8IDEwKSB8IGQpIF4gaW5mby5mb3JtYXRNYXNrO1xuICAgIH0sXG4gICAgdmVyc2lvbkJpdHModmVyKSB7XG4gICAgICAgIGxldCBkID0gdmVyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspXG4gICAgICAgICAgICBkID0gKGQgPDwgMSkgXiAoKGQgPj4gMTEpICogMGIxMTExMTAwMTAwMTAxKTtcbiAgICAgICAgcmV0dXJuICh2ZXIgPDwgMTIpIHwgZDtcbiAgICB9LFxuICAgIGFscGhhYmV0OiB7XG4gICAgICAgIG51bWVyaWM6IGFscGhhYmV0KCcwMTIzNDU2Nzg5JyksXG4gICAgICAgIGFscGhhbnVtZXJjOiBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaICQlKistLi86JyksXG4gICAgfSwgLy8gYXMgUmVjb3JkPEVuY29kaW5nVHlwZSwgUmV0dXJuVHlwZTx0eXBlb2YgYWxwaGFiZXQ+PixcbiAgICBsZW5ndGhCaXRzKHZlciwgdHlwZSkge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHtcbiAgICAgICAgICAgIG51bWVyaWM6IFsxMCwgMTIsIDE0XSxcbiAgICAgICAgICAgIGFscGhhbnVtZXJpYzogWzksIDExLCAxM10sXG4gICAgICAgICAgICBieXRlOiBbOCwgMTYsIDE2XSxcbiAgICAgICAgICAgIGthbmppOiBbOCwgMTAsIDEyXSxcbiAgICAgICAgICAgIGVjaTogWzAsIDAsIDBdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGFibGVbdHlwZV1baW5mby5zaXplVHlwZSh2ZXIpXTtcbiAgICB9LFxuICAgIG1vZGVCaXRzOiB7XG4gICAgICAgIG51bWVyaWM6ICcwMDAxJyxcbiAgICAgICAgYWxwaGFudW1lcmljOiAnMDAxMCcsXG4gICAgICAgIGJ5dGU6ICcwMTAwJyxcbiAgICAgICAga2Fuamk6ICcxMDAwJyxcbiAgICAgICAgZWNpOiAnMDExMScsXG4gICAgfSxcbiAgICBjYXBhY2l0eSh2ZXIsIGVjYykge1xuICAgICAgICBjb25zdCBieXRlcyA9IEJZVEVTW3ZlciAtIDFdO1xuICAgICAgICBjb25zdCB3b3JkcyA9IFdPUkRTX1BFUl9CTE9DS1tlY2NdW3ZlciAtIDFdO1xuICAgICAgICBjb25zdCBudW1CbG9ja3MgPSBFQ0NfQkxPQ0tTW2VjY11bdmVyIC0gMV07XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gTWF0aC5mbG9vcihieXRlcyAvIG51bUJsb2NrcykgLSB3b3JkcztcbiAgICAgICAgY29uc3Qgc2hvcnRCbG9ja3MgPSBudW1CbG9ja3MgLSAoYnl0ZXMgJSBudW1CbG9ja3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd29yZHMsXG4gICAgICAgICAgICBudW1CbG9ja3MsXG4gICAgICAgICAgICBzaG9ydEJsb2NrcyxcbiAgICAgICAgICAgIGJsb2NrTGVuLFxuICAgICAgICAgICAgY2FwYWNpdHk6IChieXRlcyAtIHdvcmRzICogbnVtQmxvY2tzKSAqIDgsXG4gICAgICAgICAgICB0b3RhbDogKHdvcmRzICsgYmxvY2tMZW4pICogbnVtQmxvY2tzICsgbnVtQmxvY2tzIC0gc2hvcnRCbG9ja3MsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5jb25zdCBQQVRURVJOUyA9IFtcbiAgICAoeCwgeSkgPT4gKHggKyB5KSAlIDIgPT0gMCxcbiAgICAoX3gsIHkpID0+IHkgJSAyID09IDAsXG4gICAgKHgsIF95KSA9PiB4ICUgMyA9PSAwLFxuICAgICh4LCB5KSA9PiAoeCArIHkpICUgMyA9PSAwLFxuICAgICh4LCB5KSA9PiAoTWF0aC5mbG9vcih5IC8gMikgKyBNYXRoLmZsb29yKHggLyAzKSkgJSAyID09IDAsXG4gICAgKHgsIHkpID0+ICgoeCAqIHkpICUgMikgKyAoKHggKiB5KSAlIDMpID09IDAsXG4gICAgKHgsIHkpID0+ICgoKHggKiB5KSAlIDIpICsgKCh4ICogeSkgJSAzKSkgJSAyID09IDAsXG4gICAgKHgsIHkpID0+ICgoKHggKyB5KSAlIDIpICsgKCh4ICogeSkgJSAzKSkgJSAyID09IDAsXG5dO1xuLy8gR2Fsb2lzIGZpZWxkICYmIHJlZWQtc29sb21vbiBlbmNvZGluZ1xuY29uc3QgR0YgPSB7XG4gICAgdGFibGVzOiAoKHBfcG9seSkgPT4ge1xuICAgICAgICBjb25zdCBleHAgPSBmaWxsQXJyKDI1NiwgMCk7XG4gICAgICAgIGNvbnN0IGxvZyA9IGZpbGxBcnIoMjU2LCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHggPSAxOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgIGV4cFtpXSA9IHg7XG4gICAgICAgICAgICBsb2dbeF0gPSBpO1xuICAgICAgICAgICAgeCA8PD0gMTtcbiAgICAgICAgICAgIGlmICh4ICYgMHgxMDApXG4gICAgICAgICAgICAgICAgeCBePSBwX3BvbHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZXhwLCBsb2cgfTtcbiAgICB9KSgweDExZCksXG4gICAgZXhwOiAoeCkgPT4gR0YudGFibGVzLmV4cFt4XSxcbiAgICBsb2coeCkge1xuICAgICAgICBpZiAoeCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR0YubG9nOiBpbnZhbGlkIGFyZz0ke3h9YCk7XG4gICAgICAgIHJldHVybiBHRi50YWJsZXMubG9nW3hdICUgMjU1O1xuICAgIH0sXG4gICAgbXVsKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IDAgfHwgeSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gR0YudGFibGVzLmV4cFsoR0YudGFibGVzLmxvZ1t4XSArIEdGLnRhYmxlcy5sb2dbeV0pICUgMjU1XTtcbiAgICB9LFxuICAgIGFkZDogKHgsIHkpID0+IHggXiB5LFxuICAgIHBvdzogKHgsIGUpID0+IEdGLnRhYmxlcy5leHBbKEdGLnRhYmxlcy5sb2dbeF0gKiBlKSAlIDI1NV0sXG4gICAgaW52KHgpIHtcbiAgICAgICAgaWYgKHggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdGLmludmVyc2U6IGludmFsaWQgYXJnPSR7eH1gKTtcbiAgICAgICAgcmV0dXJuIEdGLnRhYmxlcy5leHBbMjU1IC0gR0YudGFibGVzLmxvZ1t4XV07XG4gICAgfSxcbiAgICBwb2x5bm9taWFsKHBvbHkpIHtcbiAgICAgICAgaWYgKHBvbHkubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dGLnBvbHltb21pYWw6IGludmFsaWQgbGVuZ3RoJyk7XG4gICAgICAgIGlmIChwb2x5WzBdICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHBvbHk7XG4gICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVyb3NcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IHBvbHkubGVuZ3RoIC0gMSAmJiBwb2x5W2ldID09IDA7IGkrKylcbiAgICAgICAgICAgIDtcbiAgICAgICAgcmV0dXJuIHBvbHkuc2xpY2UoaSk7XG4gICAgfSxcbiAgICBtb25vbWlhbChkZWdyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgIGlmIChkZWdyZWUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHRi5tb25vbWlhbDogaW52YWxpZCBkZWdyZWU9JHtkZWdyZWV9YCk7XG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswXTtcbiAgICAgICAgbGV0IGNvZWZmaWNpZW50cyA9IGZpbGxBcnIoZGVncmVlICsgMSwgMCk7XG4gICAgICAgIGNvZWZmaWNpZW50c1swXSA9IGNvZWZmaWNpZW50O1xuICAgICAgICByZXR1cm4gR0YucG9seW5vbWlhbChjb2VmZmljaWVudHMpO1xuICAgIH0sXG4gICAgZGVncmVlOiAoYSkgPT4gYS5sZW5ndGggLSAxLFxuICAgIGNvZWZmaWNpZW50OiAoYSwgZGVncmVlKSA9PiBhW0dGLmRlZ3JlZShhKSAtIGRlZ3JlZV0sXG4gICAgbXVsUG9seShhLCBiKSB7XG4gICAgICAgIGlmIChhWzBdID09PSAwIHx8IGJbMF0gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgICBjb25zdCByZXMgPSBmaWxsQXJyKGEubGVuZ3RoICsgYi5sZW5ndGggLSAxLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaSArIGpdID0gR0YuYWRkKHJlc1tpICsgal0sIEdGLm11bChhW2ldLCBiW2pdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdGLnBvbHlub21pYWwocmVzKTtcbiAgICB9LFxuICAgIG11bFBvbHlTY2FsYXIoYSwgc2NhbGFyKSB7XG4gICAgICAgIGlmIChzY2FsYXIgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGlmIChzY2FsYXIgPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICBjb25zdCByZXMgPSBmaWxsQXJyKGEubGVuZ3RoLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzW2ldID0gR0YubXVsKGFbaV0sIHNjYWxhcik7XG4gICAgICAgIHJldHVybiBHRi5wb2x5bm9taWFsKHJlcyk7XG4gICAgfSxcbiAgICBtdWxQb2x5TW9ub21pYWwoYSwgZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgICAgICBpZiAoZGVncmVlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR0YubXVsUG9seU1vbm9taWFsOiBpbnZhbGlkIGRlZ3JlZScpO1xuICAgICAgICBpZiAoY29lZmZpY2llbnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGNvbnN0IHJlcyA9IGZpbGxBcnIoYS5sZW5ndGggKyBkZWdyZWUsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXNbaV0gPSBHRi5tdWwoYVtpXSwgY29lZmZpY2llbnQpO1xuICAgICAgICByZXR1cm4gR0YucG9seW5vbWlhbChyZXMpO1xuICAgIH0sXG4gICAgYWRkUG9seShhLCBiKSB7XG4gICAgICAgIGlmIChhWzBdID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIGlmIChiWzBdID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGxldCBzbWFsbGVyID0gYTtcbiAgICAgICAgbGV0IGxhcmdlciA9IGI7XG4gICAgICAgIGlmIChzbWFsbGVyLmxlbmd0aCA+IGxhcmdlci5sZW5ndGgpXG4gICAgICAgICAgICBbc21hbGxlciwgbGFyZ2VyXSA9IFtsYXJnZXIsIHNtYWxsZXJdO1xuICAgICAgICBsZXQgc3VtRGlmZiA9IGZpbGxBcnIobGFyZ2VyLmxlbmd0aCwgMCk7XG4gICAgICAgIGxldCBsZW5ndGhEaWZmID0gbGFyZ2VyLmxlbmd0aCAtIHNtYWxsZXIubGVuZ3RoO1xuICAgICAgICBsZXQgcyA9IGxhcmdlci5zbGljZSgwLCBsZW5ndGhEaWZmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc3VtRGlmZltpXSA9IHNbaV07XG4gICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGhEaWZmOyBpIDwgbGFyZ2VyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc3VtRGlmZltpXSA9IEdGLmFkZChzbWFsbGVyW2kgLSBsZW5ndGhEaWZmXSwgbGFyZ2VyW2ldKTtcbiAgICAgICAgcmV0dXJuIEdGLnBvbHlub21pYWwoc3VtRGlmZik7XG4gICAgfSxcbiAgICByZW1haW5kZXJQb2x5KGRhdGEsIGRpdmlzb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIGRpdmlzb3IubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG0gPSBvdXRbaV07XG4gICAgICAgICAgICBpZiAoZWxtID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBkaXZpc29yLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3Jbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIG91dFtpICsgal0gPSBHRi5hZGQob3V0W2kgKyBqXSwgR0YubXVsKGRpdmlzb3Jbal0sIGVsbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuc2xpY2UoZGF0YS5sZW5ndGggLSBkaXZpc29yLmxlbmd0aCArIDEsIG91dC5sZW5ndGgpO1xuICAgIH0sXG4gICAgZGl2aXNvclBvbHkoZGVncmVlKSB7XG4gICAgICAgIGxldCBnID0gWzFdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZTsgaSsrKVxuICAgICAgICAgICAgZyA9IEdGLm11bFBvbHkoZywgWzEsIEdGLnBvdygyLCBpKV0pO1xuICAgICAgICByZXR1cm4gZztcbiAgICB9LFxuICAgIGV2YWxQb2x5KHBvbHksIGEpIHtcbiAgICAgICAgaWYgKGEgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBHRi5jb2VmZmljaWVudChwb2x5LCAwKTsgLy8gSnVzdCByZXR1cm4gdGhlIHheMCBjb2VmZmljaWVudFxuICAgICAgICBsZXQgcmVzID0gcG9seVswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2x5Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzID0gR0YuYWRkKEdGLm11bChhLCByZXMpLCBwb2x5W2ldKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIC8vIFRPRE86IGNsZWFudXBcbiAgICBldWNsaWRpYW4oYSwgYiwgUikge1xuICAgICAgICAvLyBGb3JjZSBkZWdyZWUoYSkgPj0gZGVncmVlKGIpXG4gICAgICAgIGlmIChHRi5kZWdyZWUoYSkgPCBHRi5kZWdyZWUoYikpXG4gICAgICAgICAgICBbYSwgYl0gPSBbYiwgYV07XG4gICAgICAgIGxldCByTGFzdCA9IGE7XG4gICAgICAgIGxldCByID0gYjtcbiAgICAgICAgbGV0IHRMYXN0ID0gWzBdO1xuICAgICAgICBsZXQgdCA9IFsxXTtcbiAgICAgICAgLy8gd2hpbGUgZGVncmVlIG9mIFJpIOKJpSB0LzJcbiAgICAgICAgd2hpbGUgKDIgKiBHRi5kZWdyZWUocikgPj0gUikge1xuICAgICAgICAgICAgbGV0IHJMYXN0TGFzdCA9IHJMYXN0O1xuICAgICAgICAgICAgbGV0IHRMYXN0TGFzdCA9IHRMYXN0O1xuICAgICAgICAgICAgckxhc3QgPSByO1xuICAgICAgICAgICAgdExhc3QgPSB0O1xuICAgICAgICAgICAgaWYgKHJMYXN0WzBdID09PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignckxhc3RbMF0gPT09IDAnKTtcbiAgICAgICAgICAgIHIgPSByTGFzdExhc3Q7XG4gICAgICAgICAgICBsZXQgcSA9IFswXTtcbiAgICAgICAgICAgIGNvbnN0IGRsdEludmVyc2UgPSBHRi5pbnYockxhc3RbMF0pO1xuICAgICAgICAgICAgd2hpbGUgKEdGLmRlZ3JlZShyKSA+PSBHRi5kZWdyZWUockxhc3QpICYmIHJbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWdyZWVEaWZmID0gR0YuZGVncmVlKHIpIC0gR0YuZGVncmVlKHJMYXN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IEdGLm11bChyWzBdLCBkbHRJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICBxID0gR0YuYWRkUG9seShxLCBHRi5tb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgIHIgPSBHRi5hZGRQb2x5KHIsIEdGLm11bFBvbHlNb25vbWlhbChyTGFzdCwgZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEgPSBHRi5tdWxQb2x5KHEsIHRMYXN0KTtcbiAgICAgICAgICAgIHQgPSBHRi5hZGRQb2x5KHEsIHRMYXN0TGFzdCk7XG4gICAgICAgICAgICBpZiAoR0YuZGVncmVlKHIpID49IEdGLmRlZ3JlZShyTGFzdCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXZpc2lvbiBmYWlsZWQgcjogJHtyfSwgckxhc3Q6ICR7ckxhc3R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbWFUaWxkZUF0WmVybyA9IEdGLmNvZWZmaWNpZW50KHQsIDApO1xuICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWdtYVRpbGRlKDApIHdhcyB6ZXJvJyk7XG4gICAgICAgIGNvbnN0IGludmVyc2UgPSBHRi5pbnYoc2lnbWFUaWxkZUF0WmVybyk7XG4gICAgICAgIHJldHVybiBbR0YubXVsUG9seVNjYWxhcih0LCBpbnZlcnNlKSwgR0YubXVsUG9seVNjYWxhcihyLCBpbnZlcnNlKV07XG4gICAgfSxcbn07XG5mdW5jdGlvbiBSUyhlY2NXb3Jkcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShmcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gR0YuZGl2aXNvclBvbHkoZWNjV29yZHMpO1xuICAgICAgICAgICAgY29uc3QgcG9sID0gQXJyYXkuZnJvbShmcm9tKTtcbiAgICAgICAgICAgIHBvbC5wdXNoKC4uLmQuc2xpY2UoMCwgLTEpLmZpbGwoMCkpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShHRi5yZW1haW5kZXJQb2x5KHBvbCwgZCkpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUodG8pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRvLnNsaWNlKCk7XG4gICAgICAgICAgICBjb25zdCBwb2x5ID0gR0YucG9seW5vbWlhbChBcnJheS5mcm9tKHRvKSk7XG4gICAgICAgICAgICAvLyBGaW5kIGVycm9yc1xuICAgICAgICAgICAgbGV0IHN5bmRyb21lID0gZmlsbEFycihlY2NXb3JkcywgMCk7XG4gICAgICAgICAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWNjV29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2bCA9IEdGLmV2YWxQb2x5KHBvbHksIEdGLmV4cChpKSk7XG4gICAgICAgICAgICAgICAgc3luZHJvbWVbc3luZHJvbWUubGVuZ3RoIC0gMSAtIGldID0gZXZsO1xuICAgICAgICAgICAgICAgIGlmIChldmwgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIHN5bmRyb21lID0gR0YucG9seW5vbWlhbChzeW5kcm9tZSk7XG4gICAgICAgICAgICBjb25zdCBtb25vbWlhbCA9IEdGLm1vbm9taWFsKGVjY1dvcmRzLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IFtlcnJvckxvY2F0b3IsIGVycm9yRXZhbHVhdG9yXSA9IEdGLmV1Y2xpZGlhbihtb25vbWlhbCwgc3luZHJvbWUsIGVjY1dvcmRzKTtcbiAgICAgICAgICAgIC8vIEVycm9yIGxvY2F0aW9uc1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb25zID0gZmlsbEFycihHRi5kZWdyZWUoZXJyb3JMb2NhdG9yKSwgMCk7XG4gICAgICAgICAgICBsZXQgZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDI1NiAmJiBlIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEdGLmV2YWxQb2x5KGVycm9yTG9jYXRvciwgaSkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uc1tlKytdID0gR0YuaW52KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgIT09IGxvY2F0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSUy5kZWNvZGU6IGludmFsaWQgZXJyb3JzIG51bWJlcicpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSByZXMubGVuZ3RoIC0gMSAtIEdGLmxvZyhsb2NhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPCAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JTLmRlY29kZTogaW52YWxpZCBlcnJvciBsb2NhdGlvbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhpSW52ZXJzZSA9IEdGLmludihsb2NhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIGxldCBkZW5vbWluYXRvciA9IDE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGopXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVub21pbmF0b3IgPSBHRi5tdWwoZGVub21pbmF0b3IsIEdGLmFkZCgxLCBHRi5tdWwobG9jYXRpb25zW2pdLCB4aUludmVyc2UpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc1twb3NdID0gR0YuYWRkKHJlc1twb3NdLCBHRi5tdWwoR0YuZXZhbFBvbHkoZXJyb3JFdmFsdWF0b3IsIHhpSW52ZXJzZSksIEdGLmludihkZW5vbWluYXRvcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIEludGVybGVhdmVzIGJsb2Nrc1xuZnVuY3Rpb24gaW50ZXJsZWF2ZSh2ZXIsIGVjYykge1xuICAgIGNvbnN0IHsgd29yZHMsIHNob3J0QmxvY2tzLCBudW1CbG9ja3MsIGJsb2NrTGVuLCB0b3RhbCB9ID0gaW5mby5jYXBhY2l0eSh2ZXIsIGVjYyk7XG4gICAgY29uc3QgcnMgPSBSUyh3b3Jkcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBBZGQgZXJyb3IgY29ycmVjdGlvbiB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgICAgICAgICBjb25zdCBlY2NCbG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQmxvY2tzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Nob3J0ID0gaSA8IHNob3J0QmxvY2tzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJsb2NrTGVuICsgKGlzU2hvcnQgPyAwIDogMSk7XG4gICAgICAgICAgICAgICAgYmxvY2tzLnB1c2goYnl0ZXMuc3ViYXJyYXkoMCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgZWNjQmxvY2tzLnB1c2gocnMuZW5jb2RlKGJ5dGVzLnN1YmFycmF5KDAsIGxlbikpKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YmFycmF5KGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNCbG9ja3MgPSBpbnRlcmxlYXZlQnl0ZXMoYmxvY2tzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc0VDQyA9IGludGVybGVhdmVCeXRlcyhlY2NCbG9ja3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkocmVzQmxvY2tzLmxlbmd0aCArIHJlc0VDQy5sZW5ndGgpO1xuICAgICAgICAgICAgcmVzLnNldChyZXNCbG9ja3MpO1xuICAgICAgICAgICAgcmVzLnNldChyZXNFQ0MsIHJlc0Jsb2Nrcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdG90YWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnRlcmxlYXZlLmRlY29kZTogbGVuKGRhdGEpPSR7ZGF0YS5sZW5ndGh9LCB0b3RhbD0ke3RvdGFsfWApO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaG9ydCA9IGkgPCBzaG9ydEJsb2NrcztcbiAgICAgICAgICAgICAgICBibG9ja3MucHVzaChuZXcgVWludDhBcnJheSh3b3JkcyArIGJsb2NrTGVuICsgKGlzU2hvcnQgPyAwIDogMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNob3J0IGJsb2Nrc1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUJsb2NrczsgaisrKVxuICAgICAgICAgICAgICAgICAgICBibG9ja3Nbal1baV0gPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvbmcgYmxvY2tzXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gc2hvcnRCbG9ja3M7IGogPCBudW1CbG9ja3M7IGorKylcbiAgICAgICAgICAgICAgICBibG9ja3Nbal1bYmxvY2tMZW5dID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAvLyBFQ0NcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBibG9ja0xlbjsgaSA8IGJsb2NrTGVuICsgd29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTaG9ydCA9IGogPCBzaG9ydEJsb2NrcztcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2pdW2kgKyAoaXNTaG9ydCA/IDAgOiAxKV0gPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGVcbiAgICAgICAgICAgIC8vIEVycm9yLWNvcnJlY3QgYW5kIGNvcHkgZGF0YSBibG9ja3MgdG9nZXRoZXIgaW50byBhIHN0cmVhbSBvZiBieXRlc1xuICAgICAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJsb2NrcylcbiAgICAgICAgICAgICAgICByZXMucHVzaCguLi5BcnJheS5mcm9tKHJzLmRlY29kZShibG9jaykpLnNsaWNlKDAsIC13b3JkcykpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBEcmF3XG4vLyBHZW5lcmljIHRlbXBsYXRlIHBlciB2ZXJzaW9uK2VjYyttYXNrLiBDYW4gYmUgY2FjaGVkLCB0byBzcGVlZHVwIGNhbGN1bGF0aW9ucy5cbmZ1bmN0aW9uIGRyYXdUZW1wbGF0ZSh2ZXIsIGVjYywgbWFza0lkeCwgdGVzdCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGluZm8uc2l6ZS5lbmNvZGUodmVyKTtcbiAgICBsZXQgYiA9IG5ldyBCaXRtYXAoc2l6ZSArIDIpO1xuICAgIC8vIEZpbmRlciBwYXR0ZXJuc1xuICAgIC8vIFdlIGRyYXcgZnVsbCBwYXR0ZXJuIGFuZCBsYXRlciBzbGljZSwgc2luY2UgYmVmb3JlIGFkZGl0aW9uIG9mIGJvcmRlcnMgZmluZGVyIGlzIHRydW5jYXRlZCBieSBvbmUgcGl4ZWwgb24gc2lkZXNcbiAgICBjb25zdCBmaW5kZXIgPSBuZXcgQml0bWFwKDMpLnJlY3QoMCwgMywgdHJ1ZSkuYm9yZGVyKDEsIGZhbHNlKS5ib3JkZXIoMSwgdHJ1ZSkuYm9yZGVyKDEsIGZhbHNlKTtcbiAgICBiID0gYlxuICAgICAgICAuZW1iZWQoMCwgZmluZGVyKSAvLyB0b3AgbGVmdFxuICAgICAgICAuZW1iZWQoeyB4OiAtZmluZGVyLndpZHRoLCB5OiAwIH0sIGZpbmRlcikgLy8gdG9wIHJpZ2h0XG4gICAgICAgIC5lbWJlZCh7IHg6IDAsIHk6IC1maW5kZXIuaGVpZ2h0IH0sIGZpbmRlcik7IC8vIGJvdHRvbSBsZWZ0XG4gICAgYiA9IGIucmVjdFNsaWNlKDEsIHNpemUpO1xuICAgIC8vIEFsaWdubWVudCBwYXR0ZXJuc1xuICAgIGNvbnN0IGFsaWduID0gbmV3IEJpdG1hcCgxKS5yZWN0KDAsIDEsIHRydWUpLmJvcmRlcigxLCBmYWxzZSkuYm9yZGVyKDEsIHRydWUpO1xuICAgIGNvbnN0IGFsaWduUG9zID0gaW5mby5hbGlnbm1lbnRQYXR0ZXJucyh2ZXIpO1xuICAgIGZvciAoY29uc3QgeSBvZiBhbGlnblBvcykge1xuICAgICAgICBmb3IgKGNvbnN0IHggb2YgYWxpZ25Qb3MpIHtcbiAgICAgICAgICAgIGlmIChiLmlzRGVmaW5lZCh4LCB5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGIuZW1iZWQoeyB4OiB4IC0gMiwgeTogeSAtIDIgfSwgYWxpZ24pOyAvLyBjZW50ZXIgb2YgcGF0dGVybiBzaG91bGQgYmUgYXQgcG9zaXRpb25cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaW1pbmcgcGF0dGVybnNcbiAgICBiID0gYlxuICAgICAgICAuaExpbmUoeyB4OiAwLCB5OiA2IH0sIEluZmluaXR5LCAoeyB4IH0pID0+IChiLmlzRGVmaW5lZCh4LCA2KSA/IHVuZGVmaW5lZCA6IHggJSAyID09IDApKVxuICAgICAgICAudkxpbmUoeyB4OiA2LCB5OiAwIH0sIEluZmluaXR5LCAoeyB5IH0pID0+IChiLmlzRGVmaW5lZCg2LCB5KSA/IHVuZGVmaW5lZCA6IHkgJSAyID09IDApKTtcbiAgICAvLyBGb3JtYXQgaW5mb3JtYXRpb25cbiAgICB7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBpbmZvLmZvcm1hdEJpdHMoZWNjLCBtYXNrSWR4KTtcbiAgICAgICAgY29uc3QgZ2V0Qml0ID0gKGkpID0+ICF0ZXN0ICYmICgoYml0cyA+PiBpKSAmIDEpID09IDE7XG4gICAgICAgIC8vIHZlcnRpY2FsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICAgICAgYi5zZXQoOCwgaSwgZ2V0Qml0KGkpKTsgLy8gcmlnaHQgb2YgdG9wLWxlZnQgZmluZGVyXG4gICAgICAgIC8vIFRPRE86IHJlLXdyaXRlIGFzIGxpbmVzLCBsaWtlOlxuICAgICAgICAvLyBiLnZMaW5lKHsgeDogOCwgeTogMCB9LCA2LCAoeyB4LCB5IH0pID0+IGdldEJpdCh5KSk7XG4gICAgICAgIGZvciAobGV0IGkgPSA2OyBpIDwgODsgaSsrKVxuICAgICAgICAgICAgYi5zZXQoOCwgaSArIDEsIGdldEJpdChpKSk7IC8vIGFmdGVyIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgIGZvciAobGV0IGkgPSA4OyBpIDwgMTU7IGkrKylcbiAgICAgICAgICAgIGIuc2V0KDgsIHNpemUgLSAxNSArIGksIGdldEJpdChpKSk7IC8vIHJpZ2h0IG9mIGJvdHRvbS1sZWZ0IGZpbmRlclxuICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICAgICAgYi5zZXQoc2l6ZSAtIGkgLSAxLCA4LCBnZXRCaXQoaSkpOyAvLyB1bmRlciB0b3AtcmlnaHQgZmluZGVyXG4gICAgICAgIGZvciAobGV0IGkgPSA4OyBpIDwgOTsgaSsrKVxuICAgICAgICAgICAgYi5zZXQoMTUgLSBpIC0gMSArIDEsIDgsIGdldEJpdChpKSk7IC8vIFZWViwgYWZ0ZXIgdGltaW5nXG4gICAgICAgIGZvciAobGV0IGkgPSA5OyBpIDwgMTU7IGkrKylcbiAgICAgICAgICAgIGIuc2V0KDE1IC0gaSAtIDEsIDgsIGdldEJpdChpKSk7IC8vIHVuZGVyIHRvcC1sZWZ0IGZpbmRlclxuICAgICAgICBiLnNldCg4LCBzaXplIC0gOCwgIXRlc3QpOyAvLyBib3R0b20tbGVmdCBmaW5kZXIsIHJpZ2h0XG4gICAgfVxuICAgIC8vIFZlcnNpb24gaW5mb3JtYXRpb25cbiAgICBpZiAodmVyID49IDcpIHtcbiAgICAgICAgY29uc3QgYml0cyA9IGluZm8udmVyc2lvbkJpdHModmVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxODsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBiaXQgPSAhdGVzdCAmJiAoKGJpdHMgPj4gaSkgJiAxKSA9PSAxO1xuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGguZmxvb3IoaSAvIDMpO1xuICAgICAgICAgICAgY29uc3QgeSA9IChpICUgMykgKyBzaXplIC0gOCAtIDM7XG4gICAgICAgICAgICAvLyB0d28gY29waWVzXG4gICAgICAgICAgICBiLnNldCh5LCB4LCBiaXQpO1xuICAgICAgICAgICAgYi5zZXQoeCwgeSwgYml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbi8vIHppZ3phZzogYm90dG9tLT50b3AgJiYgdG9wLT5ib3R0b21cbmZ1bmN0aW9uIHppZ3phZyh0cGwsIG1hc2tJZHgsIGZuKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRwbC5oZWlnaHQ7XG4gICAgY29uc3QgcGF0dGVybiA9IFBBVFRFUk5TW21hc2tJZHhdO1xuICAgIC8vIHppZy16YWcgcGF0dGVyblxuICAgIGxldCBkaXIgPSAtMTtcbiAgICBsZXQgeSA9IHNpemUgLSAxO1xuICAgIC8vIHR3byBjb2x1bW5zIGF0IHRpbWVcbiAgICBmb3IgKGxldCB4T2Zmc2V0ID0gc2l6ZSAtIDE7IHhPZmZzZXQgPiAwOyB4T2Zmc2V0IC09IDIpIHtcbiAgICAgICAgaWYgKHhPZmZzZXQgPT0gNilcbiAgICAgICAgICAgIHhPZmZzZXQgPSA1OyAvLyBza2lwIHZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgIGZvciAoOzsgeSArPSBkaXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhPZmZzZXQgLSBqO1xuICAgICAgICAgICAgICAgIGlmICh0cGwuaXNEZWZpbmVkKHgsIHkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBhbHJlYWR5IHdyaXR0ZW4gZWxlbWVudHNcbiAgICAgICAgICAgICAgICBmbih4LCB5LCBwYXR0ZXJuKHgsIHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICsgZGlyIDwgMCB8fCB5ICsgZGlyID49IHNpemUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGlyID0gLWRpcjsgLy8gY2hhbmdlIGRpcmVjdGlvblxuICAgIH1cbn1cbi8vIE5PVEU6IGJ5dGUgZW5jb2RpbmcgaXMganVzdCByZXByZXNlbnRhdGlvbiwgUVIgd29ya3Mgd2l0aCBzdHJpbmdzIG9ubHkuIE1vc3QgZGVjb2RlcnMgd2lsbCBmYWlsIG9uIHJhdyBieXRlIGFycmF5LFxuLy8gc2luY2UgdGhleSBleHBlY3QgdW5pY29kZSBvciBvdGhlciB0ZXh0IGVuY29kaW5nIGluc2lkZSBieXRlc1xuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdHIpIHtcbiAgICBsZXQgdHlwZSA9ICdudW1lcmljJztcbiAgICBmb3IgKGxldCB4IG9mIHN0cikge1xuICAgICAgICBpZiAoaW5mby5hbHBoYWJldC5udW1lcmljLmhhcyh4KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0eXBlID0gJ2FscGhhbnVtZXJpYyc7XG4gICAgICAgIGlmICghaW5mby5hbHBoYWJldC5hbHBoYW51bWVyYy5oYXMoeCkpXG4gICAgICAgICAgICByZXR1cm4gJ2J5dGUnO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuZnVuY3Rpb24gZW5jb2RlKHZlciwgZWNjLCBkYXRhLCB0eXBlLCBlbmNvZGVyID0gdXRmOFRvQnl0ZXMpIHtcbiAgICBsZXQgZW5jb2RlZCA9ICcnO1xuICAgIGxldCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHR5cGUgPT09ICdudW1lcmljJykge1xuICAgICAgICBjb25zdCB0ID0gaW5mby5hbHBoYWJldC5udW1lcmljLmRlY29kZShkYXRhLnNwbGl0KCcnKSk7XG4gICAgICAgIGNvbnN0IG4gPSB0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuIC0gMjsgaSArPSAzKVxuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtpXSAqIDEwMCArIHRbaSArIDFdICogMTAgKyB0W2kgKyAyXSwgMTApO1xuICAgICAgICBpZiAobiAlIDMgPT09IDEpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbbiAtIDFdLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuICUgMyA9PT0gMikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtuIC0gMl0gKiAxMCArIHRbbiAtIDFdLCA3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYWxwaGFudW1lcmljJykge1xuICAgICAgICBjb25zdCB0ID0gaW5mby5hbHBoYWJldC5hbHBoYW51bWVyYy5kZWNvZGUoZGF0YS5zcGxpdCgnJykpO1xuICAgICAgICBjb25zdCBuID0gdC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkgKz0gMilcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbaV0gKiA0NSArIHRbaSArIDFdLCAxMSk7XG4gICAgICAgIGlmIChuICUgMiA9PSAxKVxuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtuIC0gMV0sIDYpOyAvLyBwYWQgaWYgb2RkIG51bWJlciBvZiBjaGFyc1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYnl0ZScpIHtcbiAgICAgICAgY29uc3QgdXRmOCA9IGVuY29kZXIoZGF0YSk7XG4gICAgICAgIGRhdGFMZW4gPSB1dGY4Lmxlbmd0aDtcbiAgICAgICAgZW5jb2RlZCA9IEFycmF5LmZyb20odXRmOClcbiAgICAgICAgICAgIC5tYXAoKGkpID0+IGJpbihpLCA4KSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5jb2RlOiB1bnN1cHBvcnRlZCB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2FwYWNpdHkgfSA9IGluZm8uY2FwYWNpdHkodmVyLCBlY2MpO1xuICAgIGNvbnN0IGxlbiA9IGJpbihkYXRhTGVuLCBpbmZvLmxlbmd0aEJpdHModmVyLCB0eXBlKSk7XG4gICAgbGV0IGJpdHMgPSBpbmZvLm1vZGVCaXRzW3R5cGVdICsgbGVuICsgZW5jb2RlZDtcbiAgICBpZiAoYml0cy5sZW5ndGggPiBjYXBhY2l0eSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXBhY2l0eSBvdmVyZmxvdycpO1xuICAgIC8vIFRlcm1pbmF0b3JcbiAgICBiaXRzICs9ICcwJy5yZXBlYXQoTWF0aC5taW4oNCwgTWF0aC5tYXgoMCwgY2FwYWNpdHkgLSBiaXRzLmxlbmd0aCkpKTtcbiAgICAvLyBQYWQgYml0cyBzdHJpbmcgdW50aWxsIGZ1bGwgYnl0ZVxuICAgIGlmIChiaXRzLmxlbmd0aCAlIDgpXG4gICAgICAgIGJpdHMgKz0gJzAnLnJlcGVhdCg4IC0gKGJpdHMubGVuZ3RoICUgOCkpO1xuICAgIC8vIEFkZCBwYWRkaW5nIHVudGlsIGNhcGFjaXR5IGlzIGZ1bGxcbiAgICBjb25zdCBwYWRkaW5nID0gJzExMTAxMTAwMDAwMTAwMDEnO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGJpdHMubGVuZ3RoICE9PSBjYXBhY2l0eTsgaWR4KyspXG4gICAgICAgIGJpdHMgKz0gcGFkZGluZ1tpZHggJSBwYWRkaW5nLmxlbmd0aF07XG4gICAgLy8gQ29udmVydCBhIGJpdHN0cmluZyB0byBhcnJheSBvZiBieXRlc1xuICAgIGNvbnN0IGJ5dGVzID0gVWludDhBcnJheS5mcm9tKGJpdHMubWF0Y2goLyguezh9KS9nKS5tYXAoKGkpID0+IE51bWJlcihgMGIke2l9YCkpKTtcbiAgICByZXR1cm4gaW50ZXJsZWF2ZSh2ZXIsIGVjYykuZW5jb2RlKGJ5dGVzKTtcbn1cbi8vIERSQVdcbmZ1bmN0aW9uIGRyYXdRUih2ZXIsIGVjYywgZGF0YSwgbWFza0lkeCwgdGVzdCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYiA9IGRyYXdUZW1wbGF0ZSh2ZXIsIGVjYywgbWFza0lkeCwgdGVzdCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IG5lZWQgPSA4ICogZGF0YS5sZW5ndGg7XG4gICAgemlnemFnKGIsIG1hc2tJZHgsICh4LCB5LCBtYXNrKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoaSA8IG5lZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKChkYXRhW2kgPj4+IDNdID4+ICgoNyAtIGkpICYgNykpICYgMSkgIT09IDA7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgYi5zZXQoeCwgeSwgdmFsdWUgIT09IG1hc2spOyAvLyAhPT0gYXMgeG9yXG4gICAgfSk7XG4gICAgaWYgKGkgIT09IG5lZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUVI6IGJ5dGVzIGxlZnQgYWZ0ZXIgZHJhdycpO1xuICAgIHJldHVybiBiO1xufVxuY29uc3QgbWtQYXR0ZXJuID0gKHBhdHRlcm4pID0+IHtcbiAgICBjb25zdCBzID0gcGF0dGVybi5tYXAoKGkpID0+IChpID8gJzEnIDogJzAnKSkuam9pbignJyk7XG4gICAgcmV0dXJuIHsgbGVuOiBzLmxlbmd0aCwgbjogTnVtYmVyKGAwYiR7c31gKSB9O1xufTtcbi8vIDE6MTozOjE6MSByYXRpbyAoZGFyazpsaWdodDpkYXJrOmxpZ2h0OmRhcmspIHBhdHRlcm4gaW4gcm93L2NvbHVtbiwgcHJlY2VkZWQgb3IgZm9sbG93ZWQgYnkgbGlnaHQgYXJlYSA0IG1vZHVsZXMgd2lkZVxuY29uc3QgZmluZGVyUGF0dGVybiA9IFt0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWVdOyAvLyBkYXJrOmxpZ2h0OmRhcms6bGlnaHQ6ZGFya1xuY29uc3QgbGlnaHRQYXR0ZXJuID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXTsgLy8gbGlnaHQgYXJlYSA0IG1vZHVsZXMgd2lkZVxuY29uc3QgUDEgPSBta1BhdHRlcm4oWy4uLmZpbmRlclBhdHRlcm4sIC4uLmxpZ2h0UGF0dGVybl0pO1xuY29uc3QgUDIgPSBta1BhdHRlcm4oWy4uLmxpZ2h0UGF0dGVybiwgLi4uZmluZGVyUGF0dGVybl0pO1xuZnVuY3Rpb24gcGVuYWx0eShibSkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYm07XG4gICAgY29uc3QgdHJhbnNwb3NlZCA9IGJtLnRyYW5zcG9zZSgpO1xuICAgIC8vIEFkamFjZW50IG1vZHVsZXMgaW4gcm93L2NvbHVtbiBpbiBzYW1lIHwgTm8uIG9mIG1vZHVsZXMgPSAoNSArIGkpIGNvbG9yXG4gICAgbGV0IGFkamFjZW50ID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGJtLmdldFJ1bnMoeSwgKGxlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGxlbiA+PSA1KVxuICAgICAgICAgICAgICAgIGFkamFjZW50ICs9IDMgKyAobGVuIC0gNSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHdpZHRoOyB5KyspIHtcbiAgICAgICAgdHJhbnNwb3NlZC5nZXRSdW5zKHksIChsZW4pID0+IHtcbiAgICAgICAgICAgIGlmIChsZW4gPj0gNSlcbiAgICAgICAgICAgICAgICBhZGphY2VudCArPSAzICsgKGxlbiAtIDUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQmxvY2sgb2YgbW9kdWxlcyBpbiBzYW1lIGNvbG9yIChCbG9jayBzaXplID0gMngyKVxuICAgIGxldCBib3ggPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0IC0gMTsgeSsrKVxuICAgICAgICBib3ggKz0gMyAqIGJtLmNvdW50Qm94ZXMyeDIoeSk7XG4gICAgbGV0IGZpbmRlciA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKylcbiAgICAgICAgZmluZGVyICs9IDQwICogYm0uY291bnRQYXR0ZXJuSW5Sb3coeSwgUDEubGVuLCBQMS5uLCBQMi5uKTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHdpZHRoOyB5KyspXG4gICAgICAgIGZpbmRlciArPSA0MCAqIHRyYW5zcG9zZWQuY291bnRQYXR0ZXJuSW5Sb3coeSwgUDEubGVuLCBQMS5uLCBQMi5uKTtcbiAgICAvLyBQcm9wb3J0aW9uIG9mIGRhcmsgbW9kdWxlcyBpbiBlbnRpcmUgc3ltYm9sXG4gICAgLy8gQWRkIDEwIHBvaW50cyB0byBhIGRldmlhdGlvbiBvZiA1JSBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGluIHRoZSBwcm9wb3J0aW9uXG4gICAgLy8gcmF0aW8gb2YgZGFyayBtb2R1bGUgZnJvbSB0aGUgcmVmZXJlbnRpYWwgNTAlXG4gICAgbGV0IGRhcmtQaXhlbHMgPSAwO1xuICAgIGRhcmtQaXhlbHMgPSBibS5wb3BjbnQoKTtcbiAgICAvL2JtLnJlY3RSZWFkKDAsIEluZmluaXR5LCAoX2MsIHZhbCkgPT4gKGRhcmtQaXhlbHMgKz0gdmFsID8gMSA6IDApKTtcbiAgICAvLyBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgLy8gICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIGlmIChibS5nZXQoeCwgeSkpIGRhcmtQaXhlbHMrKztcbiAgICAvLyB9XG4gICAgY29uc3QgZGFya1BlcmNlbnQgPSAoZGFya1BpeGVscyAvIChoZWlnaHQgKiB3aWR0aCkpICogMTAwO1xuICAgIGNvbnN0IGRhcmsgPSAxMCAqIE1hdGguZmxvb3IoTWF0aC5hYnMoZGFya1BlcmNlbnQgLSA1MCkgLyA1KTtcbiAgICByZXR1cm4gYWRqYWNlbnQgKyBib3ggKyBmaW5kZXIgKyBkYXJrO1xufVxuLy8gU2VsZWN0cyBiZXN0IG1hc2sgYWNjb3JkaW5nIHRvIHBlbmFsdHksIGlmIG5vIG1hc2sgaXMgcHJvdmlkZWRcbmZ1bmN0aW9uIGRyYXdRUkJlc3QodmVyLCBlY2MsIGRhdGEsIG1hc2tJZHgpIHtcbiAgICBpZiAobWFza0lkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJlc3RNYXNrID0gYmVzdCgpO1xuICAgICAgICBmb3IgKGxldCBtYXNrID0gMDsgbWFzayA8IFBBVFRFUk5TLmxlbmd0aDsgbWFzaysrKVxuICAgICAgICAgICAgYmVzdE1hc2suYWRkKHBlbmFsdHkoZHJhd1FSKHZlciwgZWNjLCBkYXRhLCBtYXNrLCB0cnVlKSksIG1hc2spO1xuICAgICAgICBtYXNrSWR4ID0gYmVzdE1hc2suZ2V0KCk7XG4gICAgfVxuICAgIGlmIChtYXNrSWR4ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgbWFzaycpOyAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgcmV0dXJuIGRyYXdRUih2ZXIsIGVjYywgZGF0YSwgbWFza0lkeCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUVDQyhlYykge1xuICAgIGlmICghRUNNb2RlLmluY2x1ZGVzKGVjKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGVycm9yIGNvcnJlY3Rpb24gbW9kZT0ke2VjfS4gRXhwZWN0ZWQ6ICR7RUNNb2RlfWApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFbmNvZGluZyhlbmMpIHtcbiAgICBpZiAoIUVuY29kaW5nLmluY2x1ZGVzKGVuYykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW5jb2Rpbmc6IGludmFsaWQgbW9kZT0ke2VuY30uIEV4cGVjdGVkOiAke0VuY29kaW5nfWApO1xuICAgIGlmIChlbmMgPT09ICdrYW5qaScgfHwgZW5jID09PSAnZWNpJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbmNvZGluZzogJHtlbmN9IGlzIG5vdCBzdXBwb3J0ZWQgKHlldD8pLmApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNYXNrKG1hc2spIHtcbiAgICBpZiAoIVswLCAxLCAyLCAzLCA0LCA1LCA2LCA3XS5pbmNsdWRlcyhtYXNrKSB8fCAhUEFUVEVSTlNbbWFza10pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtYXNrPSR7bWFza30uIEV4cGVjdGVkIG51bWJlciBbMC4uN11gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVRUih0ZXh0LCBvdXRwdXQgPSAncmF3Jywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZWNjID0gb3B0cy5lY2MgIT09IHVuZGVmaW5lZCA/IG9wdHMuZWNjIDogJ21lZGl1bSc7XG4gICAgdmFsaWRhdGVFQ0MoZWNjKTtcbiAgICBjb25zdCBlbmNvZGluZyA9IG9wdHMuZW5jb2RpbmcgIT09IHVuZGVmaW5lZCA/IG9wdHMuZW5jb2RpbmcgOiBkZXRlY3RUeXBlKHRleHQpO1xuICAgIHZhbGlkYXRlRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgIGlmIChvcHRzLm1hc2sgIT09IHVuZGVmaW5lZClcbiAgICAgICAgdmFsaWRhdGVNYXNrKG9wdHMubWFzayk7XG4gICAgbGV0IHZlciA9IG9wdHMudmVyc2lvbjtcbiAgICBsZXQgZGF0YSwgZXJyID0gbmV3IEVycm9yKCdVbmtub3duIGVycm9yJyk7XG4gICAgaWYgKHZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbGlkYXRlVmVyc2lvbih2ZXIpO1xuICAgICAgICBkYXRhID0gZW5jb2RlKHZlciwgZWNjLCB0ZXh0LCBlbmNvZGluZywgb3B0cy50ZXh0RW5jb2Rlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiBubyB2ZXJzaW9uIGlzIHByb3ZpZGVkLCB0cnkgdG8gZmluZCBzbWFsbGVzdCBvbmUgd2hpY2ggZml0c1xuICAgICAgICAvLyBDdXJyZW50bHkganVzdCBzY2FucyBhbGwgdmVyc2lvbiwgY2FuIGJlIHNpZ25pZmljYW50bHkgc3BlZWR1cCBpZiBuZWVkZWRcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNDA7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZW5jb2RlKGksIGVjYywgdGV4dCwgZW5jb2RpbmcsIG9wdHMudGV4dEVuY29kZXIpO1xuICAgICAgICAgICAgICAgIHZlciA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF2ZXIgfHwgIWRhdGEpXG4gICAgICAgIHRocm93IGVycjtcbiAgICBsZXQgcmVzID0gZHJhd1FSQmVzdCh2ZXIsIGVjYywgZGF0YSwgb3B0cy5tYXNrKTtcbiAgICByZXMuYXNzZXJ0RHJhd24oKTtcbiAgICBjb25zdCBib3JkZXIgPSBvcHRzLmJvcmRlciA9PT0gdW5kZWZpbmVkID8gMiA6IG9wdHMuYm9yZGVyO1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYm9yZGVyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGJvcmRlciB0eXBlPSR7dHlwZW9mIGJvcmRlcn1gKTtcbiAgICByZXMgPSByZXMuYm9yZGVyKGJvcmRlciwgZmFsc2UpOyAvLyBBZGQgYm9yZGVyXG4gICAgaWYgKG9wdHMuc2NhbGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmVzID0gcmVzLnNjYWxlKG9wdHMuc2NhbGUpOyAvLyBTY2FsZSBpbWFnZVxuICAgIGlmIChvdXRwdXQgPT09ICdyYXcnKVxuICAgICAgICByZXR1cm4gcmVzLnRvUmF3KCk7XG4gICAgZWxzZSBpZiAob3V0cHV0ID09PSAnYXNjaWknKVxuICAgICAgICByZXR1cm4gcmVzLnRvQVNDSUkoKTtcbiAgICBlbHNlIGlmIChvdXRwdXQgPT09ICdzdmcnKVxuICAgICAgICByZXR1cm4gcmVzLnRvU1ZHKG9wdHMub3B0aW1pemUpO1xuICAgIGVsc2UgaWYgKG91dHB1dCA9PT0gJ2dpZicpXG4gICAgICAgIHJldHVybiByZXMudG9HSUYoKTtcbiAgICBlbHNlIGlmIChvdXRwdXQgPT09ICd0ZXJtJylcbiAgICAgICAgcmV0dXJuIHJlcy50b1Rlcm0oKTtcbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvdXRwdXQ6ICR7b3V0cHV0fWApO1xufVxuZXhwb3J0IGRlZmF1bHQgZW5jb2RlUVI7XG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYmVzdCxcbiAgICBiaW4sXG4gICAgcG9wY250LFxuICAgIGRyYXdUZW1wbGF0ZSxcbiAgICBmaWxsQXJyLFxuICAgIGluZm8sXG4gICAgaW50ZXJsZWF2ZSxcbiAgICB2YWxpZGF0ZVZlcnNpb24sXG4gICAgemlnemFnLFxufTtcbi8vIFVuc2FmZSBBUEkgdXRpbHMsIGV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzXG5leHBvcnQgY29uc3QgX3Rlc3RzID0ge1xuICAgIEJpdG1hcCxcbiAgICBpbmZvLFxuICAgIGRldGVjdFR5cGUsXG4gICAgZW5jb2RlLFxuICAgIGRyYXdRUixcbiAgICBwZW5hbHR5LFxuICAgIFBBVFRFUk5TLFxufTtcbi8vIFR5cGUgdGVzdHNcbi8vIGNvbnN0IG8xID0gcXIoJ3Rlc3QnLCAnYXNjaWknKTtcbi8vIGNvbnN0IG8yID0gcXIoJ3Rlc3QnLCAncmF3Jyk7XG4vLyBjb25zdCBvMyA9IHFyKCd0ZXN0JywgJ2dpZicpO1xuLy8gY29uc3QgbzQgPSBxcigndGVzdCcsICdzdmcnKTtcbi8vIGNvbnN0IG81ID0gcXIoJ3Rlc3QnLCAndGVybScpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImNoQ29kZXMiLCJuZXdsaW5lIiwicmVzZXQiLCJhc3NlcnROdW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwidmFsaWRhdGVWZXJzaW9uIiwidmVyIiwiYmluIiwiZGVjIiwicGFkIiwidG9TdHJpbmciLCJwYWRTdGFydCIsIm1vZCIsImEiLCJiIiwicmVzdWx0IiwiZmlsbEFyciIsImxlbmd0aCIsInZhbCIsIkFycmF5IiwiZmlsbCIsInBvcGNudCIsImludGVybGVhdmVCeXRlcyIsImJsb2NrcyIsIm1heExlbiIsInRvdGFsTGVuIiwiYmxvY2siLCJNYXRoIiwibWF4IiwiVWludDhBcnJheSIsImlkeCIsImkiLCJiZXN0IiwiYmVzdFNjb3JlIiwiSW5maW5pdHkiLCJhZGQiLCJzY29yZSIsInZhbHVlIiwiZ2V0IiwiYWxwaGFiZXQiLCJoYXMiLCJjaGFyIiwiaW5jbHVkZXMiLCJkZWNvZGUiLCJpbnB1dCIsImlzQXJyYXkiLCJtYXAiLCJsZXR0ZXIiLCJpbmRleCIsImluZGV4T2YiLCJlbmNvZGUiLCJkaWdpdHMiLCJ0cmFuc3Bvc2UzMiIsIm1hc2tzIiwic3RhZ2UiLCJtIiwicyIsInN0ZXAiLCJrIiwiaTAiLCJpMSIsIngiLCJ5IiwidCIsImJpdE1hc2siLCJyYW5nZU1hc2siLCJzaGlmdCIsImxlbiIsIkJpdG1hcCIsInNpemUiLCJsaW1pdCIsImhlaWdodCIsIndpZHRoIiwidW5kZWZpbmVkIiwibWluIiwiZnJvbVN0cmluZyIsInJlcGxhY2UiLCJsaW5lcyIsInNwbGl0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicm93cyIsImxpbmUiLCJyb3ciLCJwdXNoIiwiY29uc3RydWN0b3IiLCJkYXRhIiwidGFpbE1hc2siLCJ3b3JkcyIsImNlaWwiLCJmdWxsV29yZHMiLCJmbG9vciIsIlVpbnQzMkFycmF5IiwiZGVmaW5lZCIsInNldCIsInBvaW50IiwicCIsImlzSW5zaWRlIiwib2Zmc2V0IiwieHkiLCJjIiwid29yZEluZGV4IiwiYml0SW5kZXgiLCJ3b3JkIiwiYml0IiwiaXNEZWZpbmVkIiwid2kiLCJtYXNrV29yZCIsIm1hc2siLCJ2IiwiZmlsbFJlY3RDb25zdCIsIngwIiwieTAiLCJ3IiwiaCIsInN0YXJ0V29yZCIsImVuZFdvcmQiLCJzdGFydEJpdCIsImVuZEJpdCIsInJ5Iiwicm93QmFzZSIsInJlY3RXb3JkcyIsImNiIiwieVBvcyIsIlB5IiwieFBvcyIsImJpdFgiLCJiaXRzUGVyV29yZCIsInJlY3QiLCJmbiIsImRlZldvcmQiLCJ2YWxXb3JkIiwicmVzIiwicmVjdFJlYWQiLCJoTGluZSIsInZMaW5lIiwiYm9yZGVyIiwib3V0IiwiZW1iZWQiLCJzcmMiLCJzcmNTdHJpZGUiLCJzcmNWYWx1ZSIsInNyY1JvdyIsImRzdFgiLCJkc3RXb3JkIiwiZHN0Qml0Iiwic3JjV29yZCIsInNyY0JpdCIsIncwIiwidzEiLCJzVmFsIiwiZHN0TWFzayIsInZhbEJpdHMiLCJyZWN0U2xpY2UiLCJjdXIiLCJ0cmFuc3Bvc2UiLCJkc3QiLCJkc3RTdHJpZGUiLCJkc3RWYWx1ZSIsImRzdERlZmluZWQiLCJkc3RUYWlsIiwidG1wViIsInRtcEQiLCJieSIsImJ4IiwiciIsImRzdFkiLCJkc3RQb3MiLCJjdXJNYXNrIiwibmVnYXRlIiwic2NhbGUiLCJmYWN0b3IiLCJjbG9uZSIsImFzc2VydERyYXduIiwiY291bnRQYXR0ZXJuSW5Sb3ciLCJwYXR0ZXJuTGVuIiwicGF0dGVybnMiLCJjb3VudCIsIndpbmRvdyIsImJpdEVuZCIsImdldFJ1bnMiLCJydW5MZW4iLCJydW5WYWx1ZSIsImNvdW50Qm94ZXMyeDIiLCJiYXNlMCIsImJhc2UxIiwidGFpbEJpdHMiLCJ2YWxpZExhc3QiLCJib3hlcyIsImEwIiwiYTEiLCJlcVYiLCJuMCIsImVxSDAiLCJuMSIsImVxSDEiLCJubCIsInRvUmF3IiwiZnJvbSIsInRvQVNDSUkiLCJmaXJzdCIsInNlY29uZCIsInRvVGVybSIsImNjIiwid2hpdGVCRyIsImRhcmtCRyIsInRvU1ZHIiwib3B0aW1pemUiLCJwYXRoRGF0YSIsInByZXZQb2ludCIsInJlbE0iLCJiSCIsInRvR0lGIiwidTE2bGUiLCJkaW1zIiwiXyIsIk4iLCJieXRlcyIsImZ1bGxDaHVua3MiLCJzbGljZSIsInRvSW1hZ2UiLCJpc1JHQiIsIkVDTW9kZSIsIkVuY29kaW5nIiwiQllURVMiLCJXT1JEU19QRVJfQkxPQ0siLCJsb3ciLCJtZWRpdW0iLCJxdWFydGlsZSIsImhpZ2giLCJFQ0NfQkxPQ0tTIiwiaW5mbyIsInNpemVUeXBlIiwiYWxpZ25tZW50UGF0dGVybnMiLCJsYXN0IiwiZGlzdGFuY2UiLCJpbnRlcnZhbCIsIkVDQ29kZSIsImZvcm1hdE1hc2siLCJmb3JtYXRCaXRzIiwiZWNjIiwibWFza0lkeCIsImQiLCJ2ZXJzaW9uQml0cyIsIm51bWVyaWMiLCJhbHBoYW51bWVyYyIsImxlbmd0aEJpdHMiLCJ0eXBlIiwidGFibGUiLCJhbHBoYW51bWVyaWMiLCJieXRlIiwia2FuamkiLCJlY2kiLCJtb2RlQml0cyIsImNhcGFjaXR5IiwibnVtQmxvY2tzIiwiYmxvY2tMZW4iLCJzaG9ydEJsb2NrcyIsInRvdGFsIiwiUEFUVEVSTlMiLCJfeCIsIl95IiwiR0YiLCJ0YWJsZXMiLCJwX3BvbHkiLCJleHAiLCJsb2ciLCJtdWwiLCJwb3ciLCJlIiwiaW52IiwicG9seW5vbWlhbCIsInBvbHkiLCJtb25vbWlhbCIsImRlZ3JlZSIsImNvZWZmaWNpZW50IiwiY29lZmZpY2llbnRzIiwibXVsUG9seSIsImoiLCJtdWxQb2x5U2NhbGFyIiwic2NhbGFyIiwibXVsUG9seU1vbm9taWFsIiwiYWRkUG9seSIsInNtYWxsZXIiLCJsYXJnZXIiLCJzdW1EaWZmIiwibGVuZ3RoRGlmZiIsInJlbWFpbmRlclBvbHkiLCJkaXZpc29yIiwiZWxtIiwiZGl2aXNvclBvbHkiLCJnIiwiZXZhbFBvbHkiLCJldWNsaWRpYW4iLCJSIiwickxhc3QiLCJ0TGFzdCIsInJMYXN0TGFzdCIsInRMYXN0TGFzdCIsInEiLCJkbHRJbnZlcnNlIiwiZGVncmVlRGlmZiIsInNpZ21hVGlsZGVBdFplcm8iLCJpbnZlcnNlIiwiUlMiLCJlY2NXb3JkcyIsInBvbCIsInRvIiwic3luZHJvbWUiLCJoYXNFcnJvciIsImV2bCIsImVycm9yTG9jYXRvciIsImVycm9yRXZhbHVhdG9yIiwibG9jYXRpb25zIiwicG9zIiwieGlJbnZlcnNlIiwiZGVub21pbmF0b3IiLCJpbnRlcmxlYXZlIiwicnMiLCJlY2NCbG9ja3MiLCJpc1Nob3J0Iiwic3ViYXJyYXkiLCJyZXNCbG9ja3MiLCJyZXNFQ0MiLCJkcmF3VGVtcGxhdGUiLCJ0ZXN0IiwiZmluZGVyIiwiYWxpZ24iLCJhbGlnblBvcyIsImJpdHMiLCJnZXRCaXQiLCJ6aWd6YWciLCJ0cGwiLCJwYXR0ZXJuIiwiZGlyIiwieE9mZnNldCIsImRldGVjdFR5cGUiLCJzdHIiLCJ1dGY4VG9CeXRlcyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlciIsImVuY29kZWQiLCJkYXRhTGVuIiwidXRmOCIsImpvaW4iLCJyZXBlYXQiLCJwYWRkaW5nIiwibWF0Y2giLCJkcmF3UVIiLCJuZWVkIiwibWtQYXR0ZXJuIiwiZmluZGVyUGF0dGVybiIsImxpZ2h0UGF0dGVybiIsIlAxIiwiUDIiLCJwZW5hbHR5IiwiYm0iLCJ0cmFuc3Bvc2VkIiwiYWRqYWNlbnQiLCJib3giLCJkYXJrUGl4ZWxzIiwiZGFya1BlcmNlbnQiLCJkYXJrIiwiYWJzIiwiZHJhd1FSQmVzdCIsImJlc3RNYXNrIiwidmFsaWRhdGVFQ0MiLCJlYyIsInZhbGlkYXRlRW5jb2RpbmciLCJlbmMiLCJ2YWxpZGF0ZU1hc2siLCJlbmNvZGVRUiIsInRleHQiLCJvdXRwdXQiLCJvcHRzIiwiZW5jb2RpbmciLCJ2ZXJzaW9uIiwiZXJyIiwidGV4dEVuY29kZXIiLCJ1dGlscyIsIl90ZXN0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/qr/index.js\n");

/***/ })

};
;