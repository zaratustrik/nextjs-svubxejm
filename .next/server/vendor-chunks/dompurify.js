"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dompurify";
exports.ids = ["vendor-chunks/dompurify"];
exports.modules = {

/***/ "(ssr)/./node_modules/dompurify/dist/purify.cjs.js":
/*!***************************************************!*\
  !*** ./node_modules/dompurify/dist/purify.cjs.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE */ \nconst { entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor } = Object;\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== \"undefined\" && Reflect;\nif (!freeze) {\n    freeze = function freeze(x) {\n        return x;\n    };\n}\nif (!seal) {\n    seal = function seal(x) {\n        return x;\n    };\n}\nif (!apply) {\n    apply = function apply(func, thisArg) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        return func.apply(thisArg, args);\n    };\n}\nif (!construct) {\n    construct = function construct(Func) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        return new Func(...args);\n    };\n}\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySplice = unapply(Array.prototype.splice);\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\nconst regExpTest = unapply(RegExp.prototype.test);\nconst typeErrorCreate = unconstruct(TypeError);\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */ function unapply(func) {\n    return function(thisArg) {\n        if (thisArg instanceof RegExp) {\n            thisArg.lastIndex = 0;\n        }\n        for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){\n            args[_key3 - 1] = arguments[_key3];\n        }\n        return apply(func, thisArg, args);\n    };\n}\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */ function unconstruct(Func) {\n    return function() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return construct(Func, args);\n    };\n}\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */ function addToSet(set, array) {\n    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n    if (setPrototypeOf) {\n        // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n    }\n    let l = array.length;\n    while(l--){\n        let element = array[l];\n        if (typeof element === \"string\") {\n            const lcElement = transformCaseFunc(element);\n            if (lcElement !== element) {\n                // Config presets (e.g. tags.js, attrs.js) are immutable.\n                if (!isFrozen(array)) {\n                    array[l] = lcElement;\n                }\n                element = lcElement;\n            }\n        }\n        set[element] = true;\n    }\n    return set;\n}\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */ function cleanArray(array) {\n    for(let index = 0; index < array.length; index++){\n        const isPropertyExist = objectHasOwnProperty(array, index);\n        if (!isPropertyExist) {\n            array[index] = null;\n        }\n    }\n    return array;\n}\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */ function clone(object) {\n    const newObject = create(null);\n    for (const [property, value] of entries(object)){\n        const isPropertyExist = objectHasOwnProperty(object, property);\n        if (isPropertyExist) {\n            if (Array.isArray(value)) {\n                newObject[property] = cleanArray(value);\n            } else if (value && typeof value === \"object\" && value.constructor === Object) {\n                newObject[property] = clone(value);\n            } else {\n                newObject[property] = value;\n            }\n        }\n    }\n    return newObject;\n}\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */ function lookupGetter(object, prop) {\n    while(object !== null){\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n            if (desc.get) {\n                return unapply(desc.get);\n            }\n            if (typeof desc.value === \"function\") {\n                return unapply(desc.value);\n            }\n        }\n        object = getPrototypeOf(object);\n    }\n    function fallbackValue() {\n        return null;\n    }\n    return fallbackValue;\n}\nconst html$1 = freeze([\n    \"a\",\n    \"abbr\",\n    \"acronym\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blink\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"center\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"content\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"decorator\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"element\",\n    \"em\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"font\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meter\",\n    \"nav\",\n    \"nobr\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"search\",\n    \"section\",\n    \"select\",\n    \"shadow\",\n    \"slot\",\n    \"small\",\n    \"source\",\n    \"spacer\",\n    \"span\",\n    \"strike\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"template\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"track\",\n    \"tt\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\"\n]);\nconst svg$1 = freeze([\n    \"svg\",\n    \"a\",\n    \"altglyph\",\n    \"altglyphdef\",\n    \"altglyphitem\",\n    \"animatecolor\",\n    \"animatemotion\",\n    \"animatetransform\",\n    \"circle\",\n    \"clippath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"enterkeyhint\",\n    \"exportparts\",\n    \"filter\",\n    \"font\",\n    \"g\",\n    \"glyph\",\n    \"glyphref\",\n    \"hkern\",\n    \"image\",\n    \"inputmode\",\n    \"line\",\n    \"lineargradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"mpath\",\n    \"part\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialgradient\",\n    \"rect\",\n    \"stop\",\n    \"style\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textpath\",\n    \"title\",\n    \"tref\",\n    \"tspan\",\n    \"view\",\n    \"vkern\"\n]);\nconst svgFilters = freeze([\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\"\n]);\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nconst svgDisallowed = freeze([\n    \"animate\",\n    \"color-profile\",\n    \"cursor\",\n    \"discard\",\n    \"font-face\",\n    \"font-face-format\",\n    \"font-face-name\",\n    \"font-face-src\",\n    \"font-face-uri\",\n    \"foreignobject\",\n    \"hatch\",\n    \"hatchpath\",\n    \"mesh\",\n    \"meshgradient\",\n    \"meshpatch\",\n    \"meshrow\",\n    \"missing-glyph\",\n    \"script\",\n    \"set\",\n    \"solidcolor\",\n    \"unknown\",\n    \"use\"\n]);\nconst mathMl$1 = freeze([\n    \"math\",\n    \"menclose\",\n    \"merror\",\n    \"mfenced\",\n    \"mfrac\",\n    \"mglyph\",\n    \"mi\",\n    \"mlabeledtr\",\n    \"mmultiscripts\",\n    \"mn\",\n    \"mo\",\n    \"mover\",\n    \"mpadded\",\n    \"mphantom\",\n    \"mroot\",\n    \"mrow\",\n    \"ms\",\n    \"mspace\",\n    \"msqrt\",\n    \"mstyle\",\n    \"msub\",\n    \"msup\",\n    \"msubsup\",\n    \"mtable\",\n    \"mtd\",\n    \"mtext\",\n    \"mtr\",\n    \"munder\",\n    \"munderover\",\n    \"mprescripts\"\n]);\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nconst mathMlDisallowed = freeze([\n    \"maction\",\n    \"maligngroup\",\n    \"malignmark\",\n    \"mlongdiv\",\n    \"mscarries\",\n    \"mscarry\",\n    \"msgroup\",\n    \"mstack\",\n    \"msline\",\n    \"msrow\",\n    \"semantics\",\n    \"annotation\",\n    \"annotation-xml\",\n    \"mprescripts\",\n    \"none\"\n]);\nconst text = freeze([\n    \"#text\"\n]);\nconst html = freeze([\n    \"accept\",\n    \"action\",\n    \"align\",\n    \"alt\",\n    \"autocapitalize\",\n    \"autocomplete\",\n    \"autopictureinpicture\",\n    \"autoplay\",\n    \"background\",\n    \"bgcolor\",\n    \"border\",\n    \"capture\",\n    \"cellpadding\",\n    \"cellspacing\",\n    \"checked\",\n    \"cite\",\n    \"class\",\n    \"clear\",\n    \"color\",\n    \"cols\",\n    \"colspan\",\n    \"controls\",\n    \"controlslist\",\n    \"coords\",\n    \"crossorigin\",\n    \"datetime\",\n    \"decoding\",\n    \"default\",\n    \"dir\",\n    \"disabled\",\n    \"disablepictureinpicture\",\n    \"disableremoteplayback\",\n    \"download\",\n    \"draggable\",\n    \"enctype\",\n    \"enterkeyhint\",\n    \"exportparts\",\n    \"face\",\n    \"for\",\n    \"headers\",\n    \"height\",\n    \"hidden\",\n    \"high\",\n    \"href\",\n    \"hreflang\",\n    \"id\",\n    \"inert\",\n    \"inputmode\",\n    \"integrity\",\n    \"ismap\",\n    \"kind\",\n    \"label\",\n    \"lang\",\n    \"list\",\n    \"loading\",\n    \"loop\",\n    \"low\",\n    \"max\",\n    \"maxlength\",\n    \"media\",\n    \"method\",\n    \"min\",\n    \"minlength\",\n    \"multiple\",\n    \"muted\",\n    \"name\",\n    \"nonce\",\n    \"noshade\",\n    \"novalidate\",\n    \"nowrap\",\n    \"open\",\n    \"optimum\",\n    \"part\",\n    \"pattern\",\n    \"placeholder\",\n    \"playsinline\",\n    \"popover\",\n    \"popovertarget\",\n    \"popovertargetaction\",\n    \"poster\",\n    \"preload\",\n    \"pubdate\",\n    \"radiogroup\",\n    \"readonly\",\n    \"rel\",\n    \"required\",\n    \"rev\",\n    \"reversed\",\n    \"role\",\n    \"rows\",\n    \"rowspan\",\n    \"spellcheck\",\n    \"scope\",\n    \"selected\",\n    \"shape\",\n    \"size\",\n    \"sizes\",\n    \"slot\",\n    \"span\",\n    \"srclang\",\n    \"start\",\n    \"src\",\n    \"srcset\",\n    \"step\",\n    \"style\",\n    \"summary\",\n    \"tabindex\",\n    \"title\",\n    \"translate\",\n    \"type\",\n    \"usemap\",\n    \"valign\",\n    \"value\",\n    \"width\",\n    \"wrap\",\n    \"xmlns\",\n    \"slot\"\n]);\nconst svg = freeze([\n    \"accent-height\",\n    \"accumulate\",\n    \"additive\",\n    \"alignment-baseline\",\n    \"amplitude\",\n    \"ascent\",\n    \"attributename\",\n    \"attributetype\",\n    \"azimuth\",\n    \"basefrequency\",\n    \"baseline-shift\",\n    \"begin\",\n    \"bias\",\n    \"by\",\n    \"class\",\n    \"clip\",\n    \"clippathunits\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"color\",\n    \"color-interpolation\",\n    \"color-interpolation-filters\",\n    \"color-profile\",\n    \"color-rendering\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"dx\",\n    \"dy\",\n    \"diffuseconstant\",\n    \"direction\",\n    \"display\",\n    \"divisor\",\n    \"dur\",\n    \"edgemode\",\n    \"elevation\",\n    \"end\",\n    \"exponent\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"filter\",\n    \"filterunits\",\n    \"flood-color\",\n    \"flood-opacity\",\n    \"font-family\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-variant\",\n    \"font-weight\",\n    \"fx\",\n    \"fy\",\n    \"g1\",\n    \"g2\",\n    \"glyph-name\",\n    \"glyphref\",\n    \"gradientunits\",\n    \"gradienttransform\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"image-rendering\",\n    \"in\",\n    \"in2\",\n    \"intercept\",\n    \"k\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"kerning\",\n    \"keypoints\",\n    \"keysplines\",\n    \"keytimes\",\n    \"lang\",\n    \"lengthadjust\",\n    \"letter-spacing\",\n    \"kernelmatrix\",\n    \"kernelunitlength\",\n    \"lighting-color\",\n    \"local\",\n    \"marker-end\",\n    \"marker-mid\",\n    \"marker-start\",\n    \"markerheight\",\n    \"markerunits\",\n    \"markerwidth\",\n    \"maskcontentunits\",\n    \"maskunits\",\n    \"max\",\n    \"mask\",\n    \"mask-type\",\n    \"media\",\n    \"method\",\n    \"mode\",\n    \"min\",\n    \"name\",\n    \"numoctaves\",\n    \"offset\",\n    \"operator\",\n    \"opacity\",\n    \"order\",\n    \"orient\",\n    \"orientation\",\n    \"origin\",\n    \"overflow\",\n    \"paint-order\",\n    \"path\",\n    \"pathlength\",\n    \"patterncontentunits\",\n    \"patterntransform\",\n    \"patternunits\",\n    \"points\",\n    \"preservealpha\",\n    \"preserveaspectratio\",\n    \"primitiveunits\",\n    \"r\",\n    \"rx\",\n    \"ry\",\n    \"radius\",\n    \"refx\",\n    \"refy\",\n    \"repeatcount\",\n    \"repeatdur\",\n    \"restart\",\n    \"result\",\n    \"rotate\",\n    \"scale\",\n    \"seed\",\n    \"shape-rendering\",\n    \"slope\",\n    \"specularconstant\",\n    \"specularexponent\",\n    \"spreadmethod\",\n    \"startoffset\",\n    \"stddeviation\",\n    \"stitchtiles\",\n    \"stop-color\",\n    \"stop-opacity\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-linecap\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke\",\n    \"stroke-width\",\n    \"style\",\n    \"surfacescale\",\n    \"systemlanguage\",\n    \"tabindex\",\n    \"tablevalues\",\n    \"targetx\",\n    \"targety\",\n    \"transform\",\n    \"transform-origin\",\n    \"text-anchor\",\n    \"text-decoration\",\n    \"text-rendering\",\n    \"textlength\",\n    \"type\",\n    \"u1\",\n    \"u2\",\n    \"unicode\",\n    \"values\",\n    \"viewbox\",\n    \"visibility\",\n    \"version\",\n    \"vert-adv-y\",\n    \"vert-origin-x\",\n    \"vert-origin-y\",\n    \"width\",\n    \"word-spacing\",\n    \"wrap\",\n    \"writing-mode\",\n    \"xchannelselector\",\n    \"ychannelselector\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"xmlns\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"z\",\n    \"zoomandpan\"\n]);\nconst mathMl = freeze([\n    \"accent\",\n    \"accentunder\",\n    \"align\",\n    \"bevelled\",\n    \"close\",\n    \"columnsalign\",\n    \"columnlines\",\n    \"columnspan\",\n    \"denomalign\",\n    \"depth\",\n    \"dir\",\n    \"display\",\n    \"displaystyle\",\n    \"encoding\",\n    \"fence\",\n    \"frame\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"largeop\",\n    \"length\",\n    \"linethickness\",\n    \"lspace\",\n    \"lquote\",\n    \"mathbackground\",\n    \"mathcolor\",\n    \"mathsize\",\n    \"mathvariant\",\n    \"maxsize\",\n    \"minsize\",\n    \"movablelimits\",\n    \"notation\",\n    \"numalign\",\n    \"open\",\n    \"rowalign\",\n    \"rowlines\",\n    \"rowspacing\",\n    \"rowspan\",\n    \"rspace\",\n    \"rquote\",\n    \"scriptlevel\",\n    \"scriptminsize\",\n    \"scriptsizemultiplier\",\n    \"selection\",\n    \"separator\",\n    \"separators\",\n    \"stretchy\",\n    \"subscriptshift\",\n    \"supscriptshift\",\n    \"symmetric\",\n    \"voffset\",\n    \"width\",\n    \"xmlns\"\n]);\nconst xml = freeze([\n    \"xlink:href\",\n    \"xml:id\",\n    \"xlink:title\",\n    \"xml:space\",\n    \"xmlns:xlink\"\n]);\n// eslint-disable-next-line unicorn/better-regex\nconst MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nconst ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nconst TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nconst DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nconst ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nconst IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nconst IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nconst ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nconst DOCTYPE_NAME = seal(/^html$/i);\nconst CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\nvar EXPRESSIONS = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ARIA_ATTR: ARIA_ATTR,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    CUSTOM_ELEMENT: CUSTOM_ELEMENT,\n    DATA_ATTR: DATA_ATTR,\n    DOCTYPE_NAME: DOCTYPE_NAME,\n    ERB_EXPR: ERB_EXPR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR\n});\n/* eslint-disable @typescript-eslint/indent */ // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n    element: 1,\n    attribute: 2,\n    text: 3,\n    cdataSection: 4,\n    entityReference: 5,\n    // Deprecated\n    entityNode: 6,\n    // Deprecated\n    progressingInstruction: 7,\n    comment: 8,\n    document: 9,\n    documentType: 10,\n    documentFragment: 11,\n    notation: 12 // Deprecated\n};\nconst getGlobal = function getGlobal() {\n    return  true ? null : 0;\n};\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== \"object\" || typeof trustedTypes.createPolicy !== \"function\") {\n        return null;\n    }\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    let suffix = null;\n    const ATTR_NAME = \"data-tt-policy-suffix\";\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    const policyName = \"dompurify\" + (suffix ? \"#\" + suffix : \"\");\n    try {\n        return trustedTypes.createPolicy(policyName, {\n            createHTML (html) {\n                return html;\n            },\n            createScriptURL (scriptUrl) {\n                return scriptUrl;\n            }\n        });\n    } catch (_) {\n        // Policy creation failed (most likely another DOMPurify script has\n        // already run). Skip creating the policy, as this will only cause errors\n        // if TT are enforced.\n        console.warn(\"TrustedTypes policy \" + policyName + \" could not be created.\");\n        return null;\n    }\n};\nconst _createHooksMap = function _createHooksMap() {\n    return {\n        afterSanitizeAttributes: [],\n        afterSanitizeElements: [],\n        afterSanitizeShadowDOM: [],\n        beforeSanitizeAttributes: [],\n        beforeSanitizeElements: [],\n        beforeSanitizeShadowDOM: [],\n        uponSanitizeAttribute: [],\n        uponSanitizeElement: [],\n        uponSanitizeShadowNode: []\n    };\n};\nfunction createDOMPurify() {\n    let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    const DOMPurify = (root)=>createDOMPurify(root);\n    DOMPurify.version = \"3.3.1\";\n    DOMPurify.removed = [];\n    if (!window1 || !window1.document || window1.document.nodeType !== NODE_TYPE.document || !window1.Element) {\n        // Not running in a browser, provide a factory function\n        // so that you can pass your own Window\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n    }\n    let { document } = window1;\n    const originalDocument = document;\n    const currentScript = originalDocument.currentScript;\n    const { DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes } = window1;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n    const remove = lookupGetter(ElementPrototype, \"remove\");\n    const getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n    const getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n    const getParentNode = lookupGetter(ElementPrototype, \"parentNode\");\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === \"function\") {\n        const template = document.createElement(\"template\");\n        if (template.content && template.content.ownerDocument) {\n            document = template.content.ownerDocument;\n        }\n    }\n    let trustedTypesPolicy;\n    let emptyHTML = \"\";\n    const { implementation, createNodeIterator, createDocumentFragment, getElementsByTagName } = document;\n    const { importNode } = originalDocument;\n    let hooks = _createHooksMap();\n    /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */ DOMPurify.isSupported = typeof entries === \"function\" && typeof getParentNode === \"function\" && implementation && implementation.createHTMLDocument !== undefined;\n    const { MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, CUSTOM_ELEMENT } = EXPRESSIONS;\n    let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;\n    /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */ /* allowed element names */ let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n    ]);\n    /* Allowed attribute names */ let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n    ]);\n    /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */ let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n        tagNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        allowCustomizedBuiltInElements: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: false\n        }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;\n    /* Config object to store ADD_TAGS/ADD_ATTR functions (when used as functions) */ const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {\n        tagCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        }\n    }));\n    /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */ let SAFE_FOR_TEMPLATES = false;\n    /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */ let SAFE_FOR_XML = true;\n    /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */ let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */ let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (§7.3.3)\n   *   - DOM Tree Accessors (§3.1.5)\n   *   - Form Element Parent-Child Relations (§4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n   *   - HTMLCollection (§4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */ let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = \"user-content-\";\n    /* Keep element content when removing element? */ let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        \"annotation-xml\",\n        \"audio\",\n        \"colgroup\",\n        \"desc\",\n        \"foreignobject\",\n        \"head\",\n        \"iframe\",\n        \"math\",\n        \"mi\",\n        \"mn\",\n        \"mo\",\n        \"ms\",\n        \"mtext\",\n        \"noembed\",\n        \"noframes\",\n        \"noscript\",\n        \"plaintext\",\n        \"script\",\n        \"style\",\n        \"svg\",\n        \"template\",\n        \"thead\",\n        \"title\",\n        \"video\",\n        \"xmp\"\n    ]);\n    /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        \"audio\",\n        \"video\",\n        \"img\",\n        \"source\",\n        \"image\",\n        \"track\"\n    ]);\n    /* Attributes safe for values like \"javascript:\" */ let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        \"alt\",\n        \"class\",\n        \"for\",\n        \"id\",\n        \"label\",\n        \"name\",\n        \"pattern\",\n        \"placeholder\",\n        \"role\",\n        \"summary\",\n        \"title\",\n        \"value\",\n        \"style\",\n        \"xmlns\"\n    ]);\n    const MATHML_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n    const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n    const HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n    /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n    ], stringToString);\n    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        \"mi\",\n        \"mo\",\n        \"mn\",\n        \"ms\",\n        \"mtext\"\n    ]);\n    let HTML_INTEGRATION_POINTS = addToSet({}, [\n        \"annotation-xml\"\n    ]);\n    // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        \"title\",\n        \"style\",\n        \"font\",\n        \"a\",\n        \"script\"\n    ]);\n    /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE = null;\n    const SUPPORTED_PARSER_MEDIA_TYPES = [\n        \"application/xhtml+xml\",\n        \"text/html\"\n    ];\n    const DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n    let transformCaseFunc = null;\n    /* Keep a reference to config to pass to hooks */ let CONFIG = null;\n    /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement(\"form\");\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */ // eslint-disable-next-line complexity\n    const _parseConfig = function _parseConfig() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (CONFIG && CONFIG === cfg) {\n            return;\n        }\n        /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== \"object\") {\n            cfg = {};\n        }\n        /* Shield configuration object from prototype pollution */ cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n        transformCaseFunc = PARSER_MEDIA_TYPE === \"application/xhtml+xml\" ? stringToString : stringToLowerCase;\n        /* Set configuration parameters */ ALLOWED_TAGS = objectHasOwnProperty(cfg, \"ALLOWED_TAGS\") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = objectHasOwnProperty(cfg, \"ALLOWED_ATTR\") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, \"ALLOWED_NAMESPACES\") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, \"ADD_URI_SAFE_ATTR\") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = objectHasOwnProperty(cfg, \"ADD_DATA_URI_TAGS\") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = objectHasOwnProperty(cfg, \"FORBID_CONTENTS\") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = objectHasOwnProperty(cfg, \"FORBID_TAGS\") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});\n        FORBID_ATTR = objectHasOwnProperty(cfg, \"FORBID_ATTR\") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});\n        USE_PROFILES = objectHasOwnProperty(cfg, \"USE_PROFILES\") ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n        RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n        FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n        IN_PLACE = cfg.IN_PLACE || false; // Default false\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") {\n            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n            ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n            RETURN_DOM = true;\n        }\n        /* Parse profile info */ if (USE_PROFILES) {\n            ALLOWED_TAGS = addToSet({}, text);\n            ALLOWED_ATTR = [];\n            if (USE_PROFILES.html === true) {\n                addToSet(ALLOWED_TAGS, html$1);\n                addToSet(ALLOWED_ATTR, html);\n            }\n            if (USE_PROFILES.svg === true) {\n                addToSet(ALLOWED_TAGS, svg$1);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.svgFilters === true) {\n                addToSet(ALLOWED_TAGS, svgFilters);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.mathMl === true) {\n                addToSet(ALLOWED_TAGS, mathMl$1);\n                addToSet(ALLOWED_ATTR, mathMl);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n        }\n        /* Merge configuration parameters */ if (cfg.ADD_TAGS) {\n            if (typeof cfg.ADD_TAGS === \"function\") {\n                EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;\n            } else {\n                if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n                    ALLOWED_TAGS = clone(ALLOWED_TAGS);\n                }\n                addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n            }\n        }\n        if (cfg.ADD_ATTR) {\n            if (typeof cfg.ADD_ATTR === \"function\") {\n                EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;\n            } else {\n                if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n                    ALLOWED_ATTR = clone(ALLOWED_ATTR);\n                }\n                addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n            }\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n                FORBID_CONTENTS = clone(FORBID_CONTENTS);\n            }\n            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        if (cfg.ADD_FORBID_CONTENTS) {\n            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n                FORBID_CONTENTS = clone(FORBID_CONTENTS);\n            }\n            addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);\n        }\n        /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) {\n            ALLOWED_TAGS[\"#text\"] = true;\n        }\n        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) {\n            addToSet(ALLOWED_TAGS, [\n                \"html\",\n                \"head\",\n                \"body\"\n            ]);\n        }\n        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {\n            addToSet(ALLOWED_TAGS, [\n                \"tbody\"\n            ]);\n            delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n            }\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n            }\n            // Overwrite existing TrustedTypes policy.\n            trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n            // Sign local variables required by `sanitize`.\n            emptyHTML = trustedTypesPolicy.createHTML(\"\");\n        } else {\n            // Uninitialized policy, attempt to initialize the internal dompurify policy.\n            if (trustedTypesPolicy === undefined) {\n                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n            }\n            // If creating the internal policy succeeded sign internal variables.\n            if (trustedTypesPolicy !== null && typeof emptyHTML === \"string\") {\n                emptyHTML = trustedTypesPolicy.createHTML(\"\");\n            }\n        }\n        // Prevent further manipulation of configuration.\n        // Not available in IE8, Safari 5, etc.\n        if (freeze) {\n            freeze(cfg);\n        }\n        CONFIG = cfg;\n    };\n    /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */ const ALL_SVG_TAGS = addToSet({}, [\n        ...svg$1,\n        ...svgFilters,\n        ...svgDisallowed\n    ]);\n    const ALL_MATHML_TAGS = addToSet({}, [\n        ...mathMl$1,\n        ...mathMlDisallowed\n    ]);\n    /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */ const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        // In JSDOM, if we're inside shadow DOM, then parentNode\n        // can be null. We just simulate parent in this case.\n        if (!parent || !parent.tagName) {\n            parent = {\n                namespaceURI: NAMESPACE,\n                tagName: \"template\"\n            };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n            // The only way to switch from HTML namespace to SVG\n            // is via <svg>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"svg\";\n            }\n            // The only way to switch from MathML to SVG is via`\n            // svg if parent is either <annotation-xml> or MathML\n            // text integration points.\n            if (parent.namespaceURI === MATHML_NAMESPACE) {\n                return tagName === \"svg\" && (parentTagName === \"annotation-xml\" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n            }\n            // We only allow elements that are defined in SVG\n            // spec. All others are disallowed in SVG namespace.\n            return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n            // The only way to switch from HTML namespace to MathML\n            // is via <math>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"math\";\n            }\n            // The only way to switch from SVG to MathML is via\n            // <math> and HTML integration points\n            if (parent.namespaceURI === SVG_NAMESPACE) {\n                return tagName === \"math\" && HTML_INTEGRATION_POINTS[parentTagName];\n            }\n            // We only allow elements that are defined in MathML\n            // spec. All others are disallowed in MathML namespace.\n            return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n            // The only way to switch from SVG to HTML is via\n            // HTML integration points, and from MathML to HTML\n            // is via MathML text integration points\n            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            // We disallow tags that are specific for MathML\n            // or SVG and should never appear in HTML namespace\n            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        // For XHTML and XML documents that support custom namespaces\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return true;\n        }\n        // The code should never reach this place (this means\n        // that the element somehow got namespace that is not\n        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n        // Return false just in case.\n        return false;\n    };\n    /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */ const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, {\n            element: node\n        });\n        try {\n            // eslint-disable-next-line unicorn/prefer-dom-node-remove\n            getParentNode(node).removeChild(node);\n        } catch (_) {\n            remove(node);\n        }\n    };\n    /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */ const _removeAttribute = function _removeAttribute(name, element) {\n        try {\n            arrayPush(DOMPurify.removed, {\n                attribute: element.getAttributeNode(name),\n                from: element\n            });\n        } catch (_) {\n            arrayPush(DOMPurify.removed, {\n                attribute: null,\n                from: element\n            });\n        }\n        element.removeAttribute(name);\n        // We void attribute values for unremovable \"is\" attributes\n        if (name === \"is\") {\n            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n                try {\n                    _forceRemove(element);\n                } catch (_) {}\n            } else {\n                try {\n                    element.setAttribute(name, \"\");\n                } catch (_) {}\n            }\n        }\n    };\n    /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */ const _initDocument = function _initDocument(dirty) {\n        /* Create a HTML document */ let doc = null;\n        let leadingWhitespace = null;\n        if (FORCE_BODY) {\n            dirty = \"<remove></remove>\" + dirty;\n        } else {\n            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n            leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && NAMESPACE === HTML_NAMESPACE) {\n            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n            dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + \"</body></html>\";\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */ if (NAMESPACE === HTML_NAMESPACE) {\n            try {\n                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n            } catch (_) {}\n        }\n        /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {\n            doc = implementation.createDocument(NAMESPACE, \"template\", null);\n            try {\n                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n            } catch (_) {\n            // Syntax error if dirtyPayload is invalid xml\n            }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) {\n            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */ const _createNodeIterator = function _createNodeIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n    };\n    /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */ const _isClobbered = function _isClobbered(element) {\n        return element instanceof HTMLFormElement && (typeof element.nodeName !== \"string\" || typeof element.textContent !== \"string\" || typeof element.removeChild !== \"function\" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== \"function\" || typeof element.setAttribute !== \"function\" || typeof element.namespaceURI !== \"string\" || typeof element.insertBefore !== \"function\" || typeof element.hasChildNodes !== \"function\");\n    };\n    /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */ const _isNode = function _isNode(value) {\n        return typeof Node === \"function\" && value instanceof Node;\n    };\n    function _executeHooks(hooks, currentNode, data) {\n        arrayForEach(hooks, (hook)=>{\n            hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n    }\n    /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */ const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content = null;\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n        /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);\n        /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeElement, currentNode, {\n            tagName,\n            allowedTags: ALLOWED_TAGS\n        });\n        /* Detect mXSS attempts abusing namespace confusion */ if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\\w!]/g, currentNode.textContent)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any occurrence of processing instructions */ if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any kind of possibly harmful comments */ if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove element if anything forbids its presence */ if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {\n            /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n                    return false;\n                }\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n                    return false;\n                }\n            }\n            /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n                const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n                if (childNodes && parentNode) {\n                    const childCount = childNodes.length;\n                    for(let i = childCount - 1; i >= 0; --i){\n                        const childClone = cloneNode(childNodes[i], true);\n                        childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n                        parentNode.insertBefore(childClone, getNextSibling(currentNode));\n                    }\n                }\n            }\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === \"noscript\" || tagName === \"noembed\" || tagName === \"noframes\") && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n            /* Get the element's text content */ content = currentNode.textContent;\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                content = stringReplace(content, expr, \" \");\n            });\n            if (currentNode.textContent !== content) {\n                arrayPush(DOMPurify.removed, {\n                    element: currentNode.cloneNode()\n                });\n                currentNode.textContent = content;\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n        return false;\n    };\n    /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */ // eslint-disable-next-line complexity\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === \"id\" || lcName === \"name\") && (value in document || value in formElement)) {\n            return false;\n        }\n        /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;\n        else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n            if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND\n            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n            _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            lcName === \"is\" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;\n            else {\n                return false;\n            }\n        /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if ((lcName === \"src\" || lcName === \"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && stringIndexOf(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag]) ;\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if (value) {\n            return false;\n        } else ;\n        return true;\n    };\n    /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */ const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n        return tagName !== \"annotation-xml\" && stringMatch(tagName, CUSTOM_ELEMENT);\n    };\n    /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n        const { attributes } = currentNode;\n        /* Check if we have attributes; if not we might have a text node */ if (!attributes || _isClobbered(currentNode)) {\n            return;\n        }\n        const hookEvent = {\n            attrName: \"\",\n            attrValue: \"\",\n            keepAttr: true,\n            allowedAttributes: ALLOWED_ATTR,\n            forceKeepAttr: undefined\n        };\n        let l = attributes.length;\n        /* Go backwards over all attributes; safely remove bad ones */ while(l--){\n            const attr = attributes[l];\n            const { name, namespaceURI, value: attrValue } = attr;\n            const lcName = transformCaseFunc(name);\n            const initValue = attrValue;\n            let value = name === \"value\" ? initValue : stringTrim(initValue);\n            /* Execute a hook if present */ hookEvent.attrName = lcName;\n            hookEvent.attrValue = value;\n            hookEvent.keepAttr = true;\n            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n            _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n            value = hookEvent.attrValue;\n            /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */ if (SANITIZE_NAMED_PROPS && (lcName === \"id\" || lcName === \"name\")) {\n                // Remove the attribute with this value\n                _removeAttribute(name, currentNode);\n                // Prefix the value and later re-create the attribute with the sanitized value\n                value = SANITIZE_NAMED_PROPS_PREFIX + value;\n            }\n            /* Work around a security issue with comments inside attributes */ if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title|textarea)/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Make sure we cannot easily use animated hrefs, even if animations are allowed */ if (lcName === \"attributename\" && stringMatch(value, \"href\")) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) {\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) {\n                arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    value = stringReplace(value, expr, \" \");\n                });\n            }\n            /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);\n            if (!_isValidAttribute(lcTag, lcName, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === \"object\" && typeof trustedTypes.getAttributeType === \"function\") {\n                if (namespaceURI) ;\n                else {\n                    switch(trustedTypes.getAttributeType(lcTag, lcName)){\n                        case \"TrustedHTML\":\n                            {\n                                value = trustedTypesPolicy.createHTML(value);\n                                break;\n                            }\n                        case \"TrustedScriptURL\":\n                            {\n                                value = trustedTypesPolicy.createScriptURL(value);\n                                break;\n                            }\n                    }\n                }\n            }\n            /* Handle invalid data-* attribute set by try-catching it */ if (value !== initValue) {\n                try {\n                    if (namespaceURI) {\n                        currentNode.setAttributeNS(namespaceURI, name, value);\n                    } else {\n                        /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */ currentNode.setAttribute(name, value);\n                    }\n                    if (_isClobbered(currentNode)) {\n                        _forceRemove(currentNode);\n                    } else {\n                        arrayPop(DOMPurify.removed);\n                    }\n                } catch (_) {\n                    _removeAttribute(name, currentNode);\n                }\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n    };\n    /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode = null;\n        const shadowIterator = _createNodeIterator(fragment);\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n        while(shadowNode = shadowIterator.nextNode()){\n            /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n            /* Sanitize tags and elements */ _sanitizeElements(shadowNode);\n            /* Check attributes next */ _sanitizeAttributes(shadowNode);\n            /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(shadowNode.content);\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n    };\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function(dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body = null;\n        let importedNode = null;\n        let currentNode = null;\n        let returnNode = null;\n        /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n            dirty = \"<!-->\";\n        }\n        /* Stringify, in case dirty is an object */ if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n            if (typeof dirty.toString === \"function\") {\n                dirty = dirty.toString();\n                if (typeof dirty !== \"string\") {\n                    throw typeErrorCreate(\"dirty is not a string, aborting\");\n                }\n            } else {\n                throw typeErrorCreate(\"toString is not a function\");\n            }\n        }\n        /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) {\n            return dirty;\n        }\n        /* Assign config vars */ if (!SET_CONFIG) {\n            _parseConfig(cfg);\n        }\n        /* Clean up removed elements */ DOMPurify.removed = [];\n        /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === \"string\") {\n            IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n            /* Do some early pre-sanitization to avoid unsafe root nodes */ if (dirty.nodeName) {\n                const tagName = transformCaseFunc(dirty.nodeName);\n                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                    throw typeErrorCreate(\"root node is forbidden and cannot be sanitized in-place\");\n                }\n            }\n        } else if (dirty instanceof Node) {\n            /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */ body = _initDocument(\"<!---->\");\n            importedNode = body.ownerDocument.importNode(dirty, true);\n            if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === \"BODY\") {\n                /* Node is already a body, use as is */ body = importedNode;\n            } else if (importedNode.nodeName === \"HTML\") {\n                body = importedNode;\n            } else {\n                // eslint-disable-next-line unicorn/prefer-dom-node-append\n                body.appendChild(importedNode);\n            }\n        } else {\n            /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n            dirty.indexOf(\"<\") === -1) {\n                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n            }\n            /* Initialize the document to work on */ body = _initDocument(dirty);\n            /* Check we have a DOM node from the data */ if (!body) {\n                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \"\";\n            }\n        }\n        /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) {\n            _forceRemove(body.firstChild);\n        }\n        /* Get node iterator */ const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n        /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){\n            /* Sanitize tags and elements */ _sanitizeElements(currentNode);\n            /* Check attributes next */ _sanitizeAttributes(currentNode);\n            /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(currentNode.content);\n            }\n        }\n        /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) {\n            return dirty;\n        }\n        /* Return sanitized string or DOM */ if (RETURN_DOM) {\n            if (RETURN_DOM_FRAGMENT) {\n                returnNode = createDocumentFragment.call(body.ownerDocument);\n                while(body.firstChild){\n                    // eslint-disable-next-line unicorn/prefer-dom-node-append\n                    returnNode.appendChild(body.firstChild);\n                }\n            } else {\n                returnNode = body;\n            }\n            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n                /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */ returnNode = importNode.call(originalDocument, returnNode, true);\n            }\n            return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS[\"!doctype\"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n            serializedHTML = \"<!DOCTYPE \" + body.ownerDocument.doctype.name + \">\\n\" + serializedHTML;\n        }\n        /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) {\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                serializedHTML = stringReplace(serializedHTML, expr, \" \");\n            });\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    DOMPurify.setConfig = function() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n    };\n    DOMPurify.clearConfig = function() {\n        CONFIG = null;\n        SET_CONFIG = false;\n    };\n    DOMPurify.isValidAttribute = function(tag, attr, value) {\n        /* Initialize shared config vars if necessary. */ if (!CONFIG) {\n            _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n    };\n    DOMPurify.addHook = function(entryPoint, hookFunction) {\n        if (typeof hookFunction !== \"function\") {\n            return;\n        }\n        arrayPush(hooks[entryPoint], hookFunction);\n    };\n    DOMPurify.removeHook = function(entryPoint, hookFunction) {\n        if (hookFunction !== undefined) {\n            const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n            return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];\n        }\n        return arrayPop(hooks[entryPoint]);\n    };\n    DOMPurify.removeHooks = function(entryPoint) {\n        hooks[entryPoint] = [];\n    };\n    DOMPurify.removeAllHooks = function() {\n        hooks = _createHooksMap();\n    };\n    return DOMPurify;\n}\nvar purify = createDOMPurify();\nmodule.exports = purify; //# sourceMappingURL=purify.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5TEFBeUwsR0FFekw7QUFFQSxNQUFNLEVBQ0pBLE9BQU8sRUFDUEMsY0FBYyxFQUNkQyxRQUFRLEVBQ1JDLGNBQWMsRUFDZEMsd0JBQXdCLEVBQ3pCLEdBQUdDO0FBQ0osSUFBSSxFQUNGQyxNQUFNLEVBQ05DLElBQUksRUFDSkMsTUFBTSxFQUNQLEdBQUdILFFBQVEsZ0RBQWdEO0FBQzVELElBQUksRUFDRkksS0FBSyxFQUNMQyxTQUFTLEVBQ1YsR0FBRyxPQUFPQyxZQUFZLGVBQWVBO0FBQ3RDLElBQUksQ0FBQ0wsUUFBUTtJQUNYQSxTQUFTLFNBQVNBLE9BQU9NLENBQUM7UUFDeEIsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsSUFBSSxDQUFDTCxNQUFNO0lBQ1RBLE9BQU8sU0FBU0EsS0FBS0ssQ0FBQztRQUNwQixPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxJQUFJLENBQUNILE9BQU87SUFDVkEsUUFBUSxTQUFTQSxNQUFNSSxJQUFJLEVBQUVDLE9BQU87UUFDbEMsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1lBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDbEM7UUFDQSxPQUFPUCxLQUFLSixLQUFLLENBQUNLLFNBQVNJO0lBQzdCO0FBQ0Y7QUFDQSxJQUFJLENBQUNSLFdBQVc7SUFDZEEsWUFBWSxTQUFTQSxVQUFVVyxJQUFJO1FBQ2pDLElBQUssSUFBSUMsUUFBUU4sVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1HLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlDLFFBQVEsR0FBR0EsUUFBUUQsT0FBT0MsUUFBUztZQUNqSEwsSUFBSSxDQUFD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QUMsRUFBRTtRQUMvRTtRQUNBLE9BQU96QyxTQUFTdUosS0FBSyxDQUFDcUssV0FBVztJQUNuQztJQUNBdk0sVUFBVTBNLFdBQVcsR0FBRyxTQUFVSCxVQUFVO1FBQzFDckssS0FBSyxDQUFDcUssV0FBVyxHQUFHLEVBQUU7SUFDeEI7SUFDQXZNLFVBQVUyTSxjQUFjLEdBQUc7UUFDekJ6SyxRQUFRN0M7SUFDVjtJQUNBLE9BQU9XO0FBQ1Q7QUFDQSxJQUFJNE0sU0FBUzdNO0FBRWI4TSxPQUFPQyxPQUFPLEdBQUdGLFFBQ2pCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuY2pzLmpzP2U5YTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEBsaWNlbnNlIERPTVB1cmlmeSAzLjMuMSB8IChjKSBDdXJlNTMgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgbGljZW5zZSAyLjAgYW5kIE1vemlsbGEgUHVibGljIExpY2Vuc2UgMi4wIHwgZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvMy4zLjEvTElDRU5TRSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgZW50cmllcyxcbiAgc2V0UHJvdG90eXBlT2YsXG4gIGlzRnJvemVuLFxuICBnZXRQcm90b3R5cGVPZixcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59ID0gT2JqZWN0O1xubGV0IHtcbiAgZnJlZXplLFxuICBzZWFsLFxuICBjcmVhdGVcbn0gPSBPYmplY3Q7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0c1xubGV0IHtcbiAgYXBwbHksXG4gIGNvbnN0cnVjdFxufSA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0O1xuaWYgKCFmcmVlemUpIHtcbiAgZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbmlmICghc2VhbCkge1xuICBzZWFsID0gZnVuY3Rpb24gc2VhbCh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5pZiAoIWFwcGx5KSB7XG4gIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn1cbmlmICghY29uc3RydWN0KSB7XG4gIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIGNvbnN0cnVjdChGdW5jKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnVuYyguLi5hcmdzKTtcbiAgfTtcbn1cbmNvbnN0IGFycmF5Rm9yRWFjaCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xuY29uc3QgYXJyYXlMYXN0SW5kZXhPZiA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKTtcbmNvbnN0IGFycmF5UG9wID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucG9wKTtcbmNvbnN0IGFycmF5UHVzaCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuY29uc3QgYXJyYXlTcGxpY2UgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xuY29uc3Qgc3RyaW5nVG9Mb3dlckNhc2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UpO1xuY29uc3Qgc3RyaW5nVG9TdHJpbmcgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcpO1xuY29uc3Qgc3RyaW5nTWF0Y2ggPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUubWF0Y2gpO1xuY29uc3Qgc3RyaW5nUmVwbGFjZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbmNvbnN0IHN0cmluZ0luZGV4T2YgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7XG5jb25zdCBzdHJpbmdUcmltID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuY29uc3Qgb2JqZWN0SGFzT3duUHJvcGVydHkgPSB1bmFwcGx5KE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuY29uc3QgcmVnRXhwVGVzdCA9IHVuYXBwbHkoUmVnRXhwLnByb3RvdHlwZS50ZXN0KTtcbmNvbnN0IHR5cGVFcnJvckNyZWF0ZSA9IHVuY29uc3RydWN0KFR5cGVFcnJvcik7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2l0aCBhIHNwZWNpZmllZCB0aGlzQXJnIGFuZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gYmUgd3JhcHBlZCBhbmQgY2FsbGVkLlxuICogQHJldHVybnMgQSBuZXcgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2l0aCBhIHNwZWNpZmllZCB0aGlzQXJnIGFuZCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHVuYXBwbHkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBpZiAodGhpc0FyZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgdGhpc0FyZy5sYXN0SW5kZXggPSAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQgY29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGJlIHdyYXBwZWQgYW5kIGNhbGxlZC5cbiAqIEByZXR1cm5zIEEgbmV3IGZ1bmN0aW9uIHRoYXQgY29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiB1bmNvbnN0cnVjdChGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJ1Y3QoRnVuYywgYXJncyk7XG4gIH07XG59XG4vKipcbiAqIEFkZCBwcm9wZXJ0aWVzIHRvIGEgbG9va3VwIHRhYmxlXG4gKlxuICogQHBhcmFtIHNldCAtIFRoZSBzZXQgdG8gd2hpY2ggZWxlbWVudHMgd2lsbCBiZSBhZGRlZC5cbiAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSBjb250YWluaW5nIGVsZW1lbnRzIHRvIGJlIGFkZGVkIHRvIHRoZSBzZXQuXG4gKiBAcGFyYW0gdHJhbnNmb3JtQ2FzZUZ1bmMgLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIGNhc2Ugb2YgZWFjaCBlbGVtZW50IGJlZm9yZSBhZGRpbmcgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIFRoZSBtb2RpZmllZCBzZXQgd2l0aCBhZGRlZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gYWRkVG9TZXQoc2V0LCBhcnJheSkge1xuICBsZXQgdHJhbnNmb3JtQ2FzZUZ1bmMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHN0cmluZ1RvTG93ZXJDYXNlO1xuICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAvLyBNYWtlICdpbicgYW5kIHRydXRoeSBjaGVja3MgbGlrZSBCb29sZWFuKHNldC5jb25zdHJ1Y3RvcilcbiAgICAvLyBpbmRlcGVuZGVudCBvZiBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIE9iamVjdC5wcm90b3R5cGUuXG4gICAgLy8gUHJldmVudCBwcm90b3R5cGUgc2V0dGVycyBmcm9tIGludGVyY2VwdGluZyBzZXQgYXMgYSB0aGlzIHZhbHVlLlxuICAgIHNldFByb3RvdHlwZU9mKHNldCwgbnVsbCk7XG4gIH1cbiAgbGV0IGwgPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsLS0pIHtcbiAgICBsZXQgZWxlbWVudCA9IGFycmF5W2xdO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGxjRWxlbWVudCA9IHRyYW5zZm9ybUNhc2VGdW5jKGVsZW1lbnQpO1xuICAgICAgaWYgKGxjRWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICAvLyBDb25maWcgcHJlc2V0cyAoZS5nLiB0YWdzLmpzLCBhdHRycy5qcykgYXJlIGltbXV0YWJsZS5cbiAgICAgICAgaWYgKCFpc0Zyb3plbihhcnJheSkpIHtcbiAgICAgICAgICBhcnJheVtsXSA9IGxjRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50ID0gbGNFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRbZWxlbWVudF0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBzZXQ7XG59XG4vKipcbiAqIENsZWFuIHVwIGFuIGFycmF5IHRvIGhhcmRlbiBhZ2FpbnN0IENTUFBcbiAqXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gYmUgY2xlYW5lZC5cbiAqIEByZXR1cm5zIFRoZSBjbGVhbmVkIHZlcnNpb24gb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNsZWFuQXJyYXkoYXJyYXkpIHtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGlzUHJvcGVydHlFeGlzdCA9IG9iamVjdEhhc093blByb3BlcnR5KGFycmF5LCBpbmRleCk7XG4gICAgaWYgKCFpc1Byb3BlcnR5RXhpc3QpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogU2hhbGxvdyBjbG9uZSBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBiZSBjbG9uZWQuXG4gKiBAcmV0dXJucyBBIG5ldyBvYmplY3QgdGhhdCBjb3BpZXMgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdIG9mIGVudHJpZXMob2JqZWN0KSkge1xuICAgIGNvbnN0IGlzUHJvcGVydHlFeGlzdCA9IG9iamVjdEhhc093blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpO1xuICAgIGlmIChpc1Byb3BlcnR5RXhpc3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBuZXdPYmplY3RbcHJvcGVydHldID0gY2xlYW5BcnJheSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBuZXdPYmplY3RbcHJvcGVydHldID0gY2xvbmUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3T2JqZWN0O1xufVxuLyoqXG4gKiBUaGlzIG1ldGhvZCBhdXRvbWF0aWNhbGx5IGNoZWNrcyBpZiB0aGUgcHJvcCBpcyBmdW5jdGlvbiBvciBnZXR0ZXIgYW5kIGJlaGF2ZXMgYWNjb3JkaW5nbHkuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbG9vayB1cCB0aGUgZ2V0dGVyIGZ1bmN0aW9uIGluIGl0cyBwcm90b3R5cGUgY2hhaW4uXG4gKiBAcGFyYW0gcHJvcCAtIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciB3aGljaCB0byBmaW5kIHRoZSBnZXR0ZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBUaGUgZ2V0dGVyIGZ1bmN0aW9uIGZvdW5kIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb3IgYSBmYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcCkge1xuICB3aGlsZSAob2JqZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgZGVzYyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3ApO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy5nZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICB9XG4gIGZ1bmN0aW9uIGZhbGxiYWNrVmFsdWUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrVmFsdWU7XG59XG5cbmNvbnN0IGh0bWwkMSA9IGZyZWV6ZShbJ2EnLCAnYWJicicsICdhY3JvbnltJywgJ2FkZHJlc3MnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2F1ZGlvJywgJ2InLCAnYmRpJywgJ2JkbycsICdiaWcnLCAnYmxpbmsnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdjb250ZW50JywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGQnLCAnZGVjb3JhdG9yJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbGVtZW50JywgJ2VtJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2ZvbnQnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaScsICdpbWcnLCAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbWFpbicsICdtYXAnLCAnbWFyaycsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0ZXInLCAnbmF2JywgJ25vYnInLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BpY3R1cmUnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2VhcmNoJywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NoYWRvdycsICdzbG90JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFjZXInLCAnc3BhbicsICdzdHJpa2UnLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdW1tYXJ5JywgJ3N1cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aW1lJywgJ3RyJywgJ3RyYWNrJywgJ3R0JywgJ3UnLCAndWwnLCAndmFyJywgJ3ZpZGVvJywgJ3diciddKTtcbmNvbnN0IHN2ZyQxID0gZnJlZXplKFsnc3ZnJywgJ2EnLCAnYWx0Z2x5cGgnLCAnYWx0Z2x5cGhkZWYnLCAnYWx0Z2x5cGhpdGVtJywgJ2FuaW1hdGVjb2xvcicsICdhbmltYXRlbW90aW9uJywgJ2FuaW1hdGV0cmFuc2Zvcm0nLCAnY2lyY2xlJywgJ2NsaXBwYXRoJywgJ2RlZnMnLCAnZGVzYycsICdlbGxpcHNlJywgJ2VudGVya2V5aGludCcsICdleHBvcnRwYXJ0cycsICdmaWx0ZXInLCAnZm9udCcsICdnJywgJ2dseXBoJywgJ2dseXBocmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2lucHV0bW9kZScsICdsaW5lJywgJ2xpbmVhcmdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21wYXRoJywgJ3BhcnQnLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsZ3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N0eWxlJywgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0cGF0aCcsICd0aXRsZScsICd0cmVmJywgJ3RzcGFuJywgJ3ZpZXcnLCAndmtlcm4nXSk7XG5jb25zdCBzdmdGaWx0ZXJzID0gZnJlZXplKFsnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JywgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZURyb3BTaGFkb3cnLCAnZmVGbG9vZCcsICdmZUZ1bmNBJywgJ2ZlRnVuY0InLCAnZmVGdW5jRycsICdmZUZ1bmNSJywgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlSW1hZ2UnLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJ10pO1xuLy8gTGlzdCBvZiBTVkcgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWxsb3dlZCBieSBkZWZhdWx0LlxuLy8gV2Ugc3RpbGwgbmVlZCB0byBrbm93IHRoZW0gc28gdGhhdCB3ZSBjYW4gZG8gbmFtZXNwYWNlXG4vLyBjaGVja3MgcHJvcGVybHkgaW4gY2FzZSBvbmUgd2FudHMgdG8gYWRkIHRoZW0gdG9cbi8vIGFsbG93LWxpc3QuXG5jb25zdCBzdmdEaXNhbGxvd2VkID0gZnJlZXplKFsnYW5pbWF0ZScsICdjb2xvci1wcm9maWxlJywgJ2N1cnNvcicsICdkaXNjYXJkJywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS1zcmMnLCAnZm9udC1mYWNlLXVyaScsICdmb3JlaWdub2JqZWN0JywgJ2hhdGNoJywgJ2hhdGNocGF0aCcsICdtZXNoJywgJ21lc2hncmFkaWVudCcsICdtZXNocGF0Y2gnLCAnbWVzaHJvdycsICdtaXNzaW5nLWdseXBoJywgJ3NjcmlwdCcsICdzZXQnLCAnc29saWRjb2xvcicsICd1bmtub3duJywgJ3VzZSddKTtcbmNvbnN0IG1hdGhNbCQxID0gZnJlZXplKFsnbWF0aCcsICdtZW5jbG9zZScsICdtZXJyb3InLCAnbWZlbmNlZCcsICdtZnJhYycsICdtZ2x5cGgnLCAnbWknLCAnbWxhYmVsZWR0cicsICdtbXVsdGlzY3JpcHRzJywgJ21uJywgJ21vJywgJ21vdmVyJywgJ21wYWRkZWQnLCAnbXBoYW50b20nLCAnbXJvb3QnLCAnbXJvdycsICdtcycsICdtc3BhY2UnLCAnbXNxcnQnLCAnbXN0eWxlJywgJ21zdWInLCAnbXN1cCcsICdtc3Vic3VwJywgJ210YWJsZScsICdtdGQnLCAnbXRleHQnLCAnbXRyJywgJ211bmRlcicsICdtdW5kZXJvdmVyJywgJ21wcmVzY3JpcHRzJ10pO1xuLy8gU2ltaWxhcmx5IHRvIFNWRywgd2Ugd2FudCB0byBrbm93IGFsbCBNYXRoTUwgZWxlbWVudHMsXG4vLyBldmVuIHRob3NlIHRoYXQgd2UgZGlzYWxsb3cgYnkgZGVmYXVsdC5cbmNvbnN0IG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoWydtYWN0aW9uJywgJ21hbGlnbmdyb3VwJywgJ21hbGlnbm1hcmsnLCAnbWxvbmdkaXYnLCAnbXNjYXJyaWVzJywgJ21zY2FycnknLCAnbXNncm91cCcsICdtc3RhY2snLCAnbXNsaW5lJywgJ21zcm93JywgJ3NlbWFudGljcycsICdhbm5vdGF0aW9uJywgJ2Fubm90YXRpb24teG1sJywgJ21wcmVzY3JpcHRzJywgJ25vbmUnXSk7XG5jb25zdCB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbmNvbnN0IGh0bWwgPSBmcmVlemUoWydhY2NlcHQnLCAnYWN0aW9uJywgJ2FsaWduJywgJ2FsdCcsICdhdXRvY2FwaXRhbGl6ZScsICdhdXRvY29tcGxldGUnLCAnYXV0b3BpY3R1cmVpbnBpY3R1cmUnLCAnYXV0b3BsYXknLCAnYmFja2dyb3VuZCcsICdiZ2NvbG9yJywgJ2JvcmRlcicsICdjYXB0dXJlJywgJ2NlbGxwYWRkaW5nJywgJ2NlbGxzcGFjaW5nJywgJ2NoZWNrZWQnLCAnY2l0ZScsICdjbGFzcycsICdjbGVhcicsICdjb2xvcicsICdjb2xzJywgJ2NvbHNwYW4nLCAnY29udHJvbHMnLCAnY29udHJvbHNsaXN0JywgJ2Nvb3JkcycsICdjcm9zc29yaWdpbicsICdkYXRldGltZScsICdkZWNvZGluZycsICdkZWZhdWx0JywgJ2RpcicsICdkaXNhYmxlZCcsICdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsICdkaXNhYmxlcmVtb3RlcGxheWJhY2snLCAnZG93bmxvYWQnLCAnZHJhZ2dhYmxlJywgJ2VuY3R5cGUnLCAnZW50ZXJrZXloaW50JywgJ2V4cG9ydHBhcnRzJywgJ2ZhY2UnLCAnZm9yJywgJ2hlYWRlcnMnLCAnaGVpZ2h0JywgJ2hpZGRlbicsICdoaWdoJywgJ2hyZWYnLCAnaHJlZmxhbmcnLCAnaWQnLCAnaW5lcnQnLCAnaW5wdXRtb2RlJywgJ2ludGVncml0eScsICdpc21hcCcsICdraW5kJywgJ2xhYmVsJywgJ2xhbmcnLCAnbGlzdCcsICdsb2FkaW5nJywgJ2xvb3AnLCAnbG93JywgJ21heCcsICdtYXhsZW5ndGgnLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21pbicsICdtaW5sZW5ndGgnLCAnbXVsdGlwbGUnLCAnbXV0ZWQnLCAnbmFtZScsICdub25jZScsICdub3NoYWRlJywgJ25vdmFsaWRhdGUnLCAnbm93cmFwJywgJ29wZW4nLCAnb3B0aW11bScsICdwYXJ0JywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncGxheXNpbmxpbmUnLCAncG9wb3ZlcicsICdwb3BvdmVydGFyZ2V0JywgJ3BvcG92ZXJ0YXJnZXRhY3Rpb24nLCAncG9zdGVyJywgJ3ByZWxvYWQnLCAncHViZGF0ZScsICdyYWRpb2dyb3VwJywgJ3JlYWRvbmx5JywgJ3JlbCcsICdyZXF1aXJlZCcsICdyZXYnLCAncmV2ZXJzZWQnLCAncm9sZScsICdyb3dzJywgJ3Jvd3NwYW4nLCAnc3BlbGxjaGVjaycsICdzY29wZScsICdzZWxlY3RlZCcsICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3Nsb3QnLCAnc3BhbicsICdzcmNsYW5nJywgJ3N0YXJ0JywgJ3NyYycsICdzcmNzZXQnLCAnc3RlcCcsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmluZGV4JywgJ3RpdGxlJywgJ3RyYW5zbGF0ZScsICd0eXBlJywgJ3VzZW1hcCcsICd2YWxpZ24nLCAndmFsdWUnLCAnd2lkdGgnLCAnd3JhcCcsICd4bWxucycsICdzbG90J10pO1xuY29uc3Qgc3ZnID0gZnJlZXplKFsnYWNjZW50LWhlaWdodCcsICdhY2N1bXVsYXRlJywgJ2FkZGl0aXZlJywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhbXBsaXR1ZGUnLCAnYXNjZW50JywgJ2F0dHJpYnV0ZW5hbWUnLCAnYXR0cmlidXRldHlwZScsICdhemltdXRoJywgJ2Jhc2VmcmVxdWVuY3knLCAnYmFzZWxpbmUtc2hpZnQnLCAnYmVnaW4nLCAnYmlhcycsICdieScsICdjbGFzcycsICdjbGlwJywgJ2NsaXBwYXRodW5pdHMnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvcicsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdjeCcsICdjeScsICdkJywgJ2R4JywgJ2R5JywgJ2RpZmZ1c2Vjb25zdGFudCcsICdkaXJlY3Rpb24nLCAnZGlzcGxheScsICdkaXZpc29yJywgJ2R1cicsICdlZGdlbW9kZScsICdlbGV2YXRpb24nLCAnZW5kJywgJ2V4cG9uZW50JywgJ2ZpbGwnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmaWx0ZXInLCAnZmlsdGVydW5pdHMnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZngnLCAnZnknLCAnZzEnLCAnZzInLCAnZ2x5cGgtbmFtZScsICdnbHlwaHJlZicsICdncmFkaWVudHVuaXRzJywgJ2dyYWRpZW50dHJhbnNmb3JtJywgJ2hlaWdodCcsICdocmVmJywgJ2lkJywgJ2ltYWdlLXJlbmRlcmluZycsICdpbicsICdpbjInLCAnaW50ZXJjZXB0JywgJ2snLCAnazEnLCAnazInLCAnazMnLCAnazQnLCAna2VybmluZycsICdrZXlwb2ludHMnLCAna2V5c3BsaW5lcycsICdrZXl0aW1lcycsICdsYW5nJywgJ2xlbmd0aGFkanVzdCcsICdsZXR0ZXItc3BhY2luZycsICdrZXJuZWxtYXRyaXgnLCAna2VybmVsdW5pdGxlbmd0aCcsICdsaWdodGluZy1jb2xvcicsICdsb2NhbCcsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ21hcmtlcmhlaWdodCcsICdtYXJrZXJ1bml0cycsICdtYXJrZXJ3aWR0aCcsICdtYXNrY29udGVudHVuaXRzJywgJ21hc2t1bml0cycsICdtYXgnLCAnbWFzaycsICdtYXNrLXR5cGUnLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21vZGUnLCAnbWluJywgJ25hbWUnLCAnbnVtb2N0YXZlcycsICdvZmZzZXQnLCAnb3BlcmF0b3InLCAnb3BhY2l0eScsICdvcmRlcicsICdvcmllbnQnLCAnb3JpZW50YXRpb24nLCAnb3JpZ2luJywgJ292ZXJmbG93JywgJ3BhaW50LW9yZGVyJywgJ3BhdGgnLCAncGF0aGxlbmd0aCcsICdwYXR0ZXJuY29udGVudHVuaXRzJywgJ3BhdHRlcm50cmFuc2Zvcm0nLCAncGF0dGVybnVuaXRzJywgJ3BvaW50cycsICdwcmVzZXJ2ZWFscGhhJywgJ3ByZXNlcnZlYXNwZWN0cmF0aW8nLCAncHJpbWl0aXZldW5pdHMnLCAncicsICdyeCcsICdyeScsICdyYWRpdXMnLCAncmVmeCcsICdyZWZ5JywgJ3JlcGVhdGNvdW50JywgJ3JlcGVhdGR1cicsICdyZXN0YXJ0JywgJ3Jlc3VsdCcsICdyb3RhdGUnLCAnc2NhbGUnLCAnc2VlZCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc2xvcGUnLCAnc3BlY3VsYXJjb25zdGFudCcsICdzcGVjdWxhcmV4cG9uZW50JywgJ3NwcmVhZG1ldGhvZCcsICdzdGFydG9mZnNldCcsICdzdGRkZXZpYXRpb24nLCAnc3RpdGNodGlsZXMnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlJywgJ3N0cm9rZS13aWR0aCcsICdzdHlsZScsICdzdXJmYWNlc2NhbGUnLCAnc3lzdGVtbGFuZ3VhZ2UnLCAndGFiaW5kZXgnLCAndGFibGV2YWx1ZXMnLCAndGFyZ2V0eCcsICd0YXJnZXR5JywgJ3RyYW5zZm9ybScsICd0cmFuc2Zvcm0tb3JpZ2luJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd0ZXh0bGVuZ3RoJywgJ3R5cGUnLCAndTEnLCAndTInLCAndW5pY29kZScsICd2YWx1ZXMnLCAndmlld2JveCcsICd2aXNpYmlsaXR5JywgJ3ZlcnNpb24nLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd2lkdGgnLCAnd29yZC1zcGFjaW5nJywgJ3dyYXAnLCAnd3JpdGluZy1tb2RlJywgJ3hjaGFubmVsc2VsZWN0b3InLCAneWNoYW5uZWxzZWxlY3RvcicsICd4JywgJ3gxJywgJ3gyJywgJ3htbG5zJywgJ3knLCAneTEnLCAneTInLCAneicsICd6b29tYW5kcGFuJ10pO1xuY29uc3QgbWF0aE1sID0gZnJlZXplKFsnYWNjZW50JywgJ2FjY2VudHVuZGVyJywgJ2FsaWduJywgJ2JldmVsbGVkJywgJ2Nsb3NlJywgJ2NvbHVtbnNhbGlnbicsICdjb2x1bW5saW5lcycsICdjb2x1bW5zcGFuJywgJ2Rlbm9tYWxpZ24nLCAnZGVwdGgnLCAnZGlyJywgJ2Rpc3BsYXknLCAnZGlzcGxheXN0eWxlJywgJ2VuY29kaW5nJywgJ2ZlbmNlJywgJ2ZyYW1lJywgJ2hlaWdodCcsICdocmVmJywgJ2lkJywgJ2xhcmdlb3AnLCAnbGVuZ3RoJywgJ2xpbmV0aGlja25lc3MnLCAnbHNwYWNlJywgJ2xxdW90ZScsICdtYXRoYmFja2dyb3VuZCcsICdtYXRoY29sb3InLCAnbWF0aHNpemUnLCAnbWF0aHZhcmlhbnQnLCAnbWF4c2l6ZScsICdtaW5zaXplJywgJ21vdmFibGVsaW1pdHMnLCAnbm90YXRpb24nLCAnbnVtYWxpZ24nLCAnb3BlbicsICdyb3dhbGlnbicsICdyb3dsaW5lcycsICdyb3dzcGFjaW5nJywgJ3Jvd3NwYW4nLCAncnNwYWNlJywgJ3JxdW90ZScsICdzY3JpcHRsZXZlbCcsICdzY3JpcHRtaW5zaXplJywgJ3NjcmlwdHNpemVtdWx0aXBsaWVyJywgJ3NlbGVjdGlvbicsICdzZXBhcmF0b3InLCAnc2VwYXJhdG9ycycsICdzdHJldGNoeScsICdzdWJzY3JpcHRzaGlmdCcsICdzdXBzY3JpcHRzaGlmdCcsICdzeW1tZXRyaWMnLCAndm9mZnNldCcsICd3aWR0aCcsICd4bWxucyddKTtcbmNvbnN0IHhtbCA9IGZyZWV6ZShbJ3hsaW5rOmhyZWYnLCAneG1sOmlkJywgJ3hsaW5rOnRpdGxlJywgJ3htbDpzcGFjZScsICd4bWxuczp4bGluayddKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG5jb25zdCBNVVNUQUNIRV9FWFBSID0gc2VhbCgvXFx7XFx7W1xcd1xcV10qfFtcXHdcXFddKlxcfVxcfS9nbSk7IC8vIFNwZWNpZnkgdGVtcGxhdGUgZGV0ZWN0aW9uIHJlZ2V4IGZvciBTQUZFX0ZPUl9URU1QTEFURVMgbW9kZVxuY29uc3QgRVJCX0VYUFIgPSBzZWFsKC88JVtcXHdcXFddKnxbXFx3XFxXXSolPi9nbSk7XG5jb25zdCBUTVBMSVRfRVhQUiA9IHNlYWwoL1xcJFxce1tcXHdcXFddKi9nbSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdW5pY29ybi9iZXR0ZXItcmVnZXhcbmNvbnN0IERBVEFfQVRUUiA9IHNlYWwoL15kYXRhLVtcXC1cXHcuXFx1MDBCNy1cXHVGRkZGXSskLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbmNvbnN0IEFSSUFfQVRUUiA9IHNlYWwoL15hcmlhLVtcXC1cXHddKyQvKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuY29uc3QgSVNfQUxMT1dFRF9VUkkgPSBzZWFsKC9eKD86KD86KD86ZnxodCl0cHM/fG1haWx0b3x0ZWx8Y2FsbHRvfHNtc3xjaWR8eG1wcHxtYXRyaXgpOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2kgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuKTtcbmNvbnN0IElTX1NDUklQVF9PUl9EQVRBID0gc2VhbCgvXig/OlxcdytzY3JpcHR8ZGF0YSk6L2kpO1xuY29uc3QgQVRUUl9XSElURVNQQUNFID0gc2VhbCgvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXS9nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuKTtcbmNvbnN0IERPQ1RZUEVfTkFNRSA9IHNlYWwoL15odG1sJC9pKTtcbmNvbnN0IENVU1RPTV9FTEVNRU5UID0gc2VhbCgvXlthLXpdWy5cXHddKigtWy5cXHddKykrJC9pKTtcblxudmFyIEVYUFJFU1NJT05TID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFSSUFfQVRUUjogQVJJQV9BVFRSLFxuICBBVFRSX1dISVRFU1BBQ0U6IEFUVFJfV0hJVEVTUEFDRSxcbiAgQ1VTVE9NX0VMRU1FTlQ6IENVU1RPTV9FTEVNRU5ULFxuICBEQVRBX0FUVFI6IERBVEFfQVRUUixcbiAgRE9DVFlQRV9OQU1FOiBET0NUWVBFX05BTUUsXG4gIEVSQl9FWFBSOiBFUkJfRVhQUixcbiAgSVNfQUxMT1dFRF9VUkk6IElTX0FMTE9XRURfVVJJLFxuICBJU19TQ1JJUFRfT1JfREFUQTogSVNfU0NSSVBUX09SX0RBVEEsXG4gIE1VU1RBQ0hFX0VYUFI6IE1VU1RBQ0hFX0VYUFIsXG4gIFRNUExJVF9FWFBSOiBUTVBMSVRfRVhQUlxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9pbmRlbnQgKi9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL25vZGVUeXBlXG5jb25zdCBOT0RFX1RZUEUgPSB7XG4gIGVsZW1lbnQ6IDEsXG4gIGF0dHJpYnV0ZTogMixcbiAgdGV4dDogMyxcbiAgY2RhdGFTZWN0aW9uOiA0LFxuICBlbnRpdHlSZWZlcmVuY2U6IDUsXG4gIC8vIERlcHJlY2F0ZWRcbiAgZW50aXR5Tm9kZTogNixcbiAgLy8gRGVwcmVjYXRlZFxuICBwcm9ncmVzc2luZ0luc3RydWN0aW9uOiA3LFxuICBjb21tZW50OiA4LFxuICBkb2N1bWVudDogOSxcbiAgZG9jdW1lbnRUeXBlOiAxMCxcbiAgZG9jdW1lbnRGcmFnbWVudDogMTEsXG4gIG5vdGF0aW9uOiAxMiAvLyBEZXByZWNhdGVkXG59O1xuY29uc3QgZ2V0R2xvYmFsID0gZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5vLW9wIHBvbGljeSBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKiBEb24ndCBleHBvcnQgdGhpcyBmdW5jdGlvbiBvdXRzaWRlIHRoaXMgbW9kdWxlIVxuICogQHBhcmFtIHRydXN0ZWRUeXBlcyBUaGUgcG9saWN5IGZhY3RvcnkuXG4gKiBAcGFyYW0gcHVyaWZ5SG9zdEVsZW1lbnQgVGhlIFNjcmlwdCBlbGVtZW50IHVzZWQgdG8gbG9hZCBET01QdXJpZnkgKHRvIGRldGVybWluZSBwb2xpY3kgbmFtZSBzdWZmaXgpLlxuICogQHJldHVybiBUaGUgcG9saWN5IGNyZWF0ZWQgKG9yIG51bGwsIGlmIFRydXN0ZWQgVHlwZXNcbiAqIGFyZSBub3Qgc3VwcG9ydGVkIG9yIGNyZWF0aW5nIHRoZSBwb2xpY3kgZmFpbGVkKS5cbiAqL1xuY29uc3QgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBwdXJpZnlIb3N0RWxlbWVudCkge1xuICBpZiAodHlwZW9mIHRydXN0ZWRUeXBlcyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBBbGxvdyB0aGUgY2FsbGVycyB0byBjb250cm9sIHRoZSB1bmlxdWUgcG9saWN5IG5hbWVcbiAgLy8gYnkgYWRkaW5nIGEgZGF0YS10dC1wb2xpY3ktc3VmZml4IHRvIHRoZSBzY3JpcHQgZWxlbWVudCB3aXRoIHRoZSBET01QdXJpZnkuXG4gIC8vIFBvbGljeSBjcmVhdGlvbiB3aXRoIGR1cGxpY2F0ZSBuYW1lcyB0aHJvd3MgaW4gVHJ1c3RlZCBUeXBlcy5cbiAgbGV0IHN1ZmZpeCA9IG51bGw7XG4gIGNvbnN0IEFUVFJfTkFNRSA9ICdkYXRhLXR0LXBvbGljeS1zdWZmaXgnO1xuICBpZiAocHVyaWZ5SG9zdEVsZW1lbnQgJiYgcHVyaWZ5SG9zdEVsZW1lbnQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICBzdWZmaXggPSBwdXJpZnlIb3N0RWxlbWVudC5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKTtcbiAgfVxuICBjb25zdCBwb2xpY3lOYW1lID0gJ2RvbXB1cmlmeScgKyAoc3VmZml4ID8gJyMnICsgc3VmZml4IDogJycpO1xuICB0cnkge1xuICAgIHJldHVybiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KHBvbGljeU5hbWUsIHtcbiAgICAgIGNyZWF0ZUhUTUwoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTY3JpcHRVUkwoc2NyaXB0VXJsKSB7XG4gICAgICAgIHJldHVybiBzY3JpcHRVcmw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBQb2xpY3kgY3JlYXRpb24gZmFpbGVkIChtb3N0IGxpa2VseSBhbm90aGVyIERPTVB1cmlmeSBzY3JpcHQgaGFzXG4gICAgLy8gYWxyZWFkeSBydW4pLiBTa2lwIGNyZWF0aW5nIHRoZSBwb2xpY3ksIGFzIHRoaXMgd2lsbCBvbmx5IGNhdXNlIGVycm9yc1xuICAgIC8vIGlmIFRUIGFyZSBlbmZvcmNlZC5cbiAgICBjb25zb2xlLndhcm4oJ1RydXN0ZWRUeXBlcyBwb2xpY3kgJyArIHBvbGljeU5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuY29uc3QgX2NyZWF0ZUhvb2tzTWFwID0gZnVuY3Rpb24gX2NyZWF0ZUhvb2tzTWFwKCkge1xuICByZXR1cm4ge1xuICAgIGFmdGVyU2FuaXRpemVBdHRyaWJ1dGVzOiBbXSxcbiAgICBhZnRlclNhbml0aXplRWxlbWVudHM6IFtdLFxuICAgIGFmdGVyU2FuaXRpemVTaGFkb3dET006IFtdLFxuICAgIGJlZm9yZVNhbml0aXplQXR0cmlidXRlczogW10sXG4gICAgYmVmb3JlU2FuaXRpemVFbGVtZW50czogW10sXG4gICAgYmVmb3JlU2FuaXRpemVTaGFkb3dET006IFtdLFxuICAgIHVwb25TYW5pdGl6ZUF0dHJpYnV0ZTogW10sXG4gICAgdXBvblNhbml0aXplRWxlbWVudDogW10sXG4gICAgdXBvblNhbml0aXplU2hhZG93Tm9kZTogW11cbiAgfTtcbn07XG5mdW5jdGlvbiBjcmVhdGVET01QdXJpZnkoKSB7XG4gIGxldCB3aW5kb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGdldEdsb2JhbCgpO1xuICBjb25zdCBET01QdXJpZnkgPSByb290ID0+IGNyZWF0ZURPTVB1cmlmeShyb290KTtcbiAgRE9NUHVyaWZ5LnZlcnNpb24gPSAnMy4zLjEnO1xuICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudC5ub2RlVHlwZSAhPT0gTk9ERV9UWVBFLmRvY3VtZW50IHx8ICF3aW5kb3cuRWxlbWVudCkge1xuICAgIC8vIE5vdCBydW5uaW5nIGluIGEgYnJvd3NlciwgcHJvdmlkZSBhIGZhY3RvcnkgZnVuY3Rpb25cbiAgICAvLyBzbyB0aGF0IHlvdSBjYW4gcGFzcyB5b3VyIG93biBXaW5kb3dcbiAgICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICB9XG4gIGxldCB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IHdpbmRvdztcbiAgY29uc3Qgb3JpZ2luYWxEb2N1bWVudCA9IGRvY3VtZW50O1xuICBjb25zdCBjdXJyZW50U2NyaXB0ID0gb3JpZ2luYWxEb2N1bWVudC5jdXJyZW50U2NyaXB0O1xuICBjb25zdCB7XG4gICAgRG9jdW1lbnRGcmFnbWVudCxcbiAgICBIVE1MVGVtcGxhdGVFbGVtZW50LFxuICAgIE5vZGUsXG4gICAgRWxlbWVudCxcbiAgICBOb2RlRmlsdGVyLFxuICAgIE5hbWVkTm9kZU1hcCA9IHdpbmRvdy5OYW1lZE5vZGVNYXAgfHwgd2luZG93Lk1vek5hbWVkQXR0ck1hcCxcbiAgICBIVE1MRm9ybUVsZW1lbnQsXG4gICAgRE9NUGFyc2VyLFxuICAgIHRydXN0ZWRUeXBlc1xuICB9ID0gd2luZG93O1xuICBjb25zdCBFbGVtZW50UHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG4gIGNvbnN0IGNsb25lTm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2xvbmVOb2RlJyk7XG4gIGNvbnN0IHJlbW92ZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAncmVtb3ZlJyk7XG4gIGNvbnN0IGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICBjb25zdCBnZXRDaGlsZE5vZGVzID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjaGlsZE5vZGVzJyk7XG4gIGNvbnN0IGdldFBhcmVudE5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ3BhcmVudE5vZGUnKTtcbiAgLy8gQXMgcGVyIGlzc3VlICM0NywgdGhlIHdlYi1jb21wb25lbnRzIHJlZ2lzdHJ5IGlzIGluaGVyaXRlZCBieSBhXG4gIC8vIG5ldyBkb2N1bWVudCBjcmVhdGVkIHZpYSBjcmVhdGVIVE1MRG9jdW1lbnQuIEFzIHBlciB0aGUgc3BlY1xuICAvLyAoaHR0cDovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3JlYXRpbmctYW5kLXBhc3NpbmctcmVnaXN0cmllcylcbiAgLy8gYSBuZXcgZW1wdHkgcmVnaXN0cnkgaXMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgdGVtcGxhdGUgY29udGVudHMgb3duZXJcbiAgLy8gZG9jdW1lbnQsIHNvIHdlIHVzZSB0aGF0IGFzIG91ciBwYXJlbnQgZG9jdW1lbnQgdG8gZW5zdXJlIG5vdGhpbmdcbiAgLy8gaXMgaW5oZXJpdGVkLlxuICBpZiAodHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICBkb2N1bWVudCA9IHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudDtcbiAgICB9XG4gIH1cbiAgbGV0IHRydXN0ZWRUeXBlc1BvbGljeTtcbiAgbGV0IGVtcHR5SFRNTCA9ICcnO1xuICBjb25zdCB7XG4gICAgaW1wbGVtZW50YXRpb24sXG4gICAgY3JlYXRlTm9kZUl0ZXJhdG9yLFxuICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQsXG4gICAgZ2V0RWxlbWVudHNCeVRhZ05hbWVcbiAgfSA9IGRvY3VtZW50O1xuICBjb25zdCB7XG4gICAgaW1wb3J0Tm9kZVxuICB9ID0gb3JpZ2luYWxEb2N1bWVudDtcbiAgbGV0IGhvb2tzID0gX2NyZWF0ZUhvb2tzTWFwKCk7XG4gIC8qKlxuICAgKiBFeHBvc2Ugd2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgcnVubmluZyB0aGUgZnVsbCBET01QdXJpZnkuXG4gICAqL1xuICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZW50cmllcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZ2V0UGFyZW50Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09IHVuZGVmaW5lZDtcbiAgY29uc3Qge1xuICAgIE1VU1RBQ0hFX0VYUFIsXG4gICAgRVJCX0VYUFIsXG4gICAgVE1QTElUX0VYUFIsXG4gICAgREFUQV9BVFRSLFxuICAgIEFSSUFfQVRUUixcbiAgICBJU19TQ1JJUFRfT1JfREFUQSxcbiAgICBBVFRSX1dISVRFU1BBQ0UsXG4gICAgQ1VTVE9NX0VMRU1FTlRcbiAgfSA9IEVYUFJFU1NJT05TO1xuICBsZXQge1xuICAgIElTX0FMTE9XRURfVVJJOiBJU19BTExPV0VEX1VSSSQxXG4gIH0gPSBFWFBSRVNTSU9OUztcbiAgLyoqXG4gICAqIFdlIGNvbnNpZGVyIHRoZSBlbGVtZW50cyBhbmQgYXR0cmlidXRlcyBiZWxvdyB0byBiZSBzYWZlLiBJZGVhbGx5XG4gICAqIGRvbid0IGFkZCBhbnkgbmV3IG9uZXMgYnV0IGZlZWwgZnJlZSB0byByZW1vdmUgdW53YW50ZWQgb25lcy5cbiAgICovXG4gIC8qIGFsbG93ZWQgZWxlbWVudCBuYW1lcyAqL1xuICBsZXQgQUxMT1dFRF9UQUdTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9BTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgWy4uLmh0bWwkMSwgLi4uc3ZnJDEsIC4uLnN2Z0ZpbHRlcnMsIC4uLm1hdGhNbCQxLCAuLi50ZXh0XSk7XG4gIC8qIEFsbG93ZWQgYXR0cmlidXRlIG5hbWVzICovXG4gIGxldCBBTExPV0VEX0FUVFIgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbLi4uaHRtbCwgLi4uc3ZnLCAuLi5tYXRoTWwsIC4uLnhtbF0pO1xuICAvKlxuICAgKiBDb25maWd1cmUgaG93IERPTVB1cmlmeSBzaG91bGQgaGFuZGxlIGN1c3RvbSBlbGVtZW50cyBhbmQgdGhlaXIgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIGN1c3RvbWl6ZWQgYnVpbHQtaW4gZWxlbWVudHMuXG4gICAqIEBwcm9wZXJ0eSB7UmVnRXhwfEZ1bmN0aW9ufG51bGx9IHRhZ05hbWVDaGVjayBvbmUgb2YgW251bGwsIHJlZ2V4UGF0dGVybiwgcHJlZGljYXRlXS4gRGVmYXVsdDogYG51bGxgIChkaXNhbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzKVxuICAgKiBAcHJvcGVydHkge1JlZ0V4cHxGdW5jdGlvbnxudWxsfSBhdHRyaWJ1dGVOYW1lQ2hlY2sgb25lIG9mIFtudWxsLCByZWdleFBhdHRlcm4sIHByZWRpY2F0ZV0uIERlZmF1bHQ6IGBudWxsYCAoZGlzYWxsb3cgYW55IGF0dHJpYnV0ZXMgbm90IG9uIHRoZSBhbGxvdyBsaXN0KVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyBhbGxvdyBjdXN0b20gZWxlbWVudHMgZGVyaXZlZCBmcm9tIGJ1aWx0LWlucyBpZiB0aGV5IHBhc3MgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrLiBEZWZhdWx0OiBgZmFsc2VgLlxuICAgKi9cbiAgbGV0IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HID0gT2JqZWN0LnNlYWwoY3JlYXRlKG51bGwsIHtcbiAgICB0YWdOYW1lQ2hlY2s6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgYXR0cmlidXRlTmFtZUNoZWNrOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50czoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cbiAgfSkpO1xuICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiB0YWdzIChvdmVycmlkZXMgQUxMT1dFRF9UQUdTL0FERF9UQUdTKSAqL1xuICBsZXQgRk9SQklEX1RBR1MgPSBudWxsO1xuICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiBhdHRyaWJ1dGVzIChvdmVycmlkZXMgQUxMT1dFRF9BVFRSL0FERF9BVFRSKSAqL1xuICBsZXQgRk9SQklEX0FUVFIgPSBudWxsO1xuICAvKiBDb25maWcgb2JqZWN0IHRvIHN0b3JlIEFERF9UQUdTL0FERF9BVFRSIGZ1bmN0aW9ucyAod2hlbiB1c2VkIGFzIGZ1bmN0aW9ucykgKi9cbiAgY29uc3QgRVhUUkFfRUxFTUVOVF9IQU5ETElORyA9IE9iamVjdC5zZWFsKGNyZWF0ZShudWxsLCB7XG4gICAgdGFnQ2hlY2s6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgYXR0cmlidXRlQ2hlY2s6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH1cbiAgfSkpO1xuICAvKiBEZWNpZGUgaWYgQVJJQSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIGxldCBBTExPV19BUklBX0FUVFIgPSB0cnVlO1xuICAvKiBEZWNpZGUgaWYgY3VzdG9tIGRhdGEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICBsZXQgQUxMT1dfREFUQV9BVFRSID0gdHJ1ZTtcbiAgLyogRGVjaWRlIGlmIHVua25vd24gcHJvdG9jb2xzIGFyZSBva2F5ICovXG4gIGxldCBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGZhbHNlO1xuICAvKiBEZWNpZGUgaWYgc2VsZi1jbG9zaW5nIHRhZ3MgaW4gYXR0cmlidXRlcyBhcmUgYWxsb3dlZC5cbiAgICogVXN1YWxseSByZW1vdmVkIGR1ZSB0byBhIG1YU1MgaXNzdWUgaW4galF1ZXJ5IDMuMCAqL1xuICBsZXQgQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSID0gdHJ1ZTtcbiAgLyogT3V0cHV0IHNob3VsZCBiZSBzYWZlIGZvciBjb21tb24gdGVtcGxhdGUgZW5naW5lcy5cbiAgICogVGhpcyBtZWFucywgRE9NUHVyaWZ5IHJlbW92ZXMgZGF0YSBhdHRyaWJ1dGVzLCBtdXN0YWNoZXMgYW5kIEVSQlxuICAgKi9cbiAgbGV0IFNBRkVfRk9SX1RFTVBMQVRFUyA9IGZhbHNlO1xuICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZXZlbiBmb3IgWE1MIHVzZWQgd2l0aGluIEhUTUwgYW5kIGFsaWtlLlxuICAgKiBUaGlzIG1lYW5zLCBET01QdXJpZnkgcmVtb3ZlcyBjb21tZW50cyB3aGVuIGNvbnRhaW5pbmcgcmlza3kgY29udGVudC5cbiAgICovXG4gIGxldCBTQUZFX0ZPUl9YTUwgPSB0cnVlO1xuICAvKiBEZWNpZGUgaWYgZG9jdW1lbnQgd2l0aCA8aHRtbD4uLi4gc2hvdWxkIGJlIHJldHVybmVkICovXG4gIGxldCBXSE9MRV9ET0NVTUVOVCA9IGZhbHNlO1xuICAvKiBUcmFjayB3aGV0aGVyIGNvbmZpZyBpcyBhbHJlYWR5IHNldCBvbiB0aGlzIGluc3RhbmNlIG9mIERPTVB1cmlmeS4gKi9cbiAgbGV0IFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIGFsbCBlbGVtZW50cyAoZS5nLiBzdHlsZSwgc2NyaXB0KSBtdXN0IGJlIGNoaWxkcmVuIG9mXG4gICAqIGRvY3VtZW50LmJvZHkuIEJ5IGRlZmF1bHQsIGJyb3dzZXJzIG1pZ2h0IG1vdmUgdGhlbSB0byBkb2N1bWVudC5oZWFkICovXG4gIGxldCBGT1JDRV9CT0RZID0gZmFsc2U7XG4gIC8qIERlY2lkZSBpZiBhIERPTSBgSFRNTEJvZHlFbGVtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAqIHN0cmluZyAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKS5cbiAgICogSWYgYFdIT0xFX0RPQ1VNRU5UYCBpcyBlbmFibGVkIGEgYEhUTUxIdG1sRWxlbWVudGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkXG4gICAqL1xuICBsZXQgUkVUVVJOX0RPTSA9IGZhbHNlO1xuICAvKiBEZWNpZGUgaWYgYSBET00gYERvY3VtZW50RnJhZ21lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICogc3RyaW5nICAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKSAqL1xuICBsZXQgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuICAvKiBUcnkgdG8gcmV0dXJuIGEgVHJ1c3RlZCBUeXBlIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nLCByZXR1cm4gYSBzdHJpbmcgaW5cbiAgICogY2FzZSBUcnVzdGVkIFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkICAqL1xuICBsZXQgUkVUVVJOX1RSVVNURURfVFlQRSA9IGZhbHNlO1xuICAvKiBPdXRwdXQgc2hvdWxkIGJlIGZyZWUgZnJvbSBET00gY2xvYmJlcmluZyBhdHRhY2tzP1xuICAgKiBUaGlzIHNhbml0aXplcyBtYXJrdXBzIG5hbWVkIHdpdGggY29sbGlkaW5nLCBjbG9iYmVyYWJsZSBidWlsdC1pbiBET00gQVBJcy5cbiAgICovXG4gIGxldCBTQU5JVElaRV9ET00gPSB0cnVlO1xuICAvKiBBY2hpZXZlIGZ1bGwgRE9NIENsb2JiZXJpbmcgcHJvdGVjdGlvbiBieSBpc29sYXRpbmcgdGhlIG5hbWVzcGFjZSBvZiBuYW1lZFxuICAgKiBwcm9wZXJ0aWVzIGFuZCBKUyB2YXJpYWJsZXMsIG1pdGlnYXRpbmcgYXR0YWNrcyB0aGF0IGFidXNlIHRoZSBIVE1ML0RPTSBzcGVjIHJ1bGVzLlxuICAgKlxuICAgKiBIVE1ML0RPTSBzcGVjIHJ1bGVzIHRoYXQgZW5hYmxlIERPTSBDbG9iYmVyaW5nOlxuICAgKiAgIC0gTmFtZWQgQWNjZXNzIG9uIFdpbmRvdyAowqc3LjMuMylcbiAgICogICAtIERPTSBUcmVlIEFjY2Vzc29ycyAowqczLjEuNSlcbiAgICogICAtIEZvcm0gRWxlbWVudCBQYXJlbnQtQ2hpbGQgUmVsYXRpb25zICjCpzQuMTAuMylcbiAgICogICAtIElmcmFtZSBzcmNkb2MgLyBOZXN0ZWQgV2luZG93UHJveGllcyAowqc0LjguNSlcbiAgICogICAtIEhUTUxDb2xsZWN0aW9uICjCpzQuMi4xMC4yKVxuICAgKlxuICAgKiBOYW1lc3BhY2UgaXNvbGF0aW9uIGlzIGltcGxlbWVudGVkIGJ5IHByZWZpeGluZyBgaWRgIGFuZCBgbmFtZWAgYXR0cmlidXRlc1xuICAgKiB3aXRoIGEgY29uc3RhbnQgc3RyaW5nLCBpLmUuLCBgdXNlci1jb250ZW50LWBcbiAgICovXG4gIGxldCBTQU5JVElaRV9OQU1FRF9QUk9QUyA9IGZhbHNlO1xuICBjb25zdCBTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVggPSAndXNlci1jb250ZW50LSc7XG4gIC8qIEtlZXAgZWxlbWVudCBjb250ZW50IHdoZW4gcmVtb3ZpbmcgZWxlbWVudD8gKi9cbiAgbGV0IEtFRVBfQ09OVEVOVCA9IHRydWU7XG4gIC8qIElmIGEgYE5vZGVgIGlzIHBhc3NlZCB0byBzYW5pdGl6ZSgpLCB0aGVuIHBlcmZvcm1zIHNhbml0aXphdGlvbiBpbi1wbGFjZSBpbnN0ZWFkXG4gICAqIG9mIGltcG9ydGluZyBpdCBpbnRvIGEgbmV3IERvY3VtZW50IGFuZCByZXR1cm5pbmcgYSBzYW5pdGl6ZWQgY29weSAqL1xuICBsZXQgSU5fUExBQ0UgPSBmYWxzZTtcbiAgLyogQWxsb3cgdXNhZ2Ugb2YgcHJvZmlsZXMgbGlrZSBodG1sLCBzdmcgYW5kIG1hdGhNbCAqL1xuICBsZXQgVVNFX1BST0ZJTEVTID0ge307XG4gIC8qIFRhZ3MgdG8gaWdub3JlIGNvbnRlbnQgb2Ygd2hlbiBLRUVQX0NPTlRFTlQgaXMgdHJ1ZSAqL1xuICBsZXQgRk9SQklEX0NPTlRFTlRTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9GT1JCSURfQ09OVEVOVFMgPSBhZGRUb1NldCh7fSwgWydhbm5vdGF0aW9uLXhtbCcsICdhdWRpbycsICdjb2xncm91cCcsICdkZXNjJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGVhZCcsICdpZnJhbWUnLCAnbWF0aCcsICdtaScsICdtbicsICdtbycsICdtcycsICdtdGV4dCcsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ3BsYWludGV4dCcsICdzY3JpcHQnLCAnc3R5bGUnLCAnc3ZnJywgJ3RlbXBsYXRlJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3ZpZGVvJywgJ3htcCddKTtcbiAgLyogVGFncyB0aGF0IGFyZSBzYWZlIGZvciBkYXRhOiBVUklzICovXG4gIGxldCBEQVRBX1VSSV9UQUdTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9EQVRBX1VSSV9UQUdTID0gYWRkVG9TZXQoe30sIFsnYXVkaW8nLCAndmlkZW8nLCAnaW1nJywgJ3NvdXJjZScsICdpbWFnZScsICd0cmFjayddKTtcbiAgLyogQXR0cmlidXRlcyBzYWZlIGZvciB2YWx1ZXMgbGlrZSBcImphdmFzY3JpcHQ6XCIgKi9cbiAgbGV0IFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgWydhbHQnLCAnY2xhc3MnLCAnZm9yJywgJ2lkJywgJ2xhYmVsJywgJ25hbWUnLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdyb2xlJywgJ3N1bW1hcnknLCAndGl0bGUnLCAndmFsdWUnLCAnc3R5bGUnLCAneG1sbnMnXSk7XG4gIGNvbnN0IE1BVEhNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG4gIGNvbnN0IFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBjb25zdCBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgLyogRG9jdW1lbnQgbmFtZXNwYWNlICovXG4gIGxldCBOQU1FU1BBQ0UgPSBIVE1MX05BTUVTUEFDRTtcbiAgbGV0IElTX0VNUFRZX0lOUFVUID0gZmFsc2U7XG4gIC8qIEFsbG93ZWQgWEhUTUwrWE1MIG5hbWVzcGFjZXMgKi9cbiAgbGV0IEFMTE9XRURfTkFNRVNQQUNFUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfQUxMT1dFRF9OQU1FU1BBQ0VTID0gYWRkVG9TZXQoe30sIFtNQVRITUxfTkFNRVNQQUNFLCBTVkdfTkFNRVNQQUNFLCBIVE1MX05BTUVTUEFDRV0sIHN0cmluZ1RvU3RyaW5nKTtcbiAgbGV0IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ21pJywgJ21vJywgJ21uJywgJ21zJywgJ210ZXh0J10pO1xuICBsZXQgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydhbm5vdGF0aW9uLXhtbCddKTtcbiAgLy8gQ2VydGFpbiBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiBib3RoIFNWRyBhbmQgSFRNTFxuICAvLyBuYW1lc3BhY2UuIFdlIG5lZWQgdG8gc3BlY2lmeSB0aGVtIGV4cGxpY2l0bHlcbiAgLy8gc28gdGhhdCB0aGV5IGRvbid0IGdldCBlcnJvbmVvdXNseSBkZWxldGVkIGZyb21cbiAgLy8gSFRNTCBuYW1lc3BhY2UuXG4gIGNvbnN0IENPTU1PTl9TVkdfQU5EX0hUTUxfRUxFTUVOVFMgPSBhZGRUb1NldCh7fSwgWyd0aXRsZScsICdzdHlsZScsICdmb250JywgJ2EnLCAnc2NyaXB0J10pO1xuICAvKiBQYXJzaW5nIG9mIHN0cmljdCBYSFRNTCBkb2N1bWVudHMgKi9cbiAgbGV0IFBBUlNFUl9NRURJQV9UWVBFID0gbnVsbDtcbiAgY29uc3QgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFsnYXBwbGljYXRpb24veGh0bWwreG1sJywgJ3RleHQvaHRtbCddO1xuICBjb25zdCBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gIGxldCB0cmFuc2Zvcm1DYXNlRnVuYyA9IG51bGw7XG4gIC8qIEtlZXAgYSByZWZlcmVuY2UgdG8gY29uZmlnIHRvIHBhc3MgdG8gaG9va3MgKi9cbiAgbGV0IENPTkZJRyA9IG51bGw7XG4gIC8qIElkZWFsbHksIGRvIG5vdCB0b3VjaCBhbnl0aGluZyBiZWxvdyB0aGlzIGxpbmUgKi9cbiAgLyogX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyAqL1xuICBjb25zdCBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgY29uc3QgaXNSZWdleE9yRnVuY3Rpb24gPSBmdW5jdGlvbiBpc1JlZ2V4T3JGdW5jdGlvbih0ZXN0VmFsdWUpIHtcbiAgICByZXR1cm4gdGVzdFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHRlc3RWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICB9O1xuICAvKipcbiAgICogX3BhcnNlQ29uZmlnXG4gICAqXG4gICAqIEBwYXJhbSBjZmcgb3B0aW9uYWwgY29uZmlnIGxpdGVyYWxcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGNvbnN0IF9wYXJzZUNvbmZpZyA9IGZ1bmN0aW9uIF9wYXJzZUNvbmZpZygpIHtcbiAgICBsZXQgY2ZnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoQ09ORklHICYmIENPTkZJRyA9PT0gY2ZnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHRhbXBlcmluZyAqL1xuICAgIGlmICghY2ZnIHx8IHR5cGVvZiBjZmcgIT09ICdvYmplY3QnKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG4gICAgLyogU2hpZWxkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gcHJvdG90eXBlIHBvbGx1dGlvbiAqL1xuICAgIGNmZyA9IGNsb25lKGNmZyk7XG4gICAgUEFSU0VSX01FRElBX1RZUEUgPVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMuaW5kZXhPZihjZmcuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgOiBjZmcuUEFSU0VSX01FRElBX1RZUEU7XG4gICAgLy8gSFRNTCB0YWdzIGFuZCBhdHRyaWJ1dGVzIGFyZSBub3QgY2FzZS1zZW5zaXRpdmUsIGNvbnZlcnRpbmcgdG8gbG93ZXJjYXNlLiBLZWVwaW5nIFhIVE1MIGFzIGlzLlxuICAgIHRyYW5zZm9ybUNhc2VGdW5jID0gUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnID8gc3RyaW5nVG9TdHJpbmcgOiBzdHJpbmdUb0xvd2VyQ2FzZTtcbiAgICAvKiBTZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgQUxMT1dFRF9UQUdTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUxMT1dFRF9UQUdTJykgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9BTExPV0VEX1RBR1M7XG4gICAgQUxMT1dFRF9BVFRSID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUxMT1dFRF9BVFRSJykgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9BTExPV0VEX0FUVFI7XG4gICAgQUxMT1dFRF9OQU1FU1BBQ0VTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUxMT1dFRF9OQU1FU1BBQ0VTJykgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfTkFNRVNQQUNFUywgc3RyaW5nVG9TdHJpbmcpIDogREVGQVVMVF9BTExPV0VEX05BTUVTUEFDRVM7XG4gICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FERF9VUklfU0FGRV9BVFRSJykgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMpLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUztcbiAgICBEQVRBX1VSSV9UQUdTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUREX0RBVEFfVVJJX1RBR1MnKSA/IGFkZFRvU2V0KGNsb25lKERFRkFVTFRfREFUQV9VUklfVEFHUyksIGNmZy5BRERfREFUQV9VUklfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9EQVRBX1VSSV9UQUdTO1xuICAgIEZPUkJJRF9DT05URU5UUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0ZPUkJJRF9DT05URU5UUycpID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQ09OVEVOVFMsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTO1xuICAgIEZPUkJJRF9UQUdTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnRk9SQklEX1RBR1MnKSA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IGNsb25lKHt9KTtcbiAgICBGT1JCSURfQVRUUiA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0ZPUkJJRF9BVFRSJykgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBjbG9uZSh7fSk7XG4gICAgVVNFX1BST0ZJTEVTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnVVNFX1BST0ZJTEVTJykgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7XG4gICAgQUxMT1dfQVJJQV9BVFRSID0gY2ZnLkFMTE9XX0FSSUFfQVRUUiAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIEFMTE9XX0RBVEFfQVRUUiA9IGNmZy5BTExPV19EQVRBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGNmZy5BTExPV19VTktOT1dOX1BST1RPQ09MUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiA9IGNmZy5BTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBTQUZFX0ZPUl9URU1QTEFURVMgPSBjZmcuU0FGRV9GT1JfVEVNUExBVEVTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgU0FGRV9GT1JfWE1MID0gY2ZnLlNBRkVfRk9SX1hNTCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIFdIT0xFX0RPQ1VNRU5UID0gY2ZnLldIT0xFX0RPQ1VNRU5UIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgUkVUVVJOX0RPTSA9IGNmZy5SRVRVUk5fRE9NIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGNmZy5SRVRVUk5fRE9NX0ZSQUdNRU5UIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgUkVUVVJOX1RSVVNURURfVFlQRSA9IGNmZy5SRVRVUk5fVFJVU1RFRF9UWVBFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgRk9SQ0VfQk9EWSA9IGNmZy5GT1JDRV9CT0RZIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgU0FOSVRJWkVfRE9NID0gY2ZnLlNBTklUSVpFX0RPTSAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIFNBTklUSVpFX05BTUVEX1BST1BTID0gY2ZnLlNBTklUSVpFX05BTUVEX1BST1BTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgS0VFUF9DT05URU5UID0gY2ZnLktFRVBfQ09OVEVOVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIElOX1BMQUNFID0gY2ZnLklOX1BMQUNFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgSVNfQUxMT1dFRF9VUkkkMSA9IGNmZy5BTExPV0VEX1VSSV9SRUdFWFAgfHwgSVNfQUxMT1dFRF9VUkk7XG4gICAgTkFNRVNQQUNFID0gY2ZnLk5BTUVTUEFDRSB8fCBIVE1MX05BTUVTUEFDRTtcbiAgICBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMgPSBjZmcuTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTIHx8IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUztcbiAgICBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGNmZy5IVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyB8fCBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUztcbiAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORyA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyB8fCB7fTtcbiAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2spKSB7XG4gICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrO1xuICAgIH1cbiAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2spKSB7XG4gICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2sgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrO1xuICAgIH1cbiAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIHR5cGVvZiBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHM7XG4gICAgfVxuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgUkVUVVJOX0RPTSA9IHRydWU7XG4gICAgfVxuICAgIC8qIFBhcnNlIHByb2ZpbGUgaW5mbyAqL1xuICAgIGlmIChVU0VfUFJPRklMRVMpIHtcbiAgICAgIEFMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCB0ZXh0KTtcbiAgICAgIEFMTE9XRURfQVRUUiA9IFtdO1xuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5odG1sID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgaHRtbCQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBodG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgc3ZnJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2Zyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnRmlsdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2Zyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChVU0VfUFJPRklMRVMubWF0aE1sID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgbWF0aE1sJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIG1hdGhNbCk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogTWVyZ2UgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgaWYgKGNmZy5BRERfVEFHUykge1xuICAgICAgaWYgKHR5cGVvZiBjZmcuQUREX1RBR1MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgRVhUUkFfRUxFTUVOVF9IQU5ETElORy50YWdDaGVjayA9IGNmZy5BRERfVEFHUztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChBTExPV0VEX1RBR1MgPT09IERFRkFVTFRfQUxMT1dFRF9UQUdTKSB7XG4gICAgICAgICAgQUxMT1dFRF9UQUdTID0gY2xvbmUoQUxMT1dFRF9UQUdTKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGNmZy5BRERfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2ZnLkFERF9BVFRSKSB7XG4gICAgICBpZiAodHlwZW9mIGNmZy5BRERfQVRUUiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBFWFRSQV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZUNoZWNrID0gY2ZnLkFERF9BVFRSO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKEFMTE9XRURfQVRUUiA9PT0gREVGQVVMVF9BTExPV0VEX0FUVFIpIHtcbiAgICAgICAgICBBTExPV0VEX0FUVFIgPSBjbG9uZShBTExPV0VEX0FUVFIpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgY2ZnLkFERF9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjZmcuQUREX1VSSV9TQUZFX0FUVFIpIHtcbiAgICAgIGFkZFRvU2V0KFVSSV9TQUZFX0FUVFJJQlVURVMsIGNmZy5BRERfVVJJX1NBRkVfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgIH1cbiAgICBpZiAoY2ZnLkZPUkJJRF9DT05URU5UUykge1xuICAgICAgaWYgKEZPUkJJRF9DT05URU5UUyA9PT0gREVGQVVMVF9GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgICAgRk9SQklEX0NPTlRFTlRTID0gY2xvbmUoRk9SQklEX0NPTlRFTlRTKTtcbiAgICAgIH1cbiAgICAgIGFkZFRvU2V0KEZPUkJJRF9DT05URU5UUywgY2ZnLkZPUkJJRF9DT05URU5UUywgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgIH1cbiAgICBpZiAoY2ZnLkFERF9GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgIGlmIChGT1JCSURfQ09OVEVOVFMgPT09IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICAgIEZPUkJJRF9DT05URU5UUyA9IGNsb25lKEZPUkJJRF9DT05URU5UUyk7XG4gICAgICB9XG4gICAgICBhZGRUb1NldChGT1JCSURfQ09OVEVOVFMsIGNmZy5BRERfRk9SQklEX0NPTlRFTlRTLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuICAgIC8qIEFkZCAjdGV4dCBpbiBjYXNlIEtFRVBfQ09OVEVOVCBpcyBzZXQgdG8gdHJ1ZSAqL1xuICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgIEFMTE9XRURfVEFHU1snI3RleHQnXSA9IHRydWU7XG4gICAgfVxuICAgIC8qIEFkZCBodG1sLCBoZWFkIGFuZCBib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIFdIT0xFX0RPQ1VNRU5UIGlzIHRydWUgKi9cbiAgICBpZiAoV0hPTEVfRE9DVU1FTlQpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWydodG1sJywgJ2hlYWQnLCAnYm9keSddKTtcbiAgICB9XG4gICAgLyogQWRkIHRib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIHRhYmxlcyBhcmUgcGVybWl0dGVkLCBzZWUgIzI4NiwgIzM2NSAqL1xuICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWyd0Ym9keSddKTtcbiAgICAgIGRlbGV0ZSBGT1JCSURfVEFHUy50Ym9keTtcbiAgICB9XG4gICAgaWYgKGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWSkge1xuICAgICAgaWYgKHR5cGVvZiBjZmcuVFJVU1RFRF9UWVBFU19QT0xJQ1kuY3JlYXRlSFRNTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ1RSVVNURURfVFlQRVNfUE9MSUNZIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG11c3QgcHJvdmlkZSBhIFwiY3JlYXRlSFRNTFwiIGhvb2suJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWS5jcmVhdGVTY3JpcHRVUkwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdUUlVTVEVEX1RZUEVTX1BPTElDWSBjb25maWd1cmF0aW9uIG9wdGlvbiBtdXN0IHByb3ZpZGUgYSBcImNyZWF0ZVNjcmlwdFVSTFwiIGhvb2suJyk7XG4gICAgICB9XG4gICAgICAvLyBPdmVyd3JpdGUgZXhpc3RpbmcgVHJ1c3RlZFR5cGVzIHBvbGljeS5cbiAgICAgIHRydXN0ZWRUeXBlc1BvbGljeSA9IGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWTtcbiAgICAgIC8vIFNpZ24gbG9jYWwgdmFyaWFibGVzIHJlcXVpcmVkIGJ5IGBzYW5pdGl6ZWAuXG4gICAgICBlbXB0eUhUTUwgPSB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTCgnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuaW5pdGlhbGl6ZWQgcG9saWN5LCBhdHRlbXB0IHRvIGluaXRpYWxpemUgdGhlIGludGVybmFsIGRvbXB1cmlmeSBwb2xpY3kuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIGN1cnJlbnRTY3JpcHQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgY3JlYXRpbmcgdGhlIGludGVybmFsIHBvbGljeSBzdWNjZWVkZWQgc2lnbiBpbnRlcm5hbCB2YXJpYWJsZXMuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ICE9PSBudWxsICYmIHR5cGVvZiBlbXB0eUhUTUwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJldmVudCBmdXJ0aGVyIG1hbmlwdWxhdGlvbiBvZiBjb25maWd1cmF0aW9uLlxuICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuICAgIGlmIChmcmVlemUpIHtcbiAgICAgIGZyZWV6ZShjZmcpO1xuICAgIH1cbiAgICBDT05GSUcgPSBjZmc7XG4gIH07XG4gIC8qIEtlZXAgdHJhY2sgb2YgYWxsIHBvc3NpYmxlIFNWRyBhbmQgTWF0aE1MIHRhZ3NcbiAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgKiBjb3JyZWN0bHkuICovXG4gIGNvbnN0IEFMTF9TVkdfVEFHUyA9IGFkZFRvU2V0KHt9LCBbLi4uc3ZnJDEsIC4uLnN2Z0ZpbHRlcnMsIC4uLnN2Z0Rpc2FsbG93ZWRdKTtcbiAgY29uc3QgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIFsuLi5tYXRoTWwkMSwgLi4ubWF0aE1sRGlzYWxsb3dlZF0pO1xuICAvKipcbiAgICogQHBhcmFtIGVsZW1lbnQgYSBET00gZWxlbWVudCB3aG9zZSBuYW1lc3BhY2UgaXMgYmVpbmcgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBSZXR1cm4gZmFsc2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFcbiAgICogIG5hbWVzcGFjZSB0aGF0IGEgc3BlYy1jb21wbGlhbnQgcGFyc2VyIHdvdWxkIG5ldmVyXG4gICAqICByZXR1cm4uIFJldHVybiB0cnVlIG90aGVyd2lzZS5cbiAgICovXG4gIGNvbnN0IF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgIGxldCBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIC8vIEluIEpTRE9NLCBpZiB3ZSdyZSBpbnNpZGUgc2hhZG93IERPTSwgdGhlbiBwYXJlbnROb2RlXG4gICAgLy8gY2FuIGJlIG51bGwuIFdlIGp1c3Qgc2ltdWxhdGUgcGFyZW50IGluIHRoaXMgY2FzZS5cbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50LnRhZ05hbWUpIHtcbiAgICAgIHBhcmVudCA9IHtcbiAgICAgICAgbmFtZXNwYWNlVVJJOiBOQU1FU1BBQ0UsXG4gICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xuICAgIGNvbnN0IHBhcmVudFRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShwYXJlbnQudGFnTmFtZSk7XG4gICAgaWYgKCFBTExPV0VEX05BTUVTUEFDRVNbZWxlbWVudC5uYW1lc3BhY2VVUkldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIFNWR1xuICAgICAgLy8gaXMgdmlhIDxzdmc+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJztcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBNYXRoTUwgdG8gU1ZHIGlzIHZpYWBcbiAgICAgIC8vIHN2ZyBpZiBwYXJlbnQgaXMgZWl0aGVyIDxhbm5vdGF0aW9uLXhtbD4gb3IgTWF0aE1MXG4gICAgICAvLyB0ZXh0IGludGVncmF0aW9uIHBvaW50cy5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJyAmJiAocGFyZW50VGFnTmFtZSA9PT0gJ2Fubm90YXRpb24teG1sJyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pO1xuICAgICAgfVxuICAgICAgLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIFNWR1xuICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBTVkcgbmFtZXNwYWNlLlxuICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gTWF0aE1MXG4gICAgICAvLyBpcyB2aWEgPG1hdGg+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCc7XG4gICAgICB9XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIE1hdGhNTCBpcyB2aWFcbiAgICAgIC8vIDxtYXRoPiBhbmQgSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCcgJiYgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV07XG4gICAgICB9XG4gICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gTWF0aE1MXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIE1hdGhNTCBuYW1lc3BhY2UuXG4gICAgICByZXR1cm4gQm9vbGVhbihBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIEhUTUwgaXMgdmlhXG4gICAgICAvLyBIVE1MIGludGVncmF0aW9uIHBvaW50cywgYW5kIGZyb20gTWF0aE1MIHRvIEhUTUxcbiAgICAgIC8vIGlzIHZpYSBNYXRoTUwgdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFICYmICFIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSAmJiAhTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpc2FsbG93IHRhZ3MgdGhhdCBhcmUgc3BlY2lmaWMgZm9yIE1hdGhNTFxuICAgICAgLy8gb3IgU1ZHIGFuZCBzaG91bGQgbmV2ZXIgYXBwZWFyIGluIEhUTUwgbmFtZXNwYWNlXG4gICAgICByZXR1cm4gIUFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSAmJiAoQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UU1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG4gICAgLy8gRm9yIFhIVE1MIGFuZCBYTUwgZG9jdW1lbnRzIHRoYXQgc3VwcG9ydCBjdXN0b20gbmFtZXNwYWNlc1xuICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgJiYgQUxMT1dFRF9OQU1FU1BBQ0VTW2VsZW1lbnQubmFtZXNwYWNlVVJJXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRoZSBjb2RlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBsYWNlICh0aGlzIG1lYW5zXG4gICAgLy8gdGhhdCB0aGUgZWxlbWVudCBzb21laG93IGdvdCBuYW1lc3BhY2UgdGhhdCBpcyBub3RcbiAgICAvLyBIVE1MLCBTVkcsIE1hdGhNTCBvciBhbGxvd2VkIHZpYSBBTExPV0VEX05BTUVTUEFDRVMpLlxuICAgIC8vIFJldHVybiBmYWxzZSBqdXN0IGluIGNhc2UuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKipcbiAgICogX2ZvcmNlUmVtb3ZlXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIGEgRE9NIG5vZGVcbiAgICovXG4gIGNvbnN0IF9mb3JjZVJlbW92ZSA9IGZ1bmN0aW9uIF9mb3JjZVJlbW92ZShub2RlKSB7XG4gICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICBlbGVtZW50OiBub2RlXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1yZW1vdmVcbiAgICAgIGdldFBhcmVudE5vZGUobm9kZSkucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmVtb3ZlKG5vZGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIF9yZW1vdmVBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgYW4gQXR0cmlidXRlIG5hbWVcbiAgICogQHBhcmFtIGVsZW1lbnQgYSBET00gbm9kZVxuICAgKi9cbiAgY29uc3QgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgYXR0cmlidXRlOiBlbGVtZW50LmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgIGZyb206IGVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgIGZyb206IGVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAvLyBXZSB2b2lkIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIHVucmVtb3ZhYmxlIFwiaXNcIiBhdHRyaWJ1dGVzXG4gICAgaWYgKG5hbWUgPT09ICdpcycpIHtcbiAgICAgIGlmIChSRVRVUk5fRE9NIHx8IFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoZWxlbWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBfaW5pdERvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSBkaXJ0eSAtIGEgc3RyaW5nIG9mIGRpcnR5IG1hcmt1cFxuICAgKiBAcmV0dXJuIGEgRE9NLCBmaWxsZWQgd2l0aCB0aGUgZGlydHkgbWFya3VwXG4gICAqL1xuICBjb25zdCBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgIC8qIENyZWF0ZSBhIEhUTUwgZG9jdW1lbnQgKi9cbiAgICBsZXQgZG9jID0gbnVsbDtcbiAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2UgPSBudWxsO1xuICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICBkaXJ0eSA9ICc8cmVtb3ZlPjwvcmVtb3ZlPicgKyBkaXJ0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSWYgRk9SQ0VfQk9EWSBpc24ndCB1c2VkLCBsZWFkaW5nIHdoaXRlc3BhY2UgbmVlZHMgdG8gYmUgcHJlc2VydmVkIG1hbnVhbGx5ICovXG4gICAgICBjb25zdCBtYXRjaGVzID0gc3RyaW5nTWF0Y2goZGlydHksIC9eW1xcclxcblxcdCBdKy8pO1xuICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgfVxuICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgJiYgTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgLy8gUm9vdCBvZiBYSFRNTCBkb2MgbXVzdCBjb250YWluIHhtbG5zIGRlY2xhcmF0aW9uIChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3hodG1sMS9ub3JtYXRpdmUuaHRtbCNzdHJpY3QpXG4gICAgICBkaXJ0eSA9ICc8aHRtbCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj48aGVhZD48L2hlYWQ+PGJvZHk+JyArIGRpcnR5ICsgJzwvYm9keT48L2h0bWw+JztcbiAgICB9XG4gICAgY29uc3QgZGlydHlQYXlsb2FkID0gdHJ1c3RlZFR5cGVzUG9saWN5ID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgLypcbiAgICAgKiBVc2UgdGhlIERPTVBhcnNlciBBUEkgYnkgZGVmYXVsdCwgZmFsbGJhY2sgbGF0ZXIgaWYgbmVlZHMgYmVcbiAgICAgKiBET01QYXJzZXIgbm90IHdvcmsgZm9yIHN2ZyB3aGVuIGhhcyBtdWx0aXBsZSByb290IGVsZW1lbnQuXG4gICAgICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGlydHlQYXlsb2FkLCBQQVJTRVJfTUVESUFfVFlQRSk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cbiAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAgICBpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gSVNfRU1QVFlfSU5QVVQgPyBlbXB0eUhUTUwgOiBkaXJ0eVBheWxvYWQ7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIC8vIFN5bnRheCBlcnJvciBpZiBkaXJ0eVBheWxvYWQgaXMgaW52YWxpZCB4bWxcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGRvYy5ib2R5IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICBib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGJvZHkuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICB9XG4gICAgLyogV29yayBvbiB3aG9sZSBkb2N1bWVudCBvciBqdXN0IGl0cyBib2R5ICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gV0hPTEVfRE9DVU1FTlQgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogYm9keTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOb2RlSXRlcmF0b3Igb2JqZWN0IHRoYXQgeW91IGNhbiB1c2UgdG8gdHJhdmVyc2UgZmlsdGVyZWQgbGlzdHMgb2Ygbm9kZXMgb3IgZWxlbWVudHMgaW4gYSBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHJvb3QgVGhlIHJvb3QgZWxlbWVudCBvciBub2RlIHRvIHN0YXJ0IHRyYXZlcnNpbmcgb24uXG4gICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgTm9kZUl0ZXJhdG9yXG4gICAqL1xuICBjb25zdCBfY3JlYXRlTm9kZUl0ZXJhdG9yID0gZnVuY3Rpb24gX2NyZWF0ZU5vZGVJdGVyYXRvcihyb290KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVJdGVyYXRvci5jYWxsKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCByb290LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19URVhUIHwgTm9kZUZpbHRlci5TSE9XX1BST0NFU1NJTkdfSU5TVFJVQ1RJT04gfCBOb2RlRmlsdGVyLlNIT1dfQ0RBVEFfU0VDVElPTiwgbnVsbCk7XG4gIH07XG4gIC8qKlxuICAgKiBfaXNDbG9iYmVyZWRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgZWxlbWVudCB0byBjaGVjayBmb3IgY2xvYmJlcmluZyBhdHRhY2tzXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBjbG9iYmVyZWQsIGZhbHNlIGlmIHNhZmVcbiAgICovXG4gIGNvbnN0IF9pc0Nsb2JiZXJlZCA9IGZ1bmN0aW9uIF9pc0Nsb2JiZXJlZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQgJiYgKHR5cGVvZiBlbGVtZW50Lm5vZGVOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC50ZXh0Q29udGVudCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbGVtZW50LmF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBOYW1lZE5vZGVNYXApIHx8IHR5cGVvZiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQubmFtZXNwYWNlVVJJICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC5pbnNlcnRCZWZvcmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQuaGFzQ2hpbGROb2RlcyAhPT0gJ2Z1bmN0aW9uJyk7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBvYmplY3QgdG8gY2hlY2sgd2hldGhlciBpdCdzIGEgRE9NIG5vZGVcbiAgICogQHJldHVybiB0cnVlIGlzIG9iamVjdCBpcyBhIERPTSBub2RlXG4gICAqL1xuICBjb25zdCBfaXNOb2RlID0gZnVuY3Rpb24gX2lzTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGU7XG4gIH07XG4gIGZ1bmN0aW9uIF9leGVjdXRlSG9va3MoaG9va3MsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgYXJyYXlGb3JFYWNoKGhvb2tzLCBob29rID0+IHtcbiAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBfc2FuaXRpemVFbGVtZW50c1xuICAgKlxuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCB0ZXh0Q29udGVudFxuICAgKiBAcHJvdGVjdCByZW1vdmVDaGlsZFxuICAgKiBAcGFyYW0gY3VycmVudE5vZGUgdG8gY2hlY2sgZm9yIHBlcm1pc3Npb24gdG8gZXhpc3RcbiAgICogQHJldHVybiB0cnVlIGlmIG5vZGUgd2FzIGtpbGxlZCwgZmFsc2UgaWYgbGVmdCBhbGl2ZVxuICAgKi9cbiAgY29uc3QgX3Nhbml0aXplRWxlbWVudHMgPSBmdW5jdGlvbiBfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkge1xuICAgIGxldCBjb250ZW50ID0gbnVsbDtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5iZWZvcmVTYW5pdGl6ZUVsZW1lbnRzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgLyogQ2hlY2sgaWYgZWxlbWVudCBpcyBjbG9iYmVyZWQgb3IgY2FuIGNsb2JiZXIgKi9cbiAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBOb3cgbGV0J3MgY2hlY2sgdGhlIGVsZW1lbnQncyB0eXBlIGFuZCBuYW1lICovXG4gICAgY29uc3QgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy51cG9uU2FuaXRpemVFbGVtZW50LCBjdXJyZW50Tm9kZSwge1xuICAgICAgdGFnTmFtZSxcbiAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1NcbiAgICB9KTtcbiAgICAvKiBEZXRlY3QgbVhTUyBhdHRlbXB0cyBhYnVzaW5nIG5hbWVzcGFjZSBjb25mdXNpb24gKi9cbiAgICBpZiAoU0FGRV9GT1JfWE1MICYmIGN1cnJlbnROb2RlLmhhc0NoaWxkTm9kZXMoKSAmJiAhX2lzTm9kZShjdXJyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZCkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3IV0vZywgY3VycmVudE5vZGUuaW5uZXJIVE1MKSAmJiByZWdFeHBUZXN0KC88Wy9cXHchXS9nLCBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogUmVtb3ZlIGFueSBvY2N1cnJlbmNlIG9mIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zICovXG4gICAgaWYgKGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEUucHJvZ3Jlc3NpbmdJbnN0cnVjdGlvbikge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgYW55IGtpbmQgb2YgcG9zc2libHkgaGFybWZ1bCBjb21tZW50cyAqL1xuICAgIGlmIChTQUZFX0ZPUl9YTUwgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRS5jb21tZW50ICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUuZGF0YSkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogUmVtb3ZlIGVsZW1lbnQgaWYgYW55dGhpbmcgZm9yYmlkcyBpdHMgcHJlc2VuY2UgKi9cbiAgICBpZiAoIShFWFRSQV9FTEVNRU5UX0hBTkRMSU5HLnRhZ0NoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgRVhUUkFfRUxFTUVOVF9IQU5ETElORy50YWdDaGVjayh0YWdOYW1lKSkgJiYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pKSB7XG4gICAgICAvKiBDaGVjayBpZiB3ZSBoYXZlIGEgY3VzdG9tIGVsZW1lbnQgdG8gaGFuZGxlICovXG4gICAgICBpZiAoIUZPUkJJRF9UQUdTW3RhZ05hbWVdICYmIF9pc0Jhc2ljQ3VzdG9tRWxlbWVudCh0YWdOYW1lKSkge1xuICAgICAgICBpZiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrLCB0YWdOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKHRhZ05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBLZWVwIGNvbnRlbnQgZXhjZXB0IGZvciBiYWQtbGlzdGVkIGVsZW1lbnRzICovXG4gICAgICBpZiAoS0VFUF9DT05URU5UICYmICFGT1JCSURfQ09OVEVOVFNbdGFnTmFtZV0pIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBnZXRDaGlsZE5vZGVzKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2RlcyAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZENvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ2xvbmUgPSBjbG9uZU5vZGUoY2hpbGROb2Rlc1tpXSwgdHJ1ZSk7XG4gICAgICAgICAgICBjaGlsZENsb25lLl9fcmVtb3ZhbENvdW50ID0gKGN1cnJlbnROb2RlLl9fcmVtb3ZhbENvdW50IHx8IDApICsgMTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkQ2xvbmUsIGdldE5leHRTaWJsaW5nKGN1cnJlbnROb2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIENoZWNrIHdoZXRoZXIgZWxlbWVudCBoYXMgYSB2YWxpZCBuYW1lc3BhY2UgKi9cbiAgICBpZiAoY3VycmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFfY2hlY2tWYWxpZE5hbWVzcGFjZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgb2xkZXIgYnJvd3NlcnMgZG9uJ3QgZ2V0IGZhbGxiYWNrLXRhZyBtWFNTICovXG4gICAgaWYgKCh0YWdOYW1lID09PSAnbm9zY3JpcHQnIHx8IHRhZ05hbWUgPT09ICdub2VtYmVkJyB8fCB0YWdOYW1lID09PSAnbm9mcmFtZXMnKSAmJiByZWdFeHBUZXN0KC88XFwvbm8oc2NyaXB0fGVtYmVkfGZyYW1lcykvaSwgY3VycmVudE5vZGUuaW5uZXJIVE1MKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBTYW5pdGl6ZSBlbGVtZW50IGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRS50ZXh0KSB7XG4gICAgICAvKiBHZXQgdGhlIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnQgKi9cbiAgICAgIGNvbnRlbnQgPSBjdXJyZW50Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGFycmF5Rm9yRWFjaChbTVVTVEFDSEVfRVhQUiwgRVJCX0VYUFIsIFRNUExJVF9FWFBSXSwgZXhwciA9PiB7XG4gICAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIGV4cHIsICcgJyk7XG4gICAgICB9KTtcbiAgICAgIGlmIChjdXJyZW50Tm9kZS50ZXh0Q29udGVudCAhPT0gY29udGVudCkge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgICBlbGVtZW50OiBjdXJyZW50Tm9kZS5jbG9uZU5vZGUoKVxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudE5vZGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5hZnRlclNhbml0aXplRWxlbWVudHMsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKlxuICAgKiBfaXNWYWxpZEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gbGNUYWcgTG93ZXJjYXNlIHRhZyBuYW1lIG9mIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICogQHBhcmFtIGxjTmFtZSBMb3dlcmNhc2UgYXR0cmlidXRlIG5hbWUuXG4gICAqIEBwYXJhbSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAqIEByZXR1cm4gUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGNvbnN0IF9pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpIHtcbiAgICAvKiBNYWtlIHN1cmUgYXR0cmlidXRlIGNhbm5vdCBjbG9iYmVyICovXG4gICAgaWYgKFNBTklUSVpFX0RPTSAmJiAobGNOYW1lID09PSAnaWQnIHx8IGxjTmFtZSA9PT0gJ25hbWUnKSAmJiAodmFsdWUgaW4gZG9jdW1lbnQgfHwgdmFsdWUgaW4gZm9ybUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qIEFsbG93IHZhbGlkIGRhdGEtKiBhdHRyaWJ1dGVzOiBBdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGFmdGVyIFwiLVwiXG4gICAgICAgIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNlbWJlZGRpbmctY3VzdG9tLW5vbi12aXNpYmxlLWRhdGEtd2l0aC10aGUtZGF0YS0qLWF0dHJpYnV0ZXMpXG4gICAgICAgIFhNTC1jb21wYXRpYmxlIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3htbC1jb21wYXRpYmxlIGFuZCBodHRwOi8vd3d3LnczLm9yZy9UUi94bWwvI2QwZTgwNClcbiAgICAgICAgV2UgZG9uJ3QgbmVlZCB0byBjaGVjayB0aGUgdmFsdWU7IGl0J3MgYWx3YXlzIFVSSSBzYWZlLiAqL1xuICAgIGlmIChBTExPV19EQVRBX0FUVFIgJiYgIUZPUkJJRF9BVFRSW2xjTmFtZV0gJiYgcmVnRXhwVGVzdChEQVRBX0FUVFIsIGxjTmFtZSkpIDsgZWxzZSBpZiAoQUxMT1dfQVJJQV9BVFRSICYmIHJlZ0V4cFRlc3QoQVJJQV9BVFRSLCBsY05hbWUpKSA7IGVsc2UgaWYgKEVYVFJBX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBFWFRSQV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZUNoZWNrKGxjTmFtZSwgbGNUYWcpKSA7IGVsc2UgaWYgKCFBTExPV0VEX0FUVFJbbGNOYW1lXSB8fCBGT1JCSURfQVRUUltsY05hbWVdKSB7XG4gICAgICBpZiAoXG4gICAgICAvLyBGaXJzdCBjb25kaXRpb24gZG9lcyBhIHZlcnkgYmFzaWMgY2hlY2sgaWYgYSkgaXQncyBiYXNpY2FsbHkgYSB2YWxpZCBjdXN0b20gZWxlbWVudCB0YWduYW1lIEFORFxuICAgICAgLy8gYikgaWYgdGhlIHRhZ05hbWUgcGFzc2VzIHdoYXRldmVyIHRoZSB1c2VyIGhhcyBjb25maWd1cmVkIGZvciBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2tcbiAgICAgIC8vIGFuZCBjKSBpZiB0aGUgYXR0cmlidXRlIG5hbWUgcGFzc2VzIHdoYXRldmVyIHRoZSB1c2VyIGhhcyBjb25maWd1cmVkIGZvciBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2tcbiAgICAgIF9pc0Jhc2ljQ3VzdG9tRWxlbWVudChsY1RhZykgJiYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgbGNUYWcpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayhsY1RhZykpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2ssIGxjTmFtZSkgfHwgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrKGxjTmFtZSwgbGNUYWcpKSB8fFxuICAgICAgLy8gQWx0ZXJuYXRpdmUsIHNlY29uZCBjb25kaXRpb24gY2hlY2tzIGlmIGl0J3MgYW4gYGlzYC1hdHRyaWJ1dGUsIEFORFxuICAgICAgLy8gdGhlIHZhbHVlIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrXG4gICAgICBsY05hbWUgPT09ICdpcycgJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHZhbHVlKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodmFsdWUpKSkgOyBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyogQ2hlY2sgdmFsdWUgaXMgc2FmZS4gRmlyc3QsIGlzIGF0dHIgaW5lcnQ/IElmIHNvLCBpcyBzYWZlICovXG4gICAgfSBlbHNlIGlmIChVUklfU0FGRV9BVFRSSUJVVEVTW2xjTmFtZV0pIDsgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UsICcnKSkpIDsgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSkgOyBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFLCAnJykpKSA7IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc0Jhc2ljQ3VzdG9tRWxlbWVudFxuICAgKiBjaGVja3MgaWYgYXQgbGVhc3Qgb25lIGRhc2ggaXMgaW5jbHVkZWQgaW4gdGFnTmFtZSwgYW5kIGl0J3Mgbm90IHRoZSBmaXJzdCBjaGFyXG4gICAqIGZvciBtb3JlIHNvcGhpc3RpY2F0ZWQgY2hlY2tpbmcgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvdmFsaWRhdGUtZWxlbWVudC1uYW1lXG4gICAqXG4gICAqIEBwYXJhbSB0YWdOYW1lIG5hbWUgb2YgdGhlIHRhZyBvZiB0aGUgbm9kZSB0byBzYW5pdGl6ZVxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyBuYW1lIG1lZXRzIHRoZSBiYXNpYyBjcml0ZXJpYSBmb3IgYSBjdXN0b20gZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgY29uc3QgX2lzQmFzaWNDdXN0b21FbGVtZW50ID0gZnVuY3Rpb24gX2lzQmFzaWNDdXN0b21FbGVtZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gdGFnTmFtZSAhPT0gJ2Fubm90YXRpb24teG1sJyAmJiBzdHJpbmdNYXRjaCh0YWdOYW1lLCBDVVNUT01fRUxFTUVOVCk7XG4gIH07XG4gIC8qKlxuICAgKiBfc2FuaXRpemVBdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwcm90ZWN0IGF0dHJpYnV0ZXNcbiAgICogQHByb3RlY3Qgbm9kZU5hbWVcbiAgICogQHByb3RlY3QgcmVtb3ZlQXR0cmlidXRlXG4gICAqIEBwcm90ZWN0IHNldEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudE5vZGUgdG8gc2FuaXRpemVcbiAgICovXG4gIGNvbnN0IF9zYW5pdGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKSB7XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBjdXJyZW50Tm9kZTtcbiAgICAvKiBDaGVjayBpZiB3ZSBoYXZlIGF0dHJpYnV0ZXM7IGlmIG5vdCB3ZSBtaWdodCBoYXZlIGEgdGV4dCBub2RlICovXG4gICAgaWYgKCFhdHRyaWJ1dGVzIHx8IF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaG9va0V2ZW50ID0ge1xuICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgYXR0clZhbHVlOiAnJyxcbiAgICAgIGtlZXBBdHRyOiB0cnVlLFxuICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUixcbiAgICAgIGZvcmNlS2VlcEF0dHI6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgbGV0IGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAvKiBHbyBiYWNrd2FyZHMgb3ZlciBhbGwgYXR0cmlidXRlczsgc2FmZWx5IHJlbW92ZSBiYWQgb25lcyAqL1xuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2xdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBuYW1lc3BhY2VVUkksXG4gICAgICAgIHZhbHVlOiBhdHRyVmFsdWVcbiAgICAgIH0gPSBhdHRyO1xuICAgICAgY29uc3QgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMobmFtZSk7XG4gICAgICBjb25zdCBpbml0VmFsdWUgPSBhdHRyVmFsdWU7XG4gICAgICBsZXQgdmFsdWUgPSBuYW1lID09PSAndmFsdWUnID8gaW5pdFZhbHVlIDogc3RyaW5nVHJpbShpbml0VmFsdWUpO1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgaG9va0V2ZW50LmF0dHJOYW1lID0gbGNOYW1lO1xuICAgICAgaG9va0V2ZW50LmF0dHJWYWx1ZSA9IHZhbHVlO1xuICAgICAgaG9va0V2ZW50LmtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgIGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyID0gdW5kZWZpbmVkOyAvLyBBbGxvd3MgZGV2ZWxvcGVycyB0byBzZWUgdGhpcyBpcyBhIHByb3BlcnR5IHRoZXkgY2FuIHNldFxuICAgICAgX2V4ZWN1dGVIb29rcyhob29rcy51cG9uU2FuaXRpemVBdHRyaWJ1dGUsIGN1cnJlbnROb2RlLCBob29rRXZlbnQpO1xuICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgLyogRnVsbCBET00gQ2xvYmJlcmluZyBwcm90ZWN0aW9uIHZpYSBuYW1lc3BhY2UgaXNvbGF0aW9uLFxuICAgICAgICogUHJlZml4IGlkIGFuZCBuYW1lIGF0dHJpYnV0ZXMgd2l0aCBgdXNlci1jb250ZW50LWBcbiAgICAgICAqL1xuICAgICAgaWYgKFNBTklUSVpFX05BTUVEX1BST1BTICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlIHdpdGggdGhpcyB2YWx1ZVxuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgLy8gUHJlZml4IHRoZSB2YWx1ZSBhbmQgbGF0ZXIgcmUtY3JlYXRlIHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FuaXRpemVkIHZhbHVlXG4gICAgICAgIHZhbHVlID0gU0FOSVRJWkVfTkFNRURfUFJPUFNfUFJFRklYICsgdmFsdWU7XG4gICAgICB9XG4gICAgICAvKiBXb3JrIGFyb3VuZCBhIHNlY3VyaXR5IGlzc3VlIHdpdGggY29tbWVudHMgaW5zaWRlIGF0dHJpYnV0ZXMgKi9cbiAgICAgIGlmIChTQUZFX0ZPUl9YTUwgJiYgcmVnRXhwVGVzdCgvKCgtLSE/fF0pPil8PFxcLyhzdHlsZXx0aXRsZXx0ZXh0YXJlYSkvaSwgdmFsdWUpKSB7XG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIE1ha2Ugc3VyZSB3ZSBjYW5ub3QgZWFzaWx5IHVzZSBhbmltYXRlZCBocmVmcywgZXZlbiBpZiBhbmltYXRpb25zIGFyZSBhbGxvd2VkICovXG4gICAgICBpZiAobGNOYW1lID09PSAnYXR0cmlidXRlbmFtZScgJiYgc3RyaW5nTWF0Y2godmFsdWUsICdocmVmJykpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG4gICAgICBpZiAoaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGlmICghaG9va0V2ZW50LmtlZXBBdHRyKSB7XG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIFdvcmsgYXJvdW5kIGEgc2VjdXJpdHkgaXNzdWUgaW4galF1ZXJ5IDMuMCAqL1xuICAgICAgaWYgKCFBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgJiYgcmVnRXhwVGVzdCgvXFwvPi9pLCB2YWx1ZSkpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogU2FuaXRpemUgYXR0cmlidXRlIGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICBhcnJheUZvckVhY2goW01VU1RBQ0hFX0VYUFIsIEVSQl9FWFBSLCBUTVBMSVRfRVhQUl0sIGV4cHIgPT4ge1xuICAgICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgZXhwciwgJyAnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKiBJcyBgdmFsdWVgIHZhbGlkIGZvciB0aGlzIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGNvbnN0IGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmMoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuICAgICAgaWYgKCFfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogSGFuZGxlIGF0dHJpYnV0ZXMgdGhhdCByZXF1aXJlIFRydXN0ZWQgVHlwZXMgKi9cbiAgICAgIGlmICh0cnVzdGVkVHlwZXNQb2xpY3kgJiYgdHlwZW9mIHRydXN0ZWRUeXBlcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRydXN0ZWRUeXBlcy5nZXRBdHRyaWJ1dGVUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIDsgZWxzZSB7XG4gICAgICAgICAgc3dpdGNoICh0cnVzdGVkVHlwZXMuZ2V0QXR0cmlidXRlVHlwZShsY1RhZywgbGNOYW1lKSkge1xuICAgICAgICAgICAgY2FzZSAnVHJ1c3RlZEhUTUwnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1RydXN0ZWRTY3JpcHRVUkwnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlU2NyaXB0VVJMKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogSGFuZGxlIGludmFsaWQgZGF0YS0qIGF0dHJpYnV0ZSBzZXQgYnkgdHJ5LWNhdGNoaW5nIGl0ICovXG4gICAgICBpZiAodmFsdWUgIT09IGluaXRWYWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBzZXRBdHRyaWJ1dGUoKSBmb3IgYnJvd3Nlci11bnJlY29nbml6ZWQgbmFtZXNwYWNlcyBlLmcuIFwieC1zY2hlbWFcIi4gKi9cbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfaXNDbG9iYmVyZWQoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVBvcChET01QdXJpZnkucmVtb3ZlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgfTtcbiAgLyoqXG4gICAqIF9zYW5pdGl6ZVNoYWRvd0RPTVxuICAgKlxuICAgKiBAcGFyYW0gZnJhZ21lbnQgdG8gaXRlcmF0ZSBvdmVyIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBjb25zdCBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICBsZXQgc2hhZG93Tm9kZSA9IG51bGw7XG4gICAgY29uc3Qgc2hhZG93SXRlcmF0b3IgPSBfY3JlYXRlTm9kZUl0ZXJhdG9yKGZyYWdtZW50KTtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5iZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTSwgZnJhZ21lbnQsIG51bGwpO1xuICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rcyhob29rcy51cG9uU2FuaXRpemVTaGFkb3dOb2RlLCBzaGFkb3dOb2RlLCBudWxsKTtcbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICBfc2FuaXRpemVFbGVtZW50cyhzaGFkb3dOb2RlKTtcbiAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMgbmV4dCAqL1xuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICAgIC8qIERlZXAgc2hhZG93IERPTSBkZXRlY3RlZCAqL1xuICAgICAgaWYgKHNoYWRvd05vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKHNoYWRvd05vZGUuY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmFmdGVyU2FuaXRpemVTaGFkb3dET00sIGZyYWdtZW50LCBudWxsKTtcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgRE9NUHVyaWZ5LnNhbml0aXplID0gZnVuY3Rpb24gKGRpcnR5KSB7XG4gICAgbGV0IGNmZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IGJvZHkgPSBudWxsO1xuICAgIGxldCBpbXBvcnRlZE5vZGUgPSBudWxsO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgbGV0IHJldHVybk5vZGUgPSBudWxsO1xuICAgIC8qIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc3RyaW5nIHRvIHNhbml0aXplLlxuICAgICAgRE8gTk9UIHJldHVybiBlYXJseSwgYXMgdGhpcyB3aWxsIHJldHVybiB0aGUgd3JvbmcgdHlwZSBpZlxuICAgICAgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBhIERPTSBvYmplY3QgcmF0aGVyIHRoYW4gYSBzdHJpbmcgKi9cbiAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcbiAgICBpZiAoSVNfRU1QVFlfSU5QVVQpIHtcbiAgICAgIGRpcnR5ID0gJzwhLS0+JztcbiAgICB9XG4gICAgLyogU3RyaW5naWZ5LCBpbiBjYXNlIGRpcnR5IGlzIGFuIG9iamVjdCAqL1xuICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgaWYgKHR5cGVvZiBkaXJ0eS50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJ0eSA9IGRpcnR5LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdkaXJ0eSBpcyBub3QgYSBzdHJpbmcsIGFib3J0aW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgndG9TdHJpbmcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogUmV0dXJuIGRpcnR5IEhUTUwgaWYgRE9NUHVyaWZ5IGNhbm5vdCBydW4gKi9cbiAgICBpZiAoIURPTVB1cmlmeS5pc1N1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICAvKiBBc3NpZ24gY29uZmlnIHZhcnMgKi9cbiAgICBpZiAoIVNFVF9DT05GSUcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgIH1cbiAgICAvKiBDbGVhbiB1cCByZW1vdmVkIGVsZW1lbnRzICovXG4gICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcbiAgICAvKiBDaGVjayBpZiBkaXJ0eSBpcyBjb3JyZWN0bHkgdHlwZWQgZm9yIElOX1BMQUNFICovXG4gICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIElOX1BMQUNFID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgLyogRG8gc29tZSBlYXJseSBwcmUtc2FuaXRpemF0aW9uIHRvIGF2b2lkIHVuc2FmZSByb290IG5vZGVzICovXG4gICAgICBpZiAoZGlydHkubm9kZU5hbWUpIHtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGRpcnR5Lm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ3Jvb3Qgbm9kZSBpcyBmb3JiaWRkZW4gYW5kIGNhbm5vdCBiZSBzYW5pdGl6ZWQgaW4tcGxhY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlydHkgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAvKiBJZiBkaXJ0eSBpcyBhIERPTSBlbGVtZW50LCBhcHBlbmQgdG8gYW4gZW1wdHkgZG9jdW1lbnQgdG8gYXZvaWRcbiAgICAgICAgIGVsZW1lbnRzIGJlaW5nIHN0cmlwcGVkIGJ5IHRoZSBwYXJzZXIgKi9cbiAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICBpbXBvcnRlZE5vZGUgPSBib2R5Lm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShkaXJ0eSwgdHJ1ZSk7XG4gICAgICBpZiAoaW1wb3J0ZWROb2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEUuZWxlbWVudCAmJiBpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAvKiBOb2RlIGlzIGFscmVhZHkgYSBib2R5LCB1c2UgYXMgaXMgKi9cbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbXBvcnRlZE5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBFeGl0IGRpcmVjdGx5IGlmIHdlIGhhdmUgbm90aGluZyB0byBkbyAqL1xuICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItaW5jbHVkZXNcbiAgICAgIGRpcnR5LmluZGV4T2YoJzwnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICB9XG4gICAgICAvKiBJbml0aWFsaXplIHRoZSBkb2N1bWVudCB0byB3b3JrIG9uICovXG4gICAgICBib2R5ID0gX2luaXREb2N1bWVudChkaXJ0eSk7XG4gICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IFJFVFVSTl9UUlVTVEVEX1RZUEUgPyBlbXB0eUhUTUwgOiAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgLyogUmVtb3ZlIGZpcnN0IGVsZW1lbnQgbm9kZSAob3VycykgaWYgRk9SQ0VfQk9EWSBpcyBzZXQgKi9cbiAgICBpZiAoYm9keSAmJiBGT1JDRV9CT0RZKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoYm9keS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgLyogR2V0IG5vZGUgaXRlcmF0b3IgKi9cbiAgICBjb25zdCBub2RlSXRlcmF0b3IgPSBfY3JlYXRlTm9kZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTtcbiAgICAvKiBOb3cgc3RhcnQgaXRlcmF0aW5nIG92ZXIgdGhlIGNyZWF0ZWQgZG9jdW1lbnQgKi9cbiAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKTtcbiAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMgbmV4dCAqL1xuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSk7XG4gICAgICAvKiBTaGFkb3cgRE9NIGRldGVjdGVkLCBzYW5pdGl6ZSBpdCAqL1xuICAgICAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgd2Ugc2FuaXRpemVkIGBkaXJ0eWAgaW4tcGxhY2UsIHJldHVybiBpdC4gKi9cbiAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgLyogUmV0dXJuIHNhbml0aXplZCBzdHJpbmcgb3IgRE9NICovXG4gICAgaWYgKFJFVFVSTl9ET00pIHtcbiAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgIHJldHVybk5vZGUgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmNhbGwoYm9keS5vd25lckRvY3VtZW50KTtcbiAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgICByZXR1cm5Ob2RlLmFwcGVuZENoaWxkKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybk5vZGUgPSBib2R5O1xuICAgICAgfVxuICAgICAgaWYgKEFMTE9XRURfQVRUUi5zaGFkb3dyb290IHx8IEFMTE9XRURfQVRUUi5zaGFkb3dyb290bW9kZSkge1xuICAgICAgICAvKlxuICAgICAgICAgIEFkb3B0Tm9kZSgpIGlzIG5vdCB1c2VkIGJlY2F1c2UgaW50ZXJuYWwgc3RhdGUgaXMgbm90IHJlc2V0XG4gICAgICAgICAgKGUuZy4gdGhlIHBhc3QgbmFtZXMgbWFwIG9mIGEgSFRNTEZvcm1FbGVtZW50KSwgdGhpcyBpcyBzYWZlXG4gICAgICAgICAgaW4gdGhlb3J5IGJ1dCB3ZSB3b3VsZCByYXRoZXIgbm90IHJpc2sgYW5vdGhlciBhdHRhY2sgdmVjdG9yLlxuICAgICAgICAgIFRoZSBzdGF0ZSB0aGF0IGlzIGNsb25lZCBieSBpbXBvcnROb2RlKCkgaXMgZXhwbGljaXRseSBkZWZpbmVkXG4gICAgICAgICAgYnkgdGhlIHNwZWNzLlxuICAgICAgICAqL1xuICAgICAgICByZXR1cm5Ob2RlID0gaW1wb3J0Tm9kZS5jYWxsKG9yaWdpbmFsRG9jdW1lbnQsIHJldHVybk5vZGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybk5vZGU7XG4gICAgfVxuICAgIGxldCBzZXJpYWxpemVkSFRNTCA9IFdIT0xFX0RPQ1VNRU5UID8gYm9keS5vdXRlckhUTUwgOiBib2R5LmlubmVySFRNTDtcbiAgICAvKiBTZXJpYWxpemUgZG9jdHlwZSBpZiBhbGxvd2VkICovXG4gICAgaWYgKFdIT0xFX0RPQ1VNRU5UICYmIEFMTE9XRURfVEFHU1snIWRvY3R5cGUnXSAmJiBib2R5Lm93bmVyRG9jdW1lbnQgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSAmJiByZWdFeHBUZXN0KERPQ1RZUEVfTkFNRSwgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSkpIHtcbiAgICAgIHNlcmlhbGl6ZWRIVE1MID0gJzwhRE9DVFlQRSAnICsgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSArICc+XFxuJyArIHNlcmlhbGl6ZWRIVE1MO1xuICAgIH1cbiAgICAvKiBTYW5pdGl6ZSBmaW5hbCBzdHJpbmcgdGVtcGxhdGUtc2FmZSAqL1xuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgIGFycmF5Rm9yRWFjaChbTVVTVEFDSEVfRVhQUiwgRVJCX0VYUFIsIFRNUExJVF9FWFBSXSwgZXhwciA9PiB7XG4gICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgZXhwciwgJyAnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChzZXJpYWxpemVkSFRNTCkgOiBzZXJpYWxpemVkSFRNTDtcbiAgfTtcbiAgRE9NUHVyaWZ5LnNldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY2ZnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICBTRVRfQ09ORklHID0gdHJ1ZTtcbiAgfTtcbiAgRE9NUHVyaWZ5LmNsZWFyQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIENPTkZJRyA9IG51bGw7XG4gICAgU0VUX0NPTkZJRyA9IGZhbHNlO1xuICB9O1xuICBET01QdXJpZnkuaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHIsIHZhbHVlKSB7XG4gICAgLyogSW5pdGlhbGl6ZSBzaGFyZWQgY29uZmlnIHZhcnMgaWYgbmVjZXNzYXJ5LiAqL1xuICAgIGlmICghQ09ORklHKSB7XG4gICAgICBfcGFyc2VDb25maWcoe30pO1xuICAgIH1cbiAgICBjb25zdCBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7XG4gICAgY29uc3QgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoYXR0cik7XG4gICAgcmV0dXJuIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKTtcbiAgfTtcbiAgRE9NUHVyaWZ5LmFkZEhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCwgaG9va0Z1bmN0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBob29rRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXJyYXlQdXNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICB9O1xuICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICBpZiAoaG9va0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gYXJyYXlMYXN0SW5kZXhPZihob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyB1bmRlZmluZWQgOiBhcnJheVNwbGljZShob29rc1tlbnRyeVBvaW50XSwgaW5kZXgsIDEpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlQb3AoaG9va3NbZW50cnlQb2ludF0pO1xuICB9O1xuICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gW107XG4gIH07XG4gIERPTVB1cmlmeS5yZW1vdmVBbGxIb29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBob29rcyA9IF9jcmVhdGVIb29rc01hcCgpO1xuICB9O1xuICByZXR1cm4gRE9NUHVyaWZ5O1xufVxudmFyIHB1cmlmeSA9IGNyZWF0ZURPTVB1cmlmeSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHB1cmlmeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1cmlmeS5janMuanMubWFwXG4iXSwibmFtZXMiOlsiZW50cmllcyIsInNldFByb3RvdHlwZU9mIiwiaXNGcm96ZW4iLCJnZXRQcm90b3R5cGVPZiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIk9iamVjdCIsImZyZWV6ZSIsInNlYWwiLCJjcmVhdGUiLCJhcHBseSIsImNvbnN0cnVjdCIsIlJlZmxlY3QiLCJ4IiwiZnVuYyIsInRoaXNBcmciLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsIkZ1bmMiLCJfbGVuMiIsIl9rZXkyIiwiYXJyYXlGb3JFYWNoIiwidW5hcHBseSIsInByb3RvdHlwZSIsImZvckVhY2giLCJhcnJheUxhc3RJbmRleE9mIiwibGFzdEluZGV4T2YiLCJhcnJheVBvcCIsInBvcCIsImFycmF5UHVzaCIsInB1c2giLCJhcnJheVNwbGljZSIsInNwbGljZSIsInN0cmluZ1RvTG93ZXJDYXNlIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJzdHJpbmdUb1N0cmluZyIsInRvU3RyaW5nIiwic3RyaW5nTWF0Y2giLCJtYXRjaCIsInN0cmluZ1JlcGxhY2UiLCJyZXBsYWNlIiwic3RyaW5nSW5kZXhPZiIsImluZGV4T2YiLCJzdHJpbmdUcmltIiwidHJpbSIsIm9iamVjdEhhc093blByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJyZWdFeHBUZXN0IiwiUmVnRXhwIiwidGVzdCIsInR5cGVFcnJvckNyZWF0ZSIsInVuY29uc3RydWN0IiwiVHlwZUVycm9yIiwibGFzdEluZGV4IiwiX2xlbjMiLCJfa2V5MyIsIl9sZW40IiwiX2tleTQiLCJhZGRUb1NldCIsInNldCIsImFycmF5IiwidHJhbnNmb3JtQ2FzZUZ1bmMiLCJ1bmRlZmluZWQiLCJsIiwiZWxlbWVudCIsImxjRWxlbWVudCIsImNsZWFuQXJyYXkiLCJpbmRleCIsImlzUHJvcGVydHlFeGlzdCIsImNsb25lIiwib2JqZWN0IiwibmV3T2JqZWN0IiwicHJvcGVydHkiLCJ2YWx1ZSIsImlzQXJyYXkiLCJjb25zdHJ1Y3RvciIsImxvb2t1cEdldHRlciIsInByb3AiLCJkZXNjIiwiZ2V0IiwiZmFsbGJhY2tWYWx1ZSIsImh0bWwkMSIsInN2ZyQxIiwic3ZnRmlsdGVycyIsInN2Z0Rpc2FsbG93ZWQiLCJtYXRoTWwkMSIsIm1hdGhNbERpc2FsbG93ZWQiLCJ0ZXh0IiwiaHRtbCIsInN2ZyIsIm1hdGhNbCIsInhtbCIsIk1VU1RBQ0hFX0VYUFIiLCJFUkJfRVhQUiIsIlRNUExJVF9FWFBSIiwiREFUQV9BVFRSIiwiQVJJQV9BVFRSIiwiSVNfQUxMT1dFRF9VUkkiLCJJU19TQ1JJUFRfT1JfREFUQSIsIkFUVFJfV0hJVEVTUEFDRSIsIkRPQ1RZUEVfTkFNRSIsIkNVU1RPTV9FTEVNRU5UIiwiRVhQUkVTU0lPTlMiLCJfX3Byb3RvX18iLCJOT0RFX1RZUEUiLCJhdHRyaWJ1dGUiLCJjZGF0YVNlY3Rpb24iLCJlbnRpdHlSZWZlcmVuY2UiLCJlbnRpdHlOb2RlIiwicHJvZ3Jlc3NpbmdJbnN0cnVjdGlvbiIsImNvbW1lbnQiLCJkb2N1bWVudCIsImRvY3VtZW50VHlwZSIsImRvY3VtZW50RnJhZ21lbnQiLCJub3RhdGlvbiIsImdldEdsb2JhbCIsIndpbmRvdyIsIl9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kiLCJ0cnVzdGVkVHlwZXMiLCJwdXJpZnlIb3N0RWxlbWVudCIsImNyZWF0ZVBvbGljeSIsInN1ZmZpeCIsIkFUVFJfTkFNRSIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInBvbGljeU5hbWUiLCJjcmVhdGVIVE1MIiwiY3JlYXRlU2NyaXB0VVJMIiwic2NyaXB0VXJsIiwiXyIsImNvbnNvbGUiLCJ3YXJuIiwiX2NyZWF0ZUhvb2tzTWFwIiwiYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMiLCJhZnRlclNhbml0aXplRWxlbWVudHMiLCJhZnRlclNhbml0aXplU2hhZG93RE9NIiwiYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzIiwiYmVmb3JlU2FuaXRpemVFbGVtZW50cyIsImJlZm9yZVNhbml0aXplU2hhZG93RE9NIiwidXBvblNhbml0aXplQXR0cmlidXRlIiwidXBvblNhbml0aXplRWxlbWVudCIsInVwb25TYW5pdGl6ZVNoYWRvd05vZGUiLCJjcmVhdGVET01QdXJpZnkiLCJET01QdXJpZnkiLCJyb290IiwidmVyc2lvbiIsInJlbW92ZWQiLCJub2RlVHlwZSIsIkVsZW1lbnQiLCJpc1N1cHBvcnRlZCIsIm9yaWdpbmFsRG9jdW1lbnQiLCJjdXJyZW50U2NyaXB0IiwiRG9jdW1lbnRGcmFnbWVudCIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJOb2RlIiwiTm9kZUZpbHRlciIsIk5hbWVkTm9kZU1hcCIsIk1vek5hbWVkQXR0ck1hcCIsIkhUTUxGb3JtRWxlbWVudCIsIkRPTVBhcnNlciIsIkVsZW1lbnRQcm90b3R5cGUiLCJjbG9uZU5vZGUiLCJyZW1vdmUiLCJnZXROZXh0U2libGluZyIsImdldENoaWxkTm9kZXMiLCJnZXRQYXJlbnROb2RlIiwidGVtcGxhdGUiLCJjcmVhdGVFbGVtZW50IiwiY29udGVudCIsIm93bmVyRG9jdW1lbnQiLCJ0cnVzdGVkVHlwZXNQb2xpY3kiLCJlbXB0eUhUTUwiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZU5vZGVJdGVyYXRvciIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImltcG9ydE5vZGUiLCJob29rcyIsImNyZWF0ZUhUTUxEb2N1bWVudCIsIklTX0FMTE9XRURfVVJJJDEiLCJBTExPV0VEX1RBR1MiLCJERUZBVUxUX0FMTE9XRURfVEFHUyIsIkFMTE9XRURfQVRUUiIsIkRFRkFVTFRfQUxMT1dFRF9BVFRSIiwiQ1VTVE9NX0VMRU1FTlRfSEFORExJTkciLCJ0YWdOYW1lQ2hlY2siLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJhdHRyaWJ1dGVOYW1lQ2hlY2siLCJhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMiLCJGT1JCSURfVEFHUyIsIkZPUkJJRF9BVFRSIiwiRVhUUkFfRUxFTUVOVF9IQU5ETElORyIsInRhZ0NoZWNrIiwiYXR0cmlidXRlQ2hlY2siLCJBTExPV19BUklBX0FUVFIiLCJBTExPV19EQVRBX0FUVFIiLCJBTExPV19VTktOT1dOX1BST1RPQ09MUyIsIkFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiIsIlNBRkVfRk9SX1RFTVBMQVRFUyIsIlNBRkVfRk9SX1hNTCIsIldIT0xFX0RPQ1VNRU5UIiwiU0VUX0NPTkZJRyIsIkZPUkNFX0JPRFkiLCJSRVRVUk5fRE9NIiwiUkVUVVJOX0RPTV9GUkFHTUVOVCIsIlJFVFVSTl9UUlVTVEVEX1RZUEUiLCJTQU5JVElaRV9ET00iLCJTQU5JVElaRV9OQU1FRF9QUk9QUyIsIlNBTklUSVpFX05BTUVEX1BST1BTX1BSRUZJWCIsIktFRVBfQ09OVEVOVCIsIklOX1BMQUNFIiwiVVNFX1BST0ZJTEVTIiwiRk9SQklEX0NPTlRFTlRTIiwiREVGQVVMVF9GT1JCSURfQ09OVEVOVFMiLCJEQVRBX1VSSV9UQUdTIiwiREVGQVVMVF9EQVRBX1VSSV9UQUdTIiwiVVJJX1NBRkVfQVRUUklCVVRFUyIsIkRFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyIsIk1BVEhNTF9OQU1FU1BBQ0UiLCJTVkdfTkFNRVNQQUNFIiwiSFRNTF9OQU1FU1BBQ0UiLCJOQU1FU1BBQ0UiLCJJU19FTVBUWV9JTlBVVCIsIkFMTE9XRURfTkFNRVNQQUNFUyIsIkRFRkFVTFRfQUxMT1dFRF9OQU1FU1BBQ0VTIiwiTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTIiwiSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMiLCJDT01NT05fU1ZHX0FORF9IVE1MX0VMRU1FTlRTIiwiUEFSU0VSX01FRElBX1RZUEUiLCJTVVBQT1JURURfUEFSU0VSX01FRElBX1RZUEVTIiwiREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSIsIkNPTkZJRyIsImZvcm1FbGVtZW50IiwiaXNSZWdleE9yRnVuY3Rpb24iLCJ0ZXN0VmFsdWUiLCJGdW5jdGlvbiIsIl9wYXJzZUNvbmZpZyIsImNmZyIsIkFERF9VUklfU0FGRV9BVFRSIiwiQUREX0RBVEFfVVJJX1RBR1MiLCJBTExPV0VEX1VSSV9SRUdFWFAiLCJBRERfVEFHUyIsIkFERF9BVFRSIiwiQUREX0ZPUkJJRF9DT05URU5UUyIsInRhYmxlIiwidGJvZHkiLCJUUlVTVEVEX1RZUEVTX1BPTElDWSIsIkFMTF9TVkdfVEFHUyIsIkFMTF9NQVRITUxfVEFHUyIsIl9jaGVja1ZhbGlkTmFtZXNwYWNlIiwicGFyZW50IiwidGFnTmFtZSIsIm5hbWVzcGFjZVVSSSIsInBhcmVudFRhZ05hbWUiLCJCb29sZWFuIiwiX2ZvcmNlUmVtb3ZlIiwibm9kZSIsInJlbW92ZUNoaWxkIiwiX3JlbW92ZUF0dHJpYnV0ZSIsIm5hbWUiLCJnZXRBdHRyaWJ1dGVOb2RlIiwiZnJvbSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsIl9pbml0RG9jdW1lbnQiLCJkaXJ0eSIsImRvYyIsImxlYWRpbmdXaGl0ZXNwYWNlIiwibWF0Y2hlcyIsImRpcnR5UGF5bG9hZCIsInBhcnNlRnJvbVN0cmluZyIsImRvY3VtZW50RWxlbWVudCIsImNyZWF0ZURvY3VtZW50IiwiaW5uZXJIVE1MIiwiYm9keSIsImluc2VydEJlZm9yZSIsImNyZWF0ZVRleHROb2RlIiwiY2hpbGROb2RlcyIsImNhbGwiLCJfY3JlYXRlTm9kZUl0ZXJhdG9yIiwiU0hPV19FTEVNRU5UIiwiU0hPV19DT01NRU5UIiwiU0hPV19URVhUIiwiU0hPV19QUk9DRVNTSU5HX0lOU1RSVUNUSU9OIiwiU0hPV19DREFUQV9TRUNUSU9OIiwiX2lzQ2xvYmJlcmVkIiwibm9kZU5hbWUiLCJ0ZXh0Q29udGVudCIsImF0dHJpYnV0ZXMiLCJoYXNDaGlsZE5vZGVzIiwiX2lzTm9kZSIsIl9leGVjdXRlSG9va3MiLCJjdXJyZW50Tm9kZSIsImRhdGEiLCJob29rIiwiX3Nhbml0aXplRWxlbWVudHMiLCJhbGxvd2VkVGFncyIsImZpcnN0RWxlbWVudENoaWxkIiwiX2lzQmFzaWNDdXN0b21FbGVtZW50IiwicGFyZW50Tm9kZSIsImNoaWxkQ291bnQiLCJpIiwiY2hpbGRDbG9uZSIsIl9fcmVtb3ZhbENvdW50IiwiZXhwciIsIl9pc1ZhbGlkQXR0cmlidXRlIiwibGNUYWciLCJsY05hbWUiLCJfc2FuaXRpemVBdHRyaWJ1dGVzIiwiaG9va0V2ZW50IiwiYXR0ck5hbWUiLCJhdHRyVmFsdWUiLCJrZWVwQXR0ciIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiZm9yY2VLZWVwQXR0ciIsImF0dHIiLCJpbml0VmFsdWUiLCJnZXRBdHRyaWJ1dGVUeXBlIiwic2V0QXR0cmlidXRlTlMiLCJfc2FuaXRpemVTaGFkb3dET00iLCJmcmFnbWVudCIsInNoYWRvd05vZGUiLCJzaGFkb3dJdGVyYXRvciIsIm5leHROb2RlIiwic2FuaXRpemUiLCJpbXBvcnRlZE5vZGUiLCJyZXR1cm5Ob2RlIiwiYXBwZW5kQ2hpbGQiLCJmaXJzdENoaWxkIiwibm9kZUl0ZXJhdG9yIiwic2hhZG93cm9vdCIsInNoYWRvd3Jvb3Rtb2RlIiwic2VyaWFsaXplZEhUTUwiLCJvdXRlckhUTUwiLCJkb2N0eXBlIiwic2V0Q29uZmlnIiwiY2xlYXJDb25maWciLCJpc1ZhbGlkQXR0cmlidXRlIiwidGFnIiwiYWRkSG9vayIsImVudHJ5UG9pbnQiLCJob29rRnVuY3Rpb24iLCJyZW1vdmVIb29rIiwicmVtb3ZlSG9va3MiLCJyZW1vdmVBbGxIb29rcyIsInB1cmlmeSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dompurify/dist/purify.cjs.js\n");

/***/ })

};
;