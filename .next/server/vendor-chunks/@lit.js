"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lit";
exports.ids = ["vendor-chunks/@lit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/css-tag.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/css-tag.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSResult: () => (/* binding */ CSSResult),\n/* harmony export */   adoptStyles: () => (/* binding */ adoptStyles),\n/* harmony export */   css: () => (/* binding */ css),\n/* harmony export */   getCompatibleStyle: () => (/* binding */ getCompatibleStyle),\n/* harmony export */   supportsAdoptingStyleSheets: () => (/* binding */ supportsAdoptingStyleSheets),\n/* harmony export */   unsafeCSS: () => (/* binding */ unsafeCSS)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ // Allows minifiers to rename references to globalThis\nconst global = globalThis;\n/**\n * Whether the current browser supports `adoptedStyleSheets`.\n */ const supportsAdoptingStyleSheets = global.ShadowRoot && (global.ShadyCSS === undefined || global.ShadyCSS.nativeShadow) && \"adoptedStyleSheets\" in Document.prototype && \"replace\" in CSSStyleSheet.prototype;\nconst constructionToken = Symbol();\nconst cssTagCache = new WeakMap();\n/**\n * A container for a string of CSS text, that may be used to create a CSSStyleSheet.\n *\n * CSSResult is the return value of `css`-tagged template literals and\n * `unsafeCSS()`. In order to ensure that CSSResults are only created via the\n * `css` tag and `unsafeCSS()`, CSSResult cannot be constructed directly.\n */ class CSSResult {\n    constructor(cssText, strings, safeToken){\n        // This property needs to remain unminified.\n        this[\"_$cssResult$\"] = true;\n        if (safeToken !== constructionToken) {\n            throw new Error(\"CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\");\n        }\n        this.cssText = cssText;\n        this._strings = strings;\n    }\n    // This is a getter so that it's lazy. In practice, this means stylesheets\n    // are not created until the first element instance is made.\n    get styleSheet() {\n        // If `supportsAdoptingStyleSheets` is true then we assume CSSStyleSheet is\n        // constructable.\n        let styleSheet = this._styleSheet;\n        const strings = this._strings;\n        if (supportsAdoptingStyleSheets && styleSheet === undefined) {\n            const cacheable = strings !== undefined && strings.length === 1;\n            if (cacheable) {\n                styleSheet = cssTagCache.get(strings);\n            }\n            if (styleSheet === undefined) {\n                (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);\n                if (cacheable) {\n                    cssTagCache.set(strings, styleSheet);\n                }\n            }\n        }\n        return styleSheet;\n    }\n    toString() {\n        return this.cssText;\n    }\n}\nconst textFromCSSResult = (value)=>{\n    // This property needs to remain unminified.\n    if (value[\"_$cssResult$\"] === true) {\n        return value.cssText;\n    } else if (typeof value === \"number\") {\n        return value;\n    } else {\n        throw new Error(`Value passed to 'css' function must be a 'css' function result: ` + `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` + `to ensure page security.`);\n    }\n};\n/**\n * Wrap a value for interpolation in a {@linkcode css} tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */ const unsafeCSS = (value)=>new CSSResult(typeof value === \"string\" ? value : String(value), undefined, constructionToken);\n/**\n * A template literal tag which can be used with LitElement's\n * {@linkcode LitElement.styles} property to set element styles.\n *\n * For security reasons, only literal string values and number may be used in\n * embedded expressions. To incorporate non-literal values {@linkcode unsafeCSS}\n * may be used inside an expression.\n */ const css = (strings, ...values)=>{\n    const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v, idx)=>acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);\n    return new CSSResult(cssText, strings, constructionToken);\n};\n/**\n * Applies the given styles to a `shadowRoot`. When Shadow DOM is\n * available but `adoptedStyleSheets` is not, styles are appended to the\n * `shadowRoot` to [mimic the native feature](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/adoptedStyleSheets).\n * Note, when shimming is used, any styles that are subsequently placed into\n * the shadowRoot should be placed *before* any shimmed adopted styles. This\n * will match spec behavior that gives adopted sheets precedence over styles in\n * shadowRoot.\n */ const adoptStyles = (renderRoot, styles)=>{\n    if (supportsAdoptingStyleSheets) {\n        renderRoot.adoptedStyleSheets = styles.map((s)=>s instanceof CSSStyleSheet ? s : s.styleSheet);\n    } else {\n        for (const s of styles){\n            const style = document.createElement(\"style\");\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const nonce = global[\"litNonce\"];\n            if (nonce !== undefined) {\n                style.setAttribute(\"nonce\", nonce);\n            }\n            style.textContent = s.cssText;\n            renderRoot.appendChild(style);\n        }\n    }\n};\nconst cssResultFromStyleSheet = (sheet)=>{\n    let cssText = \"\";\n    for (const rule of sheet.cssRules){\n        cssText += rule.cssText;\n    }\n    return unsafeCSS(cssText);\n};\nconst getCompatibleStyle = supportsAdoptingStyleSheets || global.CSSStyleSheet === undefined ? (s)=>s : (s)=>s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;\n //# sourceMappingURL=css-tag.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvY3NzLXRhZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0Qsc0RBQXNEO0FBQ3RELE1BQU1BLFNBQVNDO0FBQ2Y7O0NBRUMsR0FDRCxNQUFNQyw4QkFBOEJGLE9BQU9HLFVBQVUsSUFDaERILENBQUFBLE9BQU9JLFFBQVEsS0FBS0MsYUFBYUwsT0FBT0ksUUFBUSxDQUFDRSxZQUFZLEtBQzlELHdCQUF3QkMsU0FBU0MsU0FBUyxJQUMxQyxhQUFhQyxjQUFjRCxTQUFTO0FBQ3hDLE1BQU1FLG9CQUFvQkM7QUFDMUIsTUFBTUMsY0FBYyxJQUFJQztBQUN4Qjs7Ozs7O0NBTUMsR0FDRCxNQUFNQztJQUNGQyxZQUFZQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsU0FBUyxDQUFFO1FBQ3JDLDRDQUE0QztRQUM1QyxJQUFJLENBQUMsZUFBZSxHQUFHO1FBQ3ZCLElBQUlBLGNBQWNSLG1CQUFtQjtZQUNqQyxNQUFNLElBQUlTLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNILE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNJLFFBQVEsR0FBR0g7SUFDcEI7SUFDQSwwRUFBMEU7SUFDMUUsNERBQTREO0lBQzVELElBQUlJLGFBQWE7UUFDYiwyRUFBMkU7UUFDM0UsaUJBQWlCO1FBQ2pCLElBQUlBLGFBQWEsSUFBSSxDQUFDQyxXQUFXO1FBQ2pDLE1BQU1MLFVBQVUsSUFBSSxDQUFDRyxRQUFRO1FBQzdCLElBQUlsQiwrQkFBK0JtQixlQUFlaEIsV0FBVztZQUN6RCxNQUFNa0IsWUFBWU4sWUFBWVosYUFBYVksUUFBUU8sTUFBTSxLQUFLO1lBQzlELElBQUlELFdBQVc7Z0JBQ1hGLGFBQWFULFlBQVlhLEdBQUcsQ0FBQ1I7WUFDakM7WUFDQSxJQUFJSSxlQUFlaEIsV0FBVztnQkFDekIsS0FBSSxDQUFDaUIsV0FBVyxHQUFHRCxhQUFhLElBQUlaLGVBQWMsRUFBR2lCLFdBQVcsQ0FBQyxJQUFJLENBQUNWLE9BQU87Z0JBQzlFLElBQUlPLFdBQVc7b0JBQ1hYLFlBQVllLEdBQUcsQ0FBQ1YsU0FBU0k7Z0JBQzdCO1lBQ0o7UUFDSjtRQUNBLE9BQU9BO0lBQ1g7SUFDQU8sV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDWixPQUFPO0lBQ3ZCO0FBQ0o7QUFDQSxNQUFNYSxvQkFBb0IsQ0FBQ0M7SUFDdkIsNENBQTRDO0lBQzVDLElBQUlBLEtBQUssQ0FBQyxlQUFlLEtBQUssTUFBTTtRQUNoQyxPQUFPQSxNQUFNZCxPQUFPO0lBQ3hCLE9BQ0ssSUFBSSxPQUFPYyxVQUFVLFVBQVU7UUFDaEMsT0FBT0E7SUFDWCxPQUNLO1FBQ0QsTUFBTSxJQUFJWCxNQUFNLENBQUMsZ0VBQWdFLENBQUMsR0FDOUUsQ0FBQyxFQUFFVyxNQUFNLDREQUE0RCxDQUFDLEdBQ3RFLENBQUMsd0JBQXdCLENBQUM7SUFDbEM7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELE1BQU1DLFlBQVksQ0FBQ0QsUUFBVSxJQUFJaEIsVUFBVSxPQUFPZ0IsVUFBVSxXQUFXQSxRQUFRRSxPQUFPRixRQUFRekIsV0FBV0s7QUFDekc7Ozs7Ozs7Q0FPQyxHQUNELE1BQU11QixNQUFNLENBQUNoQixTQUFTLEdBQUdpQjtJQUNyQixNQUFNbEIsVUFBVUMsUUFBUU8sTUFBTSxLQUFLLElBQzdCUCxPQUFPLENBQUMsRUFBRSxHQUNWaUIsT0FBT0MsTUFBTSxDQUFDLENBQUNDLEtBQUtDLEdBQUdDLE1BQVFGLE1BQU1QLGtCQUFrQlEsS0FBS3BCLE9BQU8sQ0FBQ3FCLE1BQU0sRUFBRSxFQUFFckIsT0FBTyxDQUFDLEVBQUU7SUFDOUYsT0FBTyxJQUFJSCxVQUFVRSxTQUFTQyxTQUFTUDtBQUMzQztBQUNBOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTTZCLGNBQWMsQ0FBQ0MsWUFBWUM7SUFDN0IsSUFBSXZDLDZCQUE2QjtRQUM3QnNDLFdBQVdFLGtCQUFrQixHQUFHRCxPQUFPRSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsYUFBYW5DLGdCQUFnQm1DLElBQUlBLEVBQUV2QixVQUFVO0lBQ25HLE9BQ0s7UUFDRCxLQUFLLE1BQU11QixLQUFLSCxPQUFRO1lBQ3BCLE1BQU1JLFFBQVFDLFNBQVNDLGFBQWEsQ0FBQztZQUNyQyw4REFBOEQ7WUFDOUQsTUFBTUMsUUFBUWhELE1BQU0sQ0FBQyxXQUFXO1lBQ2hDLElBQUlnRCxVQUFVM0MsV0FBVztnQkFDckJ3QyxNQUFNSSxZQUFZLENBQUMsU0FBU0Q7WUFDaEM7WUFDQUgsTUFBTUssV0FBVyxHQUFHTixFQUFFNUIsT0FBTztZQUM3QndCLFdBQVdXLFdBQVcsQ0FBQ047UUFDM0I7SUFDSjtBQUNKO0FBQ0EsTUFBTU8sMEJBQTBCLENBQUNDO0lBQzdCLElBQUlyQyxVQUFVO0lBQ2QsS0FBSyxNQUFNc0MsUUFBUUQsTUFBTUUsUUFBUSxDQUFFO1FBQy9CdkMsV0FBV3NDLEtBQUt0QyxPQUFPO0lBQzNCO0lBQ0EsT0FBT2UsVUFBVWY7QUFDckI7QUFDQSxNQUFNd0MscUJBQXFCdEQsK0JBQ3RCRixPQUFPUyxhQUFhLEtBQUtKLFlBQ3hCLENBQUN1QyxJQUFNQSxJQUNQLENBQUNBLElBQU1BLGFBQWFuQyxnQkFBZ0IyQyx3QkFBd0JSLEtBQUtBO0FBRTRCLENBQ25HLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvbm9kZS9kZXZlbG9wbWVudC9jc3MtdGFnLmpzPzJlMzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG4vLyBBbGxvd3MgbWluaWZpZXJzIHRvIHJlbmFtZSByZWZlcmVuY2VzIHRvIGdsb2JhbFRoaXNcbmNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXM7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBgYWRvcHRlZFN0eWxlU2hlZXRzYC5cbiAqL1xuY29uc3Qgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzID0gZ2xvYmFsLlNoYWRvd1Jvb3QgJiZcbiAgICAoZ2xvYmFsLlNoYWR5Q1NTID09PSB1bmRlZmluZWQgfHwgZ2xvYmFsLlNoYWR5Q1NTLm5hdGl2ZVNoYWRvdykgJiZcbiAgICAnYWRvcHRlZFN0eWxlU2hlZXRzJyBpbiBEb2N1bWVudC5wcm90b3R5cGUgJiZcbiAgICAncmVwbGFjZScgaW4gQ1NTU3R5bGVTaGVldC5wcm90b3R5cGU7XG5jb25zdCBjb25zdHJ1Y3Rpb25Ub2tlbiA9IFN5bWJvbCgpO1xuY29uc3QgY3NzVGFnQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBzdHJpbmcgb2YgQ1NTIHRleHQsIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlIGEgQ1NTU3R5bGVTaGVldC5cbiAqXG4gKiBDU1NSZXN1bHQgaXMgdGhlIHJldHVybiB2YWx1ZSBvZiBgY3NzYC10YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMgYW5kXG4gKiBgdW5zYWZlQ1NTKClgLiBJbiBvcmRlciB0byBlbnN1cmUgdGhhdCBDU1NSZXN1bHRzIGFyZSBvbmx5IGNyZWF0ZWQgdmlhIHRoZVxuICogYGNzc2AgdGFnIGFuZCBgdW5zYWZlQ1NTKClgLCBDU1NSZXN1bHQgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LlxuICovXG5jbGFzcyBDU1NSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKGNzc1RleHQsIHN0cmluZ3MsIHNhZmVUb2tlbikge1xuICAgICAgICAvLyBUaGlzIHByb3BlcnR5IG5lZWRzIHRvIHJlbWFpbiB1bm1pbmlmaWVkLlxuICAgICAgICB0aGlzWydfJGNzc1Jlc3VsdCQnXSA9IHRydWU7XG4gICAgICAgIGlmIChzYWZlVG9rZW4gIT09IGNvbnN0cnVjdGlvblRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTU1Jlc3VsdCBpcyBub3QgY29uc3RydWN0YWJsZS4gVXNlIGB1bnNhZmVDU1NgIG9yIGBjc3NgIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBnZXR0ZXIgc28gdGhhdCBpdCdzIGxhenkuIEluIHByYWN0aWNlLCB0aGlzIG1lYW5zIHN0eWxlc2hlZXRzXG4gICAgLy8gYXJlIG5vdCBjcmVhdGVkIHVudGlsIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlIGlzIG1hZGUuXG4gICAgZ2V0IHN0eWxlU2hlZXQoKSB7XG4gICAgICAgIC8vIElmIGBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHNgIGlzIHRydWUgdGhlbiB3ZSBhc3N1bWUgQ1NTU3R5bGVTaGVldCBpc1xuICAgICAgICAvLyBjb25zdHJ1Y3RhYmxlLlxuICAgICAgICBsZXQgc3R5bGVTaGVldCA9IHRoaXMuX3N0eWxlU2hlZXQ7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSB0aGlzLl9zdHJpbmdzO1xuICAgICAgICBpZiAoc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzICYmIHN0eWxlU2hlZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVhYmxlID0gc3RyaW5ncyAhPT0gdW5kZWZpbmVkICYmIHN0cmluZ3MubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgaWYgKGNhY2hlYWJsZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXQgPSBjc3NUYWdDYWNoZS5nZXQoc3RyaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3R5bGVTaGVldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgKHRoaXMuX3N0eWxlU2hlZXQgPSBzdHlsZVNoZWV0ID0gbmV3IENTU1N0eWxlU2hlZXQoKSkucmVwbGFjZVN5bmModGhpcy5jc3NUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzc1RhZ0NhY2hlLnNldChzdHJpbmdzLCBzdHlsZVNoZWV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlU2hlZXQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3NUZXh0O1xuICAgIH1cbn1cbmNvbnN0IHRleHRGcm9tQ1NTUmVzdWx0ID0gKHZhbHVlKSA9PiB7XG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgICBpZiAodmFsdWVbJ18kY3NzUmVzdWx0JCddID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5jc3NUZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgcGFzc2VkIHRvICdjc3MnIGZ1bmN0aW9uIG11c3QgYmUgYSAnY3NzJyBmdW5jdGlvbiByZXN1bHQ6IGAgK1xuICAgICAgICAgICAgYCR7dmFsdWV9LiBVc2UgJ3Vuc2FmZUNTUycgdG8gcGFzcyBub24tbGl0ZXJhbCB2YWx1ZXMsIGJ1dCB0YWtlIGNhcmUgYCArXG4gICAgICAgICAgICBgdG8gZW5zdXJlIHBhZ2Ugc2VjdXJpdHkuYCk7XG4gICAgfVxufTtcbi8qKlxuICogV3JhcCBhIHZhbHVlIGZvciBpbnRlcnBvbGF0aW9uIGluIGEge0BsaW5rY29kZSBjc3N9IHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsLlxuICpcbiAqIFRoaXMgaXMgdW5zYWZlIGJlY2F1c2UgdW50cnVzdGVkIENTUyB0ZXh0IGNhbiBiZSB1c2VkIHRvIHBob25lIGhvbWVcbiAqIG9yIGV4ZmlsdHJhdGUgZGF0YSB0byBhbiBhdHRhY2tlciBjb250cm9sbGVkIHNpdGUuIFRha2UgY2FyZSB0byBvbmx5IHVzZVxuICogdGhpcyB3aXRoIHRydXN0ZWQgaW5wdXQuXG4gKi9cbmNvbnN0IHVuc2FmZUNTUyA9ICh2YWx1ZSkgPT4gbmV3IENTU1Jlc3VsdCh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpLCB1bmRlZmluZWQsIGNvbnN0cnVjdGlvblRva2VuKTtcbi8qKlxuICogQSB0ZW1wbGF0ZSBsaXRlcmFsIHRhZyB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIExpdEVsZW1lbnQnc1xuICoge0BsaW5rY29kZSBMaXRFbGVtZW50LnN0eWxlc30gcHJvcGVydHkgdG8gc2V0IGVsZW1lbnQgc3R5bGVzLlxuICpcbiAqIEZvciBzZWN1cml0eSByZWFzb25zLCBvbmx5IGxpdGVyYWwgc3RyaW5nIHZhbHVlcyBhbmQgbnVtYmVyIG1heSBiZSB1c2VkIGluXG4gKiBlbWJlZGRlZCBleHByZXNzaW9ucy4gVG8gaW5jb3Jwb3JhdGUgbm9uLWxpdGVyYWwgdmFsdWVzIHtAbGlua2NvZGUgdW5zYWZlQ1NTfVxuICogbWF5IGJlIHVzZWQgaW5zaWRlIGFuIGV4cHJlc3Npb24uXG4gKi9cbmNvbnN0IGNzcyA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IHtcbiAgICBjb25zdCBjc3NUZXh0ID0gc3RyaW5ncy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBzdHJpbmdzWzBdXG4gICAgICAgIDogdmFsdWVzLnJlZHVjZSgoYWNjLCB2LCBpZHgpID0+IGFjYyArIHRleHRGcm9tQ1NTUmVzdWx0KHYpICsgc3RyaW5nc1tpZHggKyAxXSwgc3RyaW5nc1swXSk7XG4gICAgcmV0dXJuIG5ldyBDU1NSZXN1bHQoY3NzVGV4dCwgc3RyaW5ncywgY29uc3RydWN0aW9uVG9rZW4pO1xufTtcbi8qKlxuICogQXBwbGllcyB0aGUgZ2l2ZW4gc3R5bGVzIHRvIGEgYHNoYWRvd1Jvb3RgLiBXaGVuIFNoYWRvdyBET00gaXNcbiAqIGF2YWlsYWJsZSBidXQgYGFkb3B0ZWRTdHlsZVNoZWV0c2AgaXMgbm90LCBzdHlsZXMgYXJlIGFwcGVuZGVkIHRvIHRoZVxuICogYHNoYWRvd1Jvb3RgIHRvIFttaW1pYyB0aGUgbmF0aXZlIGZlYXR1cmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TaGFkb3dSb290L2Fkb3B0ZWRTdHlsZVNoZWV0cykuXG4gKiBOb3RlLCB3aGVuIHNoaW1taW5nIGlzIHVzZWQsIGFueSBzdHlsZXMgdGhhdCBhcmUgc3Vic2VxdWVudGx5IHBsYWNlZCBpbnRvXG4gKiB0aGUgc2hhZG93Um9vdCBzaG91bGQgYmUgcGxhY2VkICpiZWZvcmUqIGFueSBzaGltbWVkIGFkb3B0ZWQgc3R5bGVzLiBUaGlzXG4gKiB3aWxsIG1hdGNoIHNwZWMgYmVoYXZpb3IgdGhhdCBnaXZlcyBhZG9wdGVkIHNoZWV0cyBwcmVjZWRlbmNlIG92ZXIgc3R5bGVzIGluXG4gKiBzaGFkb3dSb290LlxuICovXG5jb25zdCBhZG9wdFN0eWxlcyA9IChyZW5kZXJSb290LCBzdHlsZXMpID0+IHtcbiAgICBpZiAoc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzKSB7XG4gICAgICAgIHJlbmRlclJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gc3R5bGVzLm1hcCgocykgPT4gcyBpbnN0YW5jZW9mIENTU1N0eWxlU2hlZXQgPyBzIDogcy5zdHlsZVNoZWV0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzdHlsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGdsb2JhbFsnbGl0Tm9uY2UnXTtcbiAgICAgICAgICAgIGlmIChub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gcy5jc3NUZXh0O1xuICAgICAgICAgICAgcmVuZGVyUm9vdC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgY3NzUmVzdWx0RnJvbVN0eWxlU2hlZXQgPSAoc2hlZXQpID0+IHtcbiAgICBsZXQgY3NzVGV4dCA9ICcnO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzaGVldC5jc3NSdWxlcykge1xuICAgICAgICBjc3NUZXh0ICs9IHJ1bGUuY3NzVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHVuc2FmZUNTUyhjc3NUZXh0KTtcbn07XG5jb25zdCBnZXRDb21wYXRpYmxlU3R5bGUgPSBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMgfHxcbiAgICAoZ2xvYmFsLkNTU1N0eWxlU2hlZXQgPT09IHVuZGVmaW5lZClcbiAgICA/IChzKSA9PiBzXG4gICAgOiAocykgPT4gcyBpbnN0YW5jZW9mIENTU1N0eWxlU2hlZXQgPyBjc3NSZXN1bHRGcm9tU3R5bGVTaGVldChzKSA6IHM7XG5cbmV4cG9ydCB7IENTU1Jlc3VsdCwgYWRvcHRTdHlsZXMsIGNzcywgZ2V0Q29tcGF0aWJsZVN0eWxlLCBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMsIHVuc2FmZUNTUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLXRhZy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJnbG9iYWxUaGlzIiwic3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzIiwiU2hhZG93Um9vdCIsIlNoYWR5Q1NTIiwidW5kZWZpbmVkIiwibmF0aXZlU2hhZG93IiwiRG9jdW1lbnQiLCJwcm90b3R5cGUiLCJDU1NTdHlsZVNoZWV0IiwiY29uc3RydWN0aW9uVG9rZW4iLCJTeW1ib2wiLCJjc3NUYWdDYWNoZSIsIldlYWtNYXAiLCJDU1NSZXN1bHQiLCJjb25zdHJ1Y3RvciIsImNzc1RleHQiLCJzdHJpbmdzIiwic2FmZVRva2VuIiwiRXJyb3IiLCJfc3RyaW5ncyIsInN0eWxlU2hlZXQiLCJfc3R5bGVTaGVldCIsImNhY2hlYWJsZSIsImxlbmd0aCIsImdldCIsInJlcGxhY2VTeW5jIiwic2V0IiwidG9TdHJpbmciLCJ0ZXh0RnJvbUNTU1Jlc3VsdCIsInZhbHVlIiwidW5zYWZlQ1NTIiwiU3RyaW5nIiwiY3NzIiwidmFsdWVzIiwicmVkdWNlIiwiYWNjIiwidiIsImlkeCIsImFkb3B0U3R5bGVzIiwicmVuZGVyUm9vdCIsInN0eWxlcyIsImFkb3B0ZWRTdHlsZVNoZWV0cyIsIm1hcCIsInMiLCJzdHlsZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5vbmNlIiwic2V0QXR0cmlidXRlIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsImNzc1Jlc3VsdEZyb21TdHlsZVNoZWV0Iiwic2hlZXQiLCJydWxlIiwiY3NzUnVsZXMiLCJnZXRDb21wYXRpYmxlU3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/css-tag.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/base.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   desc: () => (/* binding */ desc)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * Wraps up a few best practices when returning a property descriptor from a\n * decorator.\n *\n * Marks the defined property as configurable, and enumerable, and handles\n * the case where we have a busted Reflect.decorate zombiefill (e.g. in Angular\n * apps).\n *\n * @internal\n */ const desc = (obj, name, descriptor)=>{\n    // For backwards compatibility, we keep them configurable and enumerable.\n    descriptor.configurable = true;\n    descriptor.enumerable = true;\n    if (// We check for Reflect.decorate each time, in case the zombiefill\n    // is applied via lazy loading some Angular code.\n    Reflect.decorate && typeof name !== \"object\") {\n        // If we're called as a legacy decorator, and Reflect.decorate is present\n        // then we have no guarantees that the returned descriptor will be\n        // defined on the class, so we must apply it directly ourselves.\n        Object.defineProperty(obj, name, descriptor);\n    }\n    return descriptor;\n};\n //# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBQ0Q7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUEsT0FBTyxDQUFDQyxLQUFLQyxNQUFNQztJQUNyQix5RUFBeUU7SUFDekVBLFdBQVdDLFlBQVksR0FBRztJQUMxQkQsV0FBV0UsVUFBVSxHQUFHO0lBQ3hCLElBQ0Esa0VBQWtFO0lBQ2xFLGlEQUFpRDtJQUNqREMsUUFBUUMsUUFBUSxJQUNaLE9BQU9MLFNBQVMsVUFBVTtRQUMxQix5RUFBeUU7UUFDekUsa0VBQWtFO1FBQ2xFLGdFQUFnRTtRQUNoRU0sT0FBT0MsY0FBYyxDQUFDUixLQUFLQyxNQUFNQztJQUNyQztJQUNBLE9BQU9BO0FBQ1g7QUFFZ0IsQ0FDaEIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvYmFzZS5qcz9kNDczIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuLyoqXG4gKiBXcmFwcyB1cCBhIGZldyBiZXN0IHByYWN0aWNlcyB3aGVuIHJldHVybmluZyBhIHByb3BlcnR5IGRlc2NyaXB0b3IgZnJvbSBhXG4gKiBkZWNvcmF0b3IuXG4gKlxuICogTWFya3MgdGhlIGRlZmluZWQgcHJvcGVydHkgYXMgY29uZmlndXJhYmxlLCBhbmQgZW51bWVyYWJsZSwgYW5kIGhhbmRsZXNcbiAqIHRoZSBjYXNlIHdoZXJlIHdlIGhhdmUgYSBidXN0ZWQgUmVmbGVjdC5kZWNvcmF0ZSB6b21iaWVmaWxsIChlLmcuIGluIEFuZ3VsYXJcbiAqIGFwcHMpLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBkZXNjID0gKG9iaiwgbmFtZSwgZGVzY3JpcHRvcikgPT4ge1xuICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2Uga2VlcCB0aGVtIGNvbmZpZ3VyYWJsZSBhbmQgZW51bWVyYWJsZS5cbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXG4gICAgLy8gV2UgY2hlY2sgZm9yIFJlZmxlY3QuZGVjb3JhdGUgZWFjaCB0aW1lLCBpbiBjYXNlIHRoZSB6b21iaWVmaWxsXG4gICAgLy8gaXMgYXBwbGllZCB2aWEgbGF6eSBsb2FkaW5nIHNvbWUgQW5ndWxhciBjb2RlLlxuICAgIFJlZmxlY3QuZGVjb3JhdGUgJiZcbiAgICAgICAgdHlwZW9mIG5hbWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIGNhbGxlZCBhcyBhIGxlZ2FjeSBkZWNvcmF0b3IsIGFuZCBSZWZsZWN0LmRlY29yYXRlIGlzIHByZXNlbnRcbiAgICAgICAgLy8gdGhlbiB3ZSBoYXZlIG5vIGd1YXJhbnRlZXMgdGhhdCB0aGUgcmV0dXJuZWQgZGVzY3JpcHRvciB3aWxsIGJlXG4gICAgICAgIC8vIGRlZmluZWQgb24gdGhlIGNsYXNzLCBzbyB3ZSBtdXN0IGFwcGx5IGl0IGRpcmVjdGx5IG91cnNlbHZlcy5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuZXhwb3J0IHsgZGVzYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZXNjIiwib2JqIiwibmFtZSIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiUmVmbGVjdCIsImRlY29yYXRlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/custom-element.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/custom-element.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customElement: () => (/* binding */ customElement)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```js\n * @customElement('my-element')\n * class MyElement extends LitElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n * @category Decorator\n * @param tagName The tag name of the custom element to define.\n */ const customElement = (tagName)=>(classOrTarget, context)=>{\n        if (context !== undefined) {\n            context.addInitializer(()=>{\n                customElements.define(tagName, classOrTarget);\n            });\n        } else {\n            customElements.define(tagName, classOrTarget);\n        }\n    };\n //# sourceMappingURL=custom-element.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9jdXN0b20tZWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNEOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxNQUFNQSxnQkFBZ0IsQ0FBQ0MsVUFBWSxDQUFDQyxlQUFlQztRQUMvQyxJQUFJQSxZQUFZQyxXQUFXO1lBQ3ZCRCxRQUFRRSxjQUFjLENBQUM7Z0JBQ25CQyxlQUFlQyxNQUFNLENBQUNOLFNBQVNDO1lBQ25DO1FBQ0osT0FDSztZQUNESSxlQUFlQyxNQUFNLENBQUNOLFNBQVNDO1FBQ25DO0lBQ0o7QUFFeUIsQ0FDekIsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvY3VzdG9tLWVsZW1lbnQuanM/OWU1MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbi8qKlxuICogQ2xhc3MgZGVjb3JhdG9yIGZhY3RvcnkgdGhhdCBkZWZpbmVzIHRoZSBkZWNvcmF0ZWQgY2xhc3MgYXMgYSBjdXN0b20gZWxlbWVudC5cbiAqXG4gKiBgYGBqc1xuICogQGN1c3RvbUVsZW1lbnQoJ215LWVsZW1lbnQnKVxuICogY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBgO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIEBjYXRlZ29yeSBEZWNvcmF0b3JcbiAqIEBwYXJhbSB0YWdOYW1lIFRoZSB0YWcgbmFtZSBvZiB0aGUgY3VzdG9tIGVsZW1lbnQgdG8gZGVmaW5lLlxuICovXG5jb25zdCBjdXN0b21FbGVtZW50ID0gKHRhZ05hbWUpID0+IChjbGFzc09yVGFyZ2V0LCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyKCgpID0+IHtcbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBjbGFzc09yVGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgY2xhc3NPclRhcmdldCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgY3VzdG9tRWxlbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tLWVsZW1lbnQuanMubWFwXG4iXSwibmFtZXMiOlsiY3VzdG9tRWxlbWVudCIsInRhZ05hbWUiLCJjbGFzc09yVGFyZ2V0IiwiY29udGV4dCIsInVuZGVmaW5lZCIsImFkZEluaXRpYWxpemVyIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/custom-element.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/event-options.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/event-options.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventOptions: () => (/* binding */ eventOptions)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifies event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * ```ts\n * class MyElement {\n *   clicked = false;\n *\n *   render() {\n *     return html`\n *       <div @click=${this._onClick}>\n *         <button></button>\n *       </div>\n *     `;\n *   }\n *\n *   @eventOptions({capture: true})\n *   _onClick(e) {\n *     this.clicked = true;\n *   }\n * }\n * ```\n * @category Decorator\n */ function eventOptions(options) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (protoOrValue, nameOrContext)=>{\n        const method = typeof protoOrValue === \"function\" ? protoOrValue : protoOrValue[nameOrContext];\n        Object.assign(method, options);\n    };\n}\n //# sourceMappingURL=event-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9ldmVudC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDLEdBQ0QsU0FBU0EsYUFBYUMsT0FBTztJQUN6Qiw4REFBOEQ7SUFDOUQsT0FBUSxDQUFDQyxjQUFjQztRQUNuQixNQUFNQyxTQUFTLE9BQU9GLGlCQUFpQixhQUNqQ0EsZUFDQUEsWUFBWSxDQUFDQyxjQUFjO1FBQ2pDRSxPQUFPQyxNQUFNLENBQUNGLFFBQVFIO0lBQzFCO0FBQ0o7QUFFd0IsQ0FDeEIseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvZXZlbnQtb3B0aW9ucy5qcz9mODA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVyIG9wdGlvbnMgdG8gYSBtZXRob2QgdXNlZCBhcyBhbiBldmVudCBsaXN0ZW5lciBpbiBhXG4gKiBsaXQtaHRtbCB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBBbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgZXZlbnQgbGlzdGVuZXIgb3B0aW9ucyBhcyBhY2NlcHRlZCBieVxuICogYEV2ZW50VGFyZ2V0I2FkZEV2ZW50TGlzdGVuZXJgIGFuZCBgRXZlbnRUYXJnZXQjcmVtb3ZlRXZlbnRMaXN0ZW5lcmAuXG4gKlxuICogQ3VycmVudCBicm93c2VycyBzdXBwb3J0IHRoZSBgY2FwdHVyZWAsIGBwYXNzaXZlYCwgYW5kIGBvbmNlYCBvcHRpb25zLiBTZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNQYXJhbWV0ZXJzXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIE15RWxlbWVudCB7XG4gKiAgIGNsaWNrZWQgPSBmYWxzZTtcbiAqXG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgIDxkaXYgQGNsaWNrPSR7dGhpcy5fb25DbGlja30+XG4gKiAgICAgICAgIDxidXR0b24+PC9idXR0b24+XG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICBgO1xuICogICB9XG4gKlxuICogICBAZXZlbnRPcHRpb25zKHtjYXB0dXJlOiB0cnVlfSlcbiAqICAgX29uQ2xpY2soZSkge1xuICogICAgIHRoaXMuY2xpY2tlZCA9IHRydWU7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBldmVudE9wdGlvbnMob3B0aW9ucykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuICgocHJvdG9PclZhbHVlLCBuYW1lT3JDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHR5cGVvZiBwcm90b09yVmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdG9PclZhbHVlXG4gICAgICAgICAgICA6IHByb3RvT3JWYWx1ZVtuYW1lT3JDb250ZXh0XTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZXRob2QsIG9wdGlvbnMpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBldmVudE9wdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LW9wdGlvbnMuanMubWFwXG4iXSwibmFtZXMiOlsiZXZlbnRPcHRpb25zIiwib3B0aW9ucyIsInByb3RvT3JWYWx1ZSIsIm5hbWVPckNvbnRleHQiLCJtZXRob2QiLCJPYmplY3QiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/event-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/property.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/property.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   property: () => (/* binding */ property),\n/* harmony export */   standardProperty: () => (/* binding */ standardProperty)\n/* harmony export */ });\n/* harmony import */ var _reactive_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reactive-element.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/reactive-element.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */ let issueWarning;\n{\n    // Ensure warnings are issued only 1x, even if multiple versions of Lit\n    // are loaded.\n    globalThis.litIssuedWarnings ??= new Set();\n    /**\n     * Issue a warning if we haven't already, based either on `code` or `warning`.\n     * Warnings are disabled automatically only by `warning`; disabling via `code`\n     * can be done by users.\n     */ issueWarning = (code, warning)=>{\n        warning += ` See https://lit.dev/msg/${code} for more information.`;\n        if (!globalThis.litIssuedWarnings.has(warning) && !globalThis.litIssuedWarnings.has(code)) {\n            console.warn(warning);\n            globalThis.litIssuedWarnings.add(warning);\n        }\n    };\n}const legacyProperty = (options, proto, name)=>{\n    const hasOwnProperty = proto.hasOwnProperty(name);\n    proto.constructor.createProperty(name, options);\n    // For accessors (which have a descriptor on the prototype) we need to\n    // return a descriptor, otherwise TypeScript overwrites the descriptor we\n    // define in createProperty() with the original descriptor. We don't do this\n    // for fields, which don't have a descriptor, because this could overwrite\n    // descriptor defined by other decorators.\n    return hasOwnProperty ? Object.getOwnPropertyDescriptor(proto, name) : undefined;\n};\n// This is duplicated from a similar variable in reactive-element.ts, but\n// actually makes sense to have this default defined with the decorator, so\n// that different decorators could have different defaults.\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: _reactive_element_js__WEBPACK_IMPORTED_MODULE_0__.defaultConverter,\n    reflect: false,\n    hasChanged: _reactive_element_js__WEBPACK_IMPORTED_MODULE_0__.notEqual\n};\n/**\n * Wraps a class accessor or setter so that `requestUpdate()` is called with the\n * property name and old value when the accessor is set.\n */ const standardProperty = (options = defaultPropertyDeclaration, target, context)=>{\n    const { kind, metadata } = context;\n    if (metadata == null) {\n        issueWarning(\"missing-class-metadata\", `The class ${target} is missing decorator metadata. This ` + `could mean that you're using a compiler that supports decorators ` + `but doesn't support decorator metadata, such as TypeScript 5.1. ` + `Please update your compiler.`);\n    }\n    // Store the property options\n    let properties = globalThis.litPropertyMetadata.get(metadata);\n    if (properties === undefined) {\n        globalThis.litPropertyMetadata.set(metadata, properties = new Map());\n    }\n    if (kind === \"setter\") {\n        options = Object.create(options);\n        options.wrapped = true;\n    }\n    properties.set(context.name, options);\n    if (kind === \"accessor\") {\n        // Standard decorators cannot dynamically modify the class, so we can't\n        // replace a field with accessors. The user must use the new `accessor`\n        // keyword instead.\n        const { name } = context;\n        return {\n            set (v) {\n                const oldValue = target.get.call(this);\n                target.set.call(this, v);\n                this.requestUpdate(name, oldValue, options, true, v);\n            },\n            init (v) {\n                if (v !== undefined) {\n                    this._$changeProperty(name, undefined, options, v);\n                }\n                return v;\n            }\n        };\n    } else if (kind === \"setter\") {\n        const { name } = context;\n        return function(value) {\n            const oldValue = this[name];\n            target.call(this, value);\n            this.requestUpdate(name, oldValue, options, true, value);\n        };\n    }\n    throw new Error(`Unsupported decorator location: ${kind}`);\n};\n/**\n * A class field or accessor decorator which creates a reactive property that\n * reflects a corresponding attribute value. When a decorated property is set\n * the element will update and render. A {@linkcode PropertyDeclaration} may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the {@linkcode state} decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the {@linkcode state} decorator should be used. When\n * needed, state properties can be initialized via public properties to\n * facilitate complex interactions.\n *\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */ function property(options) {\n    return (protoOrTarget, nameOrContext)=>{\n        return typeof nameOrContext === \"object\" ? standardProperty(options, protoOrTarget, nameOrContext) : legacyProperty(options, protoOrTarget, nameOrContext);\n    };\n}\n //# sourceMappingURL=property.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9wcm9wZXJ0eS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0U7QUFFcEU7Ozs7Q0FJQyxHQUNEOzs7OztDQUtDLEdBQ0QsSUFBSUU7QUFDSjtJQUNJLHVFQUF1RTtJQUN2RSxjQUFjO0lBQ2RDLFdBQVdDLGlCQUFpQixLQUFLLElBQUlDO0lBQ3JDOzs7O0tBSUMsR0FDREgsZUFBZSxDQUFDSSxNQUFNQztRQUNsQkEsV0FBVyxDQUFDLHlCQUF5QixFQUFFRCxLQUFLLHNCQUFzQixDQUFDO1FBQ25FLElBQUksQ0FBQ0gsV0FBV0MsaUJBQWlCLENBQUNJLEdBQUcsQ0FBQ0QsWUFDbEMsQ0FBQ0osV0FBV0MsaUJBQWlCLENBQUNJLEdBQUcsQ0FBQ0YsT0FBTztZQUN6Q0csUUFBUUMsSUFBSSxDQUFDSDtZQUNiSixXQUFXQyxpQkFBaUIsQ0FBQ08sR0FBRyxDQUFDSjtRQUNyQztJQUNKO0FBQ0osQ0FDQSxNQUFNSyxpQkFBaUIsQ0FBQ0MsU0FBU0MsT0FBT0M7SUFDcEMsTUFBTUMsaUJBQWlCRixNQUFNRSxjQUFjLENBQUNEO0lBQzVDRCxNQUFNRyxXQUFXLENBQUNDLGNBQWMsQ0FBQ0gsTUFBTUY7SUFDdkMsc0VBQXNFO0lBQ3RFLHlFQUF5RTtJQUN6RSw0RUFBNEU7SUFDNUUsMEVBQTBFO0lBQzFFLDBDQUEwQztJQUMxQyxPQUFPRyxpQkFDREcsT0FBT0Msd0JBQXdCLENBQUNOLE9BQU9DLFFBQ3ZDTTtBQUNWO0FBQ0EseUVBQXlFO0FBQ3pFLDJFQUEyRTtBQUMzRSwyREFBMkQ7QUFDM0QsTUFBTUMsNkJBQTZCO0lBQy9CQyxXQUFXO0lBQ1hDLE1BQU1DO0lBQ05DLFdBQVd6QixrRUFBZ0JBO0lBQzNCMEIsU0FBUztJQUNUQyxZQUFZNUIsMERBQVFBO0FBQ3hCO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTTZCLG1CQUFtQixDQUFDaEIsVUFBVVMsMEJBQTBCLEVBQUVRLFFBQVFDO0lBQ3BFLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Y7SUFDM0IsSUFBSUUsWUFBWSxNQUFNO1FBQ2xCL0IsYUFBYSwwQkFBMEIsQ0FBQyxVQUFVLEVBQUU0QixPQUFPLHFDQUFxQyxDQUFDLEdBQzdGLENBQUMsaUVBQWlFLENBQUMsR0FDbkUsQ0FBQyxnRUFBZ0UsQ0FBQyxHQUNsRSxDQUFDLDRCQUE0QixDQUFDO0lBQ3RDO0lBQ0EsNkJBQTZCO0lBQzdCLElBQUlJLGFBQWEvQixXQUFXZ0MsbUJBQW1CLENBQUNDLEdBQUcsQ0FBQ0g7SUFDcEQsSUFBSUMsZUFBZWIsV0FBVztRQUMxQmxCLFdBQVdnQyxtQkFBbUIsQ0FBQ0UsR0FBRyxDQUFDSixVQUFXQyxhQUFhLElBQUlJO0lBQ25FO0lBQ0EsSUFBSU4sU0FBUyxVQUFVO1FBQ25CbkIsVUFBVU0sT0FBT29CLE1BQU0sQ0FBQzFCO1FBQ3hCQSxRQUFRMkIsT0FBTyxHQUFHO0lBQ3RCO0lBQ0FOLFdBQVdHLEdBQUcsQ0FBQ04sUUFBUWhCLElBQUksRUFBRUY7SUFDN0IsSUFBSW1CLFNBQVMsWUFBWTtRQUNyQix1RUFBdUU7UUFDdkUsdUVBQXVFO1FBQ3ZFLG1CQUFtQjtRQUNuQixNQUFNLEVBQUVqQixJQUFJLEVBQUUsR0FBR2dCO1FBQ2pCLE9BQU87WUFDSE0sS0FBSUksQ0FBQztnQkFDRCxNQUFNQyxXQUFXWixPQUFPTSxHQUFHLENBQUNPLElBQUksQ0FBQyxJQUFJO2dCQUNyQ2IsT0FBT08sR0FBRyxDQUFDTSxJQUFJLENBQUMsSUFBSSxFQUFFRjtnQkFDdEIsSUFBSSxDQUFDRyxhQUFhLENBQUM3QixNQUFNMkIsVUFBVTdCLFNBQVMsTUFBTTRCO1lBQ3REO1lBQ0FJLE1BQUtKLENBQUM7Z0JBQ0YsSUFBSUEsTUFBTXBCLFdBQVc7b0JBQ2pCLElBQUksQ0FBQ3lCLGdCQUFnQixDQUFDL0IsTUFBTU0sV0FBV1IsU0FBUzRCO2dCQUNwRDtnQkFDQSxPQUFPQTtZQUNYO1FBQ0o7SUFDSixPQUNLLElBQUlULFNBQVMsVUFBVTtRQUN4QixNQUFNLEVBQUVqQixJQUFJLEVBQUUsR0FBR2dCO1FBQ2pCLE9BQU8sU0FBVWdCLEtBQUs7WUFDbEIsTUFBTUwsV0FBVyxJQUFJLENBQUMzQixLQUFLO1lBQzNCZSxPQUFPYSxJQUFJLENBQUMsSUFBSSxFQUFFSTtZQUNsQixJQUFJLENBQUNILGFBQWEsQ0FBQzdCLE1BQU0yQixVQUFVN0IsU0FBUyxNQUFNa0M7UUFDdEQ7SUFDSjtJQUNBLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGdDQUFnQyxFQUFFaEIsS0FBSyxDQUFDO0FBQzdEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErQkMsR0FDRCxTQUFTaUIsU0FBU3BDLE9BQU87SUFDckIsT0FBTyxDQUFDcUMsZUFBZUM7UUFHbkIsT0FBUSxPQUFPQSxrQkFBa0IsV0FDM0J0QixpQkFBaUJoQixTQUFTcUMsZUFBZUMsaUJBQ3pDdkMsZUFBZUMsU0FBU3FDLGVBQWVDO0lBQ2pEO0FBQ0o7QUFFc0MsQ0FDdEMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvcHJvcGVydHkuanM/OGZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3RFcXVhbCwgZGVmYXVsdENvbnZlcnRlciB9IGZyb20gJy4uL3JlYWN0aXZlLWVsZW1lbnQuanMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbi8qXG4gKiBJTVBPUlRBTlQ6IEZvciBjb21wYXRpYmlsaXR5IHdpdGggdHNpY2tsZSBhbmQgdGhlIENsb3N1cmUgSlMgY29tcGlsZXIsIGFsbFxuICogcHJvcGVydHkgZGVjb3JhdG9ycyAoYnV0IG5vdCBjbGFzcyBkZWNvcmF0b3JzKSBpbiB0aGlzIGZpbGUgdGhhdCBoYXZlXG4gKiBhbiBARXhwb3J0RGVjb3JhdGVkSXRlbXMgYW5ub3RhdGlvbiBtdXN0IGJlIGRlZmluZWQgYXMgYSByZWd1bGFyIGZ1bmN0aW9uLFxuICogbm90IGFuIGFycm93IGZ1bmN0aW9uLlxuICovXG5sZXQgaXNzdWVXYXJuaW5nO1xue1xuICAgIC8vIEVuc3VyZSB3YXJuaW5ncyBhcmUgaXNzdWVkIG9ubHkgMXgsIGV2ZW4gaWYgbXVsdGlwbGUgdmVyc2lvbnMgb2YgTGl0XG4gICAgLy8gYXJlIGxvYWRlZC5cbiAgICBnbG9iYWxUaGlzLmxpdElzc3VlZFdhcm5pbmdzID8/PSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogSXNzdWUgYSB3YXJuaW5nIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSwgYmFzZWQgZWl0aGVyIG9uIGBjb2RlYCBvciBgd2FybmluZ2AuXG4gICAgICogV2FybmluZ3MgYXJlIGRpc2FibGVkIGF1dG9tYXRpY2FsbHkgb25seSBieSBgd2FybmluZ2A7IGRpc2FibGluZyB2aWEgYGNvZGVgXG4gICAgICogY2FuIGJlIGRvbmUgYnkgdXNlcnMuXG4gICAgICovXG4gICAgaXNzdWVXYXJuaW5nID0gKGNvZGUsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgd2FybmluZyArPSBgIFNlZSBodHRwczovL2xpdC5kZXYvbXNnLyR7Y29kZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uYDtcbiAgICAgICAgaWYgKCFnbG9iYWxUaGlzLmxpdElzc3VlZFdhcm5pbmdzLmhhcyh3YXJuaW5nKSAmJlxuICAgICAgICAgICAgIWdsb2JhbFRoaXMubGl0SXNzdWVkV2FybmluZ3MuaGFzKGNvZGUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgICAgICAgICBnbG9iYWxUaGlzLmxpdElzc3VlZFdhcm5pbmdzLmFkZCh3YXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBsZWdhY3lQcm9wZXJ0eSA9IChvcHRpb25zLCBwcm90bywgbmFtZSkgPT4ge1xuICAgIGNvbnN0IGhhc093blByb3BlcnR5ID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgcHJvdG8uY29uc3RydWN0b3IuY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucyk7XG4gICAgLy8gRm9yIGFjY2Vzc29ycyAod2hpY2ggaGF2ZSBhIGRlc2NyaXB0b3Igb24gdGhlIHByb3RvdHlwZSkgd2UgbmVlZCB0b1xuICAgIC8vIHJldHVybiBhIGRlc2NyaXB0b3IsIG90aGVyd2lzZSBUeXBlU2NyaXB0IG92ZXJ3cml0ZXMgdGhlIGRlc2NyaXB0b3Igd2VcbiAgICAvLyBkZWZpbmUgaW4gY3JlYXRlUHJvcGVydHkoKSB3aXRoIHRoZSBvcmlnaW5hbCBkZXNjcmlwdG9yLiBXZSBkb24ndCBkbyB0aGlzXG4gICAgLy8gZm9yIGZpZWxkcywgd2hpY2ggZG9uJ3QgaGF2ZSBhIGRlc2NyaXB0b3IsIGJlY2F1c2UgdGhpcyBjb3VsZCBvdmVyd3JpdGVcbiAgICAvLyBkZXNjcmlwdG9yIGRlZmluZWQgYnkgb3RoZXIgZGVjb3JhdG9ycy5cbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHlcbiAgICAgICAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBuYW1lKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG4vLyBUaGlzIGlzIGR1cGxpY2F0ZWQgZnJvbSBhIHNpbWlsYXIgdmFyaWFibGUgaW4gcmVhY3RpdmUtZWxlbWVudC50cywgYnV0XG4vLyBhY3R1YWxseSBtYWtlcyBzZW5zZSB0byBoYXZlIHRoaXMgZGVmYXVsdCBkZWZpbmVkIHdpdGggdGhlIGRlY29yYXRvciwgc29cbi8vIHRoYXQgZGlmZmVyZW50IGRlY29yYXRvcnMgY291bGQgaGF2ZSBkaWZmZXJlbnQgZGVmYXVsdHMuXG5jb25zdCBkZWZhdWx0UHJvcGVydHlEZWNsYXJhdGlvbiA9IHtcbiAgICBhdHRyaWJ1dGU6IHRydWUsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGNvbnZlcnRlcjogZGVmYXVsdENvbnZlcnRlcixcbiAgICByZWZsZWN0OiBmYWxzZSxcbiAgICBoYXNDaGFuZ2VkOiBub3RFcXVhbCxcbn07XG4vKipcbiAqIFdyYXBzIGEgY2xhc3MgYWNjZXNzb3Igb3Igc2V0dGVyIHNvIHRoYXQgYHJlcXVlc3RVcGRhdGUoKWAgaXMgY2FsbGVkIHdpdGggdGhlXG4gKiBwcm9wZXJ0eSBuYW1lIGFuZCBvbGQgdmFsdWUgd2hlbiB0aGUgYWNjZXNzb3IgaXMgc2V0LlxuICovXG5jb25zdCBzdGFuZGFyZFByb3BlcnR5ID0gKG9wdGlvbnMgPSBkZWZhdWx0UHJvcGVydHlEZWNsYXJhdGlvbiwgdGFyZ2V0LCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgeyBraW5kLCBtZXRhZGF0YSB9ID0gY29udGV4dDtcbiAgICBpZiAobWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgICBpc3N1ZVdhcm5pbmcoJ21pc3NpbmctY2xhc3MtbWV0YWRhdGEnLCBgVGhlIGNsYXNzICR7dGFyZ2V0fSBpcyBtaXNzaW5nIGRlY29yYXRvciBtZXRhZGF0YS4gVGhpcyBgICtcbiAgICAgICAgICAgIGBjb3VsZCBtZWFuIHRoYXQgeW91J3JlIHVzaW5nIGEgY29tcGlsZXIgdGhhdCBzdXBwb3J0cyBkZWNvcmF0b3JzIGAgK1xuICAgICAgICAgICAgYGJ1dCBkb2Vzbid0IHN1cHBvcnQgZGVjb3JhdG9yIG1ldGFkYXRhLCBzdWNoIGFzIFR5cGVTY3JpcHQgNS4xLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2UgdXBkYXRlIHlvdXIgY29tcGlsZXIuYCk7XG4gICAgfVxuICAgIC8vIFN0b3JlIHRoZSBwcm9wZXJ0eSBvcHRpb25zXG4gICAgbGV0IHByb3BlcnRpZXMgPSBnbG9iYWxUaGlzLmxpdFByb3BlcnR5TWV0YWRhdGEuZ2V0KG1ldGFkYXRhKTtcbiAgICBpZiAocHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsb2JhbFRoaXMubGl0UHJvcGVydHlNZXRhZGF0YS5zZXQobWV0YWRhdGEsIChwcm9wZXJ0aWVzID0gbmV3IE1hcCgpKSk7XG4gICAgfVxuICAgIGlmIChraW5kID09PSAnc2V0dGVyJykge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy53cmFwcGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJvcGVydGllcy5zZXQoY29udGV4dC5uYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoa2luZCA9PT0gJ2FjY2Vzc29yJykge1xuICAgICAgICAvLyBTdGFuZGFyZCBkZWNvcmF0b3JzIGNhbm5vdCBkeW5hbWljYWxseSBtb2RpZnkgdGhlIGNsYXNzLCBzbyB3ZSBjYW4ndFxuICAgICAgICAvLyByZXBsYWNlIGEgZmllbGQgd2l0aCBhY2Nlc3NvcnMuIFRoZSB1c2VyIG11c3QgdXNlIHRoZSBuZXcgYGFjY2Vzc29yYFxuICAgICAgICAvLyBrZXl3b3JkIGluc3RlYWQuXG4gICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXQuZ2V0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldC5jYWxsKHRoaXMsIHYpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZShuYW1lLCBvbGRWYWx1ZSwgb3B0aW9ucywgdHJ1ZSwgdik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdCh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8kY2hhbmdlUHJvcGVydHkobmFtZSwgdW5kZWZpbmVkLCBvcHRpb25zLCB2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChraW5kID09PSAnc2V0dGVyJykge1xuICAgICAgICBjb25zdCB7IG5hbWUgfSA9IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIHRhcmdldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZShuYW1lLCBvbGRWYWx1ZSwgb3B0aW9ucywgdHJ1ZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY29yYXRvciBsb2NhdGlvbjogJHtraW5kfWApO1xufTtcbi8qKlxuICogQSBjbGFzcyBmaWVsZCBvciBhY2Nlc3NvciBkZWNvcmF0b3Igd2hpY2ggY3JlYXRlcyBhIHJlYWN0aXZlIHByb3BlcnR5IHRoYXRcbiAqIHJlZmxlY3RzIGEgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUgdmFsdWUuIFdoZW4gYSBkZWNvcmF0ZWQgcHJvcGVydHkgaXMgc2V0XG4gKiB0aGUgZWxlbWVudCB3aWxsIHVwZGF0ZSBhbmQgcmVuZGVyLiBBIHtAbGlua2NvZGUgUHJvcGVydHlEZWNsYXJhdGlvbn0gbWF5XG4gKiBvcHRpb25hbGx5IGJlIHN1cHBsaWVkIHRvIGNvbmZpZ3VyZSBwcm9wZXJ0eSBmZWF0dXJlcy5cbiAqXG4gKiBUaGlzIGRlY29yYXRvciBzaG91bGQgb25seSBiZSB1c2VkIGZvciBwdWJsaWMgZmllbGRzLiBBcyBwdWJsaWMgZmllbGRzLFxuICogcHJvcGVydGllcyBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBwcmltYXJpbHkgc2V0dGFibGUgYnkgZWxlbWVudCB1c2VycyxcbiAqIGVpdGhlciB2aWEgYXR0cmlidXRlIG9yIHRoZSBwcm9wZXJ0eSBpdHNlbGYuXG4gKlxuICogR2VuZXJhbGx5LCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGNoYW5nZWQgYnkgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHByaXZhdGUgb3JcbiAqIHByb3RlY3RlZCBmaWVsZHMgYW5kIHNob3VsZCB1c2UgdGhlIHtAbGlua2NvZGUgc3RhdGV9IGRlY29yYXRvci5cbiAqXG4gKiBIb3dldmVyLCBzb21ldGltZXMgZWxlbWVudCBjb2RlIGRvZXMgbmVlZCB0byBzZXQgYSBwdWJsaWMgcHJvcGVydHkuIFRoaXNcbiAqIHNob3VsZCB0eXBpY2FsbHkgb25seSBiZSBkb25lIGluIHJlc3BvbnNlIHRvIHVzZXIgaW50ZXJhY3Rpb24sIGFuZCBhbiBldmVudFxuICogc2hvdWxkIGJlIGZpcmVkIGluZm9ybWluZyB0aGUgdXNlcjsgZm9yIGV4YW1wbGUsIGEgY2hlY2tib3ggc2V0cyBpdHNcbiAqIGBjaGVja2VkYCBwcm9wZXJ0eSB3aGVuIGNsaWNrZWQgYW5kIGZpcmVzIGEgYGNoYW5nZWRgIGV2ZW50LiBNdXRhdGluZyBwdWJsaWNcbiAqIHByb3BlcnRpZXMgc2hvdWxkIHR5cGljYWxseSBub3QgYmUgZG9uZSBmb3Igbm9uLXByaW1pdGl2ZSAob2JqZWN0IG9yIGFycmF5KVxuICogcHJvcGVydGllcy4gSW4gb3RoZXIgY2FzZXMgd2hlbiBhbiBlbGVtZW50IG5lZWRzIHRvIG1hbmFnZSBzdGF0ZSwgYSBwcml2YXRlXG4gKiBwcm9wZXJ0eSBkZWNvcmF0ZWQgdmlhIHRoZSB7QGxpbmtjb2RlIHN0YXRlfSBkZWNvcmF0b3Igc2hvdWxkIGJlIHVzZWQuIFdoZW5cbiAqIG5lZWRlZCwgc3RhdGUgcHJvcGVydGllcyBjYW4gYmUgaW5pdGlhbGl6ZWQgdmlhIHB1YmxpYyBwcm9wZXJ0aWVzIHRvXG4gKiBmYWNpbGl0YXRlIGNvbXBsZXggaW50ZXJhY3Rpb25zLlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBNeUVsZW1lbnQge1xuICogICBAcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuIH0pXG4gKiAgIGNsaWNrZWQgPSBmYWxzZTtcbiAqIH1cbiAqIGBgYFxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICogQEV4cG9ydERlY29yYXRlZEl0ZW1zXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKHByb3RvT3JUYXJnZXQsIG5hbWVPckNvbnRleHRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkgPT4ge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBuYW1lT3JDb250ZXh0ID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBzdGFuZGFyZFByb3BlcnR5KG9wdGlvbnMsIHByb3RvT3JUYXJnZXQsIG5hbWVPckNvbnRleHQpXG4gICAgICAgICAgICA6IGxlZ2FjeVByb3BlcnR5KG9wdGlvbnMsIHByb3RvT3JUYXJnZXQsIG5hbWVPckNvbnRleHQpKTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBwcm9wZXJ0eSwgc3RhbmRhcmRQcm9wZXJ0eSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHkuanMubWFwXG4iXSwibmFtZXMiOlsibm90RXF1YWwiLCJkZWZhdWx0Q29udmVydGVyIiwiaXNzdWVXYXJuaW5nIiwiZ2xvYmFsVGhpcyIsImxpdElzc3VlZFdhcm5pbmdzIiwiU2V0IiwiY29kZSIsIndhcm5pbmciLCJoYXMiLCJjb25zb2xlIiwid2FybiIsImFkZCIsImxlZ2FjeVByb3BlcnR5Iiwib3B0aW9ucyIsInByb3RvIiwibmFtZSIsImhhc093blByb3BlcnR5IiwiY29uc3RydWN0b3IiLCJjcmVhdGVQcm9wZXJ0eSIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInVuZGVmaW5lZCIsImRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uIiwiYXR0cmlidXRlIiwidHlwZSIsIlN0cmluZyIsImNvbnZlcnRlciIsInJlZmxlY3QiLCJoYXNDaGFuZ2VkIiwic3RhbmRhcmRQcm9wZXJ0eSIsInRhcmdldCIsImNvbnRleHQiLCJraW5kIiwibWV0YWRhdGEiLCJwcm9wZXJ0aWVzIiwibGl0UHJvcGVydHlNZXRhZGF0YSIsImdldCIsInNldCIsIk1hcCIsImNyZWF0ZSIsIndyYXBwZWQiLCJ2Iiwib2xkVmFsdWUiLCJjYWxsIiwicmVxdWVzdFVwZGF0ZSIsImluaXQiLCJfJGNoYW5nZVByb3BlcnR5IiwidmFsdWUiLCJFcnJvciIsInByb3BlcnR5IiwicHJvdG9PclRhcmdldCIsIm5hbWVPckNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/property.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-all.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query-all.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryAll: () => (/* binding */ queryAll)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ // Shared fragment used to generate empty NodeLists when a render root is\n// undefined\nlet fragment;\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * ```ts\n * class MyElement {\n *   @queryAll('div')\n *   divs: NodeListOf<HTMLDivElement>;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */ function queryAll(selector) {\n    return (obj, name)=>{\n        return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.desc)(obj, name, {\n            get () {\n                const container = this.renderRoot ?? (fragment ??= document.createDocumentFragment());\n                return container.querySelectorAll(selector);\n            }\n        });\n    };\n}\n //# sourceMappingURL=query-all.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFFakM7Ozs7Q0FJQyxHQUNELHlFQUF5RTtBQUN6RSxZQUFZO0FBQ1osSUFBSUM7QUFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDRCxTQUFTQyxTQUFTQyxRQUFRO0lBQ3RCLE9BQVEsQ0FBQ0MsS0FBS0M7UUFDVixPQUFPTCw4Q0FBSUEsQ0FBQ0ksS0FBS0MsTUFBTTtZQUNuQkM7Z0JBQ0ksTUFBTUMsWUFBWSxJQUFJLENBQUNDLFVBQVUsSUFBS1AsQ0FBQUEsYUFBYVEsU0FBU0Msc0JBQXNCLEVBQUM7Z0JBQ25GLE9BQU9ILFVBQVVJLGdCQUFnQixDQUFDUjtZQUN0QztRQUNKO0lBQ0o7QUFDSjtBQUVvQixDQUNwQixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hbGwuanM/M2RiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjIH0gZnJvbSAnLi9iYXNlLmpzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG4vLyBTaGFyZWQgZnJhZ21lbnQgdXNlZCB0byBnZW5lcmF0ZSBlbXB0eSBOb2RlTGlzdHMgd2hlbiBhIHJlbmRlciByb290IGlzXG4vLyB1bmRlZmluZWRcbmxldCBmcmFnbWVudDtcbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXJcbiAqIHRoYXQgZXhlY3V0ZXMgYSBxdWVyeVNlbGVjdG9yQWxsIG9uIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdC5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgQSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2guXG4gKlxuICogU2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L3F1ZXJ5U2VsZWN0b3JBbGxcbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgTXlFbGVtZW50IHtcbiAqICAgQHF1ZXJ5QWxsKCdkaXYnKVxuICogICBkaXZzOiBOb2RlTGlzdE9mPEhUTUxEaXZFbGVtZW50PjtcbiAqXG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgIDxkaXYgaWQ9XCJmaXJzdFwiPjwvZGl2PlxuICogICAgICAgPGRpdiBpZD1cInNlY29uZFwiPjwvZGl2PlxuICogICAgIGA7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBxdWVyeUFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiAoKG9iaiwgbmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gZGVzYyhvYmosIG5hbWUsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLnJlbmRlclJvb3QgPz8gKGZyYWdtZW50ID8/PSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgcXVlcnlBbGwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWFsbC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZXNjIiwiZnJhZ21lbnQiLCJxdWVyeUFsbCIsInNlbGVjdG9yIiwib2JqIiwibmFtZSIsImdldCIsImNvbnRhaW5lciIsInJlbmRlclJvb3QiLCJkb2N1bWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-all.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-elements.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-elements.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryAssignedElements: () => (/* binding */ queryAssignedElements)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedElements` of the given `slot`. Provides a declarative\n * way to use\n * [`HTMLSlotElement.assignedElements`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedElements).\n *\n * Can be passed an optional {@linkcode QueryAssignedElementsOptions} object.\n *\n * Example usage:\n * ```ts\n * class MyElement {\n *   @queryAssignedElements({ slot: 'list' })\n *   listItems!: Array<HTMLElement>;\n *   @queryAssignedElements()\n *   unnamedSlotEls!: Array<HTMLElement>;\n *\n *   render() {\n *     return html`\n *       <slot name=\"list\"></slot>\n *       <slot></slot>\n *     `;\n *   }\n * }\n * ```\n *\n * Note, the type of this property should be annotated as `Array<HTMLElement>`.\n *\n * @category Decorator\n */ function queryAssignedElements(options) {\n    return (obj, name)=>{\n        const { slot, selector } = options ?? {};\n        const slotSelector = `slot${slot ? `[name=${slot}]` : \":not([name])\"}`;\n        return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.desc)(obj, name, {\n            get () {\n                const slotEl = this.renderRoot?.querySelector(slotSelector);\n                const elements = slotEl?.assignedElements(options) ?? [];\n                return selector === undefined ? elements : elements.filter((node)=>node.matches(selector));\n            }\n        });\n    };\n}\n //# sourceMappingURL=query-assigned-elements.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hc3NpZ25lZC1lbGVtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQUVqQzs7OztDQUlDLEdBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDRCxTQUFTQyxzQkFBc0JDLE9BQU87SUFDbEMsT0FBUSxDQUFDQyxLQUFLQztRQUNWLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUUsR0FBR0osV0FBVyxDQUFDO1FBQ3ZDLE1BQU1LLGVBQWUsQ0FBQyxJQUFJLEVBQUVGLE9BQU8sQ0FBQyxNQUFNLEVBQUVBLEtBQUssQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDO1FBQ3RFLE9BQU9MLDhDQUFJQSxDQUFDRyxLQUFLQyxNQUFNO1lBQ25CSTtnQkFDSSxNQUFNQyxTQUFTLElBQUksQ0FBQ0MsVUFBVSxFQUFFQyxjQUFjSjtnQkFDOUMsTUFBTUssV0FBV0gsUUFBUUksaUJBQWlCWCxZQUFZLEVBQUU7Z0JBQ3hELE9BQVFJLGFBQWFRLFlBQ2ZGLFdBQ0FBLFNBQVNHLE1BQU0sQ0FBQyxDQUFDQyxPQUFTQSxLQUFLQyxPQUFPLENBQUNYO1lBQ2pEO1FBQ0o7SUFDSjtBQUNKO0FBRWlDLENBQ2pDLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvbm9kZS9kZXZlbG9wbWVudC9kZWNvcmF0b3JzL3F1ZXJ5LWFzc2lnbmVkLWVsZW1lbnRzLmpzP2VjYmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVzYyB9IGZyb20gJy4vYmFzZS5qcyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuLyoqXG4gKiBBIHByb3BlcnR5IGRlY29yYXRvciB0aGF0IGNvbnZlcnRzIGEgY2xhc3MgcHJvcGVydHkgaW50byBhIGdldHRlciB0aGF0XG4gKiByZXR1cm5zIHRoZSBgYXNzaWduZWRFbGVtZW50c2Agb2YgdGhlIGdpdmVuIGBzbG90YC4gUHJvdmlkZXMgYSBkZWNsYXJhdGl2ZVxuICogd2F5IHRvIHVzZVxuICogW2BIVE1MU2xvdEVsZW1lbnQuYXNzaWduZWRFbGVtZW50c2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MU2xvdEVsZW1lbnQvYXNzaWduZWRFbGVtZW50cykuXG4gKlxuICogQ2FuIGJlIHBhc3NlZCBhbiBvcHRpb25hbCB7QGxpbmtjb2RlIFF1ZXJ5QXNzaWduZWRFbGVtZW50c09wdGlvbnN9IG9iamVjdC5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogYGBgdHNcbiAqIGNsYXNzIE15RWxlbWVudCB7XG4gKiAgIEBxdWVyeUFzc2lnbmVkRWxlbWVudHMoeyBzbG90OiAnbGlzdCcgfSlcbiAqICAgbGlzdEl0ZW1zITogQXJyYXk8SFRNTEVsZW1lbnQ+O1xuICogICBAcXVlcnlBc3NpZ25lZEVsZW1lbnRzKClcbiAqICAgdW5uYW1lZFNsb3RFbHMhOiBBcnJheTxIVE1MRWxlbWVudD47XG4gKlxuICogICByZW5kZXIoKSB7XG4gKiAgICAgcmV0dXJuIGh0bWxgXG4gKiAgICAgICA8c2xvdCBuYW1lPVwibGlzdFwiPjwvc2xvdD5cbiAqICAgICAgIDxzbG90Pjwvc2xvdD5cbiAqICAgICBgO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBOb3RlLCB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IHNob3VsZCBiZSBhbm5vdGF0ZWQgYXMgYEFycmF5PEhUTUxFbGVtZW50PmAuXG4gKlxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBxdWVyeUFzc2lnbmVkRWxlbWVudHMob3B0aW9ucykge1xuICAgIHJldHVybiAoKG9iaiwgbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHNsb3QsIHNlbGVjdG9yIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCBzbG90U2VsZWN0b3IgPSBgc2xvdCR7c2xvdCA/IGBbbmFtZT0ke3Nsb3R9XWAgOiAnOm5vdChbbmFtZV0pJ31gO1xuICAgICAgICByZXR1cm4gZGVzYyhvYmosIG5hbWUsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90RWwgPSB0aGlzLnJlbmRlclJvb3Q/LnF1ZXJ5U2VsZWN0b3Ioc2xvdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHNsb3RFbD8uYXNzaWduZWRFbGVtZW50cyhvcHRpb25zKSA/PyBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNlbGVjdG9yID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICA6IGVsZW1lbnRzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHF1ZXJ5QXNzaWduZWRFbGVtZW50cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktYXNzaWduZWQtZWxlbWVudHMuanMubWFwXG4iXSwibmFtZXMiOlsiZGVzYyIsInF1ZXJ5QXNzaWduZWRFbGVtZW50cyIsIm9wdGlvbnMiLCJvYmoiLCJuYW1lIiwic2xvdCIsInNlbGVjdG9yIiwic2xvdFNlbGVjdG9yIiwiZ2V0Iiwic2xvdEVsIiwicmVuZGVyUm9vdCIsInF1ZXJ5U2VsZWN0b3IiLCJlbGVtZW50cyIsImFzc2lnbmVkRWxlbWVudHMiLCJ1bmRlZmluZWQiLCJmaWx0ZXIiLCJub2RlIiwibWF0Y2hlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-elements.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-nodes.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-nodes.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryAssignedNodes: () => (/* binding */ queryAssignedNodes)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedNodes` of the given `slot`.\n *\n * Can be passed an optional {@linkcode QueryAssignedNodesOptions} object.\n *\n * Example usage:\n * ```ts\n * class MyElement {\n *   @queryAssignedNodes({slot: 'list', flatten: true})\n *   listItems!: Array<Node>;\n *\n *   render() {\n *     return html`\n *       <slot name=\"list\"></slot>\n *     `;\n *   }\n * }\n * ```\n *\n * Note the type of this property should be annotated as `Array<Node>`. Use the\n * queryAssignedElements decorator to list only elements, and optionally filter\n * the element list using a CSS selector.\n *\n * @category Decorator\n */ function queryAssignedNodes(options) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (obj, name)=>{\n        const { slot } = options ?? {};\n        const slotSelector = `slot${slot ? `[name=${slot}]` : \":not([name])\"}`;\n        return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.desc)(obj, name, {\n            get () {\n                const slotEl = this.renderRoot?.querySelector(slotSelector);\n                return slotEl?.assignedNodes(options) ?? [];\n            }\n        });\n    };\n}\n //# sourceMappingURL=query-assigned-nodes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hc3NpZ25lZC1ub2Rlcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQUVqQzs7OztDQUlDLEdBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDRCxTQUFTQyxtQkFBbUJDLE9BQU87SUFDL0IsOERBQThEO0lBQzlELE9BQVEsQ0FBQ0MsS0FBS0M7UUFDVixNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHSCxXQUFXLENBQUM7UUFDN0IsTUFBTUksZUFBZSxDQUFDLElBQUksRUFBRUQsT0FBTyxDQUFDLE1BQU0sRUFBRUEsS0FBSyxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUM7UUFDdEUsT0FBT0wsOENBQUlBLENBQUNHLEtBQUtDLE1BQU07WUFDbkJHO2dCQUNJLE1BQU1DLFNBQVMsSUFBSSxDQUFDQyxVQUFVLEVBQUVDLGNBQWNKO2dCQUM5QyxPQUFRRSxRQUFRRyxjQUFjVCxZQUFZLEVBQUU7WUFDaEQ7UUFDSjtJQUNKO0FBQ0o7QUFFOEIsQ0FDOUIsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvcXVlcnktYXNzaWduZWQtbm9kZXMuanM/OGE4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjIH0gZnJvbSAnLi9iYXNlLmpzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG4vKipcbiAqIEEgcHJvcGVydHkgZGVjb3JhdG9yIHRoYXQgY29udmVydHMgYSBjbGFzcyBwcm9wZXJ0eSBpbnRvIGEgZ2V0dGVyIHRoYXRcbiAqIHJldHVybnMgdGhlIGBhc3NpZ25lZE5vZGVzYCBvZiB0aGUgZ2l2ZW4gYHNsb3RgLlxuICpcbiAqIENhbiBiZSBwYXNzZWQgYW4gb3B0aW9uYWwge0BsaW5rY29kZSBRdWVyeUFzc2lnbmVkTm9kZXNPcHRpb25zfSBvYmplY3QuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqIGBgYHRzXG4gKiBjbGFzcyBNeUVsZW1lbnQge1xuICogICBAcXVlcnlBc3NpZ25lZE5vZGVzKHtzbG90OiAnbGlzdCcsIGZsYXR0ZW46IHRydWV9KVxuICogICBsaXN0SXRlbXMhOiBBcnJheTxOb2RlPjtcbiAqXG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgIDxzbG90IG5hbWU9XCJsaXN0XCI+PC9zbG90PlxuICogICAgIGA7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBzaG91bGQgYmUgYW5ub3RhdGVkIGFzIGBBcnJheTxOb2RlPmAuIFVzZSB0aGVcbiAqIHF1ZXJ5QXNzaWduZWRFbGVtZW50cyBkZWNvcmF0b3IgdG8gbGlzdCBvbmx5IGVsZW1lbnRzLCBhbmQgb3B0aW9uYWxseSBmaWx0ZXJcbiAqIHRoZSBlbGVtZW50IGxpc3QgdXNpbmcgYSBDU1Mgc2VsZWN0b3IuXG4gKlxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBxdWVyeUFzc2lnbmVkTm9kZXMob3B0aW9ucykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuICgob2JqLCBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2xvdCB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICAgICAgY29uc3Qgc2xvdFNlbGVjdG9yID0gYHNsb3Qke3Nsb3QgPyBgW25hbWU9JHtzbG90fV1gIDogJzpub3QoW25hbWVdKSd9YDtcbiAgICAgICAgcmV0dXJuIGRlc2Mob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdEVsID0gdGhpcy5yZW5kZXJSb290Py5xdWVyeVNlbGVjdG9yKHNsb3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzbG90RWw/LmFzc2lnbmVkTm9kZXMob3B0aW9ucykgPz8gW10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHF1ZXJ5QXNzaWduZWROb2RlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktYXNzaWduZWQtbm9kZXMuanMubWFwXG4iXSwibmFtZXMiOlsiZGVzYyIsInF1ZXJ5QXNzaWduZWROb2RlcyIsIm9wdGlvbnMiLCJvYmoiLCJuYW1lIiwic2xvdCIsInNsb3RTZWxlY3RvciIsImdldCIsInNsb3RFbCIsInJlbmRlclJvb3QiLCJxdWVyeVNlbGVjdG9yIiwiYXNzaWduZWROb2RlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-nodes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-async.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query-async.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryAsync: () => (/* binding */ queryAsync)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ // Note, in the future, we may extend this decorator to support the use case\n// where the queried element may need to do work to become ready to interact\n// with (e.g. load some implementation code). If so, we might elect to\n// add a second argument defining a function that can be run to make the\n// queried element loaded/updated/ready.\n/**\n * A property decorator that converts a class property into a getter that\n * returns a promise that resolves to the result of a querySelector on the\n * element's renderRoot done after the element's `updateComplete` promise\n * resolves. When the queried property may change with element state, this\n * decorator can be used instead of requiring users to await the\n * `updateComplete` before accessing the property.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @queryAsync('#first')\n *   first: Promise<HTMLDivElement>;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n *\n * // external usage\n * async doSomethingWithFirst() {\n *  (await aMyElement.first).doSomething();\n * }\n * ```\n * @category Decorator\n */ function queryAsync(selector) {\n    return (obj, name)=>{\n        return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.desc)(obj, name, {\n            async get () {\n                await this.updateComplete;\n                return this.renderRoot?.querySelector(selector) ?? null;\n            }\n        });\n    };\n}\n //# sourceMappingURL=query-async.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hc3luYy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQUVqQzs7OztDQUlDLEdBQ0QsNEVBQTRFO0FBQzVFLDRFQUE0RTtBQUM1RSxzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFLHdDQUF3QztBQUN4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUNELFNBQVNDLFdBQVdDLFFBQVE7SUFDeEIsT0FBUSxDQUFDQyxLQUFLQztRQUNWLE9BQU9KLDhDQUFJQSxDQUFDRyxLQUFLQyxNQUFNO1lBQ25CLE1BQU1DO2dCQUNGLE1BQU0sSUFBSSxDQUFDQyxjQUFjO2dCQUN6QixPQUFPLElBQUksQ0FBQ0MsVUFBVSxFQUFFQyxjQUFjTixhQUFhO1lBQ3ZEO1FBQ0o7SUFDSjtBQUNKO0FBRXNCLENBQ3RCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvbm9kZS9kZXZlbG9wbWVudC9kZWNvcmF0b3JzL3F1ZXJ5LWFzeW5jLmpzPzc1OWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVzYyB9IGZyb20gJy4vYmFzZS5qcyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuLy8gTm90ZSwgaW4gdGhlIGZ1dHVyZSwgd2UgbWF5IGV4dGVuZCB0aGlzIGRlY29yYXRvciB0byBzdXBwb3J0IHRoZSB1c2UgY2FzZVxuLy8gd2hlcmUgdGhlIHF1ZXJpZWQgZWxlbWVudCBtYXkgbmVlZCB0byBkbyB3b3JrIHRvIGJlY29tZSByZWFkeSB0byBpbnRlcmFjdFxuLy8gd2l0aCAoZS5nLiBsb2FkIHNvbWUgaW1wbGVtZW50YXRpb24gY29kZSkuIElmIHNvLCB3ZSBtaWdodCBlbGVjdCB0b1xuLy8gYWRkIGEgc2Vjb25kIGFyZ3VtZW50IGRlZmluaW5nIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvIG1ha2UgdGhlXG4vLyBxdWVyaWVkIGVsZW1lbnQgbG9hZGVkL3VwZGF0ZWQvcmVhZHkuXG4vKipcbiAqIEEgcHJvcGVydHkgZGVjb3JhdG9yIHRoYXQgY29udmVydHMgYSBjbGFzcyBwcm9wZXJ0eSBpbnRvIGEgZ2V0dGVyIHRoYXRcbiAqIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3VsdCBvZiBhIHF1ZXJ5U2VsZWN0b3Igb24gdGhlXG4gKiBlbGVtZW50J3MgcmVuZGVyUm9vdCBkb25lIGFmdGVyIHRoZSBlbGVtZW50J3MgYHVwZGF0ZUNvbXBsZXRlYCBwcm9taXNlXG4gKiByZXNvbHZlcy4gV2hlbiB0aGUgcXVlcmllZCBwcm9wZXJ0eSBtYXkgY2hhbmdlIHdpdGggZWxlbWVudCBzdGF0ZSwgdGhpc1xuICogZGVjb3JhdG9yIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgcmVxdWlyaW5nIHVzZXJzIHRvIGF3YWl0IHRoZVxuICogYHVwZGF0ZUNvbXBsZXRlYCBiZWZvcmUgYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgQSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2guXG4gKlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvclxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBNeUVsZW1lbnQge1xuICogICBAcXVlcnlBc3luYygnI2ZpcnN0JylcbiAqICAgZmlyc3Q6IFByb21pc2U8SFRNTERpdkVsZW1lbnQ+O1xuICpcbiAqICAgcmVuZGVyKCkge1xuICogICAgIHJldHVybiBodG1sYFxuICogICAgICAgPGRpdiBpZD1cImZpcnN0XCI+PC9kaXY+XG4gKiAgICAgICA8ZGl2IGlkPVwic2Vjb25kXCI+PC9kaXY+XG4gKiAgICAgYDtcbiAqICAgfVxuICogfVxuICpcbiAqIC8vIGV4dGVybmFsIHVzYWdlXG4gKiBhc3luYyBkb1NvbWV0aGluZ1dpdGhGaXJzdCgpIHtcbiAqICAoYXdhaXQgYU15RWxlbWVudC5maXJzdCkuZG9Tb21ldGhpbmcoKTtcbiAqIH1cbiAqIGBgYFxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBxdWVyeUFzeW5jKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICgob2JqLCBuYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBkZXNjKG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgYXN5bmMgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQ29tcGxldGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdD8ucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgPz8gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBxdWVyeUFzeW5jIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1hc3luYy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZXNjIiwicXVlcnlBc3luYyIsInNlbGVjdG9yIiwib2JqIiwibmFtZSIsImdldCIsInVwZGF0ZUNvbXBsZXRlIiwicmVuZGVyUm9vdCIsInF1ZXJ5U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-async.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   query: () => (/* binding */ query)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ let issueWarning;\n{\n    // Ensure warnings are issued only 1x, even if multiple versions of Lit\n    // are loaded.\n    globalThis.litIssuedWarnings ??= new Set();\n    /**\n     * Issue a warning if we haven't already, based either on `code` or `warning`.\n     * Warnings are disabled automatically only by `warning`; disabling via `code`\n     * can be done by users.\n     */ issueWarning = (code, warning)=>{\n        warning += code ? ` See https://lit.dev/msg/${code} for more information.` : \"\";\n        if (!globalThis.litIssuedWarnings.has(warning) && !globalThis.litIssuedWarnings.has(code)) {\n            console.warn(warning);\n            globalThis.litIssuedWarnings.add(warning);\n        }\n    };\n}/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n * @param cache An optional boolean which when true performs the DOM query only\n *     once and caches the result.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @query('#first')\n *   first: HTMLDivElement;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */ function query(selector, cache) {\n    return (protoOrTarget, nameOrContext, descriptor)=>{\n        const doQuery = (el)=>{\n            const result = el.renderRoot?.querySelector(selector) ?? null;\n            if (result === null && cache && !el.hasUpdated) {\n                const name = typeof nameOrContext === \"object\" ? nameOrContext.name : nameOrContext;\n                issueWarning(\"\", `@query'd field ${JSON.stringify(String(name))} with the 'cache' ` + `flag set for selector '${selector}' has been accessed before ` + `the first update and returned null. This is expected if the ` + `renderRoot tree has not been provided beforehand (e.g. via ` + `Declarative Shadow DOM). Therefore the value hasn't been cached.`);\n            }\n            // TODO: if we want to allow users to assert that the query will never\n            // return null, we need a new option and to throw here if the result\n            // is null.\n            return result;\n        };\n        if (cache) {\n            // Accessors to wrap from either:\n            //   1. The decorator target, in the case of standard decorators\n            //   2. The property descriptor, in the case of experimental decorators\n            //      on auto-accessors.\n            //   3. Functions that access our own cache-key property on the instance,\n            //      in the case of experimental decorators on fields.\n            const { get, set } = typeof nameOrContext === \"object\" ? protoOrTarget : descriptor ?? (()=>{\n                const key = Symbol(`${String(nameOrContext)} (@query() cache)`);\n                return {\n                    get () {\n                        return this[key];\n                    },\n                    set (v) {\n                        this[key] = v;\n                    }\n                };\n            })();\n            return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.desc)(protoOrTarget, nameOrContext, {\n                get () {\n                    let result = get.call(this);\n                    if (result === undefined) {\n                        result = doQuery(this);\n                        if (result !== null || this.hasUpdated) {\n                            set.call(this, result);\n                        }\n                    }\n                    return result;\n                }\n            });\n        } else {\n            // This object works as the return type for both standard and\n            // experimental decorators.\n            return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.desc)(protoOrTarget, nameOrContext, {\n                get () {\n                    return doQuery(this);\n                }\n            });\n        }\n    };\n}\n //# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQUVqQzs7OztDQUlDLEdBQ0QsSUFBSUM7QUFDSjtJQUNJLHVFQUF1RTtJQUN2RSxjQUFjO0lBQ2RDLFdBQVdDLGlCQUFpQixLQUFLLElBQUlDO0lBQ3JDOzs7O0tBSUMsR0FDREgsZUFBZSxDQUFDSSxNQUFNQztRQUNsQkEsV0FBV0QsT0FDTCxDQUFDLHlCQUF5QixFQUFFQSxLQUFLLHNCQUFzQixDQUFDLEdBQ3hEO1FBQ04sSUFBSSxDQUFDSCxXQUFXQyxpQkFBaUIsQ0FBQ0ksR0FBRyxDQUFDRCxZQUNsQyxDQUFDSixXQUFXQyxpQkFBaUIsQ0FBQ0ksR0FBRyxDQUFDRixPQUFPO1lBQ3pDRyxRQUFRQyxJQUFJLENBQUNIO1lBQ2JKLFdBQVdDLGlCQUFpQixDQUFDTyxHQUFHLENBQUNKO1FBQ3JDO0lBQ0o7QUFDSixDQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FDRCxTQUFTSyxNQUFNQyxRQUFRLEVBQUVDLEtBQUs7SUFDMUIsT0FBUSxDQUFDQyxlQUFlQyxlQUFlQztRQUNuQyxNQUFNQyxVQUFVLENBQUNDO1lBQ2IsTUFBTUMsU0FBVUQsR0FBR0UsVUFBVSxFQUFFQyxjQUFjVCxhQUFhO1lBQzFELElBQUlPLFdBQVcsUUFBUU4sU0FBUyxDQUFDSyxHQUFHSSxVQUFVLEVBQUU7Z0JBQzVDLE1BQU1DLE9BQU8sT0FBT1Isa0JBQWtCLFdBQ2hDQSxjQUFjUSxJQUFJLEdBQ2xCUjtnQkFDTmQsYUFBYSxJQUFJLENBQUMsZUFBZSxFQUFFdUIsS0FBS0MsU0FBUyxDQUFDQyxPQUFPSCxPQUFPLGtCQUFrQixDQUFDLEdBQy9FLENBQUMsdUJBQXVCLEVBQUVYLFNBQVMsMkJBQTJCLENBQUMsR0FDL0QsQ0FBQyw0REFBNEQsQ0FBQyxHQUM5RCxDQUFDLDJEQUEyRCxDQUFDLEdBQzdELENBQUMsZ0VBQWdFLENBQUM7WUFDMUU7WUFDQSxzRUFBc0U7WUFDdEUsb0VBQW9FO1lBQ3BFLFdBQVc7WUFDWCxPQUFPTztRQUNYO1FBQ0EsSUFBSU4sT0FBTztZQUNQLGlDQUFpQztZQUNqQyxnRUFBZ0U7WUFDaEUsdUVBQXVFO1lBQ3ZFLDBCQUEwQjtZQUMxQix5RUFBeUU7WUFDekUseURBQXlEO1lBQ3pELE1BQU0sRUFBRWMsR0FBRyxFQUFFQyxHQUFHLEVBQUUsR0FBRyxPQUFPYixrQkFBa0IsV0FDeENELGdCQUNDRSxjQUNDLENBQUM7Z0JBQ0csTUFBTWEsTUFBTUMsT0FBTyxDQUFDLEVBQUVKLE9BQU9YLGVBQWUsaUJBQWlCLENBQUM7Z0JBRTlELE9BQU87b0JBQ0hZO3dCQUNJLE9BQU8sSUFBSSxDQUFDRSxJQUFJO29CQUNwQjtvQkFDQUQsS0FBSUcsQ0FBQzt3QkFDRCxJQUFJLENBQUNGLElBQUksR0FBR0U7b0JBQ2hCO2dCQUNKO1lBQ0o7WUFDUixPQUFPL0IsOENBQUlBLENBQUNjLGVBQWVDLGVBQWU7Z0JBQ3RDWTtvQkFDSSxJQUFJUixTQUFTUSxJQUFJSyxJQUFJLENBQUMsSUFBSTtvQkFDMUIsSUFBSWIsV0FBV2MsV0FBVzt3QkFDdEJkLFNBQVNGLFFBQVEsSUFBSTt3QkFDckIsSUFBSUUsV0FBVyxRQUFRLElBQUksQ0FBQ0csVUFBVSxFQUFFOzRCQUNwQ00sSUFBSUksSUFBSSxDQUFDLElBQUksRUFBRWI7d0JBQ25CO29CQUNKO29CQUNBLE9BQU9BO2dCQUNYO1lBQ0o7UUFDSixPQUNLO1lBQ0QsNkRBQTZEO1lBQzdELDJCQUEyQjtZQUMzQixPQUFPbkIsOENBQUlBLENBQUNjLGVBQWVDLGVBQWU7Z0JBQ3RDWTtvQkFDSSxPQUFPVixRQUFRLElBQUk7Z0JBQ3ZCO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFFaUIsQ0FDakIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvcXVlcnkuanM/YTVjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjIH0gZnJvbSAnLi9iYXNlLmpzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5sZXQgaXNzdWVXYXJuaW5nO1xue1xuICAgIC8vIEVuc3VyZSB3YXJuaW5ncyBhcmUgaXNzdWVkIG9ubHkgMXgsIGV2ZW4gaWYgbXVsdGlwbGUgdmVyc2lvbnMgb2YgTGl0XG4gICAgLy8gYXJlIGxvYWRlZC5cbiAgICBnbG9iYWxUaGlzLmxpdElzc3VlZFdhcm5pbmdzID8/PSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogSXNzdWUgYSB3YXJuaW5nIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSwgYmFzZWQgZWl0aGVyIG9uIGBjb2RlYCBvciBgd2FybmluZ2AuXG4gICAgICogV2FybmluZ3MgYXJlIGRpc2FibGVkIGF1dG9tYXRpY2FsbHkgb25seSBieSBgd2FybmluZ2A7IGRpc2FibGluZyB2aWEgYGNvZGVgXG4gICAgICogY2FuIGJlIGRvbmUgYnkgdXNlcnMuXG4gICAgICovXG4gICAgaXNzdWVXYXJuaW5nID0gKGNvZGUsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgd2FybmluZyArPSBjb2RlXG4gICAgICAgICAgICA/IGAgU2VlIGh0dHBzOi8vbGl0LmRldi9tc2cvJHtjb2RlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICBpZiAoIWdsb2JhbFRoaXMubGl0SXNzdWVkV2FybmluZ3MuaGFzKHdhcm5pbmcpICYmXG4gICAgICAgICAgICAhZ2xvYmFsVGhpcy5saXRJc3N1ZWRXYXJuaW5ncy5oYXMoY29kZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMubGl0SXNzdWVkV2FybmluZ3MuYWRkKHdhcm5pbmcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXIgdGhhdFxuICogZXhlY3V0ZXMgYSBxdWVyeVNlbGVjdG9yIG9uIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdC5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgQSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2guXG4gKiBAcGFyYW0gY2FjaGUgQW4gb3B0aW9uYWwgYm9vbGVhbiB3aGljaCB3aGVuIHRydWUgcGVyZm9ybXMgdGhlIERPTSBxdWVyeSBvbmx5XG4gKiAgICAgb25jZSBhbmQgY2FjaGVzIHRoZSByZXN1bHQuXG4gKlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvclxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBNeUVsZW1lbnQge1xuICogICBAcXVlcnkoJyNmaXJzdCcpXG4gKiAgIGZpcnN0OiBIVE1MRGl2RWxlbWVudDtcbiAqXG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgIDxkaXYgaWQ9XCJmaXJzdFwiPjwvZGl2PlxuICogICAgICAgPGRpdiBpZD1cInNlY29uZFwiPjwvZGl2PlxuICogICAgIGA7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBxdWVyeShzZWxlY3RvciwgY2FjaGUpIHtcbiAgICByZXR1cm4gKChwcm90b09yVGFyZ2V0LCBuYW1lT3JDb250ZXh0LCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvUXVlcnkgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChlbC5yZW5kZXJSb290Py5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA/PyBudWxsKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgJiYgY2FjaGUgJiYgIWVsLmhhc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPckNvbnRleHQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgID8gbmFtZU9yQ29udGV4dC5uYW1lXG4gICAgICAgICAgICAgICAgICAgIDogbmFtZU9yQ29udGV4dDtcbiAgICAgICAgICAgICAgICBpc3N1ZVdhcm5pbmcoJycsIGBAcXVlcnknZCBmaWVsZCAke0pTT04uc3RyaW5naWZ5KFN0cmluZyhuYW1lKSl9IHdpdGggdGhlICdjYWNoZScgYCArXG4gICAgICAgICAgICAgICAgICAgIGBmbGFnIHNldCBmb3Igc2VsZWN0b3IgJyR7c2VsZWN0b3J9JyBoYXMgYmVlbiBhY2Nlc3NlZCBiZWZvcmUgYCArXG4gICAgICAgICAgICAgICAgICAgIGB0aGUgZmlyc3QgdXBkYXRlIGFuZCByZXR1cm5lZCBudWxsLiBUaGlzIGlzIGV4cGVjdGVkIGlmIHRoZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHJlbmRlclJvb3QgdHJlZSBoYXMgbm90IGJlZW4gcHJvdmlkZWQgYmVmb3JlaGFuZCAoZS5nLiB2aWEgYCArXG4gICAgICAgICAgICAgICAgICAgIGBEZWNsYXJhdGl2ZSBTaGFkb3cgRE9NKS4gVGhlcmVmb3JlIHRoZSB2YWx1ZSBoYXNuJ3QgYmVlbiBjYWNoZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSB3YW50IHRvIGFsbG93IHVzZXJzIHRvIGFzc2VydCB0aGF0IHRoZSBxdWVyeSB3aWxsIG5ldmVyXG4gICAgICAgICAgICAvLyByZXR1cm4gbnVsbCwgd2UgbmVlZCBhIG5ldyBvcHRpb24gYW5kIHRvIHRocm93IGhlcmUgaWYgdGhlIHJlc3VsdFxuICAgICAgICAgICAgLy8gaXMgbnVsbC5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgLy8gQWNjZXNzb3JzIHRvIHdyYXAgZnJvbSBlaXRoZXI6XG4gICAgICAgICAgICAvLyAgIDEuIFRoZSBkZWNvcmF0b3IgdGFyZ2V0LCBpbiB0aGUgY2FzZSBvZiBzdGFuZGFyZCBkZWNvcmF0b3JzXG4gICAgICAgICAgICAvLyAgIDIuIFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLCBpbiB0aGUgY2FzZSBvZiBleHBlcmltZW50YWwgZGVjb3JhdG9yc1xuICAgICAgICAgICAgLy8gICAgICBvbiBhdXRvLWFjY2Vzc29ycy5cbiAgICAgICAgICAgIC8vICAgMy4gRnVuY3Rpb25zIHRoYXQgYWNjZXNzIG91ciBvd24gY2FjaGUta2V5IHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSxcbiAgICAgICAgICAgIC8vICAgICAgaW4gdGhlIGNhc2Ugb2YgZXhwZXJpbWVudGFsIGRlY29yYXRvcnMgb24gZmllbGRzLlxuICAgICAgICAgICAgY29uc3QgeyBnZXQsIHNldCB9ID0gdHlwZW9mIG5hbWVPckNvbnRleHQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyBwcm90b09yVGFyZ2V0XG4gICAgICAgICAgICAgICAgOiAoZGVzY3JpcHRvciA/P1xuICAgICAgICAgICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gU3ltYm9sKGAke1N0cmluZyhuYW1lT3JDb250ZXh0KX0gKEBxdWVyeSgpIGNhY2hlKWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjKHByb3RvT3JUYXJnZXQsIG5hbWVPckNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBnZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkb1F1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCB8fCB0aGlzLmhhc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBvYmplY3Qgd29ya3MgYXMgdGhlIHJldHVybiB0eXBlIGZvciBib3RoIHN0YW5kYXJkIGFuZFxuICAgICAgICAgICAgLy8gZXhwZXJpbWVudGFsIGRlY29yYXRvcnMuXG4gICAgICAgICAgICByZXR1cm4gZGVzYyhwcm90b09yVGFyZ2V0LCBuYW1lT3JDb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9RdWVyeSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgcXVlcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbImRlc2MiLCJpc3N1ZVdhcm5pbmciLCJnbG9iYWxUaGlzIiwibGl0SXNzdWVkV2FybmluZ3MiLCJTZXQiLCJjb2RlIiwid2FybmluZyIsImhhcyIsImNvbnNvbGUiLCJ3YXJuIiwiYWRkIiwicXVlcnkiLCJzZWxlY3RvciIsImNhY2hlIiwicHJvdG9PclRhcmdldCIsIm5hbWVPckNvbnRleHQiLCJkZXNjcmlwdG9yIiwiZG9RdWVyeSIsImVsIiwicmVzdWx0IiwicmVuZGVyUm9vdCIsInF1ZXJ5U2VsZWN0b3IiLCJoYXNVcGRhdGVkIiwibmFtZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJnZXQiLCJzZXQiLCJrZXkiLCJTeW1ib2wiLCJ2IiwiY2FsbCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/state.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/state.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   state: () => (/* binding */ state)\n/* harmony export */ });\n/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/property.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */ /**\n * Declares a private or protected reactive property that still triggers\n * updates to the element when it changes. It does not reflect from the\n * corresponding attribute.\n *\n * Properties declared this way must not be used from HTML or HTML templating\n * systems, they're solely for properties internal to the element. These\n * properties may be renamed by optimization tools like closure compiler.\n * @category Decorator\n */ function state(options) {\n    return (0,_property_js__WEBPACK_IMPORTED_MODULE_0__.property)({\n        ...options,\n        // Add both `state` and `attribute` because we found a third party\n        // controller that is keying off of PropertyOptions.state to determine\n        // whether a field is a private internal property or not.\n        state: true,\n        attribute: false\n    });\n}\n //# sourceMappingURL=state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUV6Qzs7OztDQUlDLEdBQ0Q7Ozs7O0NBS0MsR0FDRDs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQyxNQUFNQyxPQUFPO0lBQ2xCLE9BQU9GLHNEQUFRQSxDQUFDO1FBQ1osR0FBR0UsT0FBTztRQUNWLGtFQUFrRTtRQUNsRSxzRUFBc0U7UUFDdEUseURBQXlEO1FBQ3pERCxPQUFPO1FBQ1BFLFdBQVc7SUFDZjtBQUNKO0FBRWlCLENBQ2pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvbm9kZS9kZXZlbG9wbWVudC9kZWNvcmF0b3JzL3N0YXRlLmpzP2ZiOTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvcGVydHkgfSBmcm9tICcuL3Byb3BlcnR5LmpzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG4vKlxuICogSU1QT1JUQU5UOiBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRzaWNrbGUgYW5kIHRoZSBDbG9zdXJlIEpTIGNvbXBpbGVyLCBhbGxcbiAqIHByb3BlcnR5IGRlY29yYXRvcnMgKGJ1dCBub3QgY2xhc3MgZGVjb3JhdG9ycykgaW4gdGhpcyBmaWxlIHRoYXQgaGF2ZVxuICogYW4gQEV4cG9ydERlY29yYXRlZEl0ZW1zIGFubm90YXRpb24gbXVzdCBiZSBkZWZpbmVkIGFzIGEgcmVndWxhciBmdW5jdGlvbixcbiAqIG5vdCBhbiBhcnJvdyBmdW5jdGlvbi5cbiAqL1xuLyoqXG4gKiBEZWNsYXJlcyBhIHByaXZhdGUgb3IgcHJvdGVjdGVkIHJlYWN0aXZlIHByb3BlcnR5IHRoYXQgc3RpbGwgdHJpZ2dlcnNcbiAqIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQgd2hlbiBpdCBjaGFuZ2VzLiBJdCBkb2VzIG5vdCByZWZsZWN0IGZyb20gdGhlXG4gKiBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZS5cbiAqXG4gKiBQcm9wZXJ0aWVzIGRlY2xhcmVkIHRoaXMgd2F5IG11c3Qgbm90IGJlIHVzZWQgZnJvbSBIVE1MIG9yIEhUTUwgdGVtcGxhdGluZ1xuICogc3lzdGVtcywgdGhleSdyZSBzb2xlbHkgZm9yIHByb3BlcnRpZXMgaW50ZXJuYWwgdG8gdGhlIGVsZW1lbnQuIFRoZXNlXG4gKiBwcm9wZXJ0aWVzIG1heSBiZSByZW5hbWVkIGJ5IG9wdGltaXphdGlvbiB0b29scyBsaWtlIGNsb3N1cmUgY29tcGlsZXIuXG4gKiBAY2F0ZWdvcnkgRGVjb3JhdG9yXG4gKi9cbmZ1bmN0aW9uIHN0YXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJvcGVydHkoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBBZGQgYm90aCBgc3RhdGVgIGFuZCBgYXR0cmlidXRlYCBiZWNhdXNlIHdlIGZvdW5kIGEgdGhpcmQgcGFydHlcbiAgICAgICAgLy8gY29udHJvbGxlciB0aGF0IGlzIGtleWluZyBvZmYgb2YgUHJvcGVydHlPcHRpb25zLnN0YXRlIHRvIGRldGVybWluZVxuICAgICAgICAvLyB3aGV0aGVyIGEgZmllbGQgaXMgYSBwcml2YXRlIGludGVybmFsIHByb3BlcnR5IG9yIG5vdC5cbiAgICAgICAgc3RhdGU6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZTogZmFsc2UsXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHN0YXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJwcm9wZXJ0eSIsInN0YXRlIiwib3B0aW9ucyIsImF0dHJpYnV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/reactive-element.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/reactive-element.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSResult: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.CSSResult),\n/* harmony export */   ReactiveElement: () => (/* binding */ ReactiveElement),\n/* harmony export */   adoptStyles: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.adoptStyles),\n/* harmony export */   css: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.css),\n/* harmony export */   defaultConverter: () => (/* binding */ defaultConverter),\n/* harmony export */   getCompatibleStyle: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.getCompatibleStyle),\n/* harmony export */   notEqual: () => (/* binding */ notEqual),\n/* harmony export */   supportsAdoptingStyleSheets: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.supportsAdoptingStyleSheets),\n/* harmony export */   unsafeCSS: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var _lit_labs_ssr_dom_shim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit-labs/ssr-dom-shim */ \"(ssr)/./node_modules/@lit-labs/ssr-dom-shim/index.js\");\n/* harmony import */ var _css_tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css-tag.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/css-tag.js\");\n\n\n\n// TODO (justinfagnani): Add `hasOwn` here when we ship ES2022\nconst { is, defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, getPrototypeOf } = Object;\n// Lets a minifier replace globalThis references with a minified name\nconst global = globalThis;\n{\n    global.customElements ??= _lit_labs_ssr_dom_shim__WEBPACK_IMPORTED_MODULE_0__.customElements;\n}let issueWarning;\nconst trustedTypes = global.trustedTypes;\n// Temporary workaround for https://crbug.com/993268\n// Currently, any attribute starting with \"on\" is considered to be a\n// TrustedScript source. Such boolean attributes must be set to the equivalent\n// trusted emptyScript value.\nconst emptyStringForBooleanAttribute = trustedTypes ? trustedTypes.emptyScript : \"\";\nconst polyfillSupport = global.reactiveElementPolyfillSupportDevMode;\n{\n    // Ensure warnings are issued only 1x, even if multiple versions of Lit\n    // are loaded.\n    global.litIssuedWarnings ??= new Set();\n    /**\n     * Issue a warning if we haven't already, based either on `code` or `warning`.\n     * Warnings are disabled automatically only by `warning`; disabling via `code`\n     * can be done by users.\n     */ issueWarning = (code, warning)=>{\n        warning += ` See https://lit.dev/msg/${code} for more information.`;\n        if (!global.litIssuedWarnings.has(warning) && !global.litIssuedWarnings.has(code)) {\n            console.warn(warning);\n            global.litIssuedWarnings.add(warning);\n        }\n    };\n    queueMicrotask(()=>{\n        issueWarning(\"dev-mode\", `Lit is in dev mode. Not recommended for production!`);\n        // Issue polyfill support warning.\n        if (global.ShadyDOM?.inUse && polyfillSupport === undefined) {\n            issueWarning(\"polyfill-support-missing\", `Shadow DOM is being polyfilled via \\`ShadyDOM\\` but ` + `the \\`polyfill-support\\` module has not been loaded.`);\n        }\n    });\n}/**\n * Useful for visualizing and logging insights into what the Lit template system is doing.\n *\n * Compiled out of prod mode builds.\n */ const debugLogEvent = (event)=>{\n    const shouldEmit = global.emitLitDebugLogEvents;\n    if (!shouldEmit) {\n        return;\n    }\n    global.dispatchEvent(new CustomEvent(\"lit-debug\", {\n        detail: event\n    }));\n};\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */ /*@__INLINE__*/ const JSCompiler_renameProperty = (prop, _obj)=>prop;\nconst defaultConverter = {\n    toAttribute (value, type) {\n        switch(type){\n            case Boolean:\n                value = value ? emptyStringForBooleanAttribute : null;\n                break;\n            case Object:\n            case Array:\n                // if the value is `null` or `undefined` pass this through\n                // to allow removing/no change behavior.\n                value = value == null ? value : JSON.stringify(value);\n                break;\n        }\n        return value;\n    },\n    fromAttribute (value, type) {\n        let fromValue = value;\n        switch(type){\n            case Boolean:\n                fromValue = value !== null;\n                break;\n            case Number:\n                fromValue = value === null ? null : Number(value);\n                break;\n            case Object:\n            case Array:\n                // Do *not* generate exception when invalid JSON is set as elements\n                // don't normally complain on being mis-configured.\n                // TODO(sorvell): Do generate exception in *dev mode*.\n                try {\n                    // Assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n                    fromValue = JSON.parse(value);\n                } catch (e) {\n                    fromValue = null;\n                }\n                break;\n        }\n        return fromValue;\n    }\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */ const notEqual = (value, old)=>!is(value, old);\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    useDefault: false,\n    hasChanged: notEqual\n};\n// Ensure metadata is enabled. TypeScript does not polyfill\n// Symbol.metadata, so we must ensure that it exists.\nSymbol.metadata ??= Symbol(\"metadata\");\n// Map from a class's metadata object to property options\n// Note that we must use nullish-coalescing assignment so that we only use one\n// map even if we load multiple version of this module.\nglobal.litPropertyMetadata ??= new WeakMap();\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclasses to render updates as desired.\n * @noInheritDoc\n */ class ReactiveElement extends (globalThis.HTMLElement ?? _lit_labs_ssr_dom_shim__WEBPACK_IMPORTED_MODULE_0__.HTMLElement) {\n    /**\n     * Adds an initializer function to the class that is called during instance\n     * construction.\n     *\n     * This is useful for code that runs against a `ReactiveElement`\n     * subclass, such as a decorator, that needs to do work for each\n     * instance, such as setting up a `ReactiveController`.\n     *\n     * ```ts\n     * const myDecorator = (target: typeof ReactiveElement, key: string) => {\n     *   target.addInitializer((instance: ReactiveElement) => {\n     *     // This is run during construction of the element\n     *     new MyController(instance);\n     *   });\n     * }\n     * ```\n     *\n     * Decorating a field will then cause each instance to run an initializer\n     * that adds a controller:\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   @myDecorator foo;\n     * }\n     * ```\n     *\n     * Initializers are stored per-constructor. Adding an initializer to a\n     * subclass does not add it to a superclass. Since initializers are run in\n     * constructors, initializers will run in order of the class hierarchy,\n     * starting with superclasses and progressing to the instance's class.\n     *\n     * @nocollapse\n     */ static addInitializer(initializer) {\n        this.__prepare();\n        (this._initializers ??= []).push(initializer);\n    }\n    /**\n     * Returns a list of attributes corresponding to the registered properties.\n     * @nocollapse\n     * @category attributes\n     */ static get observedAttributes() {\n        // Ensure we've created all properties\n        this.finalize();\n        // this.__attributeToPropertyMap is only undefined after finalize() in\n        // ReactiveElement itself. ReactiveElement.observedAttributes is only\n        // accessed with ReactiveElement as the receiver when a subclass or mixin\n        // calls super.observedAttributes\n        return this.__attributeToPropertyMap && [\n            ...this.__attributeToPropertyMap.keys()\n        ];\n    }\n    /**\n     * Creates a property accessor on the element prototype if one does not exist\n     * and stores a {@linkcode PropertyDeclaration} for the property with the\n     * given options. The property setter calls the property's `hasChanged`\n     * property option or uses a strict identity check to determine whether or not\n     * to request an update.\n     *\n     * This method may be overridden to customize properties; however,\n     * when doing so, it's important to call `super.createProperty` to ensure\n     * the property is setup correctly. This method calls\n     * `getPropertyDescriptor` internally to get a descriptor to install.\n     * To customize what properties do when they are get or set, override\n     * `getPropertyDescriptor`. To customize the options for a property,\n     * implement `createProperty` like this:\n     *\n     * ```ts\n     * static createProperty(name, options) {\n     *   options = Object.assign(options, {myOption: true});\n     *   super.createProperty(name, options);\n     * }\n     * ```\n     *\n     * @nocollapse\n     * @category properties\n     */ static createProperty(name, options = defaultPropertyDeclaration) {\n        // If this is a state property, force the attribute to false.\n        if (options.state) {\n            options.attribute = false;\n        }\n        this.__prepare();\n        // Whether this property is wrapping accessors.\n        // Helps control the initial value change and reflection logic.\n        if (this.prototype.hasOwnProperty(name)) {\n            options = Object.create(options);\n            options.wrapped = true;\n        }\n        this.elementProperties.set(name, options);\n        if (!options.noAccessor) {\n            const key = // when doing HMR.\n            Symbol.for(`${String(name)} (@property() cache)`);\n            const descriptor = this.getPropertyDescriptor(name, key, options);\n            if (descriptor !== undefined) {\n                defineProperty(this.prototype, name, descriptor);\n            }\n        }\n    }\n    /**\n     * Returns a property descriptor to be defined on the given named property.\n     * If no descriptor is returned, the property will not become an accessor.\n     * For example,\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   static getPropertyDescriptor(name, key, options) {\n     *     const defaultDescriptor =\n     *         super.getPropertyDescriptor(name, key, options);\n     *     const setter = defaultDescriptor.set;\n     *     return {\n     *       get: defaultDescriptor.get,\n     *       set(value) {\n     *         setter.call(this, value);\n     *         // custom action.\n     *       },\n     *       configurable: true,\n     *       enumerable: true\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * @nocollapse\n     * @category properties\n     */ static getPropertyDescriptor(name, key, options) {\n        const { get, set } = getOwnPropertyDescriptor(this.prototype, name) ?? {\n            get () {\n                return this[key];\n            },\n            set (v) {\n                this[key] = v;\n            }\n        };\n        if (get == null) {\n            if (\"value\" in (getOwnPropertyDescriptor(this.prototype, name) ?? {})) {\n                throw new Error(`Field ${JSON.stringify(String(name))} on ` + `${this.name} was declared as a reactive property ` + `but it's actually declared as a value on the prototype. ` + `Usually this is due to using @property or @state on a method.`);\n            }\n            issueWarning(\"reactive-property-without-getter\", `Field ${JSON.stringify(String(name))} on ` + `${this.name} was declared as a reactive property ` + `but it does not have a getter. This will be an error in a ` + `future version of Lit.`);\n        }\n        return {\n            get,\n            set (value) {\n                const oldValue = get?.call(this);\n                set?.call(this, value);\n                this.requestUpdate(name, oldValue, options);\n            },\n            configurable: true,\n            enumerable: true\n        };\n    }\n    /**\n     * Returns the property options associated with the given property.\n     * These options are defined with a `PropertyDeclaration` via the `properties`\n     * object or the `@property` decorator and are registered in\n     * `createProperty(...)`.\n     *\n     * Note, this method should be considered \"final\" and not overridden. To\n     * customize the options for a given property, override\n     * {@linkcode createProperty}.\n     *\n     * @nocollapse\n     * @final\n     * @category properties\n     */ static getPropertyOptions(name) {\n        return this.elementProperties.get(name) ?? defaultPropertyDeclaration;\n    }\n    /**\n     * Initializes static own properties of the class used in bookkeeping\n     * for element properties, initializers, etc.\n     *\n     * Can be called multiple times by code that needs to ensure these\n     * properties exist before using them.\n     *\n     * This method ensures the superclass is finalized so that inherited\n     * property metadata can be copied down.\n     * @nocollapse\n     */ static __prepare() {\n        if (this.hasOwnProperty(JSCompiler_renameProperty(\"elementProperties\"))) {\n            // Already prepared\n            return;\n        }\n        // Finalize any superclasses\n        const superCtor = getPrototypeOf(this);\n        superCtor.finalize();\n        // Create own set of initializers for this class if any exist on the\n        // superclass and copy them down. Note, for a small perf boost, avoid\n        // creating initializers unless needed.\n        if (superCtor._initializers !== undefined) {\n            this._initializers = [\n                ...superCtor._initializers\n            ];\n        }\n        // Initialize elementProperties from the superclass\n        this.elementProperties = new Map(superCtor.elementProperties);\n    }\n    /**\n     * Finishes setting up the class so that it's ready to be registered\n     * as a custom element and instantiated.\n     *\n     * This method is called by the ReactiveElement.observedAttributes getter.\n     * If you override the observedAttributes getter, you must either call\n     * super.observedAttributes to trigger finalization, or call finalize()\n     * yourself.\n     *\n     * @nocollapse\n     */ static finalize() {\n        if (this.hasOwnProperty(JSCompiler_renameProperty(\"finalized\"))) {\n            return;\n        }\n        this.finalized = true;\n        this.__prepare();\n        // Create properties from the static properties block:\n        if (this.hasOwnProperty(JSCompiler_renameProperty(\"properties\"))) {\n            const props = this.properties;\n            const propKeys = [\n                ...getOwnPropertyNames(props),\n                ...getOwnPropertySymbols(props)\n            ];\n            for (const p of propKeys){\n                this.createProperty(p, props[p]);\n            }\n        }\n        // Create properties from standard decorator metadata:\n        const metadata = this[Symbol.metadata];\n        if (metadata !== null) {\n            const properties = litPropertyMetadata.get(metadata);\n            if (properties !== undefined) {\n                for (const [p, options] of properties){\n                    this.elementProperties.set(p, options);\n                }\n            }\n        }\n        // Create the attribute-to-property map\n        this.__attributeToPropertyMap = new Map();\n        for (const [p, options] of this.elementProperties){\n            const attr = this.__attributeNameForProperty(p, options);\n            if (attr !== undefined) {\n                this.__attributeToPropertyMap.set(attr, p);\n            }\n        }\n        this.elementStyles = this.finalizeStyles(this.styles);\n        {\n            if (this.hasOwnProperty(\"createProperty\")) {\n                issueWarning(\"no-override-create-property\", \"Overriding ReactiveElement.createProperty() is deprecated. \" + \"The override will not be called with standard decorators\");\n            }\n            if (this.hasOwnProperty(\"getPropertyDescriptor\")) {\n                issueWarning(\"no-override-get-property-descriptor\", \"Overriding ReactiveElement.getPropertyDescriptor() is deprecated. \" + \"The override will not be called with standard decorators\");\n            }\n        }\n    }\n    /**\n     * Takes the styles the user supplied via the `static styles` property and\n     * returns the array of styles to apply to the element.\n     * Override this method to integrate into a style management system.\n     *\n     * Styles are deduplicated preserving the _last_ instance in the list. This\n     * is a performance optimization to avoid duplicated styles that can occur\n     * especially when composing via subclassing. The last item is kept to try\n     * to preserve the cascade order with the assumption that it's most important\n     * that last added styles override previous styles.\n     *\n     * @nocollapse\n     * @category styles\n     */ static finalizeStyles(styles) {\n        const elementStyles = [];\n        if (Array.isArray(styles)) {\n            // Dedupe the flattened array in reverse order to preserve the last items.\n            // Casting to Array<unknown> works around TS error that\n            // appears to come from trying to flatten a type CSSResultArray.\n            const set = new Set(styles.flat(Infinity).reverse());\n            // Then preserve original order by adding the set items in reverse order.\n            for (const s of set){\n                elementStyles.unshift((0,_css_tag_js__WEBPACK_IMPORTED_MODULE_1__.getCompatibleStyle)(s));\n            }\n        } else if (styles !== undefined) {\n            elementStyles.push((0,_css_tag_js__WEBPACK_IMPORTED_MODULE_1__.getCompatibleStyle)(styles));\n        }\n        return elementStyles;\n    }\n    /**\n     * Returns the property name for the given attribute `name`.\n     * @nocollapse\n     */ static __attributeNameForProperty(name, options) {\n        const attribute = options.attribute;\n        return attribute === false ? undefined : typeof attribute === \"string\" ? attribute : typeof name === \"string\" ? name.toLowerCase() : undefined;\n    }\n    constructor(){\n        super();\n        this.__instanceProperties = undefined;\n        /**\n         * True if there is a pending update as a result of calling `requestUpdate()`.\n         * Should only be read.\n         * @category updates\n         */ this.isUpdatePending = false;\n        /**\n         * Is set to `true` after the first update. The element code cannot assume\n         * that `renderRoot` exists before the element `hasUpdated`.\n         * @category updates\n         */ this.hasUpdated = false;\n        /**\n         * Name of currently reflecting property\n         */ this.__reflectingProperty = null;\n        this.__initialize();\n    }\n    /**\n     * Internal only override point for customizing work done when elements\n     * are constructed.\n     */ __initialize() {\n        this.__updatePromise = new Promise((res)=>this.enableUpdating = res);\n        this._$changedProperties = new Map();\n        // This enqueues a microtask that must run before the first update, so it\n        // must be called before requestUpdate()\n        this.__saveInstanceProperties();\n        // ensures first update will be caught by an early access of\n        // `updateComplete`\n        this.requestUpdate();\n        this.constructor._initializers?.forEach((i)=>i(this));\n    }\n    /**\n     * Registers a `ReactiveController` to participate in the element's reactive\n     * update cycle. The element automatically calls into any registered\n     * controllers during its lifecycle callbacks.\n     *\n     * If the element is connected when `addController()` is called, the\n     * controller's `hostConnected()` callback will be immediately called.\n     * @category controllers\n     */ addController(controller) {\n        (this.__controllers ??= new Set()).add(controller);\n        // If a controller is added after the element has been connected,\n        // call hostConnected. Note, re-using existence of `renderRoot` here\n        // (which is set in connectedCallback) to avoid the need to track a\n        // first connected state.\n        if (this.renderRoot !== undefined && this.isConnected) {\n            controller.hostConnected?.();\n        }\n    }\n    /**\n     * Removes a `ReactiveController` from the element.\n     * @category controllers\n     */ removeController(controller) {\n        this.__controllers?.delete(controller);\n    }\n    /**\n     * Fixes any properties set on the instance before upgrade time.\n     * Otherwise these would shadow the accessor and break these properties.\n     * The properties are stored in a Map which is played back after the\n     * constructor runs.\n     */ __saveInstanceProperties() {\n        const instanceProperties = new Map();\n        const elementProperties = this.constructor.elementProperties;\n        for (const p of elementProperties.keys()){\n            if (this.hasOwnProperty(p)) {\n                instanceProperties.set(p, this[p]);\n                delete this[p];\n            }\n        }\n        if (instanceProperties.size > 0) {\n            this.__instanceProperties = instanceProperties;\n        }\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element's DOM is rendered. For example, to render into the element's\n     * childNodes, return `this`.\n     *\n     * @return Returns a node into which to render.\n     * @category rendering\n     */ createRenderRoot() {\n        const renderRoot = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);\n        (0,_css_tag_js__WEBPACK_IMPORTED_MODULE_1__.adoptStyles)(renderRoot, this.constructor.elementStyles);\n        return renderRoot;\n    }\n    /**\n     * On first connection, creates the element's renderRoot, sets up\n     * element styling, and enables updating.\n     * @category lifecycle\n     */ connectedCallback() {\n        // Create renderRoot before controllers `hostConnected`\n        this.renderRoot ??= this.createRenderRoot();\n        this.enableUpdating(true);\n        this.__controllers?.forEach((c)=>c.hostConnected?.());\n    }\n    /**\n     * Note, this method should be considered final and not overridden. It is\n     * overridden on the element instance with a function that triggers the first\n     * update.\n     * @category updates\n     */ enableUpdating(_requestedUpdate) {}\n    /**\n     * Allows for `super.disconnectedCallback()` in extensions while\n     * reserving the possibility of making non-breaking feature additions\n     * when disconnecting at some point in the future.\n     * @category lifecycle\n     */ disconnectedCallback() {\n        this.__controllers?.forEach((c)=>c.hostDisconnected?.());\n    }\n    /**\n     * Synchronizes property values when attributes change.\n     *\n     * Specifically, when an attribute is set, the corresponding property is set.\n     * You should rarely need to implement this callback. If this method is\n     * overridden, `super.attributeChangedCallback(name, _old, value)` must be\n     * called.\n     *\n     * See [responding to attribute changes](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#responding_to_attribute_changes)\n     * on MDN for more information about the `attributeChangedCallback`.\n     * @category attributes\n     */ attributeChangedCallback(name, _old, value) {\n        this._$attributeToProperty(name, value);\n    }\n    __propertyToAttribute(name, value) {\n        const elemProperties = this.constructor.elementProperties;\n        const options = elemProperties.get(name);\n        const attr = this.constructor.__attributeNameForProperty(name, options);\n        if (attr !== undefined && options.reflect === true) {\n            const converter = options.converter?.toAttribute !== undefined ? options.converter : defaultConverter;\n            const attrValue = converter.toAttribute(value, options.type);\n            if (this.constructor.enabledWarnings.includes(\"migration\") && attrValue === undefined) {\n                issueWarning(\"undefined-attribute-value\", `The attribute value for the ${name} property is ` + `undefined on element ${this.localName}. The attribute will be ` + `removed, but in the previous version of \\`ReactiveElement\\`, ` + `the attribute would not have changed.`);\n            }\n            // Track if the property is being reflected to avoid\n            // setting the property again via `attributeChangedCallback`. Note:\n            // 1. this takes advantage of the fact that the callback is synchronous.\n            // 2. will behave incorrectly if multiple attributes are in the reaction\n            // stack at time of calling. However, since we process attributes\n            // in `update` this should not be possible (or an extreme corner case\n            // that we'd like to discover).\n            // mark state reflecting\n            this.__reflectingProperty = name;\n            if (attrValue == null) {\n                this.removeAttribute(attr);\n            } else {\n                this.setAttribute(attr, attrValue);\n            }\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /** @internal */ _$attributeToProperty(name, value) {\n        const ctor = this.constructor;\n        // Note, hint this as an `AttributeMap` so closure clearly understands\n        // the type; it has issues with tracking types through statics\n        const propName = ctor.__attributeToPropertyMap.get(name);\n        // Use tracking info to avoid reflecting a property value to an attribute\n        // if it was just set because the attribute changed.\n        if (propName !== undefined && this.__reflectingProperty !== propName) {\n            const options = ctor.getPropertyOptions(propName);\n            const converter = typeof options.converter === \"function\" ? {\n                fromAttribute: options.converter\n            } : options.converter?.fromAttribute !== undefined ? options.converter : defaultConverter;\n            // mark state reflecting\n            this.__reflectingProperty = propName;\n            const convertedValue = converter.fromAttribute(value, options.type);\n            this[propName] = convertedValue ?? this.__defaultValues?.get(propName) ?? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            convertedValue;\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /**\n     * Requests an update which is processed asynchronously. This should be called\n     * when an element should update based on some state not triggered by setting\n     * a reactive property. In this case, pass no arguments. It should also be\n     * called when manually implementing a property setter. In this case, pass the\n     * property `name` and `oldValue` to ensure that any configured property\n     * options are honored.\n     *\n     * @param name name of requesting property\n     * @param oldValue old value of requesting property\n     * @param options property options to use instead of the previously\n     *     configured options\n     * @param useNewValue if true, the newValue argument is used instead of\n     *     reading the property value. This is important to use if the reactive\n     *     property is a standard private accessor, as opposed to a plain\n     *     property, since private members can't be dynamically read by name.\n     * @param newValue the new value of the property. This is only used if\n     *     `useNewValue` is true.\n     * @category updates\n     */ requestUpdate(name, oldValue, options, useNewValue = false, newValue) {\n        // If we have a property key, perform property update steps.\n        if (name !== undefined) {\n            if (name instanceof Event) {\n                issueWarning(``, `The requestUpdate() method was called with an Event as the property name. This is probably a mistake caused by binding this.requestUpdate as an event listener. Instead bind a function that will call it with no arguments: () => this.requestUpdate()`);\n            }\n            const ctor = this.constructor;\n            if (useNewValue === false) {\n                newValue = this[name];\n            }\n            options ??= ctor.getPropertyOptions(name);\n            const changed = (options.hasChanged ?? notEqual)(newValue, oldValue) || // When there is no change, check a corner case that can occur when\n            // 1. there's a initial value which was not reflected\n            // 2. the property is subsequently set to this value.\n            // For example, `prop: {useDefault: true, reflect: true}`\n            // and el.prop = 'foo'. This should be considered a change if the\n            // attribute is not set because we will now reflect the property to the attribute.\n            options.useDefault && options.reflect && newValue === this.__defaultValues?.get(name) && !this.hasAttribute(ctor.__attributeNameForProperty(name, options));\n            if (changed) {\n                this._$changeProperty(name, oldValue, options);\n            } else {\n                // Abort the request if the property should not be considered changed.\n                return;\n            }\n        }\n        if (this.isUpdatePending === false) {\n            this.__updatePromise = this.__enqueueUpdate();\n        }\n    }\n    /**\n     * @internal\n     */ _$changeProperty(name, oldValue, { useDefault, reflect, wrapped }, initializeValue) {\n        // Record default value when useDefault is used. This allows us to\n        // restore this value when the attribute is removed.\n        if (useDefault && !(this.__defaultValues ??= new Map()).has(name)) {\n            this.__defaultValues.set(name, initializeValue ?? oldValue ?? this[name]);\n            // if this is not wrapping an accessor, it must be an initial setting\n            // and in this case we do not want to record the change or reflect.\n            if (wrapped !== true || initializeValue !== undefined) {\n                return;\n            }\n        }\n        // TODO (justinfagnani): Create a benchmark of Map.has() + Map.set(\n        // vs just Map.set()\n        if (!this._$changedProperties.has(name)) {\n            // On the initial change, the old value should be `undefined`, except\n            // with `useDefault`\n            if (!this.hasUpdated && !useDefault) {\n                oldValue = undefined;\n            }\n            this._$changedProperties.set(name, oldValue);\n        }\n        // Add to reflecting properties set.\n        // Note, it's important that every change has a chance to add the\n        // property to `__reflectingProperties`. This ensures setting\n        // attribute + property reflects correctly.\n        if (reflect === true && this.__reflectingProperty !== name) {\n            (this.__reflectingProperties ??= new Set()).add(name);\n        }\n    }\n    /**\n     * Sets up the element to asynchronously update.\n     */ async __enqueueUpdate() {\n        this.isUpdatePending = true;\n        try {\n            // Ensure any previous update has resolved before updating.\n            // This `await` also ensures that property changes are batched.\n            await this.__updatePromise;\n        } catch (e) {\n            // Refire any previous errors async so they do not disrupt the update\n            // cycle. Errors are refired so developers have a chance to observe\n            // them, and this can be done by implementing\n            // `window.onunhandledrejection`.\n            Promise.reject(e);\n        }\n        const result = this.scheduleUpdate();\n        // If `scheduleUpdate` returns a Promise, we await it. This is done to\n        // enable coordinating updates with a scheduler. Note, the result is\n        // checked to avoid delaying an additional microtask unless we need to.\n        if (result != null) {\n            await result;\n        }\n        return !this.isUpdatePending;\n    }\n    /**\n     * Schedules an element update. You can override this method to change the\n     * timing of updates by returning a Promise. The update will await the\n     * returned Promise, and you should resolve the Promise to allow the update\n     * to proceed. If this method is overridden, `super.scheduleUpdate()`\n     * must be called.\n     *\n     * For instance, to schedule updates to occur just before the next frame:\n     *\n     * ```ts\n     * override protected async scheduleUpdate(): Promise<unknown> {\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n     *   super.scheduleUpdate();\n     * }\n     * ```\n     * @category updates\n     */ scheduleUpdate() {\n        const result = this.performUpdate();\n        if (this.constructor.enabledWarnings.includes(\"async-perform-update\") && typeof result?.then === \"function\") {\n            issueWarning(\"async-perform-update\", `Element ${this.localName} returned a Promise from performUpdate(). ` + `This behavior is deprecated and will be removed in a future ` + `version of ReactiveElement.`);\n        }\n        return result;\n    }\n    /**\n     * Performs an element update. Note, if an exception is thrown during the\n     * update, `firstUpdated` and `updated` will not be called.\n     *\n     * Call `performUpdate()` to immediately process a pending update. This should\n     * generally not be needed, but it can be done in rare cases when you need to\n     * update synchronously.\n     *\n     * @category updates\n     */ performUpdate() {\n        // Abort any update if one is not pending when this is called.\n        // This can happen if `performUpdate` is called early to \"flush\"\n        // the update.\n        if (!this.isUpdatePending) {\n            return;\n        }\n        debugLogEvent?.({\n            kind: \"update\"\n        });\n        if (!this.hasUpdated) {\n            // Create renderRoot before first update. This occurs in `connectedCallback`\n            // but is done here to support out of tree calls to `enableUpdating`/`performUpdate`.\n            this.renderRoot ??= this.createRenderRoot();\n            {\n                // Produce warning if any reactive properties on the prototype are\n                // shadowed by class fields. Instance fields set before upgrade are\n                // deleted by this point, so any own property is caused by class field\n                // initialization in the constructor.\n                const ctor = this.constructor;\n                const shadowedProperties = [\n                    ...ctor.elementProperties.keys()\n                ].filter((p)=>this.hasOwnProperty(p) && p in getPrototypeOf(this));\n                if (shadowedProperties.length) {\n                    throw new Error(`The following properties on element ${this.localName} will not ` + `trigger updates as expected because they are set using class ` + `fields: ${shadowedProperties.join(\", \")}. ` + `Native class fields and some compiled output will overwrite ` + `accessors used for detecting changes. See ` + `https://lit.dev/msg/class-field-shadowing ` + `for more information.`);\n                }\n            }\n            // Mixin instance properties once, if they exist.\n            if (this.__instanceProperties) {\n                // TODO (justinfagnani): should we use the stored value? Could a new value\n                // have been set since we stored the own property value?\n                for (const [p, value] of this.__instanceProperties){\n                    this[p] = value;\n                }\n                this.__instanceProperties = undefined;\n            }\n            // Trigger initial value reflection and populate the initial\n            // `changedProperties` map, but only for the case of properties created\n            // via `createProperty` on accessors, which will not have already\n            // populated the `changedProperties` map since they are not set.\n            // We can't know if these accessors had initializers, so we just set\n            // them anyway - a difference from experimental decorators on fields and\n            // standard decorators on auto-accessors.\n            // For context see:\n            // https://github.com/lit/lit/pull/4183#issuecomment-1711959635\n            const elementProperties = this.constructor.elementProperties;\n            if (elementProperties.size > 0) {\n                for (const [p, options] of elementProperties){\n                    const { wrapped } = options;\n                    const value = this[p];\n                    if (wrapped === true && !this._$changedProperties.has(p) && value !== undefined) {\n                        this._$changeProperty(p, undefined, options, value);\n                    }\n                }\n            }\n        }\n        let shouldUpdate = false;\n        const changedProperties = this._$changedProperties;\n        try {\n            shouldUpdate = this.shouldUpdate(changedProperties);\n            if (shouldUpdate) {\n                this.willUpdate(changedProperties);\n                this.__controllers?.forEach((c)=>c.hostUpdate?.());\n                this.update(changedProperties);\n            } else {\n                this.__markUpdated();\n            }\n        } catch (e) {\n            // Prevent `firstUpdated` and `updated` from running when there's an\n            // update exception.\n            shouldUpdate = false;\n            // Ensure element can accept additional updates after an exception.\n            this.__markUpdated();\n            throw e;\n        }\n        // The update is no longer considered pending and further updates are now allowed.\n        if (shouldUpdate) {\n            this._$didUpdate(changedProperties);\n        }\n    }\n    /**\n     * Invoked before `update()` to compute values needed during the update.\n     *\n     * Implement `willUpdate` to compute property values that depend on other\n     * properties and are used in the rest of the update process.\n     *\n     * ```ts\n     * willUpdate(changedProperties) {\n     *   // only need to check changed properties for an expensive computation.\n     *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {\n     *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);\n     *   }\n     * }\n     *\n     * render() {\n     *   return html`SHA: ${this.sha}`;\n     * }\n     * ```\n     *\n     * @category updates\n     */ willUpdate(_changedProperties) {}\n    // Note, this is an override point for polyfill-support.\n    // @internal\n    _$didUpdate(changedProperties) {\n        this.__controllers?.forEach((c)=>c.hostUpdated?.());\n        if (!this.hasUpdated) {\n            this.hasUpdated = true;\n            this.firstUpdated(changedProperties);\n        }\n        this.updated(changedProperties);\n        if (this.isUpdatePending && this.constructor.enabledWarnings.includes(\"change-in-update\")) {\n            issueWarning(\"change-in-update\", `Element ${this.localName} scheduled an update ` + `(generally because a property was set) ` + `after an update completed, causing a new update to be scheduled. ` + `This is inefficient and should be avoided unless the next update ` + `can only be scheduled as a side effect of the previous update.`);\n        }\n    }\n    __markUpdated() {\n        this._$changedProperties = new Map();\n        this.isUpdatePending = false;\n    }\n    /**\n     * Returns a Promise that resolves when the element has completed updating.\n     * The Promise value is a boolean that is `true` if the element completed the\n     * update without triggering another update. The Promise result is `false` if\n     * a property was set inside `updated()`. If the Promise is rejected, an\n     * exception was thrown during the update.\n     *\n     * To await additional asynchronous work, override the `getUpdateComplete`\n     * method. For example, it is sometimes useful to await a rendered element\n     * before fulfilling this Promise. To do this, first await\n     * `super.getUpdateComplete()`, then any subsequent state.\n     *\n     * @return A promise of a boolean that resolves to true if the update completed\n     *     without triggering another update.\n     * @category updates\n     */ get updateComplete() {\n        return this.getUpdateComplete();\n    }\n    /**\n     * Override point for the `updateComplete` promise.\n     *\n     * It is not safe to override the `updateComplete` getter directly due to a\n     * limitation in TypeScript which means it is not possible to call a\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n     * This method should be overridden instead. For example:\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   override async getUpdateComplete() {\n     *     const result = await super.getUpdateComplete();\n     *     await this._myChild.updateComplete;\n     *     return result;\n     *   }\n     * }\n     * ```\n     *\n     * @return A promise of a boolean that resolves to true if the update completed\n     *     without triggering another update.\n     * @category updates\n     */ getUpdateComplete() {\n        return this.__updatePromise;\n    }\n    /**\n     * Controls whether or not `update()` should be called when the element requests\n     * an update. By default, this method always returns `true`, but this can be\n     * customized to control when to update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */ shouldUpdate(_changedProperties) {\n        return true;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes.\n     * It can be overridden to render and keep updated element DOM.\n     * Setting properties inside this method will *not* trigger\n     * another update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */ update(_changedProperties) {\n        // The forEach() expression will only run when __reflectingProperties is\n        // defined, and it returns undefined, setting __reflectingProperties to\n        // undefined\n        this.__reflectingProperties &&= this.__reflectingProperties.forEach((p)=>this.__propertyToAttribute(p, this[p]));\n        this.__markUpdated();\n    }\n    /**\n     * Invoked whenever the element is updated. Implement to perform\n     * post-updating tasks via DOM APIs, for example, focusing an element.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */ updated(_changedProperties) {}\n    /**\n     * Invoked when the element is first updated. Implement to perform one time\n     * work on the element after update.\n     *\n     * ```ts\n     * firstUpdated() {\n     *   this.renderRoot.getElementById('my-text-area').focus();\n     * }\n     * ```\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */ firstUpdated(_changedProperties) {}\n}\n/**\n * Memoized list of all element styles.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category styles\n */ ReactiveElement.elementStyles = [];\n/**\n * Options used when calling `attachShadow`. Set this property to customize\n * the options for the shadowRoot; for example, to create a closed\n * shadowRoot: `{mode: 'closed'}`.\n *\n * Note, these options are used in `createRenderRoot`. If this method\n * is customized, options should be respected if possible.\n * @nocollapse\n * @category rendering\n */ ReactiveElement.shadowRootOptions = {\n    mode: \"open\"\n};\n// Assigned here to work around a jscompiler bug with static fields\n// when compiling to ES5.\n// https://github.com/google/closure-compiler/issues/3177\nReactiveElement[JSCompiler_renameProperty(\"elementProperties\")] = new Map();\nReactiveElement[JSCompiler_renameProperty(\"finalized\")] = new Map();\n// Apply polyfills if available\npolyfillSupport?.({\n    ReactiveElement\n});\n// Dev mode warnings...\n{\n    // Default warning set.\n    ReactiveElement.enabledWarnings = [\n        \"change-in-update\",\n        \"async-perform-update\"\n    ];\n    const ensureOwnWarnings = function(ctor) {\n        if (!ctor.hasOwnProperty(JSCompiler_renameProperty(\"enabledWarnings\"))) {\n            ctor.enabledWarnings = ctor.enabledWarnings.slice();\n        }\n    };\n    ReactiveElement.enableWarning = function(warning) {\n        ensureOwnWarnings(this);\n        if (!this.enabledWarnings.includes(warning)) {\n            this.enabledWarnings.push(warning);\n        }\n    };\n    ReactiveElement.disableWarning = function(warning) {\n        ensureOwnWarnings(this);\n        const i = this.enabledWarnings.indexOf(warning);\n        if (i >= 0) {\n            this.enabledWarnings.splice(i, 1);\n        }\n    };\n}// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for ReactiveElement usage.\n(global.reactiveElementVersions ??= []).push(\"2.1.2\");\nif (global.reactiveElementVersions.length > 1) {\n    queueMicrotask(()=>{\n        issueWarning(\"multiple-versions\", `Multiple versions of Lit loaded. Loading multiple versions ` + `is not recommended.`);\n    });\n}\n //# sourceMappingURL=reactive-element.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvcmVhY3RpdmUtZWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUNOO0FBQ3VCO0FBRXRGLDhEQUE4RDtBQUM5RCxNQUFNLEVBQUVRLEVBQUUsRUFBRUMsY0FBYyxFQUFFQyx3QkFBd0IsRUFBRUMsbUJBQW1CLEVBQUVDLHFCQUFxQixFQUFFQyxjQUFjLEVBQUcsR0FBR0M7QUFDdEgscUVBQXFFO0FBQ3JFLE1BQU1DLFNBQVNDO0FBQ2Y7SUFDSUQsT0FBT2YsY0FBYyxLQUFLQSxrRUFBY0E7QUFDNUMsQ0FDQSxJQUFJaUI7QUFDSixNQUFNQyxlQUFlSCxPQUNoQkcsWUFBWTtBQUNqQixvREFBb0Q7QUFDcEQsb0VBQW9FO0FBQ3BFLDhFQUE4RTtBQUM5RSw2QkFBNkI7QUFDN0IsTUFBTUMsaUNBQWlDRCxlQUNqQ0EsYUFBYUUsV0FBVyxHQUN4QjtBQUNOLE1BQU1DLGtCQUFrQk4sT0FBT08scUNBQXFDO0FBRXBFO0lBQ0ksdUVBQXVFO0lBQ3ZFLGNBQWM7SUFDZFAsT0FBT1EsaUJBQWlCLEtBQUssSUFBSUM7SUFDakM7Ozs7S0FJQyxHQUNEUCxlQUFlLENBQUNRLE1BQU1DO1FBQ2xCQSxXQUFXLENBQUMseUJBQXlCLEVBQUVELEtBQUssc0JBQXNCLENBQUM7UUFDbkUsSUFBSSxDQUFDVixPQUFPUSxpQkFBaUIsQ0FBQ0ksR0FBRyxDQUFDRCxZQUM5QixDQUFDWCxPQUFPUSxpQkFBaUIsQ0FBQ0ksR0FBRyxDQUFDRixPQUFPO1lBQ3JDRyxRQUFRQyxJQUFJLENBQUNIO1lBQ2JYLE9BQU9RLGlCQUFpQixDQUFDTyxHQUFHLENBQUNKO1FBQ2pDO0lBQ0o7SUFDQUssZUFBZTtRQUNYZCxhQUFhLFlBQVksQ0FBQyxtREFBbUQsQ0FBQztRQUM5RSxrQ0FBa0M7UUFDbEMsSUFBSUYsT0FBT2lCLFFBQVEsRUFBRUMsU0FBU1osb0JBQW9C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SSxDQUFDQSxLQUFLbEYsY0FBYyxDQUFDNUMsMEJBQTBCLHFCQUFxQjtZQUNwRThILEtBQUtMLGVBQWUsR0FBR0ssS0FBS0wsZUFBZSxDQUFDMkMsS0FBSztRQUNyRDtJQUNKO0lBQ0F2SSxnQkFBZ0J3SSxhQUFhLEdBQUcsU0FBVXJMLE9BQU87UUFDN0NtTCxrQkFBa0IsSUFBSTtRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDMUMsZUFBZSxDQUFDQyxRQUFRLENBQUMxSSxVQUFVO1lBQ3pDLElBQUksQ0FBQ3lJLGVBQWUsQ0FBQ3ZGLElBQUksQ0FBQ2xEO1FBQzlCO0lBQ0o7SUFDQTZDLGdCQUFnQnlJLGNBQWMsR0FBRyxTQUFVdEwsT0FBTztRQUM5Q21MLGtCQUFrQixJQUFJO1FBQ3RCLE1BQU1wRSxJQUFJLElBQUksQ0FBQzBCLGVBQWUsQ0FBQzhDLE9BQU8sQ0FBQ3ZMO1FBQ3ZDLElBQUkrRyxLQUFLLEdBQUc7WUFDUixJQUFJLENBQUMwQixlQUFlLENBQUMrQyxNQUFNLENBQUN6RSxHQUFHO1FBQ25DO0lBQ0o7QUFDSixDQUdBLDJFQUYyRTtBQUMzRSx5RUFBeUU7QUFDeEUxSCxDQUFBQSxPQUFPb00sdUJBQXVCLEtBQUssRUFBRSxFQUFFdkksSUFBSSxDQUFDO0FBQzdDLElBQUk3RCxPQUFPb00sdUJBQXVCLENBQUN0QixNQUFNLEdBQUcsR0FBRztJQUMzQzlKLGVBQWU7UUFDWGQsYUFBYSxxQkFBcUIsQ0FBQywyREFBMkQsQ0FBQyxHQUMzRixDQUFDLG1CQUFtQixDQUFDO0lBQzdCO0FBQ0o7QUFFd0YsQ0FDeEYsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L3JlYWN0aXZlLWVsZW1lbnQuanM/ODQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjdXN0b21FbGVtZW50cywgSFRNTEVsZW1lbnQgfSBmcm9tICdAbGl0LWxhYnMvc3NyLWRvbS1zaGltJztcbmltcG9ydCB7IGdldENvbXBhdGlibGVTdHlsZSwgYWRvcHRTdHlsZXMgfSBmcm9tICcuL2Nzcy10YWcuanMnO1xuZXhwb3J0IHsgQ1NTUmVzdWx0LCBjc3MsIHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cywgdW5zYWZlQ1NTIH0gZnJvbSAnLi9jc3MtdGFnLmpzJztcblxuLy8gVE9ETyAoanVzdGluZmFnbmFuaSk6IEFkZCBgaGFzT3duYCBoZXJlIHdoZW4gd2Ugc2hpcCBFUzIwMjJcbmNvbnN0IHsgaXMsIGRlZmluZVByb3BlcnR5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIGdldE93blByb3BlcnR5TmFtZXMsIGdldE93blByb3BlcnR5U3ltYm9scywgZ2V0UHJvdG90eXBlT2YsIH0gPSBPYmplY3Q7XG4vLyBMZXRzIGEgbWluaWZpZXIgcmVwbGFjZSBnbG9iYWxUaGlzIHJlZmVyZW5jZXMgd2l0aCBhIG1pbmlmaWVkIG5hbWVcbmNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXM7XG57XG4gICAgZ2xvYmFsLmN1c3RvbUVsZW1lbnRzID8/PSBjdXN0b21FbGVtZW50cztcbn1cbmxldCBpc3N1ZVdhcm5pbmc7XG5jb25zdCB0cnVzdGVkVHlwZXMgPSBnbG9iYWxcbiAgICAudHJ1c3RlZFR5cGVzO1xuLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIGh0dHBzOi8vY3JidWcuY29tLzk5MzI2OFxuLy8gQ3VycmVudGx5LCBhbnkgYXR0cmlidXRlIHN0YXJ0aW5nIHdpdGggXCJvblwiIGlzIGNvbnNpZGVyZWQgdG8gYmUgYVxuLy8gVHJ1c3RlZFNjcmlwdCBzb3VyY2UuIFN1Y2ggYm9vbGVhbiBhdHRyaWJ1dGVzIG11c3QgYmUgc2V0IHRvIHRoZSBlcXVpdmFsZW50XG4vLyB0cnVzdGVkIGVtcHR5U2NyaXB0IHZhbHVlLlxuY29uc3QgZW1wdHlTdHJpbmdGb3JCb29sZWFuQXR0cmlidXRlID0gdHJ1c3RlZFR5cGVzXG4gICAgPyB0cnVzdGVkVHlwZXMuZW1wdHlTY3JpcHRcbiAgICA6ICcnO1xuY29uc3QgcG9seWZpbGxTdXBwb3J0ID0gZ2xvYmFsLnJlYWN0aXZlRWxlbWVudFBvbHlmaWxsU3VwcG9ydERldk1vZGVcbiAgICA7XG57XG4gICAgLy8gRW5zdXJlIHdhcm5pbmdzIGFyZSBpc3N1ZWQgb25seSAxeCwgZXZlbiBpZiBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBMaXRcbiAgICAvLyBhcmUgbG9hZGVkLlxuICAgIGdsb2JhbC5saXRJc3N1ZWRXYXJuaW5ncyA/Pz0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIElzc3VlIGEgd2FybmluZyBpZiB3ZSBoYXZlbid0IGFscmVhZHksIGJhc2VkIGVpdGhlciBvbiBgY29kZWAgb3IgYHdhcm5pbmdgLlxuICAgICAqIFdhcm5pbmdzIGFyZSBkaXNhYmxlZCBhdXRvbWF0aWNhbGx5IG9ubHkgYnkgYHdhcm5pbmdgOyBkaXNhYmxpbmcgdmlhIGBjb2RlYFxuICAgICAqIGNhbiBiZSBkb25lIGJ5IHVzZXJzLlxuICAgICAqL1xuICAgIGlzc3VlV2FybmluZyA9IChjb2RlLCB3YXJuaW5nKSA9PiB7XG4gICAgICAgIHdhcm5pbmcgKz0gYCBTZWUgaHR0cHM6Ly9saXQuZGV2L21zZy8ke2NvZGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLmA7XG4gICAgICAgIGlmICghZ2xvYmFsLmxpdElzc3VlZFdhcm5pbmdzLmhhcyh3YXJuaW5nKSAmJlxuICAgICAgICAgICAgIWdsb2JhbC5saXRJc3N1ZWRXYXJuaW5ncy5oYXMoY29kZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICAgICAgICAgIGdsb2JhbC5saXRJc3N1ZWRXYXJuaW5ncy5hZGQod2FybmluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgaXNzdWVXYXJuaW5nKCdkZXYtbW9kZScsIGBMaXQgaXMgaW4gZGV2IG1vZGUuIE5vdCByZWNvbW1lbmRlZCBmb3IgcHJvZHVjdGlvbiFgKTtcbiAgICAgICAgLy8gSXNzdWUgcG9seWZpbGwgc3VwcG9ydCB3YXJuaW5nLlxuICAgICAgICBpZiAoZ2xvYmFsLlNoYWR5RE9NPy5pblVzZSAmJiBwb2x5ZmlsbFN1cHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXNzdWVXYXJuaW5nKCdwb2x5ZmlsbC1zdXBwb3J0LW1pc3NpbmcnLCBgU2hhZG93IERPTSBpcyBiZWluZyBwb2x5ZmlsbGVkIHZpYSBcXGBTaGFkeURPTVxcYCBidXQgYCArXG4gICAgICAgICAgICAgICAgYHRoZSBcXGBwb2x5ZmlsbC1zdXBwb3J0XFxgIG1vZHVsZSBoYXMgbm90IGJlZW4gbG9hZGVkLmApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFVzZWZ1bCBmb3IgdmlzdWFsaXppbmcgYW5kIGxvZ2dpbmcgaW5zaWdodHMgaW50byB3aGF0IHRoZSBMaXQgdGVtcGxhdGUgc3lzdGVtIGlzIGRvaW5nLlxuICpcbiAqIENvbXBpbGVkIG91dCBvZiBwcm9kIG1vZGUgYnVpbGRzLlxuICovXG5jb25zdCBkZWJ1Z0xvZ0V2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHNob3VsZEVtaXQgPSBnbG9iYWxcbiAgICAgICAgICAgIC5lbWl0TGl0RGVidWdMb2dFdmVudHM7XG4gICAgICAgIGlmICghc2hvdWxkRW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbGl0LWRlYnVnJywge1xuICAgICAgICAgICAgZGV0YWlsOiBldmVudCxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICA7XG4vKlxuICogV2hlbiB1c2luZyBDbG9zdXJlIENvbXBpbGVyLCBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KHByb3BlcnR5LCBvYmplY3QpIGlzXG4gKiByZXBsYWNlZCBhdCBjb21waWxlIHRpbWUgYnkgdGhlIG11bmdlZCBuYW1lIGZvciBvYmplY3RbcHJvcGVydHldLiBXZSBjYW5ub3RcbiAqIGFsaWFzIHRoaXMgZnVuY3Rpb24sIHNvIHdlIGhhdmUgdG8gdXNlIGEgc21hbGwgc2hpbSB0aGF0IGhhcyB0aGUgc2FtZVxuICogYmVoYXZpb3Igd2hlbiBub3QgY29tcGlsaW5nLlxuICovXG4vKkBfX0lOTElORV9fKi9cbmNvbnN0IEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSAocHJvcCwgX29iaikgPT4gcHJvcDtcbmNvbnN0IGRlZmF1bHRDb252ZXJ0ZXIgPSB7XG4gICAgdG9BdHRyaWJ1dGUodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IGVtcHR5U3RyaW5nRm9yQm9vbGVhbkF0dHJpYnV0ZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCBwYXNzIHRoaXMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIHRvIGFsbG93IHJlbW92aW5nL25vIGNoYW5nZSBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09IG51bGwgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBmcm9tQXR0cmlidXRlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGxldCBmcm9tVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICAgICAgZnJvbVZhbHVlID0gdmFsdWUgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgICAgICBmcm9tVmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgICAgIC8vIERvICpub3QqIGdlbmVyYXRlIGV4Y2VwdGlvbiB3aGVuIGludmFsaWQgSlNPTiBpcyBzZXQgYXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBub3JtYWxseSBjb21wbGFpbiBvbiBiZWluZyBtaXMtY29uZmlndXJlZC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBEbyBnZW5lcmF0ZSBleGNlcHRpb24gaW4gKmRldiBtb2RlKi5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBc3NlcnQgdG8gYWRoZXJlIHRvIEJhemVsJ3MgXCJtdXN0IHR5cGUgYXNzZXJ0IEpTT04gcGFyc2VcIiBydWxlLlxuICAgICAgICAgICAgICAgICAgICBmcm9tVmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21WYWx1ZTtcbiAgICB9LFxufTtcbi8qKlxuICogQ2hhbmdlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgZGlmZmVyZW50IGZyb20gYG9sZFZhbHVlYC5cbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgYXMgdGhlIGRlZmF1bHQgZm9yIGEgcHJvcGVydHkncyBgaGFzQ2hhbmdlZGAgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IG5vdEVxdWFsID0gKHZhbHVlLCBvbGQpID0+ICFpcyh2YWx1ZSwgb2xkKTtcbmNvbnN0IGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uID0ge1xuICAgIGF0dHJpYnV0ZTogdHJ1ZSxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY29udmVydGVyOiBkZWZhdWx0Q29udmVydGVyLFxuICAgIHJlZmxlY3Q6IGZhbHNlLFxuICAgIHVzZURlZmF1bHQ6IGZhbHNlLFxuICAgIGhhc0NoYW5nZWQ6IG5vdEVxdWFsLFxufTtcbi8vIEVuc3VyZSBtZXRhZGF0YSBpcyBlbmFibGVkLiBUeXBlU2NyaXB0IGRvZXMgbm90IHBvbHlmaWxsXG4vLyBTeW1ib2wubWV0YWRhdGEsIHNvIHdlIG11c3QgZW5zdXJlIHRoYXQgaXQgZXhpc3RzLlxuU3ltYm9sLm1ldGFkYXRhID8/PSBTeW1ib2woJ21ldGFkYXRhJyk7XG4vLyBNYXAgZnJvbSBhIGNsYXNzJ3MgbWV0YWRhdGEgb2JqZWN0IHRvIHByb3BlcnR5IG9wdGlvbnNcbi8vIE5vdGUgdGhhdCB3ZSBtdXN0IHVzZSBudWxsaXNoLWNvYWxlc2NpbmcgYXNzaWdubWVudCBzbyB0aGF0IHdlIG9ubHkgdXNlIG9uZVxuLy8gbWFwIGV2ZW4gaWYgd2UgbG9hZCBtdWx0aXBsZSB2ZXJzaW9uIG9mIHRoaXMgbW9kdWxlLlxuZ2xvYmFsLmxpdFByb3BlcnR5TWV0YWRhdGEgPz89IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEJhc2UgZWxlbWVudCBjbGFzcyB3aGljaCBtYW5hZ2VzIGVsZW1lbnQgcHJvcGVydGllcyBhbmQgYXR0cmlidXRlcy4gV2hlblxuICogcHJvcGVydGllcyBjaGFuZ2UsIHRoZSBgdXBkYXRlYCBtZXRob2QgaXMgYXN5bmNocm9ub3VzbHkgY2FsbGVkLiBUaGlzIG1ldGhvZFxuICogc2hvdWxkIGJlIHN1cHBsaWVkIGJ5IHN1YmNsYXNzZXMgdG8gcmVuZGVyIHVwZGF0ZXMgYXMgZGVzaXJlZC5cbiAqIEBub0luaGVyaXREb2NcbiAqL1xuY2xhc3MgUmVhY3RpdmVFbGVtZW50XG4vLyBJbiB0aGUgTm9kZSBidWlsZCwgdGhpcyBgZXh0ZW5kc2AgY2xhdXNlIHdpbGwgYmUgc3Vic3RpdHV0ZWQgd2l0aFxuLy8gYChnbG9iYWxUaGlzLkhUTUxFbGVtZW50ID8/IEhUTUxFbGVtZW50KWAuXG4vL1xuLy8gVGhpcyB3YXksIHdlIHdpbGwgZmlyc3QgcHJlZmVyIGFueSBnbG9iYWwgYEhUTUxFbGVtZW50YCBwb2x5ZmlsbCB0aGF0IHRoZVxuLy8gdXNlciBoYXMgYXNzaWduZWQsIGFuZCB0aGVuIGZhbGwgYmFjayB0byB0aGUgYEhUTUxFbGVtZW50YCBzaGltIHdoaWNoIGhhc1xuLy8gYmVlbiBpbXBvcnRlZCAoc2VlIG5vdGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUgYWJvdXQgaG93IHRoaXMgaW1wb3J0IGlzXG4vLyBnZW5lcmF0ZWQgYnkgUm9sbHVwKS4gTm90ZSB0aGF0IHRoZSBgSFRNTEVsZW1lbnRgIHZhcmlhYmxlIGhhcyBiZWVuXG4vLyBzaGFkb3dlZCBieSB0aGlzIGltcG9ydCwgc28gaXQgbm8gbG9uZ2VyIHJlZmVycyB0byB0aGUgZ2xvYmFsLlxuIGV4dGVuZHMgKGdsb2JhbFRoaXMuSFRNTEVsZW1lbnQgPz8gSFRNTEVsZW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGluaXRpYWxpemVyIGZ1bmN0aW9uIHRvIHRoZSBjbGFzcyB0aGF0IGlzIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2VcbiAgICAgKiBjb25zdHJ1Y3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29kZSB0aGF0IHJ1bnMgYWdhaW5zdCBhIGBSZWFjdGl2ZUVsZW1lbnRgXG4gICAgICogc3ViY2xhc3MsIHN1Y2ggYXMgYSBkZWNvcmF0b3IsIHRoYXQgbmVlZHMgdG8gZG8gd29yayBmb3IgZWFjaFxuICAgICAqIGluc3RhbmNlLCBzdWNoIGFzIHNldHRpbmcgdXAgYSBgUmVhY3RpdmVDb250cm9sbGVyYC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgbXlEZWNvcmF0b3IgPSAodGFyZ2V0OiB0eXBlb2YgUmVhY3RpdmVFbGVtZW50LCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAqICAgdGFyZ2V0LmFkZEluaXRpYWxpemVyKChpbnN0YW5jZTogUmVhY3RpdmVFbGVtZW50KSA9PiB7XG4gICAgICogICAgIC8vIFRoaXMgaXMgcnVuIGR1cmluZyBjb25zdHJ1Y3Rpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgKiAgICAgbmV3IE15Q29udHJvbGxlcihpbnN0YW5jZSk7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBEZWNvcmF0aW5nIGEgZmllbGQgd2lsbCB0aGVuIGNhdXNlIGVhY2ggaW5zdGFuY2UgdG8gcnVuIGFuIGluaXRpYWxpemVyXG4gICAgICogdGhhdCBhZGRzIGEgY29udHJvbGxlcjpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgICogICBAbXlEZWNvcmF0b3IgZm9vO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEluaXRpYWxpemVycyBhcmUgc3RvcmVkIHBlci1jb25zdHJ1Y3Rvci4gQWRkaW5nIGFuIGluaXRpYWxpemVyIHRvIGFcbiAgICAgKiBzdWJjbGFzcyBkb2VzIG5vdCBhZGQgaXQgdG8gYSBzdXBlcmNsYXNzLiBTaW5jZSBpbml0aWFsaXplcnMgYXJlIHJ1biBpblxuICAgICAqIGNvbnN0cnVjdG9ycywgaW5pdGlhbGl6ZXJzIHdpbGwgcnVuIGluIG9yZGVyIG9mIHRoZSBjbGFzcyBoaWVyYXJjaHksXG4gICAgICogc3RhcnRpbmcgd2l0aCBzdXBlcmNsYXNzZXMgYW5kIHByb2dyZXNzaW5nIHRvIHRoZSBpbnN0YW5jZSdzIGNsYXNzLlxuICAgICAqXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5pdGlhbGl6ZXIoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5fX3ByZXBhcmUoKTtcbiAgICAgICAgKHRoaXMuX2luaXRpYWxpemVycyA/Pz0gW10pLnB1c2goaW5pdGlhbGl6ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhdHRyaWJ1dGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlZ2lzdGVyZWQgcHJvcGVydGllcy5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqIEBjYXRlZ29yeSBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSd2ZSBjcmVhdGVkIGFsbCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgLy8gdGhpcy5fX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAgaXMgb25seSB1bmRlZmluZWQgYWZ0ZXIgZmluYWxpemUoKSBpblxuICAgICAgICAvLyBSZWFjdGl2ZUVsZW1lbnQgaXRzZWxmLiBSZWFjdGl2ZUVsZW1lbnQub2JzZXJ2ZWRBdHRyaWJ1dGVzIGlzIG9ubHlcbiAgICAgICAgLy8gYWNjZXNzZWQgd2l0aCBSZWFjdGl2ZUVsZW1lbnQgYXMgdGhlIHJlY2VpdmVyIHdoZW4gYSBzdWJjbGFzcyBvciBtaXhpblxuICAgICAgICAvLyBjYWxscyBzdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXNcbiAgICAgICAgcmV0dXJuICh0aGlzLl9fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCAmJiBbLi4udGhpcy5fX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAua2V5cygpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwcm9wZXJ0eSBhY2Nlc3NvciBvbiB0aGUgZWxlbWVudCBwcm90b3R5cGUgaWYgb25lIGRvZXMgbm90IGV4aXN0XG4gICAgICogYW5kIHN0b3JlcyBhIHtAbGlua2NvZGUgUHJvcGVydHlEZWNsYXJhdGlvbn0gZm9yIHRoZSBwcm9wZXJ0eSB3aXRoIHRoZVxuICAgICAqIGdpdmVuIG9wdGlvbnMuIFRoZSBwcm9wZXJ0eSBzZXR0ZXIgY2FsbHMgdGhlIHByb3BlcnR5J3MgYGhhc0NoYW5nZWRgXG4gICAgICogcHJvcGVydHkgb3B0aW9uIG9yIHVzZXMgYSBzdHJpY3QgaWRlbnRpdHkgY2hlY2sgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90XG4gICAgICogdG8gcmVxdWVzdCBhbiB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGRlbiB0byBjdXN0b21pemUgcHJvcGVydGllczsgaG93ZXZlcixcbiAgICAgKiB3aGVuIGRvaW5nIHNvLCBpdCdzIGltcG9ydGFudCB0byBjYWxsIGBzdXBlci5jcmVhdGVQcm9wZXJ0eWAgdG8gZW5zdXJlXG4gICAgICogdGhlIHByb3BlcnR5IGlzIHNldHVwIGNvcnJlY3RseS4gVGhpcyBtZXRob2QgY2FsbHNcbiAgICAgKiBgZ2V0UHJvcGVydHlEZXNjcmlwdG9yYCBpbnRlcm5hbGx5IHRvIGdldCBhIGRlc2NyaXB0b3IgdG8gaW5zdGFsbC5cbiAgICAgKiBUbyBjdXN0b21pemUgd2hhdCBwcm9wZXJ0aWVzIGRvIHdoZW4gdGhleSBhcmUgZ2V0IG9yIHNldCwgb3ZlcnJpZGVcbiAgICAgKiBgZ2V0UHJvcGVydHlEZXNjcmlwdG9yYC4gVG8gY3VzdG9taXplIHRoZSBvcHRpb25zIGZvciBhIHByb3BlcnR5LFxuICAgICAqIGltcGxlbWVudCBgY3JlYXRlUHJvcGVydHlgIGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogc3RhdGljIGNyZWF0ZVByb3BlcnR5KG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgKiAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtteU9wdGlvbjogdHJ1ZX0pO1xuICAgICAqICAgc3VwZXIuY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucyk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKiBAY2F0ZWdvcnkgcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eShuYW1lLCBvcHRpb25zID0gZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb24pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0YXRlIHByb3BlcnR5LCBmb3JjZSB0aGUgYXR0cmlidXRlIHRvIGZhbHNlLlxuICAgICAgICBpZiAob3B0aW9ucy5zdGF0ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fcHJlcGFyZSgpO1xuICAgICAgICAvLyBXaGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgd3JhcHBpbmcgYWNjZXNzb3JzLlxuICAgICAgICAvLyBIZWxwcyBjb250cm9sIHRoZSBpbml0aWFsIHZhbHVlIGNoYW5nZSBhbmQgcmVmbGVjdGlvbiBsb2dpYy5cbiAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMud3JhcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50UHJvcGVydGllcy5zZXQobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5ub0FjY2Vzc29yKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSAvLyBVc2UgU3ltYm9sLmZvciBpbiBkZXYgbW9kZSB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGRvaW5nIEhNUi5cbiAgICAgICAgICAgICAgICAgICAgU3ltYm9sLmZvcihgJHtTdHJpbmcobmFtZSl9IChAcHJvcGVydHkoKSBjYWNoZSlgKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldFByb3BlcnR5RGVzY3JpcHRvcihuYW1lLCBrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvcGVydHkgZGVzY3JpcHRvciB0byBiZSBkZWZpbmVkIG9uIHRoZSBnaXZlbiBuYW1lZCBwcm9wZXJ0eS5cbiAgICAgKiBJZiBubyBkZXNjcmlwdG9yIGlzIHJldHVybmVkLCB0aGUgcHJvcGVydHkgd2lsbCBub3QgYmVjb21lIGFuIGFjY2Vzc29yLlxuICAgICAqIEZvciBleGFtcGxlLFxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjbGFzcyBNeUVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgICAgKiAgIHN0YXRpYyBnZXRQcm9wZXJ0eURlc2NyaXB0b3IobmFtZSwga2V5LCBvcHRpb25zKSB7XG4gICAgICogICAgIGNvbnN0IGRlZmF1bHREZXNjcmlwdG9yID1cbiAgICAgKiAgICAgICAgIHN1cGVyLmdldFByb3BlcnR5RGVzY3JpcHRvcihuYW1lLCBrZXksIG9wdGlvbnMpO1xuICAgICAqICAgICBjb25zdCBzZXR0ZXIgPSBkZWZhdWx0RGVzY3JpcHRvci5zZXQ7XG4gICAgICogICAgIHJldHVybiB7XG4gICAgICogICAgICAgZ2V0OiBkZWZhdWx0RGVzY3JpcHRvci5nZXQsXG4gICAgICogICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICogICAgICAgICBzZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICogICAgICAgICAvLyBjdXN0b20gYWN0aW9uLlxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAqICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICogQGNhdGVnb3J5IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG5hbWUsIGtleSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy5wcm90b3R5cGUsIG5hbWUpID8/IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gKGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLnByb3RvdHlwZSwgbmFtZSkgPz8ge30pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCAke0pTT04uc3RyaW5naWZ5KFN0cmluZyhuYW1lKSl9IG9uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLm5hbWV9IHdhcyBkZWNsYXJlZCBhcyBhIHJlYWN0aXZlIHByb3BlcnR5IGAgK1xuICAgICAgICAgICAgICAgICAgICBgYnV0IGl0J3MgYWN0dWFsbHkgZGVjbGFyZWQgYXMgYSB2YWx1ZSBvbiB0aGUgcHJvdG90eXBlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFVzdWFsbHkgdGhpcyBpcyBkdWUgdG8gdXNpbmcgQHByb3BlcnR5IG9yIEBzdGF0ZSBvbiBhIG1ldGhvZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzc3VlV2FybmluZygncmVhY3RpdmUtcHJvcGVydHktd2l0aG91dC1nZXR0ZXInLCBgRmllbGQgJHtKU09OLnN0cmluZ2lmeShTdHJpbmcobmFtZSkpfSBvbiBgICtcbiAgICAgICAgICAgICAgICBgJHt0aGlzLm5hbWV9IHdhcyBkZWNsYXJlZCBhcyBhIHJlYWN0aXZlIHByb3BlcnR5IGAgK1xuICAgICAgICAgICAgICAgIGBidXQgaXQgZG9lcyBub3QgaGF2ZSBhIGdldHRlci4gVGhpcyB3aWxsIGJlIGFuIGVycm9yIGluIGEgYCArXG4gICAgICAgICAgICAgICAgYGZ1dHVyZSB2ZXJzaW9uIG9mIExpdC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQ/LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgc2V0Py5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUobmFtZSwgb2xkVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3BlcnR5IG9wdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBUaGVzZSBvcHRpb25zIGFyZSBkZWZpbmVkIHdpdGggYSBgUHJvcGVydHlEZWNsYXJhdGlvbmAgdmlhIHRoZSBgcHJvcGVydGllc2BcbiAgICAgKiBvYmplY3Qgb3IgdGhlIGBAcHJvcGVydHlgIGRlY29yYXRvciBhbmQgYXJlIHJlZ2lzdGVyZWQgaW5cbiAgICAgKiBgY3JlYXRlUHJvcGVydHkoLi4uKWAuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY29uc2lkZXJlZCBcImZpbmFsXCIgYW5kIG5vdCBvdmVycmlkZGVuLiBUb1xuICAgICAqIGN1c3RvbWl6ZSB0aGUgb3B0aW9ucyBmb3IgYSBnaXZlbiBwcm9wZXJ0eSwgb3ZlcnJpZGVcbiAgICAgKiB7QGxpbmtjb2RlIGNyZWF0ZVByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICogQGZpbmFsXG4gICAgICogQGNhdGVnb3J5IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJvcGVydHlPcHRpb25zKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFByb3BlcnRpZXMuZ2V0KG5hbWUpID8/IGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBzdGF0aWMgb3duIHByb3BlcnRpZXMgb2YgdGhlIGNsYXNzIHVzZWQgaW4gYm9va2tlZXBpbmdcbiAgICAgKiBmb3IgZWxlbWVudCBwcm9wZXJ0aWVzLCBpbml0aWFsaXplcnMsIGV0Yy5cbiAgICAgKlxuICAgICAqIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYnkgY29kZSB0aGF0IG5lZWRzIHRvIGVuc3VyZSB0aGVzZVxuICAgICAqIHByb3BlcnRpZXMgZXhpc3QgYmVmb3JlIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBzdXBlcmNsYXNzIGlzIGZpbmFsaXplZCBzbyB0aGF0IGluaGVyaXRlZFxuICAgICAqIHByb3BlcnR5IG1ldGFkYXRhIGNhbiBiZSBjb3BpZWQgZG93bi5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfX3ByZXBhcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ2VsZW1lbnRQcm9wZXJ0aWVzJykpKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHByZXBhcmVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxpemUgYW55IHN1cGVyY2xhc3Nlc1xuICAgICAgICBjb25zdCBzdXBlckN0b3IgPSBnZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgc3VwZXJDdG9yLmZpbmFsaXplKCk7XG4gICAgICAgIC8vIENyZWF0ZSBvd24gc2V0IG9mIGluaXRpYWxpemVycyBmb3IgdGhpcyBjbGFzcyBpZiBhbnkgZXhpc3Qgb24gdGhlXG4gICAgICAgIC8vIHN1cGVyY2xhc3MgYW5kIGNvcHkgdGhlbSBkb3duLiBOb3RlLCBmb3IgYSBzbWFsbCBwZXJmIGJvb3N0LCBhdm9pZFxuICAgICAgICAvLyBjcmVhdGluZyBpbml0aWFsaXplcnMgdW5sZXNzIG5lZWRlZC5cbiAgICAgICAgaWYgKHN1cGVyQ3Rvci5faW5pdGlhbGl6ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVycyA9IFsuLi5zdXBlckN0b3IuX2luaXRpYWxpemVyc107XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbGVtZW50UHJvcGVydGllcyBmcm9tIHRoZSBzdXBlcmNsYXNzXG4gICAgICAgIHRoaXMuZWxlbWVudFByb3BlcnRpZXMgPSBuZXcgTWFwKHN1cGVyQ3Rvci5lbGVtZW50UHJvcGVydGllcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmlzaGVzIHNldHRpbmcgdXAgdGhlIGNsYXNzIHNvIHRoYXQgaXQncyByZWFkeSB0byBiZSByZWdpc3RlcmVkXG4gICAgICogYXMgYSBjdXN0b20gZWxlbWVudCBhbmQgaW5zdGFudGlhdGVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBSZWFjdGl2ZUVsZW1lbnQub2JzZXJ2ZWRBdHRyaWJ1dGVzIGdldHRlci5cbiAgICAgKiBJZiB5b3Ugb3ZlcnJpZGUgdGhlIG9ic2VydmVkQXR0cmlidXRlcyBnZXR0ZXIsIHlvdSBtdXN0IGVpdGhlciBjYWxsXG4gICAgICogc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzIHRvIHRyaWdnZXIgZmluYWxpemF0aW9uLCBvciBjYWxsIGZpbmFsaXplKClcbiAgICAgKiB5b3Vyc2VsZi5cbiAgICAgKlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdmaW5hbGl6ZWQnKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX19wcmVwYXJlKCk7XG4gICAgICAgIC8vIENyZWF0ZSBwcm9wZXJ0aWVzIGZyb20gdGhlIHN0YXRpYyBwcm9wZXJ0aWVzIGJsb2NrOlxuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdwcm9wZXJ0aWVzJykpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgICAgIGNvbnN0IHByb3BLZXlzID0gW1xuICAgICAgICAgICAgICAgIC4uLmdldE93blByb3BlcnR5TmFtZXMocHJvcHMpLFxuICAgICAgICAgICAgICAgIC4uLmdldE93blByb3BlcnR5U3ltYm9scyhwcm9wcyksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHByb3BLZXlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQcm9wZXJ0eShwLCBwcm9wc1twXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHByb3BlcnRpZXMgZnJvbSBzdGFuZGFyZCBkZWNvcmF0b3IgbWV0YWRhdGE6XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpc1tTeW1ib2wubWV0YWRhdGFdO1xuICAgICAgICBpZiAobWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBsaXRQcm9wZXJ0eU1ldGFkYXRhLmdldChtZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbcCwgb3B0aW9uc10gb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRQcm9wZXJ0aWVzLnNldChwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBhdHRyaWJ1dGUtdG8tcHJvcGVydHkgbWFwXG4gICAgICAgIHRoaXMuX19hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtwLCBvcHRpb25zXSBvZiB0aGlzLmVsZW1lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gdGhpcy5fX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcC5zZXQoYXR0ciwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50U3R5bGVzID0gdGhpcy5maW5hbGl6ZVN0eWxlcyh0aGlzLnN0eWxlcyk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KCdjcmVhdGVQcm9wZXJ0eScpKSB7XG4gICAgICAgICAgICAgICAgaXNzdWVXYXJuaW5nKCduby1vdmVycmlkZS1jcmVhdGUtcHJvcGVydHknLCAnT3ZlcnJpZGluZyBSZWFjdGl2ZUVsZW1lbnQuY3JlYXRlUHJvcGVydHkoKSBpcyBkZXByZWNhdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1RoZSBvdmVycmlkZSB3aWxsIG5vdCBiZSBjYWxsZWQgd2l0aCBzdGFuZGFyZCBkZWNvcmF0b3JzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnZ2V0UHJvcGVydHlEZXNjcmlwdG9yJykpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZVdhcm5pbmcoJ25vLW92ZXJyaWRlLWdldC1wcm9wZXJ0eS1kZXNjcmlwdG9yJywgJ092ZXJyaWRpbmcgUmVhY3RpdmVFbGVtZW50LmdldFByb3BlcnR5RGVzY3JpcHRvcigpIGlzIGRlcHJlY2F0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVGhlIG92ZXJyaWRlIHdpbGwgbm90IGJlIGNhbGxlZCB3aXRoIHN0YW5kYXJkIGRlY29yYXRvcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgc3R5bGVzIHRoZSB1c2VyIHN1cHBsaWVkIHZpYSB0aGUgYHN0YXRpYyBzdHlsZXNgIHByb3BlcnR5IGFuZFxuICAgICAqIHJldHVybnMgdGhlIGFycmF5IG9mIHN0eWxlcyB0byBhcHBseSB0byB0aGUgZWxlbWVudC5cbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbnRlZ3JhdGUgaW50byBhIHN0eWxlIG1hbmFnZW1lbnQgc3lzdGVtLlxuICAgICAqXG4gICAgICogU3R5bGVzIGFyZSBkZWR1cGxpY2F0ZWQgcHJlc2VydmluZyB0aGUgX2xhc3RfIGluc3RhbmNlIGluIHRoZSBsaXN0LiBUaGlzXG4gICAgICogaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgZHVwbGljYXRlZCBzdHlsZXMgdGhhdCBjYW4gb2NjdXJcbiAgICAgKiBlc3BlY2lhbGx5IHdoZW4gY29tcG9zaW5nIHZpYSBzdWJjbGFzc2luZy4gVGhlIGxhc3QgaXRlbSBpcyBrZXB0IHRvIHRyeVxuICAgICAqIHRvIHByZXNlcnZlIHRoZSBjYXNjYWRlIG9yZGVyIHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCBpdCdzIG1vc3QgaW1wb3J0YW50XG4gICAgICogdGhhdCBsYXN0IGFkZGVkIHN0eWxlcyBvdmVycmlkZSBwcmV2aW91cyBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqIEBjYXRlZ29yeSBzdHlsZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemVTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRTdHlsZXMgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgICAgICAgLy8gRGVkdXBlIHRoZSBmbGF0dGVuZWQgYXJyYXkgaW4gcmV2ZXJzZSBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgbGFzdCBpdGVtcy5cbiAgICAgICAgICAgIC8vIENhc3RpbmcgdG8gQXJyYXk8dW5rbm93bj4gd29ya3MgYXJvdW5kIFRTIGVycm9yIHRoYXRcbiAgICAgICAgICAgIC8vIGFwcGVhcnMgdG8gY29tZSBmcm9tIHRyeWluZyB0byBmbGF0dGVuIGEgdHlwZSBDU1NSZXN1bHRBcnJheS5cbiAgICAgICAgICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoc3R5bGVzLmZsYXQoSW5maW5pdHkpLnJldmVyc2UoKSk7XG4gICAgICAgICAgICAvLyBUaGVuIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIGJ5IGFkZGluZyB0aGUgc2V0IGl0ZW1zIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2V0KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlcy51bnNoaWZ0KGdldENvbXBhdGlibGVTdHlsZShzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZXMucHVzaChnZXRDb21wYXRpYmxlU3R5bGUoc3R5bGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRTdHlsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3BlcnR5IG5hbWUgZm9yIHRoZSBnaXZlbiBhdHRyaWJ1dGUgYG5hbWVgLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9fYXR0cmlidXRlTmFtZUZvclByb3BlcnR5KG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gb3B0aW9ucy5hdHRyaWJ1dGU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGUgPT09IGZhbHNlXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB0eXBlb2YgYXR0cmlidXRlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9faW5zdGFuY2VQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgdXBkYXRlIGFzIGEgcmVzdWx0IG9mIGNhbGxpbmcgYHJlcXVlc3RVcGRhdGUoKWAuXG4gICAgICAgICAqIFNob3VsZCBvbmx5IGJlIHJlYWQuXG4gICAgICAgICAqIEBjYXRlZ29yeSB1cGRhdGVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVXBkYXRlUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgc2V0IHRvIGB0cnVlYCBhZnRlciB0aGUgZmlyc3QgdXBkYXRlLiBUaGUgZWxlbWVudCBjb2RlIGNhbm5vdCBhc3N1bWVcbiAgICAgICAgICogdGhhdCBgcmVuZGVyUm9vdGAgZXhpc3RzIGJlZm9yZSB0aGUgZWxlbWVudCBgaGFzVXBkYXRlZGAuXG4gICAgICAgICAqIEBjYXRlZ29yeSB1cGRhdGVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgY3VycmVudGx5IHJlZmxlY3RpbmcgcHJvcGVydHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19yZWZsZWN0aW5nUHJvcGVydHkgPSBudWxsO1xuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBvbmx5IG92ZXJyaWRlIHBvaW50IGZvciBjdXN0b21pemluZyB3b3JrIGRvbmUgd2hlbiBlbGVtZW50c1xuICAgICAqIGFyZSBjb25zdHJ1Y3RlZC5cbiAgICAgKi9cbiAgICBfX2luaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuX191cGRhdGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlcykgPT4gKHRoaXMuZW5hYmxlVXBkYXRpbmcgPSByZXMpKTtcbiAgICAgICAgdGhpcy5fJGNoYW5nZWRQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBUaGlzIGVucXVldWVzIGEgbWljcm90YXNrIHRoYXQgbXVzdCBydW4gYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUsIHNvIGl0XG4gICAgICAgIC8vIG11c3QgYmUgY2FsbGVkIGJlZm9yZSByZXF1ZXN0VXBkYXRlKClcbiAgICAgICAgdGhpcy5fX3NhdmVJbnN0YW5jZVByb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gZW5zdXJlcyBmaXJzdCB1cGRhdGUgd2lsbCBiZSBjYXVnaHQgYnkgYW4gZWFybHkgYWNjZXNzIG9mXG4gICAgICAgIC8vIGB1cGRhdGVDb21wbGV0ZWBcbiAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuX2luaXRpYWxpemVycz8uZm9yRWFjaCgoaSkgPT4gaSh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGBSZWFjdGl2ZUNvbnRyb2xsZXJgIHRvIHBhcnRpY2lwYXRlIGluIHRoZSBlbGVtZW50J3MgcmVhY3RpdmVcbiAgICAgKiB1cGRhdGUgY3ljbGUuIFRoZSBlbGVtZW50IGF1dG9tYXRpY2FsbHkgY2FsbHMgaW50byBhbnkgcmVnaXN0ZXJlZFxuICAgICAqIGNvbnRyb2xsZXJzIGR1cmluZyBpdHMgbGlmZWN5Y2xlIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCB3aGVuIGBhZGRDb250cm9sbGVyKClgIGlzIGNhbGxlZCwgdGhlXG4gICAgICogY29udHJvbGxlcidzIGBob3N0Q29ubmVjdGVkKClgIGNhbGxiYWNrIHdpbGwgYmUgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgICAqIEBjYXRlZ29yeSBjb250cm9sbGVyc1xuICAgICAqL1xuICAgIGFkZENvbnRyb2xsZXIoY29udHJvbGxlcikge1xuICAgICAgICAodGhpcy5fX2NvbnRyb2xsZXJzID8/PSBuZXcgU2V0KCkpLmFkZChjb250cm9sbGVyKTtcbiAgICAgICAgLy8gSWYgYSBjb250cm9sbGVyIGlzIGFkZGVkIGFmdGVyIHRoZSBlbGVtZW50IGhhcyBiZWVuIGNvbm5lY3RlZCxcbiAgICAgICAgLy8gY2FsbCBob3N0Q29ubmVjdGVkLiBOb3RlLCByZS11c2luZyBleGlzdGVuY2Ugb2YgYHJlbmRlclJvb3RgIGhlcmVcbiAgICAgICAgLy8gKHdoaWNoIGlzIHNldCBpbiBjb25uZWN0ZWRDYWxsYmFjaykgdG8gYXZvaWQgdGhlIG5lZWQgdG8gdHJhY2sgYVxuICAgICAgICAvLyBmaXJzdCBjb25uZWN0ZWQgc3RhdGUuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlclJvb3QgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmhvc3RDb25uZWN0ZWQ/LigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBgUmVhY3RpdmVDb250cm9sbGVyYCBmcm9tIHRoZSBlbGVtZW50LlxuICAgICAqIEBjYXRlZ29yeSBjb250cm9sbGVyc1xuICAgICAqL1xuICAgIHJlbW92ZUNvbnRyb2xsZXIoY29udHJvbGxlcikge1xuICAgICAgICB0aGlzLl9fY29udHJvbGxlcnM/LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRml4ZXMgYW55IHByb3BlcnRpZXMgc2V0IG9uIHRoZSBpbnN0YW5jZSBiZWZvcmUgdXBncmFkZSB0aW1lLlxuICAgICAqIE90aGVyd2lzZSB0aGVzZSB3b3VsZCBzaGFkb3cgdGhlIGFjY2Vzc29yIGFuZCBicmVhayB0aGVzZSBwcm9wZXJ0aWVzLlxuICAgICAqIFRoZSBwcm9wZXJ0aWVzIGFyZSBzdG9yZWQgaW4gYSBNYXAgd2hpY2ggaXMgcGxheWVkIGJhY2sgYWZ0ZXIgdGhlXG4gICAgICogY29uc3RydWN0b3IgcnVucy5cbiAgICAgKi9cbiAgICBfX3NhdmVJbnN0YW5jZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAuZWxlbWVudFByb3BlcnRpZXM7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBlbGVtZW50UHJvcGVydGllcy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VQcm9wZXJ0aWVzLnNldChwLCB0aGlzW3BdKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdGFuY2VQcm9wZXJ0aWVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9faW5zdGFuY2VQcm9wZXJ0aWVzID0gaW5zdGFuY2VQcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vZGUgaW50byB3aGljaCB0aGUgZWxlbWVudCBzaG91bGQgcmVuZGVyIGFuZCBieSBkZWZhdWx0XG4gICAgICogY3JlYXRlcyBhbmQgcmV0dXJucyBhbiBvcGVuIHNoYWRvd1Jvb3QuIEltcGxlbWVudCB0byBjdXN0b21pemUgd2hlcmUgdGhlXG4gICAgICogZWxlbWVudCdzIERPTSBpcyByZW5kZXJlZC4gRm9yIGV4YW1wbGUsIHRvIHJlbmRlciBpbnRvIHRoZSBlbGVtZW50J3NcbiAgICAgKiBjaGlsZE5vZGVzLCByZXR1cm4gYHRoaXNgLlxuICAgICAqXG4gICAgICogQHJldHVybiBSZXR1cm5zIGEgbm9kZSBpbnRvIHdoaWNoIHRvIHJlbmRlci5cbiAgICAgKiBAY2F0ZWdvcnkgcmVuZGVyaW5nXG4gICAgICovXG4gICAgY3JlYXRlUmVuZGVyUm9vdCgpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyUm9vdCA9IHRoaXMuc2hhZG93Um9vdCA/P1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3codGhpcy5jb25zdHJ1Y3Rvci5zaGFkb3dSb290T3B0aW9ucyk7XG4gICAgICAgIGFkb3B0U3R5bGVzKHJlbmRlclJvb3QsIHRoaXMuY29uc3RydWN0b3IuZWxlbWVudFN0eWxlcyk7XG4gICAgICAgIHJldHVybiByZW5kZXJSb290O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBmaXJzdCBjb25uZWN0aW9uLCBjcmVhdGVzIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdCwgc2V0cyB1cFxuICAgICAqIGVsZW1lbnQgc3R5bGluZywgYW5kIGVuYWJsZXMgdXBkYXRpbmcuXG4gICAgICogQGNhdGVnb3J5IGxpZmVjeWNsZVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAvLyBDcmVhdGUgcmVuZGVyUm9vdCBiZWZvcmUgY29udHJvbGxlcnMgYGhvc3RDb25uZWN0ZWRgXG4gICAgICAgIHRoaXMucmVuZGVyUm9vdCA/Pz1cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVuZGVyUm9vdCgpO1xuICAgICAgICB0aGlzLmVuYWJsZVVwZGF0aW5nKHRydWUpO1xuICAgICAgICB0aGlzLl9fY29udHJvbGxlcnM/LmZvckVhY2goKGMpID0+IGMuaG9zdENvbm5lY3RlZD8uKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RlLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY29uc2lkZXJlZCBmaW5hbCBhbmQgbm90IG92ZXJyaWRkZW4uIEl0IGlzXG4gICAgICogb3ZlcnJpZGRlbiBvbiB0aGUgZWxlbWVudCBpbnN0YW5jZSB3aXRoIGEgZnVuY3Rpb24gdGhhdCB0cmlnZ2VycyB0aGUgZmlyc3RcbiAgICAgKiB1cGRhdGUuXG4gICAgICogQGNhdGVnb3J5IHVwZGF0ZXNcbiAgICAgKi9cbiAgICBlbmFibGVVcGRhdGluZyhfcmVxdWVzdGVkVXBkYXRlKSB7IH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZm9yIGBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpYCBpbiBleHRlbnNpb25zIHdoaWxlXG4gICAgICogcmVzZXJ2aW5nIHRoZSBwb3NzaWJpbGl0eSBvZiBtYWtpbmcgbm9uLWJyZWFraW5nIGZlYXR1cmUgYWRkaXRpb25zXG4gICAgICogd2hlbiBkaXNjb25uZWN0aW5nIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBAY2F0ZWdvcnkgbGlmZWN5Y2xlXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX19jb250cm9sbGVycz8uZm9yRWFjaCgoYykgPT4gYy5ob3N0RGlzY29ubmVjdGVkPy4oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9uaXplcyBwcm9wZXJ0eSB2YWx1ZXMgd2hlbiBhdHRyaWJ1dGVzIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIFNwZWNpZmljYWxseSwgd2hlbiBhbiBhdHRyaWJ1dGUgaXMgc2V0LCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBpcyBzZXQuXG4gICAgICogWW91IHNob3VsZCByYXJlbHkgbmVlZCB0byBpbXBsZW1lbnQgdGhpcyBjYWxsYmFjay4gSWYgdGhpcyBtZXRob2QgaXNcbiAgICAgKiBvdmVycmlkZGVuLCBgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIF9vbGQsIHZhbHVlKWAgbXVzdCBiZVxuICAgICAqIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFNlZSBbcmVzcG9uZGluZyB0byBhdHRyaWJ1dGUgY2hhbmdlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9jb21wb25lbnRzL1VzaW5nX2N1c3RvbV9lbGVtZW50cyNyZXNwb25kaW5nX3RvX2F0dHJpYnV0ZV9jaGFuZ2VzKVxuICAgICAqIG9uIE1ETiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAgICogQGNhdGVnb3J5IGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgX29sZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fJGF0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBfX3Byb3BlcnR5VG9BdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZWxlbVByb3BlcnRpZXMgPSB0aGlzLmNvbnN0cnVjdG9yLmVsZW1lbnRQcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gZWxlbVByb3BlcnRpZXMuZ2V0KG5hbWUpO1xuICAgICAgICBjb25zdCBhdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlZmxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG9wdGlvbnMuY29udmVydGVyPy50b0F0dHJpYnV0ZSAhPT1cbiAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuY29udmVydGVyXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0Q29udmVydGVyO1xuICAgICAgICAgICAgY29uc3QgYXR0clZhbHVlID0gY29udmVydGVyLnRvQXR0cmlidXRlKHZhbHVlLCBvcHRpb25zLnR5cGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZW5hYmxlZFdhcm5pbmdzLmluY2x1ZGVzKCdtaWdyYXRpb24nKSAmJlxuICAgICAgICAgICAgICAgIGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXNzdWVXYXJuaW5nKCd1bmRlZmluZWQtYXR0cmlidXRlLXZhbHVlJywgYFRoZSBhdHRyaWJ1dGUgdmFsdWUgZm9yIHRoZSAke25hbWV9IHByb3BlcnR5IGlzIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdW5kZWZpbmVkIG9uIGVsZW1lbnQgJHt0aGlzLmxvY2FsTmFtZX0uIFRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHJlbW92ZWQsIGJ1dCBpbiB0aGUgcHJldmlvdXMgdmVyc2lvbiBvZiBcXGBSZWFjdGl2ZUVsZW1lbnRcXGAsIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdGhlIGF0dHJpYnV0ZSB3b3VsZCBub3QgaGF2ZSBjaGFuZ2VkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJhY2sgaWYgdGhlIHByb3BlcnR5IGlzIGJlaW5nIHJlZmxlY3RlZCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgcHJvcGVydHkgYWdhaW4gdmlhIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLiBOb3RlOlxuICAgICAgICAgICAgLy8gMS4gdGhpcyB0YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCB0aGUgY2FsbGJhY2sgaXMgc3luY2hyb25vdXMuXG4gICAgICAgICAgICAvLyAyLiB3aWxsIGJlaGF2ZSBpbmNvcnJlY3RseSBpZiBtdWx0aXBsZSBhdHRyaWJ1dGVzIGFyZSBpbiB0aGUgcmVhY3Rpb25cbiAgICAgICAgICAgIC8vIHN0YWNrIGF0IHRpbWUgb2YgY2FsbGluZy4gSG93ZXZlciwgc2luY2Ugd2UgcHJvY2VzcyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBpbiBgdXBkYXRlYCB0aGlzIHNob3VsZCBub3QgYmUgcG9zc2libGUgKG9yIGFuIGV4dHJlbWUgY29ybmVyIGNhc2VcbiAgICAgICAgICAgIC8vIHRoYXQgd2UnZCBsaWtlIHRvIGRpc2NvdmVyKS5cbiAgICAgICAgICAgIC8vIG1hcmsgc3RhdGUgcmVmbGVjdGluZ1xuICAgICAgICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0eSA9IG5hbWU7XG4gICAgICAgICAgICBpZiAoYXR0clZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIHN0YXRlIG5vdCByZWZsZWN0aW5nXG4gICAgICAgICAgICB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgXyRhdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAvLyBOb3RlLCBoaW50IHRoaXMgYXMgYW4gYEF0dHJpYnV0ZU1hcGAgc28gY2xvc3VyZSBjbGVhcmx5IHVuZGVyc3RhbmRzXG4gICAgICAgIC8vIHRoZSB0eXBlOyBpdCBoYXMgaXNzdWVzIHdpdGggdHJhY2tpbmcgdHlwZXMgdGhyb3VnaCBzdGF0aWNzXG4gICAgICAgIGNvbnN0IHByb3BOYW1lID0gY3Rvci5fX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAuZ2V0KG5hbWUpO1xuICAgICAgICAvLyBVc2UgdHJhY2tpbmcgaW5mbyB0byBhdm9pZCByZWZsZWN0aW5nIGEgcHJvcGVydHkgdmFsdWUgdG8gYW4gYXR0cmlidXRlXG4gICAgICAgIC8vIGlmIGl0IHdhcyBqdXN0IHNldCBiZWNhdXNlIHRoZSBhdHRyaWJ1dGUgY2hhbmdlZC5cbiAgICAgICAgaWYgKHByb3BOYW1lICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0eSAhPT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjdG9yLmdldFByb3BlcnR5T3B0aW9ucyhwcm9wTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5jb252ZXJ0ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHsgZnJvbUF0dHJpYnV0ZTogb3B0aW9ucy5jb252ZXJ0ZXIgfVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5jb252ZXJ0ZXI/LmZyb21BdHRyaWJ1dGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuY29udmVydGVyXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdENvbnZlcnRlcjtcbiAgICAgICAgICAgIC8vIG1hcmsgc3RhdGUgcmVmbGVjdGluZ1xuICAgICAgICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0eSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZXIuZnJvbUF0dHJpYnV0ZSh2YWx1ZSwgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID1cbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA/P1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVmYXVsdFZhbHVlcz8uZ2V0KHByb3BOYW1lKSA/P1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgICAgICAgIC8vIG1hcmsgc3RhdGUgbm90IHJlZmxlY3RpbmdcbiAgICAgICAgICAgIHRoaXMuX19yZWZsZWN0aW5nUHJvcGVydHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGFuIHVwZGF0ZSB3aGljaCBpcyBwcm9jZXNzZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgc2hvdWxkIGJlIGNhbGxlZFxuICAgICAqIHdoZW4gYW4gZWxlbWVudCBzaG91bGQgdXBkYXRlIGJhc2VkIG9uIHNvbWUgc3RhdGUgbm90IHRyaWdnZXJlZCBieSBzZXR0aW5nXG4gICAgICogYSByZWFjdGl2ZSBwcm9wZXJ0eS4gSW4gdGhpcyBjYXNlLCBwYXNzIG5vIGFyZ3VtZW50cy4gSXQgc2hvdWxkIGFsc28gYmVcbiAgICAgKiBjYWxsZWQgd2hlbiBtYW51YWxseSBpbXBsZW1lbnRpbmcgYSBwcm9wZXJ0eSBzZXR0ZXIuIEluIHRoaXMgY2FzZSwgcGFzcyB0aGVcbiAgICAgKiBwcm9wZXJ0eSBgbmFtZWAgYW5kIGBvbGRWYWx1ZWAgdG8gZW5zdXJlIHRoYXQgYW55IGNvbmZpZ3VyZWQgcHJvcGVydHlcbiAgICAgKiBvcHRpb25zIGFyZSBob25vcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiByZXF1ZXN0aW5nIHByb3BlcnR5XG4gICAgICogQHBhcmFtIG9sZFZhbHVlIG9sZCB2YWx1ZSBvZiByZXF1ZXN0aW5nIHByb3BlcnR5XG4gICAgICogQHBhcmFtIG9wdGlvbnMgcHJvcGVydHkgb3B0aW9ucyB0byB1c2UgaW5zdGVhZCBvZiB0aGUgcHJldmlvdXNseVxuICAgICAqICAgICBjb25maWd1cmVkIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gdXNlTmV3VmFsdWUgaWYgdHJ1ZSwgdGhlIG5ld1ZhbHVlIGFyZ3VtZW50IGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgICAqICAgICByZWFkaW5nIHRoZSBwcm9wZXJ0eSB2YWx1ZS4gVGhpcyBpcyBpbXBvcnRhbnQgdG8gdXNlIGlmIHRoZSByZWFjdGl2ZVxuICAgICAqICAgICBwcm9wZXJ0eSBpcyBhIHN0YW5kYXJkIHByaXZhdGUgYWNjZXNzb3IsIGFzIG9wcG9zZWQgdG8gYSBwbGFpblxuICAgICAqICAgICBwcm9wZXJ0eSwgc2luY2UgcHJpdmF0ZSBtZW1iZXJzIGNhbid0IGJlIGR5bmFtaWNhbGx5IHJlYWQgYnkgbmFtZS5cbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuIFRoaXMgaXMgb25seSB1c2VkIGlmXG4gICAgICogICAgIGB1c2VOZXdWYWx1ZWAgaXMgdHJ1ZS5cbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIHJlcXVlc3RVcGRhdGUobmFtZSwgb2xkVmFsdWUsIG9wdGlvbnMsIHVzZU5ld1ZhbHVlID0gZmFsc2UsIG5ld1ZhbHVlKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwcm9wZXJ0eSBrZXksIHBlcmZvcm0gcHJvcGVydHkgdXBkYXRlIHN0ZXBzLlxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobmFtZSBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaXNzdWVXYXJuaW5nKGBgLCBgVGhlIHJlcXVlc3RVcGRhdGUoKSBtZXRob2Qgd2FzIGNhbGxlZCB3aXRoIGFuIEV2ZW50IGFzIHRoZSBwcm9wZXJ0eSBuYW1lLiBUaGlzIGlzIHByb2JhYmx5IGEgbWlzdGFrZSBjYXVzZWQgYnkgYmluZGluZyB0aGlzLnJlcXVlc3RVcGRhdGUgYXMgYW4gZXZlbnQgbGlzdGVuZXIuIEluc3RlYWQgYmluZCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIGl0IHdpdGggbm8gYXJndW1lbnRzOiAoKSA9PiB0aGlzLnJlcXVlc3RVcGRhdGUoKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBpZiAodXNlTmV3VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA/Pz0gY3Rvci5nZXRQcm9wZXJ0eU9wdGlvbnMobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gKG9wdGlvbnMuaGFzQ2hhbmdlZCA/PyBub3RFcXVhbCkobmV3VmFsdWUsIG9sZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gY2hhbmdlLCBjaGVjayBhIGNvcm5lciBjYXNlIHRoYXQgY2FuIG9jY3VyIHdoZW5cbiAgICAgICAgICAgICAgICAvLyAxLiB0aGVyZSdzIGEgaW5pdGlhbCB2YWx1ZSB3aGljaCB3YXMgbm90IHJlZmxlY3RlZFxuICAgICAgICAgICAgICAgIC8vIDIuIHRoZSBwcm9wZXJ0eSBpcyBzdWJzZXF1ZW50bHkgc2V0IHRvIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGBwcm9wOiB7dXNlRGVmYXVsdDogdHJ1ZSwgcmVmbGVjdDogdHJ1ZX1gXG4gICAgICAgICAgICAgICAgLy8gYW5kIGVsLnByb3AgPSAnZm9vJy4gVGhpcyBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZSBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgaXMgbm90IHNldCBiZWNhdXNlIHdlIHdpbGwgbm93IHJlZmxlY3QgdGhlIHByb3BlcnR5IHRvIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMudXNlRGVmYXVsdCAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlZmxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPT09IHRoaXMuX19kZWZhdWx0VmFsdWVzPy5nZXQobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuaGFzQXR0cmlidXRlKGN0b3IuX19hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkobmFtZSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fJGNoYW5nZVByb3BlcnR5KG5hbWUsIG9sZFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFib3J0IHRoZSByZXF1ZXN0IGlmIHRoZSBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNVcGRhdGVQZW5kaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fX3VwZGF0ZVByb21pc2UgPSB0aGlzLl9fZW5xdWV1ZVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF8kY2hhbmdlUHJvcGVydHkobmFtZSwgb2xkVmFsdWUsIHsgdXNlRGVmYXVsdCwgcmVmbGVjdCwgd3JhcHBlZCB9LCBpbml0aWFsaXplVmFsdWUpIHtcbiAgICAgICAgLy8gUmVjb3JkIGRlZmF1bHQgdmFsdWUgd2hlbiB1c2VEZWZhdWx0IGlzIHVzZWQuIFRoaXMgYWxsb3dzIHVzIHRvXG4gICAgICAgIC8vIHJlc3RvcmUgdGhpcyB2YWx1ZSB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgcmVtb3ZlZC5cbiAgICAgICAgaWYgKHVzZURlZmF1bHQgJiYgISh0aGlzLl9fZGVmYXVsdFZhbHVlcyA/Pz0gbmV3IE1hcCgpKS5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWZhdWx0VmFsdWVzLnNldChuYW1lLCBpbml0aWFsaXplVmFsdWUgPz8gb2xkVmFsdWUgPz8gdGhpc1tuYW1lXSk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCB3cmFwcGluZyBhbiBhY2Nlc3NvciwgaXQgbXVzdCBiZSBhbiBpbml0aWFsIHNldHRpbmdcbiAgICAgICAgICAgIC8vIGFuZCBpbiB0aGlzIGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gcmVjb3JkIHRoZSBjaGFuZ2Ugb3IgcmVmbGVjdC5cbiAgICAgICAgICAgIGlmICh3cmFwcGVkICE9PSB0cnVlIHx8IGluaXRpYWxpemVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gKGp1c3RpbmZhZ25hbmkpOiBDcmVhdGUgYSBiZW5jaG1hcmsgb2YgTWFwLmhhcygpICsgTWFwLnNldChcbiAgICAgICAgLy8gdnMganVzdCBNYXAuc2V0KClcbiAgICAgICAgaWYgKCF0aGlzLl8kY2hhbmdlZFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBPbiB0aGUgaW5pdGlhbCBjaGFuZ2UsIHRoZSBvbGQgdmFsdWUgc2hvdWxkIGJlIGB1bmRlZmluZWRgLCBleGNlcHRcbiAgICAgICAgICAgIC8vIHdpdGggYHVzZURlZmF1bHRgXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzVXBkYXRlZCAmJiAhdXNlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fJGNoYW5nZWRQcm9wZXJ0aWVzLnNldChuYW1lLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRvIHJlZmxlY3RpbmcgcHJvcGVydGllcyBzZXQuXG4gICAgICAgIC8vIE5vdGUsIGl0J3MgaW1wb3J0YW50IHRoYXQgZXZlcnkgY2hhbmdlIGhhcyBhIGNoYW5jZSB0byBhZGQgdGhlXG4gICAgICAgIC8vIHByb3BlcnR5IHRvIGBfX3JlZmxlY3RpbmdQcm9wZXJ0aWVzYC4gVGhpcyBlbnN1cmVzIHNldHRpbmdcbiAgICAgICAgLy8gYXR0cmlidXRlICsgcHJvcGVydHkgcmVmbGVjdHMgY29ycmVjdGx5LlxuICAgICAgICBpZiAocmVmbGVjdCA9PT0gdHJ1ZSAmJiB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnR5ICE9PSBuYW1lKSB7XG4gICAgICAgICAgICAodGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID8/PSBuZXcgU2V0KCkpLmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBlbGVtZW50IHRvIGFzeW5jaHJvbm91c2x5IHVwZGF0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBfX2VucXVldWVVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuaXNVcGRhdGVQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbnkgcHJldmlvdXMgdXBkYXRlIGhhcyByZXNvbHZlZCBiZWZvcmUgdXBkYXRpbmcuXG4gICAgICAgICAgICAvLyBUaGlzIGBhd2FpdGAgYWxzbyBlbnN1cmVzIHRoYXQgcHJvcGVydHkgY2hhbmdlcyBhcmUgYmF0Y2hlZC5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX191cGRhdGVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBSZWZpcmUgYW55IHByZXZpb3VzIGVycm9ycyBhc3luYyBzbyB0aGV5IGRvIG5vdCBkaXNydXB0IHRoZSB1cGRhdGVcbiAgICAgICAgICAgIC8vIGN5Y2xlLiBFcnJvcnMgYXJlIHJlZmlyZWQgc28gZGV2ZWxvcGVycyBoYXZlIGEgY2hhbmNlIHRvIG9ic2VydmVcbiAgICAgICAgICAgIC8vIHRoZW0sIGFuZCB0aGlzIGNhbiBiZSBkb25lIGJ5IGltcGxlbWVudGluZ1xuICAgICAgICAgICAgLy8gYHdpbmRvdy5vbnVuaGFuZGxlZHJlamVjdGlvbmAuXG4gICAgICAgICAgICBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICAgIC8vIElmIGBzY2hlZHVsZVVwZGF0ZWAgcmV0dXJucyBhIFByb21pc2UsIHdlIGF3YWl0IGl0LiBUaGlzIGlzIGRvbmUgdG9cbiAgICAgICAgLy8gZW5hYmxlIGNvb3JkaW5hdGluZyB1cGRhdGVzIHdpdGggYSBzY2hlZHVsZXIuIE5vdGUsIHRoZSByZXN1bHQgaXNcbiAgICAgICAgLy8gY2hlY2tlZCB0byBhdm9pZCBkZWxheWluZyBhbiBhZGRpdGlvbmFsIG1pY3JvdGFzayB1bmxlc3Mgd2UgbmVlZCB0by5cbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLmlzVXBkYXRlUGVuZGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIGVsZW1lbnQgdXBkYXRlLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGVcbiAgICAgKiB0aW1pbmcgb2YgdXBkYXRlcyBieSByZXR1cm5pbmcgYSBQcm9taXNlLiBUaGUgdXBkYXRlIHdpbGwgYXdhaXQgdGhlXG4gICAgICogcmV0dXJuZWQgUHJvbWlzZSwgYW5kIHlvdSBzaG91bGQgcmVzb2x2ZSB0aGUgUHJvbWlzZSB0byBhbGxvdyB0aGUgdXBkYXRlXG4gICAgICogdG8gcHJvY2VlZC4gSWYgdGhpcyBtZXRob2QgaXMgb3ZlcnJpZGRlbiwgYHN1cGVyLnNjaGVkdWxlVXBkYXRlKClgXG4gICAgICogbXVzdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRvIHNjaGVkdWxlIHVwZGF0ZXMgdG8gb2NjdXIganVzdCBiZWZvcmUgdGhlIG5leHQgZnJhbWU6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIG92ZXJyaWRlIHByb3RlY3RlZCBhc3luYyBzY2hlZHVsZVVwZGF0ZSgpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICAgKiAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcmVzb2x2ZSgpKSk7XG4gICAgICogICBzdXBlci5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIHNjaGVkdWxlVXBkYXRlKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBlcmZvcm1VcGRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZW5hYmxlZFdhcm5pbmdzLmluY2x1ZGVzKCdhc3luYy1wZXJmb3JtLXVwZGF0ZScpICYmXG4gICAgICAgICAgICB0eXBlb2YgcmVzdWx0Py50aGVuID09PVxuICAgICAgICAgICAgICAgICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlzc3VlV2FybmluZygnYXN5bmMtcGVyZm9ybS11cGRhdGUnLCBgRWxlbWVudCAke3RoaXMubG9jYWxOYW1lfSByZXR1cm5lZCBhIFByb21pc2UgZnJvbSBwZXJmb3JtVXBkYXRlKCkuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIGJlaGF2aW9yIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBgICtcbiAgICAgICAgICAgICAgICBgdmVyc2lvbiBvZiBSZWFjdGl2ZUVsZW1lbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW4gZWxlbWVudCB1cGRhdGUuIE5vdGUsIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZHVyaW5nIHRoZVxuICAgICAqIHVwZGF0ZSwgYGZpcnN0VXBkYXRlZGAgYW5kIGB1cGRhdGVkYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBDYWxsIGBwZXJmb3JtVXBkYXRlKClgIHRvIGltbWVkaWF0ZWx5IHByb2Nlc3MgYSBwZW5kaW5nIHVwZGF0ZS4gVGhpcyBzaG91bGRcbiAgICAgKiBnZW5lcmFsbHkgbm90IGJlIG5lZWRlZCwgYnV0IGl0IGNhbiBiZSBkb25lIGluIHJhcmUgY2FzZXMgd2hlbiB5b3UgbmVlZCB0b1xuICAgICAqIHVwZGF0ZSBzeW5jaHJvbm91c2x5LlxuICAgICAqXG4gICAgICogQGNhdGVnb3J5IHVwZGF0ZXNcbiAgICAgKi9cbiAgICBwZXJmb3JtVXBkYXRlKCkge1xuICAgICAgICAvLyBBYm9ydCBhbnkgdXBkYXRlIGlmIG9uZSBpcyBub3QgcGVuZGluZyB3aGVuIHRoaXMgaXMgY2FsbGVkLlxuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgYHBlcmZvcm1VcGRhdGVgIGlzIGNhbGxlZCBlYXJseSB0byBcImZsdXNoXCJcbiAgICAgICAgLy8gdGhlIHVwZGF0ZS5cbiAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRlUGVuZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnTG9nRXZlbnQ/Lih7IGtpbmQ6ICd1cGRhdGUnIH0pO1xuICAgICAgICBpZiAoIXRoaXMuaGFzVXBkYXRlZCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHJlbmRlclJvb3QgYmVmb3JlIGZpcnN0IHVwZGF0ZS4gVGhpcyBvY2N1cnMgaW4gYGNvbm5lY3RlZENhbGxiYWNrYFxuICAgICAgICAgICAgLy8gYnV0IGlzIGRvbmUgaGVyZSB0byBzdXBwb3J0IG91dCBvZiB0cmVlIGNhbGxzIHRvIGBlbmFibGVVcGRhdGluZ2AvYHBlcmZvcm1VcGRhdGVgLlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJSb290ID8/PVxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVuZGVyUm9vdCgpO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFByb2R1Y2Ugd2FybmluZyBpZiBhbnkgcmVhY3RpdmUgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlIGFyZVxuICAgICAgICAgICAgICAgIC8vIHNoYWRvd2VkIGJ5IGNsYXNzIGZpZWxkcy4gSW5zdGFuY2UgZmllbGRzIHNldCBiZWZvcmUgdXBncmFkZSBhcmVcbiAgICAgICAgICAgICAgICAvLyBkZWxldGVkIGJ5IHRoaXMgcG9pbnQsIHNvIGFueSBvd24gcHJvcGVydHkgaXMgY2F1c2VkIGJ5IGNsYXNzIGZpZWxkXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgICAgIGNvbnN0IGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd2VkUHJvcGVydGllcyA9IFsuLi5jdG9yLmVsZW1lbnRQcm9wZXJ0aWVzLmtleXMoKV0uZmlsdGVyKChwKSA9PiB0aGlzLmhhc093blByb3BlcnR5KHApICYmIHAgaW4gZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIG9uIGVsZW1lbnQgJHt0aGlzLmxvY2FsTmFtZX0gd2lsbCBub3QgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgdHJpZ2dlciB1cGRhdGVzIGFzIGV4cGVjdGVkIGJlY2F1c2UgdGhleSBhcmUgc2V0IHVzaW5nIGNsYXNzIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGZpZWxkczogJHtzaGFkb3dlZFByb3BlcnRpZXMuam9pbignLCAnKX0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYE5hdGl2ZSBjbGFzcyBmaWVsZHMgYW5kIHNvbWUgY29tcGlsZWQgb3V0cHV0IHdpbGwgb3ZlcndyaXRlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGFjY2Vzc29ycyB1c2VkIGZvciBkZXRlY3RpbmcgY2hhbmdlcy4gU2VlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGh0dHBzOi8vbGl0LmRldi9tc2cvY2xhc3MtZmllbGQtc2hhZG93aW5nIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGZvciBtb3JlIGluZm9ybWF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1peGluIGluc3RhbmNlIHByb3BlcnRpZXMgb25jZSwgaWYgdGhleSBleGlzdC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9faW5zdGFuY2VQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyAoanVzdGluZmFnbmFuaSk6IHNob3VsZCB3ZSB1c2UgdGhlIHN0b3JlZCB2YWx1ZT8gQ291bGQgYSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGJlZW4gc2V0IHNpbmNlIHdlIHN0b3JlZCB0aGUgb3duIHByb3BlcnR5IHZhbHVlP1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3AsIHZhbHVlXSBvZiB0aGlzLl9faW5zdGFuY2VQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fX2luc3RhbmNlUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCB2YWx1ZSByZWZsZWN0aW9uIGFuZCBwb3B1bGF0ZSB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgLy8gYGNoYW5nZWRQcm9wZXJ0aWVzYCBtYXAsIGJ1dCBvbmx5IGZvciB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIHZpYSBgY3JlYXRlUHJvcGVydHlgIG9uIGFjY2Vzc29ycywgd2hpY2ggd2lsbCBub3QgaGF2ZSBhbHJlYWR5XG4gICAgICAgICAgICAvLyBwb3B1bGF0ZWQgdGhlIGBjaGFuZ2VkUHJvcGVydGllc2AgbWFwIHNpbmNlIHRoZXkgYXJlIG5vdCBzZXQuXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBrbm93IGlmIHRoZXNlIGFjY2Vzc29ycyBoYWQgaW5pdGlhbGl6ZXJzLCBzbyB3ZSBqdXN0IHNldFxuICAgICAgICAgICAgLy8gdGhlbSBhbnl3YXkgLSBhIGRpZmZlcmVuY2UgZnJvbSBleHBlcmltZW50YWwgZGVjb3JhdG9ycyBvbiBmaWVsZHMgYW5kXG4gICAgICAgICAgICAvLyBzdGFuZGFyZCBkZWNvcmF0b3JzIG9uIGF1dG8tYWNjZXNzb3JzLlxuICAgICAgICAgICAgLy8gRm9yIGNvbnRleHQgc2VlOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpdC9saXQvcHVsbC80MTgzI2lzc3VlY29tbWVudC0xNzExOTU5NjM1XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50UHJvcGVydGllcyA9IHRoaXMuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAuZWxlbWVudFByb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFByb3BlcnRpZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtwLCBvcHRpb25zXSBvZiBlbGVtZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdyYXBwZWQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1twXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdyYXBwZWQgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl8kY2hhbmdlZFByb3BlcnRpZXMuaGFzKHApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl8kY2hhbmdlUHJvcGVydHkocCwgdW5kZWZpbmVkLCBvcHRpb25zLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGFuZ2VkUHJvcGVydGllcyA9IHRoaXMuXyRjaGFuZ2VkUHJvcGVydGllcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IHRoaXMuc2hvdWxkVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpbGxVcGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19jb250cm9sbGVycz8uZm9yRWFjaCgoYykgPT4gYy5ob3N0VXBkYXRlPy4oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX21hcmtVcGRhdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgYGZpcnN0VXBkYXRlZGAgYW5kIGB1cGRhdGVkYCBmcm9tIHJ1bm5pbmcgd2hlbiB0aGVyZSdzIGFuXG4gICAgICAgICAgICAvLyB1cGRhdGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBFbnN1cmUgZWxlbWVudCBjYW4gYWNjZXB0IGFkZGl0aW9uYWwgdXBkYXRlcyBhZnRlciBhbiBleGNlcHRpb24uXG4gICAgICAgICAgICB0aGlzLl9fbWFya1VwZGF0ZWQoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHVwZGF0ZSBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBwZW5kaW5nIGFuZCBmdXJ0aGVyIHVwZGF0ZXMgYXJlIG5vdyBhbGxvd2VkLlxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl8kZGlkVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIGJlZm9yZSBgdXBkYXRlKClgIHRvIGNvbXB1dGUgdmFsdWVzIG5lZWRlZCBkdXJpbmcgdGhlIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudCBgd2lsbFVwZGF0ZWAgdG8gY29tcHV0ZSBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBkZXBlbmQgb24gb3RoZXJcbiAgICAgKiBwcm9wZXJ0aWVzIGFuZCBhcmUgdXNlZCBpbiB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHdpbGxVcGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgKiAgIC8vIG9ubHkgbmVlZCB0byBjaGVjayBjaGFuZ2VkIHByb3BlcnRpZXMgZm9yIGFuIGV4cGVuc2l2ZSBjb21wdXRhdGlvbi5cbiAgICAgKiAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ2ZpcnN0TmFtZScpIHx8IGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnbGFzdE5hbWUnKSkge1xuICAgICAqICAgICB0aGlzLnNoYSA9IGNvbXB1dGVTSEEoYCR7dGhpcy5maXJzdE5hbWV9ICR7dGhpcy5sYXN0TmFtZX1gKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiByZW5kZXIoKSB7XG4gICAgICogICByZXR1cm4gaHRtbGBTSEE6ICR7dGhpcy5zaGF9YDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIHdpbGxVcGRhdGUoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7IH1cbiAgICAvLyBOb3RlLCB0aGlzIGlzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwb2x5ZmlsbC1zdXBwb3J0LlxuICAgIC8vIEBpbnRlcm5hbFxuICAgIF8kZGlkVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuX19jb250cm9sbGVycz8uZm9yRWFjaCgoYykgPT4gYy5ob3N0VXBkYXRlZD8uKCkpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzVXBkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5oYXNVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RVcGRhdGVkKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICBpZiAodGhpcy5pc1VwZGF0ZVBlbmRpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuZW5hYmxlZFdhcm5pbmdzLmluY2x1ZGVzKCdjaGFuZ2UtaW4tdXBkYXRlJykpIHtcbiAgICAgICAgICAgIGlzc3VlV2FybmluZygnY2hhbmdlLWluLXVwZGF0ZScsIGBFbGVtZW50ICR7dGhpcy5sb2NhbE5hbWV9IHNjaGVkdWxlZCBhbiB1cGRhdGUgYCArXG4gICAgICAgICAgICAgICAgYChnZW5lcmFsbHkgYmVjYXVzZSBhIHByb3BlcnR5IHdhcyBzZXQpIGAgK1xuICAgICAgICAgICAgICAgIGBhZnRlciBhbiB1cGRhdGUgY29tcGxldGVkLCBjYXVzaW5nIGEgbmV3IHVwZGF0ZSB0byBiZSBzY2hlZHVsZWQuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIGlzIGluZWZmaWNpZW50IGFuZCBzaG91bGQgYmUgYXZvaWRlZCB1bmxlc3MgdGhlIG5leHQgdXBkYXRlIGAgK1xuICAgICAgICAgICAgICAgIGBjYW4gb25seSBiZSBzY2hlZHVsZWQgYXMgYSBzaWRlIGVmZmVjdCBvZiB0aGUgcHJldmlvdXMgdXBkYXRlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9fbWFya1VwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuXyRjaGFuZ2VkUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc1VwZGF0ZVBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBlbGVtZW50IGhhcyBjb21wbGV0ZWQgdXBkYXRpbmcuXG4gICAgICogVGhlIFByb21pc2UgdmFsdWUgaXMgYSBib29sZWFuIHRoYXQgaXMgYHRydWVgIGlmIHRoZSBlbGVtZW50IGNvbXBsZXRlZCB0aGVcbiAgICAgKiB1cGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFub3RoZXIgdXBkYXRlLiBUaGUgUHJvbWlzZSByZXN1bHQgaXMgYGZhbHNlYCBpZlxuICAgICAqIGEgcHJvcGVydHkgd2FzIHNldCBpbnNpZGUgYHVwZGF0ZWQoKWAuIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBhblxuICAgICAqIGV4Y2VwdGlvbiB3YXMgdGhyb3duIGR1cmluZyB0aGUgdXBkYXRlLlxuICAgICAqXG4gICAgICogVG8gYXdhaXQgYWRkaXRpb25hbCBhc3luY2hyb25vdXMgd29yaywgb3ZlcnJpZGUgdGhlIGBnZXRVcGRhdGVDb21wbGV0ZWBcbiAgICAgKiBtZXRob2QuIEZvciBleGFtcGxlLCBpdCBpcyBzb21ldGltZXMgdXNlZnVsIHRvIGF3YWl0IGEgcmVuZGVyZWQgZWxlbWVudFxuICAgICAqIGJlZm9yZSBmdWxmaWxsaW5nIHRoaXMgUHJvbWlzZS4gVG8gZG8gdGhpcywgZmlyc3QgYXdhaXRcbiAgICAgKiBgc3VwZXIuZ2V0VXBkYXRlQ29tcGxldGUoKWAsIHRoZW4gYW55IHN1YnNlcXVlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSBvZiBhIGJvb2xlYW4gdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSB1cGRhdGUgY29tcGxldGVkXG4gICAgICogICAgIHdpdGhvdXQgdHJpZ2dlcmluZyBhbm90aGVyIHVwZGF0ZS5cbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIGdldCB1cGRhdGVDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIHRoZSBgdXBkYXRlQ29tcGxldGVgIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBJdCBpcyBub3Qgc2FmZSB0byBvdmVycmlkZSB0aGUgYHVwZGF0ZUNvbXBsZXRlYCBnZXR0ZXIgZGlyZWN0bHkgZHVlIHRvIGFcbiAgICAgKiBsaW1pdGF0aW9uIGluIFR5cGVTY3JpcHQgd2hpY2ggbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGNhbGwgYVxuICAgICAqIHN1cGVyY2xhc3MgZ2V0dGVyIChlLmcuIGBzdXBlci51cGRhdGVDb21wbGV0ZS50aGVuKC4uLilgKSB3aGVuIHRoZSB0YXJnZXRcbiAgICAgKiBsYW5ndWFnZSBpcyBFUzUgKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzM4KS5cbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbnN0ZWFkLiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgICogICBvdmVycmlkZSBhc3luYyBnZXRVcGRhdGVDb21wbGV0ZSgpIHtcbiAgICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwZXIuZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICAgKiAgICAgYXdhaXQgdGhpcy5fbXlDaGlsZC51cGRhdGVDb21wbGV0ZTtcbiAgICAgKiAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSBvZiBhIGJvb2xlYW4gdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSB1cGRhdGUgY29tcGxldGVkXG4gICAgICogICAgIHdpdGhvdXQgdHJpZ2dlcmluZyBhbm90aGVyIHVwZGF0ZS5cbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIGdldFVwZGF0ZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3VwZGF0ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGB1cGRhdGUoKWAgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBlbGVtZW50IHJlcXVlc3RzXG4gICAgICogYW4gdXBkYXRlLiBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAsIGJ1dCB0aGlzIGNhbiBiZVxuICAgICAqIGN1c3RvbWl6ZWQgdG8gY29udHJvbCB3aGVuIHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIHNob3VsZFVwZGF0ZShfY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGVsZW1lbnQuIFRoaXMgbWV0aG9kIHJlZmxlY3RzIHByb3BlcnR5IHZhbHVlcyB0byBhdHRyaWJ1dGVzLlxuICAgICAqIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIHJlbmRlciBhbmQga2VlcCB1cGRhdGVkIGVsZW1lbnQgRE9NLlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCAqbm90KiB0cmlnZ2VyXG4gICAgICogYW5vdGhlciB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX2NoYW5nZWRQcm9wZXJ0aWVzIE1hcCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgd2l0aCBvbGQgdmFsdWVzXG4gICAgICogQGNhdGVnb3J5IHVwZGF0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGUoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIFRoZSBmb3JFYWNoKCkgZXhwcmVzc2lvbiB3aWxsIG9ubHkgcnVuIHdoZW4gX19yZWZsZWN0aW5nUHJvcGVydGllcyBpc1xuICAgICAgICAvLyBkZWZpbmVkLCBhbmQgaXQgcmV0dXJucyB1bmRlZmluZWQsIHNldHRpbmcgX19yZWZsZWN0aW5nUHJvcGVydGllcyB0b1xuICAgICAgICAvLyB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0aWVzICYmPSB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnRpZXMuZm9yRWFjaCgocCkgPT4gdGhpcy5fX3Byb3BlcnR5VG9BdHRyaWJ1dGUocCwgdGhpc1twXSkpO1xuICAgICAgICB0aGlzLl9fbWFya1VwZGF0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuZXZlciB0aGUgZWxlbWVudCBpcyB1cGRhdGVkLiBJbXBsZW1lbnQgdG8gcGVyZm9ybVxuICAgICAqIHBvc3QtdXBkYXRpbmcgdGFza3MgdmlhIERPTSBBUElzLCBmb3IgZXhhbXBsZSwgZm9jdXNpbmcgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCB0cmlnZ2VyIHRoZSBlbGVtZW50IHRvIHVwZGF0ZVxuICAgICAqIGFnYWluIGFmdGVyIHRoaXMgdXBkYXRlIGN5Y2xlIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIHVwZGF0ZWQoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7IH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGVsZW1lbnQgaXMgZmlyc3QgdXBkYXRlZC4gSW1wbGVtZW50IHRvIHBlcmZvcm0gb25lIHRpbWVcbiAgICAgKiB3b3JrIG9uIHRoZSBlbGVtZW50IGFmdGVyIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogZmlyc3RVcGRhdGVkKCkge1xuICAgICAqICAgdGhpcy5yZW5kZXJSb290LmdldEVsZW1lbnRCeUlkKCdteS10ZXh0LWFyZWEnKS5mb2N1cygpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCB0cmlnZ2VyIHRoZSBlbGVtZW50IHRvIHVwZGF0ZVxuICAgICAqIGFnYWluIGFmdGVyIHRoaXMgdXBkYXRlIGN5Y2xlIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIGZpcnN0VXBkYXRlZChfY2hhbmdlZFByb3BlcnRpZXMpIHsgfVxufVxuLyoqXG4gKiBNZW1vaXplZCBsaXN0IG9mIGFsbCBlbGVtZW50IHN0eWxlcy5cbiAqIENyZWF0ZWQgbGF6aWx5IG9uIHVzZXIgc3ViY2xhc3NlcyB3aGVuIGZpbmFsaXppbmcgdGhlIGNsYXNzLlxuICogQG5vY29sbGFwc2VcbiAqIEBjYXRlZ29yeSBzdHlsZXNcbiAqL1xuUmVhY3RpdmVFbGVtZW50LmVsZW1lbnRTdHlsZXMgPSBbXTtcbi8qKlxuICogT3B0aW9ucyB1c2VkIHdoZW4gY2FsbGluZyBgYXR0YWNoU2hhZG93YC4gU2V0IHRoaXMgcHJvcGVydHkgdG8gY3VzdG9taXplXG4gKiB0aGUgb3B0aW9ucyBmb3IgdGhlIHNoYWRvd1Jvb3Q7IGZvciBleGFtcGxlLCB0byBjcmVhdGUgYSBjbG9zZWRcbiAqIHNoYWRvd1Jvb3Q6IGB7bW9kZTogJ2Nsb3NlZCd9YC5cbiAqXG4gKiBOb3RlLCB0aGVzZSBvcHRpb25zIGFyZSB1c2VkIGluIGBjcmVhdGVSZW5kZXJSb290YC4gSWYgdGhpcyBtZXRob2RcbiAqIGlzIGN1c3RvbWl6ZWQsIG9wdGlvbnMgc2hvdWxkIGJlIHJlc3BlY3RlZCBpZiBwb3NzaWJsZS5cbiAqIEBub2NvbGxhcHNlXG4gKiBAY2F0ZWdvcnkgcmVuZGVyaW5nXG4gKi9cblJlYWN0aXZlRWxlbWVudC5zaGFkb3dSb290T3B0aW9ucyA9IHsgbW9kZTogJ29wZW4nIH07XG4vLyBBc3NpZ25lZCBoZXJlIHRvIHdvcmsgYXJvdW5kIGEganNjb21waWxlciBidWcgd2l0aCBzdGF0aWMgZmllbGRzXG4vLyB3aGVuIGNvbXBpbGluZyB0byBFUzUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMxNzdcblJlYWN0aXZlRWxlbWVudFtKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdlbGVtZW50UHJvcGVydGllcycpXSA9IG5ldyBNYXAoKTtcblJlYWN0aXZlRWxlbWVudFtKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdmaW5hbGl6ZWQnKV0gPSBuZXcgTWFwKCk7XG4vLyBBcHBseSBwb2x5ZmlsbHMgaWYgYXZhaWxhYmxlXG5wb2x5ZmlsbFN1cHBvcnQ/Lih7IFJlYWN0aXZlRWxlbWVudCB9KTtcbi8vIERldiBtb2RlIHdhcm5pbmdzLi4uXG57XG4gICAgLy8gRGVmYXVsdCB3YXJuaW5nIHNldC5cbiAgICBSZWFjdGl2ZUVsZW1lbnQuZW5hYmxlZFdhcm5pbmdzID0gW1xuICAgICAgICAnY2hhbmdlLWluLXVwZGF0ZScsXG4gICAgICAgICdhc3luYy1wZXJmb3JtLXVwZGF0ZScsXG4gICAgXTtcbiAgICBjb25zdCBlbnN1cmVPd25XYXJuaW5ncyA9IGZ1bmN0aW9uIChjdG9yKSB7XG4gICAgICAgIGlmICghY3Rvci5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdlbmFibGVkV2FybmluZ3MnKSkpIHtcbiAgICAgICAgICAgIGN0b3IuZW5hYmxlZFdhcm5pbmdzID0gY3Rvci5lbmFibGVkV2FybmluZ3Muc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3RpdmVFbGVtZW50LmVuYWJsZVdhcm5pbmcgPSBmdW5jdGlvbiAod2FybmluZykge1xuICAgICAgICBlbnN1cmVPd25XYXJuaW5ncyh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWRXYXJuaW5ncy5pbmNsdWRlcyh3YXJuaW5nKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkV2FybmluZ3MucHVzaCh3YXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3RpdmVFbGVtZW50LmRpc2FibGVXYXJuaW5nID0gZnVuY3Rpb24gKHdhcm5pbmcpIHtcbiAgICAgICAgZW5zdXJlT3duV2FybmluZ3ModGhpcyk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmVuYWJsZWRXYXJuaW5ncy5pbmRleE9mKHdhcm5pbmcpO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWRXYXJuaW5ncy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gSU1QT1JUQU5UOiBkbyBub3QgY2hhbmdlIHRoZSBwcm9wZXJ0eSBuYW1lIG9yIHRoZSBhc3NpZ25tZW50IGV4cHJlc3Npb24uXG4vLyBUaGlzIGxpbmUgd2lsbCBiZSB1c2VkIGluIHJlZ2V4ZXMgdG8gc2VhcmNoIGZvciBSZWFjdGl2ZUVsZW1lbnQgdXNhZ2UuXG4oZ2xvYmFsLnJlYWN0aXZlRWxlbWVudFZlcnNpb25zID8/PSBbXSkucHVzaCgnMi4xLjInKTtcbmlmIChnbG9iYWwucmVhY3RpdmVFbGVtZW50VmVyc2lvbnMubGVuZ3RoID4gMSkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgaXNzdWVXYXJuaW5nKCdtdWx0aXBsZS12ZXJzaW9ucycsIGBNdWx0aXBsZSB2ZXJzaW9ucyBvZiBMaXQgbG9hZGVkLiBMb2FkaW5nIG11bHRpcGxlIHZlcnNpb25zIGAgK1xuICAgICAgICAgICAgYGlzIG5vdCByZWNvbW1lbmRlZC5gKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgUmVhY3RpdmVFbGVtZW50LCBhZG9wdFN0eWxlcywgZGVmYXVsdENvbnZlcnRlciwgZ2V0Q29tcGF0aWJsZVN0eWxlLCBub3RFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3RpdmUtZWxlbWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjdXN0b21FbGVtZW50cyIsIkhUTUxFbGVtZW50IiwiZ2V0Q29tcGF0aWJsZVN0eWxlIiwiYWRvcHRTdHlsZXMiLCJDU1NSZXN1bHQiLCJjc3MiLCJzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMiLCJ1bnNhZmVDU1MiLCJpcyIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFByb3RvdHlwZU9mIiwiT2JqZWN0IiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsImlzc3VlV2FybmluZyIsInRydXN0ZWRUeXBlcyIsImVtcHR5U3RyaW5nRm9yQm9vbGVhbkF0dHJpYnV0ZSIsImVtcHR5U2NyaXB0IiwicG9seWZpbGxTdXBwb3J0IiwicmVhY3RpdmVFbGVtZW50UG9seWZpbGxTdXBwb3J0RGV2TW9kZSIsImxpdElzc3VlZFdhcm5pbmdzIiwiU2V0IiwiY29kZSIsIndhcm5pbmciLCJoYXMiLCJjb25zb2xlIiwid2FybiIsImFkZCIsInF1ZXVlTWljcm90YXNrIiwiU2hhZHlET00iLCJpblVzZSIsInVuZGVmaW5lZCIsImRlYnVnTG9nRXZlbnQiLCJldmVudCIsInNob3VsZEVtaXQiLCJlbWl0TGl0RGVidWdMb2dFdmVudHMiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5IiwicHJvcCIsIl9vYmoiLCJkZWZhdWx0Q29udmVydGVyIiwidG9BdHRyaWJ1dGUiLCJ2YWx1ZSIsInR5cGUiLCJCb29sZWFuIiwiQXJyYXkiLCJKU09OIiwic3RyaW5naWZ5IiwiZnJvbUF0dHJpYnV0ZSIsImZyb21WYWx1ZSIsIk51bWJlciIsInBhcnNlIiwiZSIsIm5vdEVxdWFsIiwib2xkIiwiZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb24iLCJhdHRyaWJ1dGUiLCJTdHJpbmciLCJjb252ZXJ0ZXIiLCJyZWZsZWN0IiwidXNlRGVmYXVsdCIsImhhc0NoYW5nZWQiLCJTeW1ib2wiLCJtZXRhZGF0YSIsImxpdFByb3BlcnR5TWV0YWRhdGEiLCJXZWFrTWFwIiwiUmVhY3RpdmVFbGVtZW50IiwiYWRkSW5pdGlhbGl6ZXIiLCJpbml0aWFsaXplciIsIl9fcHJlcGFyZSIsIl9pbml0aWFsaXplcnMiLCJwdXNoIiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiZmluYWxpemUiLCJfX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAiLCJrZXlzIiwiY3JlYXRlUHJvcGVydHkiLCJuYW1lIiwib3B0aW9ucyIsInN0YXRlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjcmVhdGUiLCJ3cmFwcGVkIiwiZWxlbWVudFByb3BlcnRpZXMiLCJzZXQiLCJub0FjY2Vzc29yIiwia2V5IiwiZm9yIiwiZGVzY3JpcHRvciIsImdldFByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsInYiLCJFcnJvciIsIm9sZFZhbHVlIiwiY2FsbCIsInJlcXVlc3RVcGRhdGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0UHJvcGVydHlPcHRpb25zIiwic3VwZXJDdG9yIiwiTWFwIiwiZmluYWxpemVkIiwicHJvcHMiLCJwcm9wZXJ0aWVzIiwicHJvcEtleXMiLCJwIiwiYXR0ciIsIl9fYXR0cmlidXRlTmFtZUZvclByb3BlcnR5IiwiZWxlbWVudFN0eWxlcyIsImZpbmFsaXplU3R5bGVzIiwic3R5bGVzIiwiaXNBcnJheSIsImZsYXQiLCJJbmZpbml0eSIsInJldmVyc2UiLCJzIiwidW5zaGlmdCIsInRvTG93ZXJDYXNlIiwiY29uc3RydWN0b3IiLCJfX2luc3RhbmNlUHJvcGVydGllcyIsImlzVXBkYXRlUGVuZGluZyIsImhhc1VwZGF0ZWQiLCJfX3JlZmxlY3RpbmdQcm9wZXJ0eSIsIl9faW5pdGlhbGl6ZSIsIl9fdXBkYXRlUHJvbWlzZSIsIlByb21pc2UiLCJyZXMiLCJlbmFibGVVcGRhdGluZyIsIl8kY2hhbmdlZFByb3BlcnRpZXMiLCJfX3NhdmVJbnN0YW5jZVByb3BlcnRpZXMiLCJmb3JFYWNoIiwiaSIsImFkZENvbnRyb2xsZXIiLCJjb250cm9sbGVyIiwiX19jb250cm9sbGVycyIsInJlbmRlclJvb3QiLCJpc0Nvbm5lY3RlZCIsImhvc3RDb25uZWN0ZWQiLCJyZW1vdmVDb250cm9sbGVyIiwiZGVsZXRlIiwiaW5zdGFuY2VQcm9wZXJ0aWVzIiwic2l6ZSIsImNyZWF0ZVJlbmRlclJvb3QiLCJzaGFkb3dSb290IiwiYXR0YWNoU2hhZG93Iiwic2hhZG93Um9vdE9wdGlvbnMiLCJjb25uZWN0ZWRDYWxsYmFjayIsImMiLCJfcmVxdWVzdGVkVXBkYXRlIiwiZGlzY29ubmVjdGVkQ2FsbGJhY2siLCJob3N0RGlzY29ubmVjdGVkIiwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIiwiX29sZCIsIl8kYXR0cmlidXRlVG9Qcm9wZXJ0eSIsIl9fcHJvcGVydHlUb0F0dHJpYnV0ZSIsImVsZW1Qcm9wZXJ0aWVzIiwiYXR0clZhbHVlIiwiZW5hYmxlZFdhcm5pbmdzIiwiaW5jbHVkZXMiLCJsb2NhbE5hbWUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJjdG9yIiwicHJvcE5hbWUiLCJjb252ZXJ0ZWRWYWx1ZSIsIl9fZGVmYXVsdFZhbHVlcyIsInVzZU5ld1ZhbHVlIiwibmV3VmFsdWUiLCJFdmVudCIsImNoYW5nZWQiLCJoYXNBdHRyaWJ1dGUiLCJfJGNoYW5nZVByb3BlcnR5IiwiX19lbnF1ZXVlVXBkYXRlIiwiaW5pdGlhbGl6ZVZhbHVlIiwiX19yZWZsZWN0aW5nUHJvcGVydGllcyIsInJlamVjdCIsInJlc3VsdCIsInNjaGVkdWxlVXBkYXRlIiwicGVyZm9ybVVwZGF0ZSIsInRoZW4iLCJraW5kIiwic2hhZG93ZWRQcm9wZXJ0aWVzIiwiZmlsdGVyIiwibGVuZ3RoIiwiam9pbiIsInNob3VsZFVwZGF0ZSIsImNoYW5nZWRQcm9wZXJ0aWVzIiwid2lsbFVwZGF0ZSIsImhvc3RVcGRhdGUiLCJ1cGRhdGUiLCJfX21hcmtVcGRhdGVkIiwiXyRkaWRVcGRhdGUiLCJfY2hhbmdlZFByb3BlcnRpZXMiLCJob3N0VXBkYXRlZCIsImZpcnN0VXBkYXRlZCIsInVwZGF0ZWQiLCJ1cGRhdGVDb21wbGV0ZSIsImdldFVwZGF0ZUNvbXBsZXRlIiwibW9kZSIsImVuc3VyZU93bldhcm5pbmdzIiwic2xpY2UiLCJlbmFibGVXYXJuaW5nIiwiZGlzYWJsZVdhcm5pbmciLCJpbmRleE9mIiwic3BsaWNlIiwicmVhY3RpdmVFbGVtZW50VmVyc2lvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/reactive-element.js\n");

/***/ })

};
;