"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pdf-lib";
exports.ids = ["vendor-chunks/@pdf-lib"];
exports.modules = {

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Encoding.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Encoding.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Encodings: () => (/* binding */ Encodings)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/utils.js\");\n/* harmony import */ var _all_encodings_compressed_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./all-encodings.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/all-encodings.compressed.json\");\n/* tslint:disable max-classes-per-file */ \n\nvar decompressedEncodings = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.decompressJson)(_all_encodings_compressed_json__WEBPACK_IMPORTED_MODULE_1__);\nvar allUnicodeMappings = JSON.parse(decompressedEncodings);\nvar Encoding = /** @class */ function() {\n    function Encoding(name, unicodeMappings) {\n        var _this = this;\n        this.canEncodeUnicodeCodePoint = function(codePoint) {\n            return codePoint in _this.unicodeMappings;\n        };\n        this.encodeUnicodeCodePoint = function(codePoint) {\n            var mapped = _this.unicodeMappings[codePoint];\n            if (!mapped) {\n                var str = String.fromCharCode(codePoint);\n                var hexCode = \"0x\" + (0,_utils__WEBPACK_IMPORTED_MODULE_0__.padStart)(codePoint.toString(16), 4, \"0\");\n                var msg = _this.name + ' cannot encode \"' + str + '\" (' + hexCode + \")\";\n                throw new Error(msg);\n            }\n            return {\n                code: mapped[0],\n                name: mapped[1]\n            };\n        };\n        this.name = name;\n        this.supportedCodePoints = Object.keys(unicodeMappings).map(Number).sort(function(a, b) {\n            return a - b;\n        });\n        this.unicodeMappings = unicodeMappings;\n    }\n    return Encoding;\n}();\nvar Encodings = {\n    Symbol: new Encoding(\"Symbol\", allUnicodeMappings.symbol),\n    ZapfDingbats: new Encoding(\"ZapfDingbats\", allUnicodeMappings.zapfdingbats),\n    WinAnsi: new Encoding(\"WinAnsi\", allUnicodeMappings.win1252)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvRW5jb2RpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsdUNBQXVDLEdBQ1k7QUFDa0I7QUFDckUsSUFBSUcsd0JBQXdCSCxzREFBY0EsQ0FBQ0UsMkRBQXNCQTtBQUNqRSxJQUFJRSxxQkFBcUJDLEtBQUtDLEtBQUssQ0FBQ0g7QUFDcEMsSUFBSUksV0FBVyxXQUFXLEdBQUk7SUFDMUIsU0FBU0EsU0FBU0MsSUFBSSxFQUFFQyxlQUFlO1FBQ25DLElBQUlDLFFBQVEsSUFBSTtRQUNoQixJQUFJLENBQUNDLHlCQUF5QixHQUFHLFNBQVVDLFNBQVM7WUFDaEQsT0FBT0EsYUFBYUYsTUFBTUQsZUFBZTtRQUM3QztRQUNBLElBQUksQ0FBQ0ksc0JBQXNCLEdBQUcsU0FBVUQsU0FBUztZQUM3QyxJQUFJRSxTQUFTSixNQUFNRCxlQUFlLENBQUNHLFVBQVU7WUFDN0MsSUFBSSxDQUFDRSxRQUFRO2dCQUNULElBQUlDLE1BQU1DLE9BQU9DLFlBQVksQ0FBQ0w7Z0JBQzlCLElBQUlNLFVBQVUsT0FBT2pCLGdEQUFRQSxDQUFDVyxVQUFVTyxRQUFRLENBQUMsS0FBSyxHQUFHO2dCQUN6RCxJQUFJQyxNQUFNVixNQUFNRixJQUFJLEdBQUcscUJBQXNCTyxNQUFNLFFBQVNHLFVBQVU7Z0JBQ3RFLE1BQU0sSUFBSUcsTUFBTUQ7WUFDcEI7WUFDQSxPQUFPO2dCQUFFRSxNQUFNUixNQUFNLENBQUMsRUFBRTtnQkFBRU4sTUFBTU0sTUFBTSxDQUFDLEVBQUU7WUFBQztRQUM5QztRQUNBLElBQUksQ0FBQ04sSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2UsbUJBQW1CLEdBQUdDLE9BQU9DLElBQUksQ0FBQ2hCLGlCQUNsQ2lCLEdBQUcsQ0FBQ0MsUUFDSkMsSUFBSSxDQUFDLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztZQUFJLE9BQU9ELElBQUlDO1FBQUc7UUFDMUMsSUFBSSxDQUFDckIsZUFBZSxHQUFHQTtJQUMzQjtJQUNBLE9BQU9GO0FBQ1g7QUFDTyxJQUFJd0IsWUFBWTtJQUNuQkMsUUFBUSxJQUFJekIsU0FBUyxVQUFVSCxtQkFBbUI2QixNQUFNO0lBQ3hEQyxjQUFjLElBQUkzQixTQUFTLGdCQUFnQkgsbUJBQW1CK0IsWUFBWTtJQUMxRUMsU0FBUyxJQUFJN0IsU0FBUyxXQUFXSCxtQkFBbUJpQyxPQUFPO0FBQy9ELEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvRW5jb2RpbmcuanM/ZjVjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuaW1wb3J0IHsgZGVjb21wcmVzc0pzb24sIHBhZFN0YXJ0IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgQWxsRW5jb2RpbmdzQ29tcHJlc3NlZCBmcm9tICcuL2FsbC1lbmNvZGluZ3MuY29tcHJlc3NlZC5qc29uJztcbnZhciBkZWNvbXByZXNzZWRFbmNvZGluZ3MgPSBkZWNvbXByZXNzSnNvbihBbGxFbmNvZGluZ3NDb21wcmVzc2VkKTtcbnZhciBhbGxVbmljb2RlTWFwcGluZ3MgPSBKU09OLnBhcnNlKGRlY29tcHJlc3NlZEVuY29kaW5ncyk7XG52YXIgRW5jb2RpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5jb2RpbmcobmFtZSwgdW5pY29kZU1hcHBpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2FuRW5jb2RlVW5pY29kZUNvZGVQb2ludCA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQgaW4gX3RoaXMudW5pY29kZU1hcHBpbmdzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuY29kZVVuaWNvZGVDb2RlUG9pbnQgPSBmdW5jdGlvbiAoY29kZVBvaW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwcGVkID0gX3RoaXMudW5pY29kZU1hcHBpbmdzW2NvZGVQb2ludF07XG4gICAgICAgICAgICBpZiAoIW1hcHBlZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgdmFyIGhleENvZGUgPSBcIjB4XCIgKyBwYWRTdGFydChjb2RlUG9pbnQudG9TdHJpbmcoMTYpLCA0LCAnMCcpO1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBfdGhpcy5uYW1lICsgXCIgY2Fubm90IGVuY29kZSBcXFwiXCIgKyBzdHIgKyBcIlxcXCIgKFwiICsgaGV4Q29kZSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgY29kZTogbWFwcGVkWzBdLCBuYW1lOiBtYXBwZWRbMV0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRDb2RlUG9pbnRzID0gT2JqZWN0LmtleXModW5pY29kZU1hcHBpbmdzKVxuICAgICAgICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgICAgICB0aGlzLnVuaWNvZGVNYXBwaW5ncyA9IHVuaWNvZGVNYXBwaW5ncztcbiAgICB9XG4gICAgcmV0dXJuIEVuY29kaW5nO1xufSgpKTtcbmV4cG9ydCB2YXIgRW5jb2RpbmdzID0ge1xuICAgIFN5bWJvbDogbmV3IEVuY29kaW5nKCdTeW1ib2wnLCBhbGxVbmljb2RlTWFwcGluZ3Muc3ltYm9sKSxcbiAgICBaYXBmRGluZ2JhdHM6IG5ldyBFbmNvZGluZygnWmFwZkRpbmdiYXRzJywgYWxsVW5pY29kZU1hcHBpbmdzLnphcGZkaW5nYmF0cyksXG4gICAgV2luQW5zaTogbmV3IEVuY29kaW5nKCdXaW5BbnNpJywgYWxsVW5pY29kZU1hcHBpbmdzLndpbjEyNTIpLFxufTtcbiJdLCJuYW1lcyI6WyJkZWNvbXByZXNzSnNvbiIsInBhZFN0YXJ0IiwiQWxsRW5jb2RpbmdzQ29tcHJlc3NlZCIsImRlY29tcHJlc3NlZEVuY29kaW5ncyIsImFsbFVuaWNvZGVNYXBwaW5ncyIsIkpTT04iLCJwYXJzZSIsIkVuY29kaW5nIiwibmFtZSIsInVuaWNvZGVNYXBwaW5ncyIsIl90aGlzIiwiY2FuRW5jb2RlVW5pY29kZUNvZGVQb2ludCIsImNvZGVQb2ludCIsImVuY29kZVVuaWNvZGVDb2RlUG9pbnQiLCJtYXBwZWQiLCJzdHIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJoZXhDb2RlIiwidG9TdHJpbmciLCJtc2ciLCJFcnJvciIsImNvZGUiLCJzdXBwb3J0ZWRDb2RlUG9pbnRzIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsIk51bWJlciIsInNvcnQiLCJhIiwiYiIsIkVuY29kaW5ncyIsIlN5bWJvbCIsInN5bWJvbCIsIlphcGZEaW5nYmF0cyIsInphcGZkaW5nYmF0cyIsIldpbkFuc2kiLCJ3aW4xMjUyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Font.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Font.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontNames: () => (/* binding */ FontNames)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/utils.js\");\n/* harmony import */ var _Courier_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Courier-Bold.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Courier-Bold.compressed.json\");\n/* harmony import */ var _Courier_BoldOblique_compressed_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Courier-BoldOblique.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Courier-BoldOblique.compressed.json\");\n/* harmony import */ var _Courier_Oblique_compressed_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Courier-Oblique.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Courier-Oblique.compressed.json\");\n/* harmony import */ var _Courier_compressed_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Courier.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Courier.compressed.json\");\n/* harmony import */ var _Helvetica_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Helvetica-Bold.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Bold.compressed.json\");\n/* harmony import */ var _Helvetica_BoldOblique_compressed_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Helvetica-BoldOblique.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-BoldOblique.compressed.json\");\n/* harmony import */ var _Helvetica_Oblique_compressed_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Helvetica-Oblique.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Oblique.compressed.json\");\n/* harmony import */ var _Helvetica_compressed_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Helvetica.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica.compressed.json\");\n/* harmony import */ var _Times_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Times-Bold.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Times-Bold.compressed.json\");\n/* harmony import */ var _Times_BoldItalic_compressed_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Times-BoldItalic.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Times-BoldItalic.compressed.json\");\n/* harmony import */ var _Times_Italic_compressed_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Times-Italic.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Times-Italic.compressed.json\");\n/* harmony import */ var _Times_Roman_compressed_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Times-Roman.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Times-Roman.compressed.json\");\n/* harmony import */ var _Symbol_compressed_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Symbol.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Symbol.compressed.json\");\n/* harmony import */ var _ZapfDingbats_compressed_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ZapfDingbats.compressed.json */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/ZapfDingbats.compressed.json\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// prettier-ignore\nvar compressedJsonForFontName = {\n    \"Courier\": _Courier_compressed_json__WEBPACK_IMPORTED_MODULE_4__,\n    \"Courier-Bold\": _Courier_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_1__,\n    \"Courier-Oblique\": _Courier_Oblique_compressed_json__WEBPACK_IMPORTED_MODULE_3__,\n    \"Courier-BoldOblique\": _Courier_BoldOblique_compressed_json__WEBPACK_IMPORTED_MODULE_2__,\n    \"Helvetica\": _Helvetica_compressed_json__WEBPACK_IMPORTED_MODULE_8__,\n    \"Helvetica-Bold\": _Helvetica_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_5__,\n    \"Helvetica-Oblique\": _Helvetica_Oblique_compressed_json__WEBPACK_IMPORTED_MODULE_7__,\n    \"Helvetica-BoldOblique\": _Helvetica_BoldOblique_compressed_json__WEBPACK_IMPORTED_MODULE_6__,\n    \"Times-Roman\": _Times_Roman_compressed_json__WEBPACK_IMPORTED_MODULE_12__,\n    \"Times-Bold\": _Times_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_9__,\n    \"Times-Italic\": _Times_Italic_compressed_json__WEBPACK_IMPORTED_MODULE_11__,\n    \"Times-BoldItalic\": _Times_BoldItalic_compressed_json__WEBPACK_IMPORTED_MODULE_10__,\n    \"Symbol\": _Symbol_compressed_json__WEBPACK_IMPORTED_MODULE_13__,\n    \"ZapfDingbats\": _ZapfDingbats_compressed_json__WEBPACK_IMPORTED_MODULE_14__\n};\nvar FontNames;\n(function(FontNames) {\n    FontNames[\"Courier\"] = \"Courier\";\n    FontNames[\"CourierBold\"] = \"Courier-Bold\";\n    FontNames[\"CourierOblique\"] = \"Courier-Oblique\";\n    FontNames[\"CourierBoldOblique\"] = \"Courier-BoldOblique\";\n    FontNames[\"Helvetica\"] = \"Helvetica\";\n    FontNames[\"HelveticaBold\"] = \"Helvetica-Bold\";\n    FontNames[\"HelveticaOblique\"] = \"Helvetica-Oblique\";\n    FontNames[\"HelveticaBoldOblique\"] = \"Helvetica-BoldOblique\";\n    FontNames[\"TimesRoman\"] = \"Times-Roman\";\n    FontNames[\"TimesRomanBold\"] = \"Times-Bold\";\n    FontNames[\"TimesRomanItalic\"] = \"Times-Italic\";\n    FontNames[\"TimesRomanBoldItalic\"] = \"Times-BoldItalic\";\n    FontNames[\"Symbol\"] = \"Symbol\";\n    FontNames[\"ZapfDingbats\"] = \"ZapfDingbats\";\n})(FontNames || (FontNames = {}));\nvar fontCache = {};\nvar Font = /** @class */ function() {\n    function Font() {\n        var _this = this;\n        this.getWidthOfGlyph = function(glyphName) {\n            return _this.CharWidths[glyphName];\n        };\n        this.getXAxisKerningForPair = function(leftGlyphName, rightGlyphName) {\n            return (_this.KernPairXAmounts[leftGlyphName] || {})[rightGlyphName];\n        };\n    }\n    Font.load = function(fontName) {\n        var cachedFont = fontCache[fontName];\n        if (cachedFont) return cachedFont;\n        var json = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.decompressJson)(compressedJsonForFontName[fontName]);\n        var font = Object.assign(new Font(), JSON.parse(json));\n        font.CharWidths = font.CharMetrics.reduce(function(acc, metric) {\n            acc[metric.N] = metric.WX;\n            return acc;\n        }, {});\n        font.KernPairXAmounts = font.KernPairs.reduce(function(acc, _a) {\n            var name1 = _a[0], name2 = _a[1], width = _a[2];\n            if (!acc[name1]) acc[name1] = {};\n            acc[name1][name2] = width;\n            return acc;\n        }, {});\n        fontCache[fontName] = font;\n        return font;\n    };\n    return Font;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvRm9udC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUMwQjtBQUNjO0FBQ1I7QUFDZjtBQUNhO0FBQ2M7QUFDUjtBQUNmO0FBQ0M7QUFDWTtBQUNSO0FBQ0Y7QUFDVDtBQUNZO0FBQ3BFLGtCQUFrQjtBQUNsQixJQUFJZSw0QkFBNEI7SUFDNUIsV0FBV1gscURBQWlCQTtJQUM1QixnQkFBZ0JILDBEQUFxQkE7SUFDckMsbUJBQW1CRSw2REFBd0JBO0lBQzNDLHVCQUF1QkQsaUVBQTRCQTtJQUNuRCxhQUFhTSx1REFBbUJBO0lBQ2hDLGtCQUFrQkgsNERBQXVCQTtJQUN6QyxxQkFBcUJFLCtEQUEwQkE7SUFDL0MseUJBQXlCRCxtRUFBOEJBO0lBQ3ZELGVBQWVNLDBEQUFvQkE7SUFDbkMsY0FBY0gsd0RBQW1CQTtJQUNqQyxnQkFBZ0JFLDJEQUFxQkE7SUFDckMsb0JBQW9CRCwrREFBeUJBO0lBQzdDLFVBQVVHLHFEQUFnQkE7SUFDMUIsZ0JBQWdCQywyREFBc0JBO0FBQzFDO0FBQ08sSUFBSUUsVUFBVTtBQUNwQixVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUMsVUFBVSxHQUFHO0lBQ3ZCQSxTQUFTLENBQUMsY0FBYyxHQUFHO0lBQzNCQSxTQUFTLENBQUMsaUJBQWlCLEdBQUc7SUFDOUJBLFNBQVMsQ0FBQyxxQkFBcUIsR0FBRztJQUNsQ0EsU0FBUyxDQUFDLFlBQVksR0FBRztJQUN6QkEsU0FBUyxDQUFDLGdCQUFnQixHQUFHO0lBQzdCQSxTQUFTLENBQUMsbUJBQW1CLEdBQUc7SUFDaENBLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRztJQUNwQ0EsU0FBUyxDQUFDLGFBQWEsR0FBRztJQUMxQkEsU0FBUyxDQUFDLGlCQUFpQixHQUFHO0lBQzlCQSxTQUFTLENBQUMsbUJBQW1CLEdBQUc7SUFDaENBLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRztJQUNwQ0EsU0FBUyxDQUFDLFNBQVMsR0FBRztJQUN0QkEsU0FBUyxDQUFDLGVBQWUsR0FBRztBQUNoQyxHQUFHQSxhQUFjQSxDQUFBQSxZQUFZLENBQUM7QUFDOUIsSUFBSUMsWUFBWSxDQUFDO0FBQ2pCLElBQUlDLE9BQU8sV0FBVyxHQUFJO0lBQ3RCLFNBQVNBO1FBQ0wsSUFBSUMsUUFBUSxJQUFJO1FBQ2hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLFNBQVVDLFNBQVM7WUFDdEMsT0FBT0YsTUFBTUcsVUFBVSxDQUFDRCxVQUFVO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDRSxzQkFBc0IsR0FBRyxTQUFVQyxhQUFhLEVBQUVDLGNBQWM7WUFDakUsT0FBTyxDQUFDTixNQUFNTyxnQkFBZ0IsQ0FBQ0YsY0FBYyxJQUFJLENBQUMsRUFBRSxDQUFDQyxlQUFlO1FBQ3hFO0lBQ0o7SUFDQVAsS0FBS1MsSUFBSSxHQUFHLFNBQVVDLFFBQVE7UUFDMUIsSUFBSUMsYUFBYVosU0FBUyxDQUFDVyxTQUFTO1FBQ3BDLElBQUlDLFlBQ0EsT0FBT0E7UUFDWCxJQUFJQyxPQUFPOUIsc0RBQWNBLENBQUNlLHlCQUF5QixDQUFDYSxTQUFTO1FBQzdELElBQUlHLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQyxJQUFJZixRQUFRZ0IsS0FBS0MsS0FBSyxDQUFDTDtRQUNoREMsS0FBS1QsVUFBVSxHQUFHUyxLQUFLSyxXQUFXLENBQUNDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHLEVBQUVDLE1BQU07WUFDM0RELEdBQUcsQ0FBQ0MsT0FBT0MsQ0FBQyxDQUFDLEdBQUdELE9BQU9FLEVBQUU7WUFDekIsT0FBT0g7UUFDWCxHQUFHLENBQUM7UUFDSlAsS0FBS0wsZ0JBQWdCLEdBQUdLLEtBQUtXLFNBQVMsQ0FBQ0wsTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUssRUFBRTtZQUMzRCxJQUFJQyxRQUFRRCxFQUFFLENBQUMsRUFBRSxFQUFFRSxRQUFRRixFQUFFLENBQUMsRUFBRSxFQUFFRyxRQUFRSCxFQUFFLENBQUMsRUFBRTtZQUMvQyxJQUFJLENBQUNMLEdBQUcsQ0FBQ00sTUFBTSxFQUNYTixHQUFHLENBQUNNLE1BQU0sR0FBRyxDQUFDO1lBQ2xCTixHQUFHLENBQUNNLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHQztZQUNwQixPQUFPUjtRQUNYLEdBQUcsQ0FBQztRQUNKckIsU0FBUyxDQUFDVyxTQUFTLEdBQUdHO1FBQ3RCLE9BQU9BO0lBQ1g7SUFDQSxPQUFPYjtBQUNYO0FBQ2dCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL2VzL0ZvbnQuanM/MDhlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWNvbXByZXNzSnNvbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IENvdXJpZXJCb2xkQ29tcHJlc3NlZCBmcm9tICcuL0NvdXJpZXItQm9sZC5jb21wcmVzc2VkLmpzb24nO1xuaW1wb3J0IENvdXJpZXJCb2xkT2JsaXF1ZUNvbXByZXNzZWQgZnJvbSAnLi9Db3VyaWVyLUJvbGRPYmxpcXVlLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgQ291cmllck9ibGlxdWVDb21wcmVzc2VkIGZyb20gJy4vQ291cmllci1PYmxpcXVlLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgQ291cmllckNvbXByZXNzZWQgZnJvbSAnLi9Db3VyaWVyLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgSGVsdmV0aWNhQm9sZENvbXByZXNzZWQgZnJvbSAnLi9IZWx2ZXRpY2EtQm9sZC5jb21wcmVzc2VkLmpzb24nO1xuaW1wb3J0IEhlbHZldGljYUJvbGRPYmxpcXVlQ29tcHJlc3NlZCBmcm9tICcuL0hlbHZldGljYS1Cb2xkT2JsaXF1ZS5jb21wcmVzc2VkLmpzb24nO1xuaW1wb3J0IEhlbHZldGljYU9ibGlxdWVDb21wcmVzc2VkIGZyb20gJy4vSGVsdmV0aWNhLU9ibGlxdWUuY29tcHJlc3NlZC5qc29uJztcbmltcG9ydCBIZWx2ZXRpY2FDb21wcmVzc2VkIGZyb20gJy4vSGVsdmV0aWNhLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgVGltZXNCb2xkQ29tcHJlc3NlZCBmcm9tICcuL1RpbWVzLUJvbGQuY29tcHJlc3NlZC5qc29uJztcbmltcG9ydCBUaW1lc0JvbGRJdGFsaWNDb21wcmVzc2VkIGZyb20gJy4vVGltZXMtQm9sZEl0YWxpYy5jb21wcmVzc2VkLmpzb24nO1xuaW1wb3J0IFRpbWVzSXRhbGljQ29tcHJlc3NlZCBmcm9tICcuL1RpbWVzLUl0YWxpYy5jb21wcmVzc2VkLmpzb24nO1xuaW1wb3J0IFRpbWVzUm9tYW5Db21wcmVzc2VkIGZyb20gJy4vVGltZXMtUm9tYW4uY29tcHJlc3NlZC5qc29uJztcbmltcG9ydCBTeW1ib2xDb21wcmVzc2VkIGZyb20gJy4vU3ltYm9sLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgWmFwZkRpbmdiYXRzQ29tcHJlc3NlZCBmcm9tICcuL1phcGZEaW5nYmF0cy5jb21wcmVzc2VkLmpzb24nO1xuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY29tcHJlc3NlZEpzb25Gb3JGb250TmFtZSA9IHtcbiAgICAnQ291cmllcic6IENvdXJpZXJDb21wcmVzc2VkLFxuICAgICdDb3VyaWVyLUJvbGQnOiBDb3VyaWVyQm9sZENvbXByZXNzZWQsXG4gICAgJ0NvdXJpZXItT2JsaXF1ZSc6IENvdXJpZXJPYmxpcXVlQ29tcHJlc3NlZCxcbiAgICAnQ291cmllci1Cb2xkT2JsaXF1ZSc6IENvdXJpZXJCb2xkT2JsaXF1ZUNvbXByZXNzZWQsXG4gICAgJ0hlbHZldGljYSc6IEhlbHZldGljYUNvbXByZXNzZWQsXG4gICAgJ0hlbHZldGljYS1Cb2xkJzogSGVsdmV0aWNhQm9sZENvbXByZXNzZWQsXG4gICAgJ0hlbHZldGljYS1PYmxpcXVlJzogSGVsdmV0aWNhT2JsaXF1ZUNvbXByZXNzZWQsXG4gICAgJ0hlbHZldGljYS1Cb2xkT2JsaXF1ZSc6IEhlbHZldGljYUJvbGRPYmxpcXVlQ29tcHJlc3NlZCxcbiAgICAnVGltZXMtUm9tYW4nOiBUaW1lc1JvbWFuQ29tcHJlc3NlZCxcbiAgICAnVGltZXMtQm9sZCc6IFRpbWVzQm9sZENvbXByZXNzZWQsXG4gICAgJ1RpbWVzLUl0YWxpYyc6IFRpbWVzSXRhbGljQ29tcHJlc3NlZCxcbiAgICAnVGltZXMtQm9sZEl0YWxpYyc6IFRpbWVzQm9sZEl0YWxpY0NvbXByZXNzZWQsXG4gICAgJ1N5bWJvbCc6IFN5bWJvbENvbXByZXNzZWQsXG4gICAgJ1phcGZEaW5nYmF0cyc6IFphcGZEaW5nYmF0c0NvbXByZXNzZWQsXG59O1xuZXhwb3J0IHZhciBGb250TmFtZXM7XG4oZnVuY3Rpb24gKEZvbnROYW1lcykge1xuICAgIEZvbnROYW1lc1tcIkNvdXJpZXJcIl0gPSBcIkNvdXJpZXJcIjtcbiAgICBGb250TmFtZXNbXCJDb3VyaWVyQm9sZFwiXSA9IFwiQ291cmllci1Cb2xkXCI7XG4gICAgRm9udE5hbWVzW1wiQ291cmllck9ibGlxdWVcIl0gPSBcIkNvdXJpZXItT2JsaXF1ZVwiO1xuICAgIEZvbnROYW1lc1tcIkNvdXJpZXJCb2xkT2JsaXF1ZVwiXSA9IFwiQ291cmllci1Cb2xkT2JsaXF1ZVwiO1xuICAgIEZvbnROYW1lc1tcIkhlbHZldGljYVwiXSA9IFwiSGVsdmV0aWNhXCI7XG4gICAgRm9udE5hbWVzW1wiSGVsdmV0aWNhQm9sZFwiXSA9IFwiSGVsdmV0aWNhLUJvbGRcIjtcbiAgICBGb250TmFtZXNbXCJIZWx2ZXRpY2FPYmxpcXVlXCJdID0gXCJIZWx2ZXRpY2EtT2JsaXF1ZVwiO1xuICAgIEZvbnROYW1lc1tcIkhlbHZldGljYUJvbGRPYmxpcXVlXCJdID0gXCJIZWx2ZXRpY2EtQm9sZE9ibGlxdWVcIjtcbiAgICBGb250TmFtZXNbXCJUaW1lc1JvbWFuXCJdID0gXCJUaW1lcy1Sb21hblwiO1xuICAgIEZvbnROYW1lc1tcIlRpbWVzUm9tYW5Cb2xkXCJdID0gXCJUaW1lcy1Cb2xkXCI7XG4gICAgRm9udE5hbWVzW1wiVGltZXNSb21hbkl0YWxpY1wiXSA9IFwiVGltZXMtSXRhbGljXCI7XG4gICAgRm9udE5hbWVzW1wiVGltZXNSb21hbkJvbGRJdGFsaWNcIl0gPSBcIlRpbWVzLUJvbGRJdGFsaWNcIjtcbiAgICBGb250TmFtZXNbXCJTeW1ib2xcIl0gPSBcIlN5bWJvbFwiO1xuICAgIEZvbnROYW1lc1tcIlphcGZEaW5nYmF0c1wiXSA9IFwiWmFwZkRpbmdiYXRzXCI7XG59KShGb250TmFtZXMgfHwgKEZvbnROYW1lcyA9IHt9KSk7XG52YXIgZm9udENhY2hlID0ge307XG52YXIgRm9udCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb250KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmdldFdpZHRoT2ZHbHlwaCA9IGZ1bmN0aW9uIChnbHlwaE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5DaGFyV2lkdGhzW2dseXBoTmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0WEF4aXNLZXJuaW5nRm9yUGFpciA9IGZ1bmN0aW9uIChsZWZ0R2x5cGhOYW1lLCByaWdodEdseXBoTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5LZXJuUGFpclhBbW91bnRzW2xlZnRHbHlwaE5hbWVdIHx8IHt9KVtyaWdodEdseXBoTmFtZV07XG4gICAgICAgIH07XG4gICAgfVxuICAgIEZvbnQubG9hZCA9IGZ1bmN0aW9uIChmb250TmFtZSkge1xuICAgICAgICB2YXIgY2FjaGVkRm9udCA9IGZvbnRDYWNoZVtmb250TmFtZV07XG4gICAgICAgIGlmIChjYWNoZWRGb250KVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEZvbnQ7XG4gICAgICAgIHZhciBqc29uID0gZGVjb21wcmVzc0pzb24oY29tcHJlc3NlZEpzb25Gb3JGb250TmFtZVtmb250TmFtZV0pO1xuICAgICAgICB2YXIgZm9udCA9IE9iamVjdC5hc3NpZ24obmV3IEZvbnQoKSwgSlNPTi5wYXJzZShqc29uKSk7XG4gICAgICAgIGZvbnQuQ2hhcldpZHRocyA9IGZvbnQuQ2hhck1ldHJpY3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG1ldHJpYykge1xuICAgICAgICAgICAgYWNjW21ldHJpYy5OXSA9IG1ldHJpYy5XWDtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgZm9udC5LZXJuUGFpclhBbW91bnRzID0gZm9udC5LZXJuUGFpcnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZTEgPSBfYVswXSwgbmFtZTIgPSBfYVsxXSwgd2lkdGggPSBfYVsyXTtcbiAgICAgICAgICAgIGlmICghYWNjW25hbWUxXSlcbiAgICAgICAgICAgICAgICBhY2NbbmFtZTFdID0ge307XG4gICAgICAgICAgICBhY2NbbmFtZTFdW25hbWUyXSA9IHdpZHRoO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBmb250Q2FjaGVbZm9udE5hbWVdID0gZm9udDtcbiAgICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgfTtcbiAgICByZXR1cm4gRm9udDtcbn0oKSk7XG5leHBvcnQgeyBGb250IH07XG4iXSwibmFtZXMiOlsiZGVjb21wcmVzc0pzb24iLCJDb3VyaWVyQm9sZENvbXByZXNzZWQiLCJDb3VyaWVyQm9sZE9ibGlxdWVDb21wcmVzc2VkIiwiQ291cmllck9ibGlxdWVDb21wcmVzc2VkIiwiQ291cmllckNvbXByZXNzZWQiLCJIZWx2ZXRpY2FCb2xkQ29tcHJlc3NlZCIsIkhlbHZldGljYUJvbGRPYmxpcXVlQ29tcHJlc3NlZCIsIkhlbHZldGljYU9ibGlxdWVDb21wcmVzc2VkIiwiSGVsdmV0aWNhQ29tcHJlc3NlZCIsIlRpbWVzQm9sZENvbXByZXNzZWQiLCJUaW1lc0JvbGRJdGFsaWNDb21wcmVzc2VkIiwiVGltZXNJdGFsaWNDb21wcmVzc2VkIiwiVGltZXNSb21hbkNvbXByZXNzZWQiLCJTeW1ib2xDb21wcmVzc2VkIiwiWmFwZkRpbmdiYXRzQ29tcHJlc3NlZCIsImNvbXByZXNzZWRKc29uRm9yRm9udE5hbWUiLCJGb250TmFtZXMiLCJmb250Q2FjaGUiLCJGb250IiwiX3RoaXMiLCJnZXRXaWR0aE9mR2x5cGgiLCJnbHlwaE5hbWUiLCJDaGFyV2lkdGhzIiwiZ2V0WEF4aXNLZXJuaW5nRm9yUGFpciIsImxlZnRHbHlwaE5hbWUiLCJyaWdodEdseXBoTmFtZSIsIktlcm5QYWlyWEFtb3VudHMiLCJsb2FkIiwiZm9udE5hbWUiLCJjYWNoZWRGb250IiwianNvbiIsImZvbnQiLCJPYmplY3QiLCJhc3NpZ24iLCJKU09OIiwicGFyc2UiLCJDaGFyTWV0cmljcyIsInJlZHVjZSIsImFjYyIsIm1ldHJpYyIsIk4iLCJXWCIsIktlcm5QYWlycyIsIl9hIiwibmFtZTEiLCJuYW1lMiIsIndpZHRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Font.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Encodings: () => (/* reexport safe */ _Encoding__WEBPACK_IMPORTED_MODULE_1__.Encodings),\n/* harmony export */   Font: () => (/* reexport safe */ _Font__WEBPACK_IMPORTED_MODULE_0__.Font),\n/* harmony export */   FontNames: () => (/* reexport safe */ _Font__WEBPACK_IMPORTED_MODULE_0__.FontNames)\n/* harmony export */ });\n/* harmony import */ var _Font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Font */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Font.js\");\n/* harmony import */ var _Encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Encoding */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Encoding.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUI7QUFDSSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9lcy9pbmRleC5qcz9hN2Y4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vRm9udCc7XG5leHBvcnQgKiBmcm9tICcuL0VuY29kaW5nJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeFromBase64: () => (/* binding */ decodeFromBase64),\n/* harmony export */   decompressJson: () => (/* binding */ decompressJson),\n/* harmony export */   padStart: () => (/* binding */ padStart)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_0__);\n/*\n * The `chars`, `lookup`, and `decodeFromBase64` members of this file are\n * licensed under the following:\n *\n *     base64-arraybuffer\n *     https://github.com/niklasvh/base64-arraybuffer\n *\n *     Copyright (c) 2012 Niklas von Hertzen\n *     Licensed under the MIT license.\n *\n */ \nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n// Use a lookup table to find the index.\nvar lookup = new Uint8Array(256);\nfor(var i = 0; i < chars.length; i++){\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar decodeFromBase64 = function(base64) {\n    var bufferLength = base64.length * 0.75;\n    var len = base64.length;\n    var i;\n    var p = 0;\n    var encoded1;\n    var encoded2;\n    var encoded3;\n    var encoded4;\n    if (base64[base64.length - 1] === \"=\") {\n        bufferLength--;\n        if (base64[base64.length - 2] === \"=\") {\n            bufferLength--;\n        }\n    }\n    var bytes = new Uint8Array(bufferLength);\n    for(i = 0; i < len; i += 4){\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return bytes;\n};\nvar arrayToString = function(array) {\n    var str = \"\";\n    for(var i = 0; i < array.length; i++){\n        str += String.fromCharCode(array[i]);\n    }\n    return str;\n};\nvar decompressJson = function(compressedJson) {\n    return arrayToString(pako__WEBPACK_IMPORTED_MODULE_0___default().inflate(decodeFromBase64(compressedJson)));\n};\nvar padStart = function(value, length, padChar) {\n    var padding = \"\";\n    for(var idx = 0, len = length - value.length; idx < len; idx++){\n        padding += padChar;\n    }\n    return padding + value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQ3VCO0FBQ3hCLElBQUlDLFFBQVE7QUFDWix3Q0FBd0M7QUFDeEMsSUFBSUMsU0FBUyxJQUFJQyxXQUFXO0FBQzVCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxNQUFNSSxNQUFNLEVBQUVELElBQUs7SUFDbkNGLE1BQU0sQ0FBQ0QsTUFBTUssVUFBVSxDQUFDRixHQUFHLEdBQUdBO0FBQ2xDO0FBQ08sSUFBSUcsbUJBQW1CLFNBQVVDLE1BQU07SUFDMUMsSUFBSUMsZUFBZUQsT0FBT0gsTUFBTSxHQUFHO0lBQ25DLElBQUlLLE1BQU1GLE9BQU9ILE1BQU07SUFDdkIsSUFBSUQ7SUFDSixJQUFJTyxJQUFJO0lBQ1IsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJUCxNQUFNLENBQUNBLE9BQU9ILE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSztRQUNuQ0k7UUFDQSxJQUFJRCxNQUFNLENBQUNBLE9BQU9ILE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSztZQUNuQ0k7UUFDSjtJQUNKO0lBQ0EsSUFBSU8sUUFBUSxJQUFJYixXQUFXTTtJQUMzQixJQUFLTCxJQUFJLEdBQUdBLElBQUlNLEtBQUtOLEtBQUssRUFBRztRQUN6QlEsV0FBV1YsTUFBTSxDQUFDTSxPQUFPRixVQUFVLENBQUNGLEdBQUc7UUFDdkNTLFdBQVdYLE1BQU0sQ0FBQ00sT0FBT0YsVUFBVSxDQUFDRixJQUFJLEdBQUc7UUFDM0NVLFdBQVdaLE1BQU0sQ0FBQ00sT0FBT0YsVUFBVSxDQUFDRixJQUFJLEdBQUc7UUFDM0NXLFdBQVdiLE1BQU0sQ0FBQ00sT0FBT0YsVUFBVSxDQUFDRixJQUFJLEdBQUc7UUFDM0NZLEtBQUssQ0FBQ0wsSUFBSSxHQUFHLFlBQWEsSUFBTUUsWUFBWTtRQUM1Q0csS0FBSyxDQUFDTCxJQUFJLEdBQUcsQ0FBRUUsV0FBVyxFQUFDLEtBQU0sSUFBTUMsWUFBWTtRQUNuREUsS0FBSyxDQUFDTCxJQUFJLEdBQUcsQ0FBRUcsV0FBVyxNQUFNLElBQU1DLFdBQVc7SUFDckQ7SUFDQSxPQUFPQztBQUNYLEVBQUU7QUFDRixJQUFJQyxnQkFBZ0IsU0FBVUMsS0FBSztJQUMvQixJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJZixJQUFJLEdBQUdBLElBQUljLE1BQU1iLE1BQU0sRUFBRUQsSUFBSztRQUNuQ2UsT0FBT0MsT0FBT0MsWUFBWSxDQUFDSCxLQUFLLENBQUNkLEVBQUU7SUFDdkM7SUFDQSxPQUFPZTtBQUNYO0FBQ08sSUFBSUcsaUJBQWlCLFNBQVVDLGNBQWM7SUFDaEQsT0FBT04sY0FBY2pCLG1EQUFZLENBQUNPLGlCQUFpQmdCO0FBQ3ZELEVBQUU7QUFDSyxJQUFJRSxXQUFXLFNBQVVDLEtBQUssRUFBRXJCLE1BQU0sRUFBRXNCLE9BQU87SUFDbEQsSUFBSUMsVUFBVTtJQUNkLElBQUssSUFBSUMsTUFBTSxHQUFHbkIsTUFBTUwsU0FBU3FCLE1BQU1yQixNQUFNLEVBQUV3QixNQUFNbkIsS0FBS21CLE1BQU87UUFDN0RELFdBQVdEO0lBQ2Y7SUFDQSxPQUFPQyxVQUFVRjtBQUNyQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL2VzL3V0aWxzLmpzPzA3ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFRoZSBgY2hhcnNgLCBgbG9va3VwYCwgYW5kIGBkZWNvZGVGcm9tQmFzZTY0YCBtZW1iZXJzIG9mIHRoaXMgZmlsZSBhcmVcbiAqIGxpY2Vuc2VkIHVuZGVyIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogICAgIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCBwYWtvIGZyb20gJ3Bha28nO1xudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxudmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cbmV4cG9ydCB2YXIgZGVjb2RlRnJvbUJhc2U2NCA9IGZ1bmN0aW9uIChiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzU7XG4gICAgdmFyIGxlbiA9IGJhc2U2NC5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBlbmNvZGVkMTtcbiAgICB2YXIgZW5jb2RlZDI7XG4gICAgdmFyIGVuY29kZWQzO1xuICAgIHZhciBlbmNvZGVkNDtcbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gJz0nKSB7XG4gICAgICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAyKV07XG4gICAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59O1xudmFyIGFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuZXhwb3J0IHZhciBkZWNvbXByZXNzSnNvbiA9IGZ1bmN0aW9uIChjb21wcmVzc2VkSnNvbikge1xuICAgIHJldHVybiBhcnJheVRvU3RyaW5nKHBha28uaW5mbGF0ZShkZWNvZGVGcm9tQmFzZTY0KGNvbXByZXNzZWRKc29uKSkpO1xufTtcbmV4cG9ydCB2YXIgcGFkU3RhcnQgPSBmdW5jdGlvbiAodmFsdWUsIGxlbmd0aCwgcGFkQ2hhcikge1xuICAgIHZhciBwYWRkaW5nID0gJyc7XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuID0gbGVuZ3RoIC0gdmFsdWUubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICAgIHBhZGRpbmcgKz0gcGFkQ2hhcjtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRpbmcgKyB2YWx1ZTtcbn07XG4iXSwibmFtZXMiOlsicGFrbyIsImNoYXJzIiwibG9va3VwIiwiVWludDhBcnJheSIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiZGVjb2RlRnJvbUJhc2U2NCIsImJhc2U2NCIsImJ1ZmZlckxlbmd0aCIsImxlbiIsInAiLCJlbmNvZGVkMSIsImVuY29kZWQyIiwiZW5jb2RlZDMiLCJlbmNvZGVkNCIsImJ5dGVzIiwiYXJyYXlUb1N0cmluZyIsImFycmF5Iiwic3RyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZGVjb21wcmVzc0pzb24iLCJjb21wcmVzc2VkSnNvbiIsImluZmxhdGUiLCJwYWRTdGFydCIsInZhbHVlIiwicGFkQ2hhciIsInBhZGRpbmciLCJpZHgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/es/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Top level file is just a mixin of submodules & constants\n\nvar assign = (__webpack_require__(/*! ./lib/utils/common */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\").assign);\nvar deflate = __webpack_require__(/*! ./lib/deflate */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/deflate.js\");\nvar inflate = __webpack_require__(/*! ./lib/inflate */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js\");\nvar pako = {};\nassign(pako, deflate, inflate, constants);\nmodule.exports = pako;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsMkRBQTJEO0FBQzNEO0FBRUEsSUFBSUEsU0FBWUMsNElBQW9DO0FBRXBELElBQUlDLFVBQVlELG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlFLFVBQVlGLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlHLFlBQVlILG1CQUFPQSxDQUFDO0FBRXhCLElBQUlJLE9BQU8sQ0FBQztBQUVaTCxPQUFPSyxNQUFNSCxTQUFTQyxTQUFTQztBQUUvQkUsT0FBT0MsT0FBTyxHQUFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcz82YmRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iXSwibmFtZXMiOlsiYXNzaWduIiwicmVxdWlyZSIsImRlZmxhdGUiLCJpbmZsYXRlIiwiY29uc3RhbnRzIiwicGFrbyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/deflate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/deflate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/deflate.js\");\nvar utils = __webpack_require__(/*! ./utils/common */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar strings = __webpack_require__(/*! ./utils/strings */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js\");\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js\");\nvar toString = Object.prototype.toString;\n/* Public constants ==========================================================*/ /* ===========================================================================*/ var Z_NO_FLUSH = 0;\nvar Z_FINISH = 4;\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_SYNC_FLUSH = 2;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_DEFAULT_STRATEGY = 0;\nvar Z_DEFLATED = 8;\n/* ===========================================================================*/ /**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/ /* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/ /**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/ /**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/ /**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/ /**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/ function Deflate(options) {\n    if (!(this instanceof Deflate)) return new Deflate(options);\n    this.options = utils.assign({\n        level: Z_DEFAULT_COMPRESSION,\n        method: Z_DEFLATED,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY,\n        to: \"\"\n    }, options || {});\n    var opt = this.options;\n    if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits;\n    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16;\n    }\n    this.err = 0; // error code, if happens (0 = Z_OK)\n    this.msg = \"\"; // error message\n    this.ended = false; // used to avoid multiple onEnd() calls\n    this.chunks = []; // chunks of compressed data\n    this.strm = new ZStream();\n    this.strm.avail_out = 0;\n    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n    if (status !== Z_OK) {\n        throw new Error(msg[status]);\n    }\n    if (opt.header) {\n        zlib_deflate.deflateSetHeader(this.strm, opt.header);\n    }\n    if (opt.dictionary) {\n        var dict;\n        // Convert data if needed\n        if (typeof opt.dictionary === \"string\") {\n            // If we need to compress text, change encoding to utf8.\n            dict = strings.string2buf(opt.dictionary);\n        } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n            dict = new Uint8Array(opt.dictionary);\n        } else {\n            dict = opt.dictionary;\n        }\n        status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n        if (status !== Z_OK) {\n            throw new Error(msg[status]);\n        }\n        this._dict_set = true;\n    }\n}\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/ Deflate.prototype.push = function(data, mode) {\n    var strm = this.strm;\n    var chunkSize = this.options.chunkSize;\n    var status, _mode;\n    if (this.ended) {\n        return false;\n    }\n    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;\n    // Convert data if needed\n    if (typeof data === \"string\") {\n        // If we need to compress text, change encoding to utf8.\n        strm.input = strings.string2buf(data);\n    } else if (toString.call(data) === \"[object ArrayBuffer]\") {\n        strm.input = new Uint8Array(data);\n    } else {\n        strm.input = data;\n    }\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n    do {\n        if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n        }\n        status = zlib_deflate.deflate(strm, _mode); /* no bad return value */ \n        if (status !== Z_STREAM_END && status !== Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n        }\n        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {\n            if (this.options.to === \"string\") {\n                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n            } else {\n                this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n            }\n        }\n    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n    // Finalize on the last chunk.\n    if (_mode === Z_FINISH) {\n        status = zlib_deflate.deflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === Z_OK;\n    }\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === Z_SYNC_FLUSH) {\n        this.onEnd(Z_OK);\n        strm.avail_out = 0;\n        return true;\n    }\n    return true;\n};\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/ Deflate.prototype.onData = function(chunk) {\n    this.chunks.push(chunk);\n};\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/ Deflate.prototype.onEnd = function(status) {\n    // On success - join\n    if (status === Z_OK) {\n        if (this.options.to === \"string\") {\n            this.result = this.chunks.join(\"\");\n        } else {\n            this.result = utils.flattenChunks(this.chunks);\n        }\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n};\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/ function deflate(input, options) {\n    var deflator = new Deflate(options);\n    deflator.push(input, true);\n    // That will never happens, if you don't cheat with options :)\n    if (deflator.err) {\n        throw deflator.msg || msg[deflator.err];\n    }\n    return deflator.result;\n}\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/ function deflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return deflate(input, options);\n}\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/ function gzip(input, options) {\n    options = options || {};\n    options.gzip = true;\n    return deflate(input, options);\n}\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFHQSxJQUFJQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUMzQixJQUFJQyxRQUFlRCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJRSxVQUFlRixtQkFBT0EsQ0FBQztBQUMzQixJQUFJRyxNQUFlSCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJSSxVQUFlSixtQkFBT0EsQ0FBQztBQUUzQixJQUFJSyxXQUFXQyxPQUFPQyxTQUFTLENBQUNGLFFBQVE7QUFFeEMsOEVBQThFLEdBQzlFLDhFQUE4RSxHQUU5RSxJQUFJRyxhQUFrQjtBQUN0QixJQUFJQyxXQUFrQjtBQUV0QixJQUFJQyxPQUFrQjtBQUN0QixJQUFJQyxlQUFrQjtBQUN0QixJQUFJQyxlQUFrQjtBQUV0QixJQUFJQyx3QkFBd0IsQ0FBQztBQUU3QixJQUFJQyxxQkFBd0I7QUFFNUIsSUFBSUMsYUFBYztBQUVsQiw4RUFBOEUsR0FHOUU7Ozs7OztFQU1FLEdBRUY7Ozs7RUFJRSxHQUVGOzs7Ozs7OztFQVFFLEdBRUY7Ozs7Ozs7RUFPRSxHQUVGOzs7O0VBSUUsR0FHRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ0RFLEdBQ0YsU0FBU0MsUUFBUUMsT0FBTztJQUN0QixJQUFJLENBQUUsS0FBSSxZQUFZRCxPQUFNLEdBQUksT0FBTyxJQUFJQSxRQUFRQztJQUVuRCxJQUFJLENBQUNBLE9BQU8sR0FBR2hCLE1BQU1pQixNQUFNLENBQUM7UUFDMUJDLE9BQU9OO1FBQ1BPLFFBQVFMO1FBQ1JNLFdBQVc7UUFDWEMsWUFBWTtRQUNaQyxVQUFVO1FBQ1ZDLFVBQVVWO1FBQ1ZXLElBQUk7SUFDTixHQUFHUixXQUFXLENBQUM7SUFFZixJQUFJUyxNQUFNLElBQUksQ0FBQ1QsT0FBTztJQUV0QixJQUFJUyxJQUFJ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V2xCLEtBQUssRUFBRWpDLE9BQU87SUFDaENBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QkEsUUFBUVUsR0FBRyxHQUFHO0lBQ2QsT0FBTzhCLFFBQVFQLE9BQU9qQztBQUN4QjtBQUdBOzs7Ozs7O0VBT0UsR0FDRixTQUFTVyxLQUFLc0IsS0FBSyxFQUFFakMsT0FBTztJQUMxQkEsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCQSxRQUFRVyxJQUFJLEdBQUc7SUFDZixPQUFPNkIsUUFBUVAsT0FBT2pDO0FBQ3hCO0FBR0FvRCxlQUFlLEdBQUdyRDtBQUNsQnFELGVBQWUsR0FBR1o7QUFDbEJZLGtCQUFrQixHQUFHRDtBQUNyQkMsWUFBWSxHQUFHekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanM/OWFlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iXSwibmFtZXMiOlsiemxpYl9kZWZsYXRlIiwicmVxdWlyZSIsInV0aWxzIiwic3RyaW5ncyIsIm1zZyIsIlpTdHJlYW0iLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsIlpfTk9fRkxVU0giLCJaX0ZJTklTSCIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX1NZTkNfRkxVU0giLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX0RFRkxBVEVEIiwiRGVmbGF0ZSIsIm9wdGlvbnMiLCJhc3NpZ24iLCJsZXZlbCIsIm1ldGhvZCIsImNodW5rU2l6ZSIsIndpbmRvd0JpdHMiLCJtZW1MZXZlbCIsInN0cmF0ZWd5IiwidG8iLCJvcHQiLCJyYXciLCJnemlwIiwiZXJyIiwiZW5kZWQiLCJjaHVua3MiLCJzdHJtIiwiYXZhaWxfb3V0Iiwic3RhdHVzIiwiZGVmbGF0ZUluaXQyIiwiRXJyb3IiLCJoZWFkZXIiLCJkZWZsYXRlU2V0SGVhZGVyIiwiZGljdGlvbmFyeSIsImRpY3QiLCJzdHJpbmcyYnVmIiwiY2FsbCIsIlVpbnQ4QXJyYXkiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsIl9kaWN0X3NldCIsInB1c2giLCJkYXRhIiwibW9kZSIsIl9tb2RlIiwiaW5wdXQiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJsZW5ndGgiLCJvdXRwdXQiLCJCdWY4IiwibmV4dF9vdXQiLCJkZWZsYXRlIiwib25FbmQiLCJvbkRhdGEiLCJidWYyYmluc3RyaW5nIiwic2hyaW5rQnVmIiwiZGVmbGF0ZUVuZCIsImNodW5rIiwicmVzdWx0Iiwiam9pbiIsImZsYXR0ZW5DaHVua3MiLCJkZWZsYXRvciIsImRlZmxhdGVSYXciLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/inflate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/inflate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inflate.js\");\nvar utils = __webpack_require__(/*! ./utils/common */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar strings = __webpack_require__(/*! ./utils/strings */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js\");\nvar c = __webpack_require__(/*! ./zlib/constants */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js\");\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader = __webpack_require__(/*! ./zlib/gzheader */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/gzheader.js\");\nvar toString = Object.prototype.toString;\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/ /* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/ /**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/ /**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/ /**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/ /**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/ function Inflate(options) {\n    if (!(this instanceof Inflate)) return new Inflate(options);\n    this.options = utils.assign({\n        chunkSize: 16384,\n        windowBits: 0,\n        to: \"\"\n    }, options || {});\n    var opt = this.options;\n    // Force window size for `raw` data, if not set directly,\n    // because we have no header for autodetect.\n    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n        opt.windowBits = -opt.windowBits;\n        if (opt.windowBits === 0) {\n            opt.windowBits = -15;\n        }\n    }\n    // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {\n        opt.windowBits += 32;\n    }\n    // Gzip header has no info about windows size, we can do autodetect only\n    // for deflate. So, if window size not set, force it to max when gzip possible\n    if (opt.windowBits > 15 && opt.windowBits < 48) {\n        // bit 3 (16) -> gzipped data\n        // bit 4 (32) -> autodetect gzip/deflate\n        if ((opt.windowBits & 15) === 0) {\n            opt.windowBits |= 15;\n        }\n    }\n    this.err = 0; // error code, if happens (0 = Z_OK)\n    this.msg = \"\"; // error message\n    this.ended = false; // used to avoid multiple onEnd() calls\n    this.chunks = []; // chunks of compressed data\n    this.strm = new ZStream();\n    this.strm.avail_out = 0;\n    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n    if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n    }\n    this.header = new GZheader();\n    zlib_inflate.inflateGetHeader(this.strm, this.header);\n    // Setup dictionary\n    if (opt.dictionary) {\n        // Convert data if needed\n        if (typeof opt.dictionary === \"string\") {\n            opt.dictionary = strings.string2buf(opt.dictionary);\n        } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n            opt.dictionary = new Uint8Array(opt.dictionary);\n        }\n        if (opt.raw) {\n            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n            if (status !== c.Z_OK) {\n                throw new Error(msg[status]);\n            }\n        }\n    }\n}\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/ Inflate.prototype.push = function(data, mode) {\n    var strm = this.strm;\n    var chunkSize = this.options.chunkSize;\n    var dictionary = this.options.dictionary;\n    var status, _mode;\n    var next_out_utf8, tail, utf8str;\n    // Flag to properly process Z_BUF_ERROR on testing inflate call\n    // when we check that all output data was flushed.\n    var allowBufError = false;\n    if (this.ended) {\n        return false;\n    }\n    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;\n    // Convert data if needed\n    if (typeof data === \"string\") {\n        // Only binary strings can be decompressed on practice\n        strm.input = strings.binstring2buf(data);\n    } else if (toString.call(data) === \"[object ArrayBuffer]\") {\n        strm.input = new Uint8Array(data);\n    } else {\n        strm.input = data;\n    }\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n    do {\n        if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n        }\n        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */ \n        if (status === c.Z_NEED_DICT && dictionary) {\n            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n        }\n        if (status === c.Z_BUF_ERROR && allowBufError === true) {\n            status = c.Z_OK;\n            allowBufError = false;\n        }\n        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n        }\n        if (strm.next_out) {\n            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {\n                if (this.options.to === \"string\") {\n                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n                    tail = strm.next_out - next_out_utf8;\n                    utf8str = strings.buf2string(strm.output, next_out_utf8);\n                    // move tail\n                    strm.next_out = tail;\n                    strm.avail_out = chunkSize - tail;\n                    if (tail) {\n                        utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);\n                    }\n                    this.onData(utf8str);\n                } else {\n                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n                }\n            }\n        }\n        // When no more input data, we should check that internal inflate buffers\n        // are flushed. The only way to do it when avail_out = 0 - run one more\n        // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n        // Here we set flag to process this error properly.\n        //\n        // NOTE. Deflate does not return error in this case and does not needs such\n        // logic.\n        if (strm.avail_in === 0 && strm.avail_out === 0) {\n            allowBufError = true;\n        }\n    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n    if (status === c.Z_STREAM_END) {\n        _mode = c.Z_FINISH;\n    }\n    // Finalize on the last chunk.\n    if (_mode === c.Z_FINISH) {\n        status = zlib_inflate.inflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === c.Z_OK;\n    }\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === c.Z_SYNC_FLUSH) {\n        this.onEnd(c.Z_OK);\n        strm.avail_out = 0;\n        return true;\n    }\n    return true;\n};\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/ Inflate.prototype.onData = function(chunk) {\n    this.chunks.push(chunk);\n};\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/ Inflate.prototype.onEnd = function(status) {\n    // On success - join\n    if (status === c.Z_OK) {\n        if (this.options.to === \"string\") {\n            // Glue & convert here, until we teach pako to send\n            // utf8 aligned strings to onData\n            this.result = this.chunks.join(\"\");\n        } else {\n            this.result = utils.flattenChunks(this.chunks);\n        }\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n};\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/ function inflate(input, options) {\n    var inflator = new Inflate(options);\n    inflator.push(input, true);\n    // That will never happens, if you don't cheat with options :)\n    if (inflator.err) {\n        throw inflator.msg || msg[inflator.err];\n    }\n    return inflator.result;\n}\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/ function inflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return inflate(input, options);\n}\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/ exports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip = inflate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFHQSxJQUFJQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUMzQixJQUFJQyxRQUFlRCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJRSxVQUFlRixtQkFBT0EsQ0FBQztBQUMzQixJQUFJRyxJQUFlSCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJSSxNQUFlSixtQkFBT0EsQ0FBQztBQUMzQixJQUFJSyxVQUFlTCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJTSxXQUFlTixtQkFBT0EsQ0FBQztBQUUzQixJQUFJTyxXQUFXQyxPQUFPQyxTQUFTLENBQUNGLFFBQVE7QUFFeEM7Ozs7OztFQU1FLEdBRUY7Ozs7RUFJRSxHQUVGOzs7Ozs7OztFQVFFLEdBRUY7Ozs7O0VBS0UsR0FFRjs7OztFQUlFLEdBR0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF3Q0UsR0FDRixTQUFTRyxRQUFRQyxPQUFPO0lBQ3RCLElBQUksQ0FBRSxLQUFJLFlBQVlELE9BQU0sR0FBSSxPQUFPLElBQUlBLFFBQVFDO0lBRW5ELElBQUksQ0FBQ0EsT0FBTyxHQUFHVixNQUFNVyxNQUFNLENBQUM7UUFDMUJDLFdBQVc7UUFDWEMsWUFBWTtRQUNaQyxJQUFJO0lBQ04sR0FBR0osV0FBVyxDQUFDO0lBRWYsSUFBSUssTUFBTSxJQUFJLENBQUNMLE9BQU87SUFFdEIseURBQXlEO0lBQ3pELDRDQUE0QztJQUM1QyxJQUFJSyxJQUFJQyxHQUFHLElBQUtELElBQUlGLFVBQVUsSUFBSSxLQUFPRSxJQUFJRixVQUFVLEdBQUcsSUFBSztRQUM3REUsSUFBSUYsVUFBVSxHQUFHLENBQUNFLElBQUlGLFVBQVU7UUFDaEMsSUFBSUUsSUFBSUYsVUFBVSxLQUFLLEdBQUc7WUFBRUUsSUFBSUYsVUFBVSxHQUFHLENBQUM7UUFBSTtJ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QU87SUFDN0IsSUFBSXlELFdBQVcsSUFBSTFELFFBQVFDO0lBRTNCeUQsU0FBU2xDLElBQUksQ0FBQ1UsT0FBTztJQUVyQiw4REFBOEQ7SUFDOUQsSUFBSXdCLFNBQVNsRCxHQUFHLEVBQUU7UUFBRSxNQUFNa0QsU0FBU2hFLEdBQUcsSUFBSUEsR0FBRyxDQUFDZ0UsU0FBU2xELEdBQUcsQ0FBQztJQUFFO0lBRTdELE9BQU9rRCxTQUFTSCxNQUFNO0FBQ3hCO0FBR0E7Ozs7Ozs7RUFPRSxHQUNGLFNBQVNJLFdBQVd6QixLQUFLLEVBQUVqQyxPQUFPO0lBQ2hDQSxVQUFVQSxXQUFXLENBQUM7SUFDdEJBLFFBQVFNLEdBQUcsR0FBRztJQUNkLE9BQU9tQyxRQUFRUixPQUFPakM7QUFDeEI7QUFHQTs7Ozs7OztFQU9FLEdBR0YyRCxlQUFlLEdBQUc1RDtBQUNsQjRELGVBQWUsR0FBR2xCO0FBQ2xCa0Isa0JBQWtCLEdBQUdEO0FBQ3JCQyxjQUFjLEdBQUlsQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcz9jMjUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xudmFyIEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xuXG4gIC8vIFNldHVwIGRpY3Rpb25hcnlcbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIGlmIChvcHQucmF3KSB7IC8vSW4gcmF3IG1vZGUgd2UgbmVlZCB0byBzZXQgdGhlIGRpY3Rpb25hcnkgZWFybHlcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTtcbiAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0aW9uYXJ5KTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHtcbiAgICAgIHN0YXR1cyA9IGMuWl9PSztcbiAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBubyBtb3JlIGlucHV0IGRhdGEsIHdlIHNob3VsZCBjaGVjayB0aGF0IGludGVybmFsIGluZmxhdGUgYnVmZmVyc1xuICAgIC8vIGFyZSBmbHVzaGVkLiBUaGUgb25seSB3YXkgdG8gZG8gaXQgd2hlbiBhdmFpbF9vdXQgPSAwIC0gcnVuIG9uZSBtb3JlXG4gICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuXG4gICAgLy8gSGVyZSB3ZSBzZXQgZmxhZyB0byBwcm9jZXNzIHRoaXMgZXJyb3IgcHJvcGVybHkuXG4gICAgLy9cbiAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2hcbiAgICAvLyBsb2dpYy5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7XG5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHtcbiAgICBfbW9kZSA9IGMuWl9GSU5JU0g7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoYy5aX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZFxuICAgICAgLy8gdXRmOCBhbGlnbmVkIHN0cmluZ3MgdG8gb25EYXRhXG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB7IHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbmV4cG9ydHMudW5nemlwICA9IGluZmxhdGU7XG4iXSwibmFtZXMiOlsiemxpYl9pbmZsYXRlIiwicmVxdWlyZSIsInV0aWxzIiwic3RyaW5ncyIsImMiLCJtc2ciLCJaU3RyZWFtIiwiR1poZWFkZXIiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsIkluZmxhdGUiLCJvcHRpb25zIiwiYXNzaWduIiwiY2h1bmtTaXplIiwid2luZG93Qml0cyIsInRvIiwib3B0IiwicmF3IiwiZXJyIiwiZW5kZWQiLCJjaHVua3MiLCJzdHJtIiwiYXZhaWxfb3V0Iiwic3RhdHVzIiwiaW5mbGF0ZUluaXQyIiwiWl9PSyIsIkVycm9yIiwiaGVhZGVyIiwiaW5mbGF0ZUdldEhlYWRlciIsImRpY3Rpb25hcnkiLCJzdHJpbmcyYnVmIiwiY2FsbCIsIlVpbnQ4QXJyYXkiLCJpbmZsYXRlU2V0RGljdGlvbmFyeSIsInB1c2giLCJkYXRhIiwibW9kZSIsIl9tb2RlIiwibmV4dF9vdXRfdXRmOCIsInRhaWwiLCJ1dGY4c3RyIiwiYWxsb3dCdWZFcnJvciIsIlpfRklOSVNIIiwiWl9OT19GTFVTSCIsImlucHV0IiwiYmluc3RyaW5nMmJ1ZiIsIm5leHRfaW4iLCJhdmFpbF9pbiIsImxlbmd0aCIsIm91dHB1dCIsIkJ1ZjgiLCJuZXh0X291dCIsImluZmxhdGUiLCJaX05FRURfRElDVCIsIlpfQlVGX0VSUk9SIiwiWl9TVFJFQU1fRU5EIiwib25FbmQiLCJaX1NZTkNfRkxVU0giLCJ1dGY4Ym9yZGVyIiwiYnVmMnN0cmluZyIsImFycmF5U2V0Iiwib25EYXRhIiwic2hyaW5rQnVmIiwiaW5mbGF0ZUVuZCIsImNodW5rIiwicmVzdWx0Iiwiam9pbiIsImZsYXR0ZW5DaHVua3MiLCJpbmZsYXRvciIsImluZmxhdGVSYXciLCJleHBvcnRzIiwidW5nemlwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/inflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nvar TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\nfunction _has(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexports.assign = function(obj /*from1, from2, from3, ...*/ ) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    while(sources.length){\n        var source = sources.shift();\n        if (!source) {\n            continue;\n        }\n        if (typeof source !== \"object\") {\n            throw new TypeError(source + \"must be non-object\");\n        }\n        for(var p in source){\n            if (_has(source, p)) {\n                obj[p] = source[p];\n            }\n        }\n    }\n    return obj;\n};\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function(buf, size) {\n    if (buf.length === size) {\n        return buf;\n    }\n    if (buf.subarray) {\n        return buf.subarray(0, size);\n    }\n    buf.length = size;\n    return buf;\n};\nvar fnTyped = {\n    arraySet: function(dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n            return;\n        }\n        // Fallback to ordinary array\n        for(var i = 0; i < len; i++){\n            dest[dest_offs + i] = src[src_offs + i];\n        }\n    },\n    // Join array of chunks to single array.\n    flattenChunks: function(chunks) {\n        var i, l, len, pos, chunk, result;\n        // calculate data length\n        len = 0;\n        for(i = 0, l = chunks.length; i < l; i++){\n            len += chunks[i].length;\n        }\n        // join chunks\n        result = new Uint8Array(len);\n        pos = 0;\n        for(i = 0, l = chunks.length; i < l; i++){\n            chunk = chunks[i];\n            result.set(chunk, pos);\n            pos += chunk.length;\n        }\n        return result;\n    }\n};\nvar fnUntyped = {\n    arraySet: function(dest, src, src_offs, len, dest_offs) {\n        for(var i = 0; i < len; i++){\n            dest[dest_offs + i] = src[src_offs + i];\n        }\n    },\n    // Join array of chunks to single array.\n    flattenChunks: function(chunks) {\n        return [].concat.apply([], chunks);\n    }\n};\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function(on) {\n    if (on) {\n        exports.Buf8 = Uint8Array;\n        exports.Buf16 = Uint16Array;\n        exports.Buf32 = Int32Array;\n        exports.assign(exports, fnTyped);\n    } else {\n        exports.Buf8 = Array;\n        exports.Buf16 = Array;\n        exports.Buf32 = Array;\n        exports.assign(exports, fnUntyped);\n    }\n};\nexports.setTyped(TYPED_OK);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUdBLElBQUlBLFdBQVksT0FBUUMsZUFBZSxlQUN0QixPQUFPQyxnQkFBZ0IsZUFDdkIsT0FBT0MsZUFBZTtBQUV2QyxTQUFTQyxLQUFLQyxHQUFHLEVBQUVDLEdBQUc7SUFDcEIsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsS0FBS0M7QUFDbkQ7QUFFQUssY0FBYyxHQUFHLFNBQVVOLElBQUksMEJBQTBCLEdBQTNCO0lBQzVCLElBQUlRLFVBQVVDLE1BQU1OLFNBQVMsQ0FBQ08sS0FBSyxDQUFDTCxJQUFJLENBQUNNLFdBQVc7SUFDcEQsTUFBT0gsUUFBUUksTUFBTSxDQUFFO1FBQ3JCLElBQUlDLFNBQVNMLFFBQVFNLEtBQUs7UUFDMUIsSUFBSSxDQUFDRCxRQUFRO1lBQUU7UUFBVTtRQUV6QixJQUFJLE9BQU9BLFdBQVcsVUFBVTtZQUM5QixNQUFNLElBQUlFLFVBQVVGLFNBQVM7UUFDL0I7UUFFQSxJQUFLLElBQUlHLEtBQUtILE9BQVE7WUFDcEIsSUFBSWQsS0FBS2MsUUFBUUcsSUFBSTtnQkFDbkJoQixHQUFHLENBQUNnQixFQUFFLEdBQUdILE1BQU0sQ0FBQ0csRUFBRTtZQUNwQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPaEI7QUFDVDtBQUdBLHdDQUF3QztBQUN4Q00saUJBQWlCLEdBQUcsU0FBVVksR0FBRyxFQUFFQyxJQUFJO0lBQ3JDLElBQUlELElBQUlOLE1BQU0sS0FBS08sTUFBTTtRQUFFLE9BQU9EO0lBQUs7SUFDdkMsSUFBSUEsSUFBSUUsUUFBUSxFQUFFO1FBQUUsT0FBT0YsSUFBSUUsUUFBUSxDQUFDLEdBQUdEO0lBQU87SUFDbERELElBQUlOLE1BQU0sR0FBR087SUFDYixPQUFPRDtBQUNUO0FBR0EsSUFBSUcsVUFBVTtJQUNaQyxVQUFVLFNBQVVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLEdBQUcsRUFBRUMsU0FBUztRQUNyRCxJQUFJSCxJQUFJSixRQUFRLElBQUlHLEtBQUtILFFBQVEsRUFBRTtZQUNqQ0csS0FBS0ssR0FBRyxDQUFDSixJQUFJSixRQUFRLENBQUNLLFVBQVVBLFdBQVdDLE1BQU1DO1lBQ2pEO1FBQ0Y7UUFDQSw2QkFBNkI7UUFDN0IsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlILEtBQUtHLElBQUs7WUFDNUJOLElBQUksQ0FBQ0ksWUFBWUUsRUFBRSxHQUFHTCxHQUFHLENBQUNDLFdBQVdJLEVBQUU7UUFDekM7SUFDRjtJQUNBLHdDQUF3QztJQUN4Q0MsZUFBZSxTQUFVQyxNQUFNO1FBQzdCLElBQUlGLEdBQUdHLEdBQUdOLEtBQUtPLEtBQUtDLE9BQU9DO1FBRTNCLHdCQUF3QjtRQUN4QlQsTUFBTTtRQUNOLElBQUtHLElBQUksR0FBR0csSUFBSUQsT0FBT25CLE1BQU0sRUFBRWlCLElBQUlHLEdBQUdILElBQUs7WUFDekNILE9BQU9LLE1BQU0sQ0FBQ0YsRUFBRSxDQUFDakIsTUFBTTtRQUN6QjtRQUVBLGNBQWM7UUFDZHVCLFNBQVMsSUFBSXZDLFdBQVc4QjtRQUN4Qk8sTUFBTTtRQUNOLElBQUtKLElBQUksR0FBR0csSUFBSUQsT0FBT25CLE1BQU0sRUFBRWlCLElBQUlHLEdBQUdILElBQUs7WUFDekNLLFFBQVFILE1BQU0sQ0FBQ0YsRUFBRTtZQUNqQk0sT0FBT1AsR0FBRyxDQUFDTSxPQUFPRDtZQUNsQkEsT0FBT0MsTUFBTXRCLE1BQU07UUFDckI7UUFFQSxPQUFPdUI7SUFDVDtBQUNGO0FBRUEsSUFBSUMsWUFBWTtJQUNkZCxVQUFVLFNBQVVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLEdBQUcsRUFBRUMsU0FBUztRQUNyRCxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUgsS0FBS0csSUFBSztZQUM1Qk4sSUFBSSxDQUFDSSxZQUFZRSxFQUFFLEdBQUdMLEdBQUcsQ0FBQ0MsV0FBV0ksRUFBRTtRQUN6QztJQUNGO0lBQ0Esd0NBQXdDO0lBQ3hDQyxlQUFlLFNBQVVDLE1BQU07UUFDN0IsT0FBTyxFQUFFLENBQUNNLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDLEVBQUUsRUFBRVA7SUFDN0I7QUFDRjtBQUdBLCtDQUErQztBQUMvQyxFQUFFO0FBQ0Z6QixnQkFBZ0IsR0FBRyxTQUFVa0MsRUFBRTtJQUM3QixJQUFJQSxJQUFJO1FBQ05sQyxZQUFZLEdBQUlWO1FBQ2hCVSxhQUFhLEdBQUdUO1FBQ2hCUyxhQUFhLEdBQUdSO1FBQ2hCUSxRQUFRQyxNQUFNLENBQUNELFNBQVNlO0lBQzFCLE9BQU87UUFDTGYsWUFBWSxHQUFJRztRQUNoQkgsYUFBYSxHQUFHRztRQUNoQkgsYUFBYSxHQUFHRztRQUNoQkgsUUFBUUMsTUFBTSxDQUFDRCxTQUFTOEI7SUFDMUI7QUFDRjtBQUVBOUIsUUFBUWlDLFFBQVEsQ0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanM/NDI4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbmZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gcmVkdWNlIGJ1ZmZlciBzaXplLCBhdm9pZGluZyBtZW0gY29weVxuZXhwb3J0cy5zaHJpbmtCdWYgPSBmdW5jdGlvbiAoYnVmLCBzaXplKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7IHJldHVybiBidWY7IH1cbiAgaWYgKGJ1Zi5zdWJhcnJheSkgeyByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOyB9XG4gIGJ1Zi5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYnVmO1xufTtcblxuXG52YXIgZm5UeXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG9yZGluYXJ5IGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gICAgbGVuID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gam9pbiBjaHVua3NcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHBvcyA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZuVW50eXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7XG4gIH1cbn07XG5cblxuLy8gRW5hYmxlL0Rpc2FibGUgdHlwZWQgYXJyYXlzIHVzZSwgZm9yIHRlc3Rpbmdcbi8vXG5leHBvcnRzLnNldFR5cGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbikge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBVaW50OEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBVaW50MTZBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gSW50MzJBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblVudHlwZWQpO1xuICB9XG59O1xuXG5leHBvcnRzLnNldFR5cGVkKFRZUEVEX09LKTtcbiJdLCJuYW1lcyI6WyJUWVBFRF9PSyIsIlVpbnQ4QXJyYXkiLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJfaGFzIiwib2JqIiwia2V5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZXhwb3J0cyIsImFzc2lnbiIsInNvdXJjZXMiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwic2hpZnQiLCJUeXBlRXJyb3IiLCJwIiwic2hyaW5rQnVmIiwiYnVmIiwic2l6ZSIsInN1YmFycmF5IiwiZm5UeXBlZCIsImFycmF5U2V0IiwiZGVzdCIsInNyYyIsInNyY19vZmZzIiwibGVuIiwiZGVzdF9vZmZzIiwic2V0IiwiaSIsImZsYXR0ZW5DaHVua3MiLCJjaHVua3MiLCJsIiwicG9zIiwiY2h1bmsiLCJyZXN1bHQiLCJmblVudHlwZWQiLCJjb25jYXQiLCJhcHBseSIsInNldFR5cGVkIiwib24iLCJCdWY4IiwiQnVmMTYiLCJCdWYzMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// String encode/decode helpers\n\nvar utils = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\ntry {\n    String.fromCharCode.apply(null, [\n        0\n    ]);\n} catch (__) {\n    STR_APPLY_OK = false;\n}\ntry {\n    String.fromCharCode.apply(null, new Uint8Array(1));\n} catch (__) {\n    STR_APPLY_UIA_OK = false;\n}\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor(var q = 0; q < 256; q++){\n    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\nexports.string2buf = function(str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n    // count binary size\n    for(m_pos = 0; m_pos < str_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    buf = new utils.Buf8(buf_len);\n    // convert\n    for(i = 0, m_pos = 0; i < buf_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n};\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n    // On Chrome, the arguments in a function call that are allowed is `65534`.\n    // If the length of the buffer is smaller than that, we can use this optimization,\n    // otherwise we will take a slower path.\n    if (len < 65534) {\n        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {\n            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n        }\n    }\n    var result = \"\";\n    for(var i = 0; i < len; i++){\n        result += String.fromCharCode(buf[i]);\n    }\n    return result;\n}\n// Convert byte array to binary string\nexports.buf2binstring = function(buf) {\n    return buf2binstring(buf, buf.length);\n};\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function(str) {\n    var buf = new utils.Buf8(str.length);\n    for(var i = 0, len = buf.length; i < len; i++){\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n};\n// convert array to string\nexports.buf2string = function(buf, max) {\n    var i, out, c, c_len;\n    var len = max || buf.length;\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len * 2);\n    for(out = 0, i = 0; i < len;){\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n        }\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n        }\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while(c_len > 1 && i < len){\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n        }\n        // terminated by end of string?\n        if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n        }\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n        }\n    }\n    return buf2binstring(utf16buf, out);\n};\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function(buf, max) {\n    var pos;\n    max = max || buf.length;\n    if (max > buf.length) {\n        max = buf.length;\n    }\n    // go back from last position, until start of sequence found\n    pos = max - 1;\n    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80){\n        pos--;\n    }\n    // Very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) {\n        return max;\n    }\n    // If we came to start of buffer - that means buffer is too small,\n    // return max too.\n    if (pos === 0) {\n        return max;\n    }\n    return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsK0JBQStCO0FBQy9CO0FBR0EsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFHcEIsZ0VBQWdFO0FBQ2hFLEVBQUU7QUFDRix5Q0FBeUM7QUFDekMsaURBQWlEO0FBQ2pELEVBQUU7QUFDRixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLG1CQUFtQjtBQUV2QixJQUFJO0lBQUVDLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU07UUFBRTtLQUFHO0FBQUcsRUFBRSxPQUFPQyxJQUFJO0lBQUVMLGVBQWU7QUFBTztBQUNuRixJQUFJO0lBQUVFLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU0sSUFBSUUsV0FBVztBQUFLLEVBQUUsT0FBT0QsSUFBSTtJQUFFSixtQkFBbUI7QUFBTztBQUduRyxpRUFBaUU7QUFDakUsb0ZBQW9GO0FBQ3BGLDZDQUE2QztBQUM3QyxJQUFJTSxXQUFXLElBQUlULE1BQU1VLElBQUksQ0FBQztBQUM5QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLQSxJQUFLO0lBQzVCRixRQUFRLENBQUNFLEVBQUUsR0FBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJO0FBQzVGO0FBQ0FGLFFBQVEsQ0FBQyxJQUFJLEdBQUdBLFFBQVEsQ0FBQyxJQUFJLEdBQUcsR0FBRyx5QkFBeUI7QUFHNUQsaURBQWlEO0FBQ2pERyxrQkFBa0IsR0FBRyxTQUFVRSxHQUFHO0lBQ2hDLElBQUlDLEtBQUtDLEdBQUdDLElBQUlDLE9BQU9DLEdBQUdDLFVBQVVOLElBQUlPLE1BQU0sRUFBRUMsVUFBVTtJQUUxRCxvQkFBb0I7SUFDcEIsSUFBS0osUUFBUSxHQUFHQSxR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QUN4Q0UsUUFBUSxDQUFDRixNQUFNLEdBQUcsU0FBVWhCLElBQUk7UUFDbEM7SUFDRjtJQUVBLE9BQU9RLGNBQWNVLFVBQVVGO0FBQ2pDO0FBR0Esa0RBQWtEO0FBQ2xELHVEQUF1RDtBQUN2RCwrQ0FBK0M7QUFDL0MsRUFBRTtBQUNGLDJCQUEyQjtBQUMzQixvQ0FBb0M7QUFDcENwQixrQkFBa0IsR0FBRyxTQUFVRyxHQUFHLEVBQUVnQixHQUFHO0lBQ3JDLElBQUlNO0lBRUpOLE1BQU1BLE9BQU9oQixJQUFJTSxNQUFNO0lBQ3ZCLElBQUlVLE1BQU1oQixJQUFJTSxNQUFNLEVBQUU7UUFBRVUsTUFBTWhCLElBQUlNLE1BQU07SUFBRTtJQUUxQyw0REFBNEQ7SUFDNURnQixNQUFNTixNQUFNO0lBQ1osTUFBT00sT0FBTyxLQUFLLENBQUN0QixHQUFHLENBQUNzQixJQUFJLEdBQUcsSUFBRyxNQUFPLEtBQU07UUFBRUE7SUFBTztJQUV4RCxrQ0FBa0M7SUFDbEMseURBQXlEO0lBQ3pELElBQUlBLE1BQU0sR0FBRztRQUFFLE9BQU9OO0lBQUs7SUFFM0Isa0VBQWtFO0lBQ2xFLGtCQUFrQjtJQUNsQixJQUFJTSxRQUFRLEdBQUc7UUFBRSxPQUFPTjtJQUFLO0lBRTdCLE9BQU8sTUFBT3RCLFFBQVEsQ0FBQ00sR0FBRyxDQUFDc0IsSUFBSSxDQUFDLEdBQUdOLE1BQU9NLE1BQU1OO0FBQ2xEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzP2ExMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmICgoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHx8ICghYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vLyBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gYmluYXJ5IHN0cmluZ1xuZXhwb3J0cy5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpO1xufTtcblxuXG4vLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbmV4cG9ydHMudXRmOGJvcmRlciA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgcG9zO1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiU1RSX0FQUExZX09LIiwiU1RSX0FQUExZX1VJQV9PSyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiX18iLCJVaW50OEFycmF5IiwiX3V0ZjhsZW4iLCJCdWY4IiwicSIsImV4cG9ydHMiLCJzdHJpbmcyYnVmIiwic3RyIiwiYnVmIiwiYyIsImMyIiwibV9wb3MiLCJpIiwic3RyX2xlbiIsImxlbmd0aCIsImJ1Zl9sZW4iLCJjaGFyQ29kZUF0IiwiYnVmMmJpbnN0cmluZyIsImxlbiIsInN1YmFycmF5Iiwic2hyaW5rQnVmIiwicmVzdWx0IiwiYmluc3RyaW5nMmJ1ZiIsImJ1ZjJzdHJpbmciLCJtYXgiLCJvdXQiLCJjX2xlbiIsInV0ZjE2YnVmIiwiQXJyYXkiLCJ1dGY4Ym9yZGVyIiwicG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction adler32(adler, buf, len, pos) {\n    var s1 = adler & 0xffff | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0;\n    while(len !== 0){\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len;\n        len -= n;\n        do {\n            s1 = s1 + buf[pos++] | 0;\n            s2 = s2 + s1 | 0;\n        }while (--n);\n        s1 %= 65521;\n        s2 %= 65521;\n    }\n    return s1 | s2 << 16 | 0;\n}\nmodule.exports = adler32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLDBEQUEwRDtBQUMxRCxxRUFBcUU7QUFDckUsNEJBQTRCO0FBRTVCLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLFNBQVNBLFFBQVFDLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDbkMsSUFBSUMsS0FBSyxRQUFTLFNBQVMsR0FDdkJDLEtBQUssVUFBWSxLQUFNLFNBQVMsR0FDaENDLElBQUk7SUFFUixNQUFPSixRQUFRLEVBQUc7UUFDaEIsNENBQTRDO1FBQzVDLCtDQUErQztRQUMvQyw4QkFBOEI7UUFDOUJJLElBQUlKLE1BQU0sT0FBTyxPQUFPQTtRQUN4QkEsT0FBT0k7UUFFUCxHQUFHO1lBQ0RGLEtBQUssS0FBTUgsR0FBRyxDQUFDRSxNQUFNLEdBQUc7WUFDeEJFLEtBQUssS0FBTUQsS0FBSztRQUNsQixRQUFTLEVBQUVFLEdBQUc7UUFFZEYsTUFBTTtRQUNOQyxNQUFNO0lBQ1I7SUFFQSxPQUFPLEtBQU9BLE1BQU0sS0FBTTtBQUM1QjtBQUdBRSxPQUFPQyxPQUFPLEdBQUdUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanM/NjdhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iXSwibmFtZXMiOlsiYWRsZXIzMiIsImFkbGVyIiwiYnVmIiwibGVuIiwicG9zIiwiczEiLCJzMiIsIm4iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js ***!
  \**************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nmodule.exports = {\n    /* Allowed flush values; see deflate() and inflate() below for details */ Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_TREES: 6,\n    /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */ Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    //Z_MEM_ERROR:     -4,\n    Z_BUF_ERROR: -5,\n    //Z_VERSION_ERROR: -6,\n    /* compression levels */ Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    /* Possible values of the data_type field (though see inflate()) */ Z_BINARY: 0,\n    Z_TEXT: 1,\n    //Z_ASCII:                1, // = Z_TEXT (deprecated)\n    Z_UNKNOWN: 2,\n    /* The deflate compression method */ Z_DEFLATED: 8\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0VBLE9BQU9DLE9BQU8sR0FBRztJQUVmLHVFQUF1RSxHQUN2RUMsWUFBb0I7SUFDcEJDLGlCQUFvQjtJQUNwQkMsY0FBb0I7SUFDcEJDLGNBQW9CO0lBQ3BCQyxVQUFvQjtJQUNwQkMsU0FBb0I7SUFDcEJDLFNBQW9CO0lBRXBCOztFQUVBLEdBQ0FDLE1BQW9CO0lBQ3BCQyxjQUFvQjtJQUNwQkMsYUFBb0I7SUFDcEJDLFNBQW1CLENBQUM7SUFDcEJDLGdCQUFtQixDQUFDO0lBQ3BCQyxjQUFtQixDQUFDO0lBQ3BCLHNCQUFzQjtJQUN0QkMsYUFBbUIsQ0FBQztJQUNwQixzQkFBc0I7SUFFdEIsc0JBQXNCLEdBQ3RCQyxrQkFBMEI7SUFDMUJDLGNBQTBCO0lBQzFCQyxvQkFBMEI7SUFDMUJDLHVCQUF5QixDQUFDO0lBRzFCQyxZQUEwQjtJQUMxQkMsZ0JBQTBCO0lBQzFCQyxPQUEwQjtJQUMxQkMsU0FBMEI7SUFDMUJDLG9CQUEwQjtJQUUxQixpRUFBaUUsR0FDakVDLFVBQTBCO0lBQzFCQyxRQUEwQjtJQUMxQixxREFBcUQ7SUFDckRDLFdBQTBCO0lBRTFCLGtDQUFrQyxHQUNsQ0MsWUFBMEI7QUFFNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzP2I2MjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiWl9OT19GTFVTSCIsIlpfUEFSVElBTF9GTFVTSCIsIlpfU1lOQ19GTFVTSCIsIlpfRlVMTF9GTFVTSCIsIlpfRklOSVNIIiwiWl9CTE9DSyIsIlpfVFJFRVMiLCJaX09LIiwiWl9TVFJFQU1fRU5EIiwiWl9ORUVEX0RJQ1QiLCJaX0VSUk5PIiwiWl9TVFJFQU1fRVJST1IiLCJaX0RBVEFfRVJST1IiLCJaX0JVRl9FUlJPUiIsIlpfTk9fQ09NUFJFU1NJT04iLCJaX0JFU1RfU1BFRUQiLCJaX0JFU1RfQ09NUFJFU1NJT04iLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0ZJTFRFUkVEIiwiWl9IVUZGTUFOX09OTFkiLCJaX1JMRSIsIlpfRklYRUQiLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX0JJTkFSWSIsIlpfVEVYVCIsIlpfVU5LTk9XTiIsIlpfREVGTEFURUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js ***!
  \**********************************************************************************/
/***/ ((module) => {

eval("\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n    for(var n = 0; n < 256; n++){\n        c = n;\n        for(var k = 0; k < 8; k++){\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n        }\n        table[n] = c;\n    }\n    return table;\n}\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc ^= -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\nmodule.exports = crc32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxtREFBbUQ7QUFDbkQsMERBQTBEO0FBQzFELGdDQUFnQztBQUVoQyxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RSx3REFBd0Q7QUFDeEQsU0FBU0E7SUFDUCxJQUFJQyxHQUFHQyxRQUFRLEVBQUU7SUFFakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztRQUM1QkYsSUFBSUU7UUFDSixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCSCxJQUFLLElBQUssSUFBTSxhQUFjQSxNQUFNLElBQU9BLE1BQU07UUFDbkQ7UUFDQUMsS0FBSyxDQUFDQyxFQUFFLEdBQUdGO0lBQ2I7SUFFQSxPQUFPQztBQUNUO0FBRUEsOERBQThEO0FBQzlELElBQUlHLFdBQVdMO0FBR2YsU0FBU00sTUFBTUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztJQUMvQixJQUFJQyxJQUFJTixVQUNKTyxNQUFNRixNQUFNRDtJQUVoQkYsT0FBTyxDQUFDO0lBRVIsSUFBSyxJQUFJTSxJQUFJSCxLQUFLRyxJQUFJRCxLQUFLQyxJQUFLO1FBQzlCTixNQUFNLFFBQVMsSUFBS0ksQ0FBQyxDQUFDLENBQUNKLE1BQU1DLEdBQUcsQ0FBQ0ssRUFBRSxJQUFJLEtBQUs7SUFDOUM7SUFFQSxPQUFRTixNQUFPLENBQUMsR0FBSyxTQUFTO0FBQ2hDO0FBR0FPLE9BQU9DLE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanM/YjEzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iXSwibmFtZXMiOlsibWFrZVRhYmxlIiwiYyIsInRhYmxlIiwibiIsImsiLCJjcmNUYWJsZSIsImNyYzMyIiwiY3JjIiwiYnVmIiwibGVuIiwicG9zIiwidCIsImVuZCIsImkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/deflate.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/deflate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar trees = __webpack_require__(/*! ./trees */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js\");\nvar msg = __webpack_require__(/*! ./messages */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js\");\n/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ var Z_NO_FLUSH = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\n//var Z_TREES         = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */ var Z_OK = 0;\nvar Z_STREAM_END = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR = -5;\n//var Z_VERSION_ERROR = -6;\n/* compression levels */ //var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_FILTERED = 1;\nvar Z_HUFFMAN_ONLY = 2;\nvar Z_RLE = 3;\nvar Z_FIXED = 4;\nvar Z_DEFAULT_STRATEGY = 0;\n/* Possible values of the data_type field (though see inflate()) */ //var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN = 2;\n/* The deflate compression method */ var Z_DEFLATED = 8;\n/*============================================================================*/ var MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */ var MAX_WBITS = 15;\n/* 32K LZ77 window */ var DEF_MEM_LEVEL = 8;\nvar LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;\n/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;\n/* number of distance codes */ var BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */ var MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */ var MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\nvar PRESET_DICT = 0x20;\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\nvar BS_NEED_MORE = 1; /* block not completed, need more input or more output */ \nvar BS_BLOCK_DONE = 2; /* block flush performed */ \nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */ \nvar BS_FINISH_DONE = 4; /* finish done, accept no more input or output */ \nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\nfunction err(strm, errorCode) {\n    strm.msg = msg[errorCode];\n    return errorCode;\n}\nfunction rank(f) {\n    return (f << 1) - (f > 4 ? 9 : 0);\n}\nfunction zero(buf) {\n    var len = buf.length;\n    while(--len >= 0){\n        buf[len] = 0;\n    }\n}\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */ function flush_pending(strm) {\n    var s = strm.state;\n    //_tr_flush_bits(s);\n    var len = s.pending;\n    if (len > strm.avail_out) {\n        len = strm.avail_out;\n    }\n    if (len === 0) {\n        return;\n    }\n    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n    strm.next_out += len;\n    s.pending_out += len;\n    strm.total_out += len;\n    strm.avail_out -= len;\n    s.pending -= len;\n    if (s.pending === 0) {\n        s.pending_out = 0;\n    }\n}\nfunction flush_block_only(s, last) {\n    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n    s.block_start = s.strstart;\n    flush_pending(s.strm);\n}\nfunction put_byte(s, b) {\n    s.pending_buf[s.pending++] = b;\n}\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */ function putShortMSB(s, b) {\n    //  put_byte(s, (Byte)(b >> 8));\n    //  put_byte(s, (Byte)(b & 0xff));\n    s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n    s.pending_buf[s.pending++] = b & 0xff;\n}\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */ function read_buf(strm, buf, start, size) {\n    var len = strm.avail_in;\n    if (len > size) {\n        len = size;\n    }\n    if (len === 0) {\n        return 0;\n    }\n    strm.avail_in -= len;\n    // zmemcpy(buf, strm->next_in, len);\n    utils.arraySet(buf, strm.input, strm.next_in, len, start);\n    if (strm.state.wrap === 1) {\n        strm.adler = adler32(strm.adler, buf, len, start);\n    } else if (strm.state.wrap === 2) {\n        strm.adler = crc32(strm.adler, buf, len, start);\n    }\n    strm.next_in += len;\n    strm.total_in += len;\n    return len;\n}\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */ function longest_match(s, cur_match) {\n    var chain_length = s.max_chain_length; /* max hash chain length */ \n    var scan = s.strstart; /* current string */ \n    var match; /* matched string */ \n    var len; /* length of current match */ \n    var best_len = s.prev_length; /* best match length so far */ \n    var nice_match = s.nice_match; /* stop if match long enough */ \n    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/ ;\n    var _win = s.window; // shortcut\n    var wmask = s.w_mask;\n    var prev = s.prev;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */ var strend = s.strstart + MAX_MATCH;\n    var scan_end1 = _win[scan + best_len - 1];\n    var scan_end = _win[scan + best_len];\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */ // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n    /* Do not waste too much time if we already have a good match: */ if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */ if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n    }\n    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n    do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match;\n        /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */ if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n            continue;\n        }\n        /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */ scan += 2;\n        match++;\n        // Assert(*scan == *match, \"match[2]?\");\n        /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */ do {\n        /*jshint noempty:false*/ }while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n        // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n        if (len > best_len) {\n            s.match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) {\n                break;\n            }\n            scan_end1 = _win[scan + best_len - 1];\n            scan_end = _win[scan + best_len];\n        }\n    }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n    if (best_len <= s.lookahead) {\n        return best_len;\n    }\n    return s.lookahead;\n}\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */ function fill_window(s) {\n    var _w_size = s.w_size;\n    var p, n, m, more, str;\n    //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n    do {\n        more = s.window_size - s.lookahead - s.strstart;\n        // JS ints have 32 bit, block below not needed\n        /* Deal with !@#$% 64K limit: */ //if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        //}\n        /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */ if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n            s.match_start -= _w_size;\n            s.strstart -= _w_size;\n            /* we now have strstart >= MAX_DIST */ s.block_start -= _w_size;\n            /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */ n = s.hash_size;\n            p = n;\n            do {\n                m = s.head[--p];\n                s.head[p] = m >= _w_size ? m - _w_size : 0;\n            }while (--n);\n            n = _w_size;\n            p = n;\n            do {\n                m = s.prev[--p];\n                s.prev[p] = m >= _w_size ? m - _w_size : 0;\n            /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */ }while (--n);\n            more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n            break;\n        }\n        /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */ //Assert(more >= 2, \"more < 2\");\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        /* Initialize the hash value now that we have some input: */ if (s.lookahead + s.insert >= MIN_MATCH) {\n            str = s.strstart - s.insert;\n            s.ins_h = s.window[str];\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //        Call update_hash() MIN_MATCH-3 more times\n            //#endif\n            while(s.insert){\n                /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n                s.prev[str & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = str;\n                str++;\n                s.insert--;\n                if (s.lookahead + s.insert < MIN_MATCH) {\n                    break;\n                }\n            }\n        }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */ }while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n/* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */ //  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */ function deflate_stored(s, flush) {\n    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */ var max_block_size = 0xffff;\n    if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n    }\n    /* Copy as much as possible from input to output: */ for(;;){\n        /* Fill the window as much as possible: */ if (s.lookahead <= 1) {\n            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n            //  s->block_start >= (long)s->w_size, \"slide too late\");\n            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n            //        s.block_start >= s.w_size)) {\n            //        throw  new Error(\"slide too late\");\n            //      }\n            fill_window(s);\n            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            }\n        /* flush the current block */ }\n        //Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        /* Emit a stored block if pending_buf will be full: */ var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n            /* strstart == 0 is possible when wraparound on 16-bit machine */ s.lookahead = s.strstart - max_start;\n            s.strstart = max_start;\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n        /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */ if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.strstart > s.block_start) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_NEED_MORE;\n}\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */ function deflate_fast(s, flush) {\n    var hash_head; /* head of the hash chain */ \n    var bflush; /* set if current block must be flushed */ \n    for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */ if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break; /* flush the current block */ \n            }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */ hash_head = 0 /*NIL*/ ;\n        if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n        /***/ }\n        /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */ if (hash_head !== 0 /*NIL*/  && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */ s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */ }\n        if (s.match_length >= MIN_MATCH) {\n            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n            /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */ if (s.match_length <= s.max_lazy_match /*max_insert_length*/  && s.lookahead >= MIN_MATCH) {\n                s.match_length--; /* string at strstart already in table */ \n                do {\n                    s.strstart++;\n                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                /***/ /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */ }while (--s.match_length !== 0);\n                s.strstart++;\n            } else {\n                s.strstart += s.match_length;\n                s.match_length = 0;\n                s.ins_h = s.window[s.strstart];\n                /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            //#endif\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */ }\n        } else {\n            /* No match, output a literal byte */ //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n        }\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */ function deflate_slow(s, flush) {\n    var hash_head; /* head of hash chain */ \n    var bflush; /* set if current block must be flushed */ \n    var max_insert;\n    /* Process the input block. */ for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */ if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            } /* flush the current block */ \n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */ hash_head = 0 /*NIL*/ ;\n        if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n        /***/ }\n        /* Find the longest match, discarding those <= prev_length.\n     */ s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH - 1;\n        if (hash_head !== 0 /*NIL*/  && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */ s.match_length = longest_match(s, hash_head);\n            /* longest_match() sets match_start */ if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/ )) {\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */ s.match_length = MIN_MATCH - 1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */ if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n            max_insert = s.strstart + s.lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */ //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/ bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n            /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */ s.lookahead -= s.prev_length - 1;\n            s.prev_length -= 2;\n            do {\n                if (++s.strstart <= max_insert) {\n                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                /***/ }\n            }while (--s.prev_length !== 0);\n            s.match_available = 0;\n            s.match_length = MIN_MATCH - 1;\n            s.strstart++;\n            if (bflush) {\n                /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            /***/ }\n        } else if (s.match_available) {\n            /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */ //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n            if (bflush) {\n                /*** FLUSH_BLOCK_ONLY(s, 0) ***/ flush_block_only(s, false);\n            /***/ }\n            s.strstart++;\n            s.lookahead--;\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        } else {\n            /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */ s.match_available = 1;\n            s.strstart++;\n            s.lookahead--;\n        }\n    }\n    //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s.match_available) {\n        //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */ function deflate_rle(s, flush) {\n    var bflush; /* set if current block must be flushed */ \n    var prev; /* byte at distance one to match */ \n    var scan, strend; /* scan goes up to strend for length of run */ \n    var _win = s.window;\n    for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */ if (s.lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            } /* flush the current block */ \n        }\n        /* See how many times the previous byte repeats */ s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n            scan = s.strstart - 1;\n            prev = _win[scan];\n            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n                strend = s.strstart + MAX_MATCH;\n                do {\n                /*jshint noempty:false*/ }while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n                s.match_length = MAX_MATCH - (strend - scan);\n                if (s.match_length > s.lookahead) {\n                    s.match_length = s.lookahead;\n                }\n            }\n        //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */ if (s.match_length >= MIN_MATCH) {\n            //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            s.strstart += s.match_length;\n            s.match_length = 0;\n        } else {\n            /* No match, output a literal byte */ //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n        }\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */ function deflate_huff(s, flush) {\n    var bflush; /* set if current block must be flushed */ \n    for(;;){\n        /* Make sure that we have a literal to write. */ if (s.lookahead === 0) {\n            fill_window(s);\n            if (s.lookahead === 0) {\n                if (flush === Z_NO_FLUSH) {\n                    return BS_NEED_MORE;\n                }\n                break; /* flush the current block */ \n            }\n        }\n        /* Output a literal byte */ s.match_length = 0;\n        //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */ function Config(good_length, max_lazy, nice_length, max_chain, func) {\n    this.good_length = good_length;\n    this.max_lazy = max_lazy;\n    this.nice_length = nice_length;\n    this.max_chain = max_chain;\n    this.func = func;\n}\nvar configuration_table;\nconfiguration_table = [\n    /*      good lazy nice chain */ new Config(0, 0, 0, 0, deflate_stored),\n    /* 0 store only */ new Config(4, 4, 8, 4, deflate_fast),\n    /* 1 max speed, no lazy matches */ new Config(4, 5, 16, 8, deflate_fast),\n    /* 2 */ new Config(4, 6, 32, 32, deflate_fast),\n    /* 3 */ new Config(4, 4, 16, 16, deflate_slow),\n    /* 4 lazy matches */ new Config(8, 16, 32, 32, deflate_slow),\n    /* 5 */ new Config(8, 16, 128, 128, deflate_slow),\n    /* 6 */ new Config(8, 32, 128, 256, deflate_slow),\n    /* 7 */ new Config(32, 128, 258, 1024, deflate_slow),\n    /* 8 */ new Config(32, 258, 258, 4096, deflate_slow)\n];\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */ function lm_init(s) {\n    s.window_size = 2 * s.w_size;\n    /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);\n    /* Set the default configuration parameters:\n   */ s.max_lazy_match = configuration_table[s.level].max_lazy;\n    s.good_match = configuration_table[s.level].good_length;\n    s.nice_match = configuration_table[s.level].nice_length;\n    s.max_chain_length = configuration_table[s.level].max_chain;\n    s.strstart = 0;\n    s.block_start = 0;\n    s.lookahead = 0;\n    s.insert = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    s.ins_h = 0;\n}\nfunction DeflateState() {\n    this.strm = null; /* pointer back to this zlib stream */ \n    this.status = 0; /* as the name implies */ \n    this.pending_buf = null; /* output still pending */ \n    this.pending_buf_size = 0; /* size of pending_buf */ \n    this.pending_out = 0; /* next pending byte to output to the stream */ \n    this.pending = 0; /* nb of bytes in the pending buffer */ \n    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ \n    this.gzhead = null; /* gzip header information to write */ \n    this.gzindex = 0; /* where in extra, name, or comment */ \n    this.method = Z_DEFLATED; /* can only be DEFLATED */ \n    this.last_flush = -1; /* value of flush param for previous deflate call */ \n    this.w_size = 0; /* LZ77 window size (32K by default) */ \n    this.w_bits = 0; /* log2(w_size)  (8..16) */ \n    this.w_mask = 0; /* w_size - 1 */ \n    this.window = null;\n    /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */ this.window_size = 0;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */ this.prev = null;\n    /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */ this.head = null; /* Heads of the hash chains or NIL. */ \n    this.ins_h = 0; /* hash index of string to be inserted */ \n    this.hash_size = 0; /* number of elements in hash table */ \n    this.hash_bits = 0; /* log2(hash_size) */ \n    this.hash_mask = 0; /* hash_size-1 */ \n    this.hash_shift = 0;\n    /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */ this.block_start = 0;\n    /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */ this.match_length = 0; /* length of best match */ \n    this.prev_match = 0; /* previous match */ \n    this.match_available = 0; /* set if previous match exists */ \n    this.strstart = 0; /* start of string to insert */ \n    this.match_start = 0; /* start of matching string */ \n    this.lookahead = 0; /* number of valid bytes ahead in window */ \n    this.prev_length = 0;\n    /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */ this.max_chain_length = 0;\n    /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */ this.max_lazy_match = 0;\n    /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */ // That's alias to max_lazy_match, don't use directly\n    //this.max_insert_length = 0;\n    /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */ this.level = 0; /* compression level (1..9) */ \n    this.strategy = 0; /* favor or force Huffman coding*/ \n    this.good_match = 0;\n    /* Use a faster search when the previous match is longer than this */ this.nice_match = 0; /* Stop searching when current match exceeds this */ \n    /* used by trees.c: */ /* Didn't use ct_data typedef below to suppress compiler warning */ // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n    // Use flat array of DOUBLE size, with interleaved fata,\n    // because JS does not support effective\n    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n    zero(this.dyn_ltree);\n    zero(this.dyn_dtree);\n    zero(this.bl_tree);\n    this.l_desc = null; /* desc. for literal tree */ \n    this.d_desc = null; /* desc. for distance tree */ \n    this.bl_desc = null; /* desc. for bit length tree */ \n    //ush bl_count[MAX_BITS+1];\n    this.bl_count = new utils.Buf16(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */ //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */ \n    zero(this.heap);\n    this.heap_len = 0; /* number of elements in the heap */ \n    this.heap_max = 0; /* element of largest frequency */ \n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */ this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n    zero(this.depth);\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */ this.l_buf = 0; /* buffer index for literals or lengths */ \n    this.lit_bufsize = 0;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */ this.last_lit = 0; /* running index in l_buf */ \n    this.d_buf = 0;\n    /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */ this.opt_len = 0; /* bit length of current block with optimal trees */ \n    this.static_len = 0; /* bit length of current block with static trees */ \n    this.matches = 0; /* number of string matches in current block */ \n    this.insert = 0; /* bytes at end of window left to insert */ \n    this.bi_buf = 0;\n    /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */ this.bi_valid = 0;\n/* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */ // Used for window memory init. We safely ignore it for JS. That makes\n// sense only for pointers and memory check tools.\n//this.high_water = 0;\n/* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */ }\nfunction deflateResetKeep(strm) {\n    var s;\n    if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    strm.total_in = strm.total_out = 0;\n    strm.data_type = Z_UNKNOWN;\n    s = strm.state;\n    s.pending = 0;\n    s.pending_out = 0;\n    if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */ }\n    s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n    strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n     : 1; // adler32(0, Z_NULL, 0)\n    s.last_flush = Z_NO_FLUSH;\n    trees._tr_init(s);\n    return Z_OK;\n}\nfunction deflateReset(strm) {\n    var ret = deflateResetKeep(strm);\n    if (ret === Z_OK) {\n        lm_init(strm.state);\n    }\n    return ret;\n}\nfunction deflateSetHeader(strm, head) {\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n    }\n    strm.state.gzhead = head;\n    return Z_OK;\n}\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n    if (!strm) {\n        return Z_STREAM_ERROR;\n    }\n    var wrap = 1;\n    if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n    }\n    if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    } else if (windowBits > 15) {\n        wrap = 2; /* write gzip wrapper instead */ \n        windowBits -= 16;\n    }\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    if (windowBits === 8) {\n        windowBits = 9;\n    }\n    /* until 256-byte window bug fixed */ var s = new DeflateState();\n    strm.state = s;\n    s.strm = strm;\n    s.wrap = wrap;\n    s.gzhead = null;\n    s.w_bits = windowBits;\n    s.w_size = 1 << s.w_bits;\n    s.w_mask = s.w_size - 1;\n    s.hash_bits = memLevel + 7;\n    s.hash_size = 1 << s.hash_bits;\n    s.hash_mask = s.hash_size - 1;\n    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n    s.window = new utils.Buf8(s.w_size * 2);\n    s.head = new utils.Buf16(s.hash_size);\n    s.prev = new utils.Buf16(s.w_size);\n    // Don't need mem init magic for JS.\n    //s.high_water = 0;  /* nothing written to s->window yet */\n    s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */ \n    s.pending_buf_size = s.lit_bufsize * 4;\n    //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n    //s->pending_buf = (uchf *) overlay;\n    s.pending_buf = new utils.Buf8(s.pending_buf_size);\n    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n    //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s.d_buf = 1 * s.lit_bufsize;\n    //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n    s.l_buf = (1 + 2) * s.lit_bufsize;\n    s.level = level;\n    s.strategy = strategy;\n    s.method = method;\n    return deflateReset(strm);\n}\nfunction deflateInit(strm, level) {\n    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\nfunction deflate(strm, flush) {\n    var old_flush, s;\n    var beg, val; // for gzip header write only\n    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n    }\n    s = strm.state;\n    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n    }\n    s.strm = strm; /* just in case */ \n    old_flush = s.last_flush;\n    s.last_flush = flush;\n    /* Write the header */ if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n            strm.adler = 0; //crc32(0L, Z_NULL, 0);\n            put_byte(s, 31);\n            put_byte(s, 139);\n            put_byte(s, 8);\n            if (!s.gzhead) {\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                put_byte(s, OS_CODE);\n                s.status = BUSY_STATE;\n            } else {\n                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n                put_byte(s, s.gzhead.time & 0xff);\n                put_byte(s, s.gzhead.time >> 8 & 0xff);\n                put_byte(s, s.gzhead.time >> 16 & 0xff);\n                put_byte(s, s.gzhead.time >> 24 & 0xff);\n                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                put_byte(s, s.gzhead.os & 0xff);\n                if (s.gzhead.extra && s.gzhead.extra.length) {\n                    put_byte(s, s.gzhead.extra.length & 0xff);\n                    put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n                }\n                if (s.gzhead.hcrc) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n                }\n                s.gzindex = 0;\n                s.status = EXTRA_STATE;\n            }\n        } else {\n            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n            var level_flags = -1;\n            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n                level_flags = 0;\n            } else if (s.level < 6) {\n                level_flags = 1;\n            } else if (s.level === 6) {\n                level_flags = 2;\n            } else {\n                level_flags = 3;\n            }\n            header |= level_flags << 6;\n            if (s.strstart !== 0) {\n                header |= PRESET_DICT;\n            }\n            header += 31 - header % 31;\n            s.status = BUSY_STATE;\n            putShortMSB(s, header);\n            /* Save the adler32 of the preset dictionary: */ if (s.strstart !== 0) {\n                putShortMSB(s, strm.adler >>> 16);\n                putShortMSB(s, strm.adler & 0xffff);\n            }\n            strm.adler = 1; // adler32(0L, Z_NULL, 0);\n        }\n    }\n    //#ifdef GZIP\n    if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            while(s.gzindex < (s.gzhead.extra.length & 0xffff)){\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        break;\n                    }\n                }\n                put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n                s.gzindex++;\n            }\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (s.gzindex === s.gzhead.extra.length) {\n                s.gzindex = 0;\n                s.status = NAME_STATE;\n            }\n        } else {\n            s.status = NAME_STATE;\n        }\n    }\n    if (s.status === NAME_STATE) {\n        if (s.gzhead.name /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            //int val;\n            do {\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        val = 1;\n                        break;\n                    }\n                }\n                // JS specific: little magic to add zero terminator to end of string\n                if (s.gzindex < s.gzhead.name.length) {\n                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                    val = 0;\n                }\n                put_byte(s, val);\n            }while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n                s.gzindex = 0;\n                s.status = COMMENT_STATE;\n            }\n        } else {\n            s.status = COMMENT_STATE;\n        }\n    }\n    if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            //int val;\n            do {\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        val = 1;\n                        break;\n                    }\n                }\n                // JS specific: little magic to add zero terminator to end of string\n                if (s.gzindex < s.gzhead.comment.length) {\n                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                    val = 0;\n                }\n                put_byte(s, val);\n            }while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n                s.status = HCRC_STATE;\n            }\n        } else {\n            s.status = HCRC_STATE;\n        }\n    }\n    if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n            if (s.pending + 2 > s.pending_buf_size) {\n                flush_pending(strm);\n            }\n            if (s.pending + 2 <= s.pending_buf_size) {\n                put_byte(s, strm.adler & 0xff);\n                put_byte(s, strm.adler >> 8 & 0xff);\n                strm.adler = 0; //crc32(0L, Z_NULL, 0);\n                s.status = BUSY_STATE;\n            }\n        } else {\n            s.status = BUSY_STATE;\n        }\n    }\n    //#endif\n    /* Flush as much pending output as possible */ if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n            /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */ s.last_flush = -1;\n            return Z_OK;\n        }\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */ } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n    }\n    /* User must not provide more input after the first FINISH: */ if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n    }\n    /* Start a new block or continue the current one.\n   */ if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n            s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n            if (strm.avail_out === 0) {\n                s.last_flush = -1;\n            /* avoid BUF_ERROR next call, see above */ }\n            return Z_OK;\n        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */ }\n        if (bstate === BS_BLOCK_DONE) {\n            if (flush === Z_PARTIAL_FLUSH) {\n                trees._tr_align(s);\n            } else if (flush !== Z_BLOCK) {\n                trees._tr_stored_block(s, 0, 0, false);\n                /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */ if (flush === Z_FULL_FLUSH) {\n                    /*** CLEAR_HASH(s); ***/ /* forget history */ zero(s.head); // Fill with NIL (= 0);\n                    if (s.lookahead === 0) {\n                        s.strstart = 0;\n                        s.block_start = 0;\n                        s.insert = 0;\n                    }\n                }\n            }\n            flush_pending(strm);\n            if (strm.avail_out === 0) {\n                s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */ \n                return Z_OK;\n            }\n        }\n    }\n    //Assert(strm->avail_out > 0, \"bug2\");\n    //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n    if (flush !== Z_FINISH) {\n        return Z_OK;\n    }\n    if (s.wrap <= 0) {\n        return Z_STREAM_END;\n    }\n    /* Write the trailer */ if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        put_byte(s, strm.adler >> 16 & 0xff);\n        put_byte(s, strm.adler >> 24 & 0xff);\n        put_byte(s, strm.total_in & 0xff);\n        put_byte(s, strm.total_in >> 8 & 0xff);\n        put_byte(s, strm.total_in >> 16 & 0xff);\n        put_byte(s, strm.total_in >> 24 & 0xff);\n    } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n    }\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */ if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n    }\n    /* write the trailer only once! */ return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\nfunction deflateEnd(strm) {\n    var status;\n    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    status = strm.state.status;\n    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    strm.state = null;\n    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */ function deflateSetDictionary(strm, dictionary) {\n    var dictLength = dictionary.length;\n    var s;\n    var str, n;\n    var wrap;\n    var avail;\n    var next;\n    var input;\n    var tmpDict;\n    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    s = strm.state;\n    wrap = s.wrap;\n    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n        return Z_STREAM_ERROR;\n    }\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */ if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */ strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n    }\n    s.wrap = 0; /* avoid computing Adler-32 in read_buf */ \n    /* if dictionary would fill window, just replace the history */ if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n            /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n        }\n        /* use the tail */ // dictionary = dictionary.slice(dictLength - s.w_size);\n        tmpDict = new utils.Buf8(s.w_size);\n        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n    }\n    /* insert dictionary into window and hash */ avail = strm.avail_in;\n    next = strm.next_in;\n    input = strm.input;\n    strm.avail_in = dictLength;\n    strm.next_in = 0;\n    strm.input = dictionary;\n    fill_window(s);\n    while(s.lookahead >= MIN_MATCH){\n        str = s.strstart;\n        n = s.lookahead - (MIN_MATCH - 1);\n        do {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n        }while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH - 1;\n        fill_window(s);\n    }\n    s.strstart += s.lookahead;\n    s.block_start = s.strstart;\n    s.insert = s.lookahead;\n    s.lookahead = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    strm.next_in = next;\n    strm.input = input;\n    strm.avail_in = avail;\n    s.wrap = wrap;\n    return Z_OK;\n}\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = \"pako deflate (from Nodeca project)\"; /* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLElBQUlBLFFBQVVDLG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlDLFFBQVVELG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlFLFVBQVVGLG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlHLFFBQVVILG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlJLE1BQVVKLG1CQUFPQSxDQUFDO0FBRXRCLDhFQUE4RSxHQUM5RSw4RUFBOEUsR0FHOUUsdUVBQXVFLEdBQ3ZFLElBQUlLLGFBQWtCO0FBQ3RCLElBQUlDLGtCQUFrQjtBQUN0QiwwQkFBMEI7QUFDMUIsSUFBSUMsZUFBa0I7QUFDdEIsSUFBSUMsV0FBa0I7QUFDdEIsSUFBSUMsVUFBa0I7QUFDdEIsMEJBQTBCO0FBRzFCOztDQUVDLEdBQ0QsSUFBSUMsT0FBa0I7QUFDdEIsSUFBSUMsZUFBa0I7QUFDdEIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixJQUFJQyxpQkFBa0IsQ0FBQztBQUN2QixJQUFJQyxlQUFrQixDQUFDO0FBQ3ZCLDJCQUEyQjtBQUMzQixJQUFJQyxjQUFrQixDQUFDO0FBQ3ZCLDJCQUEyQjtBQUczQixzQkFBc0IsR0FDdEIsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsSUFBSUMsd0JBQXdCLENBQUM7QUFH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akQ7SUFDZDtJQUNBQSxFQUFFYyxRQUFRLElBQUlkLEVBQUUrQyxTQUFTO0lBQ3pCL0MsRUFBRWEsV0FBVyxHQUFHYixFQUFFYyxRQUFRO0lBQzFCZCxFQUFFMkQsTUFBTSxHQUFHM0QsRUFBRStDLFNBQVM7SUFDdEIvQyxFQUFFK0MsU0FBUyxHQUFHO0lBQ2QvQyxFQUFFdUUsWUFBWSxHQUFHdkUsRUFBRWtDLFdBQVcsR0FBRzVELFlBQVk7SUFDN0MwQixFQUFFK0UsZUFBZSxHQUFHO0lBQ3BCeEYsS0FBS2dDLE9BQU8sR0FBR2lJO0lBQ2ZqSyxLQUFLK0IsS0FBSyxHQUFHQTtJQUNiL0IsS0FBSzhCLFFBQVEsR0FBR2tJO0lBQ2hCdkosRUFBRXdCLElBQUksR0FBR0E7SUFDVCxPQUFPekU7QUFDVDtBQUdBMk0sbUJBQW1CLEdBQUd6QjtBQUN0QnlCLG9CQUFvQixHQUFHN0I7QUFDdkI2QixvQkFBb0IsR0FBR2hDO0FBQ3ZCZ0Msd0JBQXdCLEdBQUduQztBQUMzQm1DLHdCQUF3QixHQUFHOUI7QUFDM0I4QixlQUFlLEdBQUd4QjtBQUNsQndCLGtCQUFrQixHQUFHUDtBQUNyQk8sNEJBQTRCLEdBQUdOO0FBQy9CTSxtQkFBbUIsR0FBRyxzQ0FFdEI7Ozs7Ozs7QUFPQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzPzg1NGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsInRyZWVzIiwiYWRsZXIzMiIsImNyYzMyIiwibXNnIiwiWl9OT19GTFVTSCIsIlpfUEFSVElBTF9GTFVTSCIsIlpfRlVMTF9GTFVTSCIsIlpfRklOSVNIIiwiWl9CTE9DSyIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX1NUUkVBTV9FUlJPUiIsIlpfREFUQV9FUlJPUiIsIlpfQlVGX0VSUk9SIiwiWl9ERUZBVUxUX0NPTVBSRVNTSU9OIiwiWl9GSUxURVJFRCIsIlpfSFVGRk1BTl9PTkxZIiwiWl9STEUiLCJaX0ZJWEVEIiwiWl9ERUZBVUxUX1NUUkFURUdZIiwiWl9VTktOT1dOIiwiWl9ERUZMQVRFRCIsIk1BWF9NRU1fTEVWRUwiLCJNQVhfV0JJVFMiLCJERUZfTUVNX0xFVkVMIiwiTEVOR1RIX0NPREVTIiwiTElURVJBTFMiLCJMX0NPREVTIiwiRF9DT0RFUyIsIkJMX0NPREVTIiwiSEVBUF9TSVpFIiwiTUFYX0JJVFMiLCJNSU5fTUFUQ0giLCJNQVhfTUFUQ0giLCJNSU5fTE9PS0FIRUFEIiwiUFJFU0VUX0RJQ1QiLCJJTklUX1NUQVRFIiwiRVhUUkFfU1RBVEUiLCJOQU1FX1NUQVRFIiwiQ09NTUVOVF9TVEFURSIsIkhDUkNfU1RBVEUiLCJCVVNZX1NUQVRFIiwiRklOSVNIX1NUQVRFIiwiQlNfTkVFRF9NT1JFIiwiQlNfQkxPQ0tfRE9ORSIsIkJTX0ZJTklTSF9TVEFSVEVEIiwiQlNfRklOSVNIX0RPTkUiLCJPU19DT0RFIiwiZXJyIiwic3RybSIsImVycm9yQ29kZSIsInJhbmsiLCJmIiwiemVybyIsImJ1ZiIsImxlbiIsImxlbmd0aCIsImZsdXNoX3BlbmRpbmciLCJzIiwic3RhdGUiLCJwZW5kaW5nIiwiYXZhaWxfb3V0IiwiYXJyYXlTZXQiLCJvdXRwdXQiLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmdfb3V0IiwibmV4dF9vdXQiLCJ0b3RhbF9vdXQiLCJmbHVzaF9ibG9ja19vbmx5IiwibGFzdCIsIl90cl9mbHVzaF9ibG9jayIsImJsb2NrX3N0YXJ0Iiwic3Ryc3RhcnQiLCJwdXRfYnl0ZSIsImIiLCJwdXRTaG9ydE1TQiIsInJlYWRfYnVmIiwic3RhcnQiLCJzaXplIiwiYXZhaWxfaW4iLCJpbnB1dCIsIm5leHRfaW4iLCJ3cmFwIiwiYWRsZXIiLCJ0b3RhbF9pbiIsImxvbmdlc3RfbWF0Y2giLCJjdXJfbWF0Y2giLCJjaGFpbl9sZW5ndGgiLCJtYXhfY2hhaW5fbGVuZ3RoIiwic2NhbiIsIm1hdGNoIiwiYmVzdF9sZW4iLCJwcmV2X2xlbmd0aCIsIm5pY2VfbWF0Y2giLCJsaW1pdCIsIndfc2l6ZSIsIl93aW4iLCJ3aW5kb3ciLCJ3bWFzayIsIndfbWFzayIsInByZXYiLCJzdHJlbmQiLCJzY2FuX2VuZDEiLCJzY2FuX2VuZCIsImdvb2RfbWF0Y2giLCJsb29rYWhlYWQiLCJtYXRjaF9zdGFydCIsImZpbGxfd2luZG93IiwiX3dfc2l6ZSIsInAiLCJuIiwibSIsIm1vcmUiLCJzdHIiLCJ3aW5kb3dfc2l6ZSIsImhhc2hfc2l6ZSIsImhlYWQiLCJpbnNlcnQiLCJpbnNfaCIsImhhc2hfc2hpZnQiLCJoYXNoX21hc2siLCJkZWZsYXRlX3N0b3JlZCIsImZsdXNoIiwibWF4X2Jsb2NrX3NpemUiLCJwZW5kaW5nX2J1Zl9zaXplIiwibWF4X3N0YXJ0IiwiZGVmbGF0ZV9mYXN0IiwiaGFzaF9oZWFkIiwiYmZsdXNoIiwibWF0Y2hfbGVuZ3RoIiwiX3RyX3RhbGx5IiwibWF4X2xhenlfbWF0Y2giLCJsYXN0X2xpdCIsImRlZmxhdGVfc2xvdyIsIm1heF9pbnNlcnQiLCJwcmV2X21hdGNoIiwic3RyYXRlZ3kiLCJtYXRjaF9hdmFpbGFibGUiLCJkZWZsYXRlX3JsZSIsImRlZmxhdGVfaHVmZiIsIkNvbmZpZyIsImdvb2RfbGVuZ3RoIiwibWF4X2xhenkiLCJuaWNlX2xlbmd0aCIsIm1heF9jaGFpbiIsImZ1bmMiLCJjb25maWd1cmF0aW9uX3RhYmxlIiwibG1faW5pdCIsImxldmVsIiwiRGVmbGF0ZVN0YXRlIiwic3RhdHVzIiwiZ3poZWFkIiwiZ3ppbmRleCIsIm1ldGhvZCIsImxhc3RfZmx1c2giLCJ3X2JpdHMiLCJoYXNoX2JpdHMiLCJkeW5fbHRyZWUiLCJCdWYxNiIsImR5bl9kdHJlZSIsImJsX3RyZWUiLCJsX2Rlc2MiLCJkX2Rlc2MiLCJibF9kZXNjIiwiYmxfY291bnQiLCJoZWFwIiwiaGVhcF9sZW4iLCJoZWFwX21heCIsImRlcHRoIiwibF9idWYiLCJsaXRfYnVmc2l6ZSIsImRfYnVmIiwib3B0X2xlbiIsInN0YXRpY19sZW4iLCJtYXRjaGVzIiwiYmlfYnVmIiwiYmlfdmFsaWQiLCJkZWZsYXRlUmVzZXRLZWVwIiwiZGF0YV90eXBlIiwiX3RyX2luaXQiLCJkZWZsYXRlUmVzZXQiLCJyZXQiLCJkZWZsYXRlU2V0SGVhZGVyIiwiZGVmbGF0ZUluaXQyIiwid2luZG93Qml0cyIsIm1lbUxldmVsIiwiQnVmOCIsImRlZmxhdGVJbml0IiwiZGVmbGF0ZSIsIm9sZF9mbHVzaCIsImJlZyIsInZhbCIsInRleHQiLCJoY3JjIiwiZXh0cmEiLCJuYW1lIiwiY29tbWVudCIsInRpbWUiLCJvcyIsImhlYWRlciIsImxldmVsX2ZsYWdzIiwiY2hhckNvZGVBdCIsImJzdGF0ZSIsIl90cl9hbGlnbiIsIl90cl9zdG9yZWRfYmxvY2siLCJkZWZsYXRlRW5kIiwiZGVmbGF0ZVNldERpY3Rpb25hcnkiLCJkaWN0aW9uYXJ5IiwiZGljdExlbmd0aCIsImF2YWlsIiwibmV4dCIsInRtcERpY3QiLCJleHBvcnRzIiwiZGVmbGF0ZUluZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/gzheader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/gzheader.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction GZheader() {\n    /* true if compressed data believed to be text */ this.text = 0;\n    /* modification time */ this.time = 0;\n    /* extra flags (not used when writing a gzip file) */ this.xflags = 0;\n    /* operating system */ this.os = 0;\n    /* pointer to extra field or Z_NULL if none */ this.extra = null;\n    /* extra field length (valid if extra != Z_NULL) */ this.extra_len = 0; // Actually, we don't need it in JS,\n    // but leave for few code modifications\n    //\n    // Setup limits is not necessary because in js we should not preallocate memory\n    // for inflate use constant limit in 65536 bytes\n    //\n    /* space at extra (only when reading header) */ // this.extra_max  = 0;\n    /* pointer to zero-terminated file name or Z_NULL */ this.name = \"\";\n    /* space at name (only when reading header) */ // this.name_max   = 0;\n    /* pointer to zero-terminated comment or Z_NULL */ this.comment = \"\";\n    /* space at comment (only when reading header) */ // this.comm_max   = 0;\n    /* true if there was or will be a header crc */ this.hcrc = 0;\n    /* true when done reading gzip header (not used when writing a gzip file) */ this.done = false;\n}\nmodule.exports = GZheader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RSxTQUFTQTtJQUNQLCtDQUErQyxHQUMvQyxJQUFJLENBQUNDLElBQUksR0FBUztJQUNsQixxQkFBcUIsR0FDckIsSUFBSSxDQUFDQyxJQUFJLEdBQVM7SUFDbEIsbURBQW1ELEdBQ25ELElBQUksQ0FBQ0MsTUFBTSxHQUFPO0lBQ2xCLG9CQUFvQixHQUNwQixJQUFJLENBQUNDLEVBQUUsR0FBVztJQUNsQiw0Q0FBNEMsR0FDNUMsSUFBSSxDQUFDQyxLQUFLLEdBQVE7SUFDbEIsaURBQWlELEdBQ2pELElBQUksQ0FBQ0MsU0FBUyxHQUFJLEdBQUcsb0NBQW9DO0lBQ3BDLHVDQUF1QztJQUU1RCxFQUFFO0lBQ0YsK0VBQStFO0lBQy9FLGdEQUFnRDtJQUNoRCxFQUFFO0lBRUYsNkNBQTZDLEdBQzdDLHVCQUF1QjtJQUN2QixrREFBa0QsR0FDbEQsSUFBSSxDQUFDQyxJQUFJLEdBQVM7SUFDbEIsNENBQTRDLEdBQzVDLHVCQUF1QjtJQUN2QixnREFBZ0QsR0FDaEQsSUFBSSxDQUFDQyxPQUFPLEdBQU07SUFDbEIsK0NBQStDLEdBQy9DLHVCQUF1QjtJQUN2Qiw2Q0FBNkMsR0FDN0MsSUFBSSxDQUFDQyxJQUFJLEdBQVM7SUFDbEIsMEVBQTBFLEdBQzFFLElBQUksQ0FBQ0MsSUFBSSxHQUFTO0FBQ3BCO0FBRUFDLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanM/NjMxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iXSwibmFtZXMiOlsiR1poZWFkZXIiLCJ0ZXh0IiwidGltZSIsInhmbGFncyIsIm9zIiwiZXh0cmEiLCJleHRyYV9sZW4iLCJuYW1lIiwiY29tbWVudCIsImhjcmMiLCJkb25lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/gzheader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inffast.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inffast.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// See state defs from inflate.js\nvar BAD = 30; /* got a data error -- remain here until reset */ \nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */ \n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */ module.exports = function inflate_fast(strm, start) {\n    var state;\n    var _in; /* local strm.input */ \n    var last; /* have enough input while in < last */ \n    var _out; /* local strm.output */ \n    var beg; /* inflate()'s initial strm.output */ \n    var end; /* while out < end, enough space available */ \n    //#ifdef INFLATE_STRICT\n    var dmax; /* maximum distance from zlib header */ \n    //#endif\n    var wsize; /* window size or zero if not using window */ \n    var whave; /* valid bytes in the window */ \n    var wnext; /* window write index */ \n    // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n    var s_window; /* allocated sliding window, if wsize != 0 */ \n    var hold; /* local strm.hold */ \n    var bits; /* local strm.bits */ \n    var lcode; /* local strm.lencode */ \n    var dcode; /* local strm.distcode */ \n    var lmask; /* mask for first level of length codes */ \n    var dmask; /* mask for first level of distance codes */ \n    var here; /* retrieved table entry */ \n    var op; /* code bits, operation, extra bits, or */ \n    /*  window position, window bytes to copy */ var len; /* match length, unused bytes */ \n    var dist; /* match distance */ \n    var from; /* where to copy match from */ \n    var from_source;\n    var input, output; // JS specific, because we have no pointers\n    /* copy state to local variables */ state = strm.state;\n    //here = state.here;\n    _in = strm.next_in;\n    input = strm.input;\n    last = _in + (strm.avail_in - 5);\n    _out = strm.next_out;\n    output = strm.output;\n    beg = _out - (start - strm.avail_out);\n    end = _out + (strm.avail_out - 257);\n    //#ifdef INFLATE_STRICT\n    dmax = state.dmax;\n    //#endif\n    wsize = state.wsize;\n    whave = state.whave;\n    wnext = state.wnext;\n    s_window = state.window;\n    hold = state.hold;\n    bits = state.bits;\n    lcode = state.lencode;\n    dcode = state.distcode;\n    lmask = (1 << state.lenbits) - 1;\n    dmask = (1 << state.distbits) - 1;\n    /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */ top: do {\n        if (bits < 15) {\n            hold += input[_in++] << bits;\n            bits += 8;\n            hold += input[_in++] << bits;\n            bits += 8;\n        }\n        here = lcode[hold & lmask];\n        dolen: for(;;){\n            op = here >>> 24 /*here.bits*/ ;\n            hold >>>= op;\n            bits -= op;\n            op = here >>> 16 & 0xff /*here.op*/ ;\n            if (op === 0) {\n                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                //        \"inflate:         literal '%c'\\n\" :\n                //        \"inflate:         literal 0x%02x\\n\", here.val));\n                output[_out++] = here & 0xffff /*here.val*/ ;\n            } else if (op & 16) {\n                len = here & 0xffff /*here.val*/ ;\n                op &= 15; /* number of extra bits */ \n                if (op) {\n                    if (bits < op) {\n                        hold += input[_in++] << bits;\n                        bits += 8;\n                    }\n                    len += hold & (1 << op) - 1;\n                    hold >>>= op;\n                    bits -= op;\n                }\n                //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n                if (bits < 15) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                }\n                here = dcode[hold & dmask];\n                dodist: for(;;){\n                    op = here >>> 24 /*here.bits*/ ;\n                    hold >>>= op;\n                    bits -= op;\n                    op = here >>> 16 & 0xff /*here.op*/ ;\n                    if (op & 16) {\n                        dist = here & 0xffff /*here.val*/ ;\n                        op &= 15; /* number of extra bits */ \n                        if (bits < op) {\n                            hold += input[_in++] << bits;\n                            bits += 8;\n                            if (bits < op) {\n                                hold += input[_in++] << bits;\n                                bits += 8;\n                            }\n                        }\n                        dist += hold & (1 << op) - 1;\n                        //#ifdef INFLATE_STRICT\n                        if (dist > dmax) {\n                            strm.msg = \"invalid distance too far back\";\n                            state.mode = BAD;\n                            break top;\n                        }\n                        //#endif\n                        hold >>>= op;\n                        bits -= op;\n                        //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                        op = _out - beg; /* max distance in output */ \n                        if (dist > op) {\n                            op = dist - op; /* distance back in window */ \n                            if (op > whave) {\n                                if (state.sane) {\n                                    strm.msg = \"invalid distance too far back\";\n                                    state.mode = BAD;\n                                    break top;\n                                }\n                            // (!) This block is disabled in zlib defaults,\n                            // don't enable it for binary compatibility\n                            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                            //                if (len <= op - whave) {\n                            //                  do {\n                            //                    output[_out++] = 0;\n                            //                  } while (--len);\n                            //                  continue top;\n                            //                }\n                            //                len -= op - whave;\n                            //                do {\n                            //                  output[_out++] = 0;\n                            //                } while (--op > whave);\n                            //                if (op === 0) {\n                            //                  from = _out - dist;\n                            //                  do {\n                            //                    output[_out++] = output[from++];\n                            //                  } while (--len);\n                            //                  continue top;\n                            //                }\n                            //#endif\n                            }\n                            from = 0; // window index\n                            from_source = s_window;\n                            if (wnext === 0) {\n                                from += wsize - op;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = _out - dist; /* rest from output */ \n                                    from_source = output;\n                                }\n                            } else if (wnext < op) {\n                                from += wsize + wnext - op;\n                                op -= wnext;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = 0;\n                                    if (wnext < len) {\n                                        op = wnext;\n                                        len -= op;\n                                        do {\n                                            output[_out++] = s_window[from++];\n                                        }while (--op);\n                                        from = _out - dist; /* rest from output */ \n                                        from_source = output;\n                                    }\n                                }\n                            } else {\n                                from += wnext - op;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = _out - dist; /* rest from output */ \n                                    from_source = output;\n                                }\n                            }\n                            while(len > 2){\n                                output[_out++] = from_source[from++];\n                                output[_out++] = from_source[from++];\n                                output[_out++] = from_source[from++];\n                                len -= 3;\n                            }\n                            if (len) {\n                                output[_out++] = from_source[from++];\n                                if (len > 1) {\n                                    output[_out++] = from_source[from++];\n                                }\n                            }\n                        } else {\n                            from = _out - dist; /* copy direct from output */ \n                            do {\n                                output[_out++] = output[from++];\n                                output[_out++] = output[from++];\n                                output[_out++] = output[from++];\n                                len -= 3;\n                            }while (len > 2);\n                            if (len) {\n                                output[_out++] = output[from++];\n                                if (len > 1) {\n                                    output[_out++] = output[from++];\n                                }\n                            }\n                        }\n                    } else if ((op & 64) === 0) {\n                        here = dcode[(here & 0xffff) + (hold & (1 << op) - 1)];\n                        continue dodist;\n                    } else {\n                        strm.msg = \"invalid distance code\";\n                        state.mode = BAD;\n                        break top;\n                    }\n                    break; // need to emulate goto via \"continue\"\n                }\n            } else if ((op & 64) === 0) {\n                here = lcode[(here & 0xffff) + (hold & (1 << op) - 1)];\n                continue dolen;\n            } else if (op & 32) {\n                //Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state.mode = TYPE;\n                break top;\n            } else {\n                strm.msg = \"invalid literal/length code\";\n                state.mode = BAD;\n                break top;\n            }\n            break; // need to emulate goto via \"continue\"\n        }\n    }while (_in < last && _out < end);\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */ len = bits >> 3;\n    _in -= len;\n    bits -= len << 3;\n    hold &= (1 << bits) - 1;\n    /* update state and return */ strm.next_in = _in;\n    strm.next_out = _out;\n    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n    state.hold = hold;\n    state.bits = bits;\n    return;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLGlDQUFpQztBQUNqQyxJQUFJQSxNQUFNLElBQVUsK0NBQStDO0FBQ25FLElBQUlDLE9BQU8sSUFBUyxxREFBcUQ7QUFFekU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQ0MsR0FDREMsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGFBQWFDLElBQUksRUFBRUMsS0FBSztJQUNoRCxJQUFJQztJQUNKLElBQUlDLEtBQXdCLG9CQUFvQjtJQUNoRCxJQUFJQyxNQUF3QixxQ0FBcUM7SUFDakUsSUFBSUMsTUFBd0IscUJBQXFCO0lBQ2pELElBQUlDLEtBQXdCLG1DQUFtQztJQUMvRCxJQUFJQyxLQUF3QiwyQ0FBMkM7SUFDekUsdUJBQXVCO0lBQ3JCLElBQUlDLE1BQXdCLHFDQUFxQztJQUNuRSxRQUFRO0lBQ04sSUFBSUMsT0FBd0IsMkNBQTJDO0lBQ3ZFLElBQUlDLE9BQXdCLDZCQUE2QjtJQUN6RCxJQUFJQyxPQUF3QixzQkFBc0I7SUFDbEQsNkVBQTZFO0lBQzdFLElBQUlDLFVBQXdCLDJDQUEyQztJQUN2RSxJQUFJQyxNQUF3QixtQkFBbUI7SUFDL0MsSUFBSUMsTUFBd0IsbUJBQW1CO0lBQy9DLElBQUlDLE9BQXdCLHNCQUFzQjtJQUNsRCxJQUFJQyxPQUF3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QUFNeUM7b0JBQ1I7b0JBRUEsT0FBTyxzQ0FBc0M7Z0JBQy9DO1lBQ0YsT0FDSyxJQUFJLENBQUNoQixLQUFLLEVBQUMsTUFBTyxHQUFHO2dCQUN4QkQsT0FBT0osS0FBSyxDQUFDLENBQUNJLE9BQU8sTUFBSyxJQUFrQk4sQ0FBQUEsT0FBUSxDQUFDLEtBQUtPLEVBQUMsSUFBSyxDQUFDLEVBQUc7Z0JBQ3BFLFNBQVNpQjtZQUNYLE9BQ0ssSUFBSWpCLEtBQUssSUFBSTtnQkFDaEIsdURBQXVEO2dCQUN2RGxCLE1BQU1zQyxJQUFJLEdBQUc1QztnQkFDYixNQUFNd0M7WUFDUixPQUNLO2dCQUNIcEMsS0FBS3VDLEdBQUcsR0FBRztnQkFDWHJDLE1BQU1zQyxJQUFJLEdBQUc3QztnQkFDYixNQUFNeUM7WUFDUjtZQUVBLE9BQU8sc0NBQXNDO1FBQy9DO0lBQ0YsUUFBU2pDLE1BQU1DLFFBQVFDLE9BQU9FLEtBQUs7SUFFbkMseUVBQXlFLEdBQ3pFYyxNQUFNUCxRQUFRO0lBQ2RYLE9BQU9rQjtJQUNQUCxRQUFRTyxPQUFPO0lBQ2ZSLFFBQVEsQ0FBQyxLQUFLQyxJQUFHLElBQUs7SUFFdEIsMkJBQTJCLEdBQzNCZCxLQUFLMkIsT0FBTyxHQUFHeEI7SUFDZkgsS0FBSzZCLFFBQVEsR0FBR3hCO0lBQ2hCTCxLQUFLNEIsUUFBUSxHQUFJekIsTUFBTUMsT0FBTyxJQUFLQSxDQUFBQSxPQUFPRCxHQUFFLElBQUssSUFBS0EsQ0FBQUEsTUFBTUMsSUFBRztJQUMvREosS0FBSzhCLFNBQVMsR0FBSXpCLE9BQU9FLE1BQU0sTUFBT0EsQ0FBQUEsTUFBTUYsSUFBRyxJQUFLLE1BQU9BLENBQUFBLE9BQU9FLEdBQUU7SUFDcEVMLE1BQU1XLElBQUksR0FBR0E7SUFDYlgsTUFBTVksSUFBSSxHQUFHQTtJQUNiO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcz84YTY0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiJdLCJuYW1lcyI6WyJCQUQiLCJUWVBFIiwibW9kdWxlIiwiZXhwb3J0cyIsImluZmxhdGVfZmFzdCIsInN0cm0iLCJzdGFydCIsInN0YXRlIiwiX2luIiwibGFzdCIsIl9vdXQiLCJiZWciLCJlbmQiLCJkbWF4Iiwid3NpemUiLCJ3aGF2ZSIsInduZXh0Iiwic193aW5kb3ciLCJob2xkIiwiYml0cyIsImxjb2RlIiwiZGNvZGUiLCJsbWFzayIsImRtYXNrIiwiaGVyZSIsIm9wIiwibGVuIiwiZGlzdCIsImZyb20iLCJmcm9tX3NvdXJjZSIsImlucHV0Iiwib3V0cHV0IiwibmV4dF9pbiIsImF2YWlsX2luIiwibmV4dF9vdXQiLCJhdmFpbF9vdXQiLCJ3aW5kb3ciLCJsZW5jb2RlIiwiZGlzdGNvZGUiLCJsZW5iaXRzIiwiZGlzdGJpdHMiLCJ0b3AiLCJkb2xlbiIsImRvZGlzdCIsIm1zZyIsIm1vZGUiLCJzYW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inffast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inflate.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inflate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast = __webpack_require__(/*! ./inffast */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inftrees.js\");\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ //var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\nvar Z_TREES = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */ var Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_NEED_DICT = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR = -5;\n//var Z_VERSION_ERROR = -6;\n/* The deflate compression method */ var Z_DEFLATED = 8;\n/* STATES ====================================================================*/ /* ===========================================================================*/ var HEAD = 1; /* i: waiting for magic header */ \nvar FLAGS = 2; /* i: waiting for method and flags (gzip) */ \nvar TIME = 3; /* i: waiting for modification time (gzip) */ \nvar OS = 4; /* i: waiting for extra flags and operating system (gzip) */ \nvar EXLEN = 5; /* i: waiting for extra length (gzip) */ \nvar EXTRA = 6; /* i: waiting for extra bytes (gzip) */ \nvar NAME = 7; /* i: waiting for end of file name (gzip) */ \nvar COMMENT = 8; /* i: waiting for end of comment (gzip) */ \nvar HCRC = 9; /* i: waiting for header crc (gzip) */ \nvar DICTID = 10; /* i: waiting for dictionary check value */ \nvar DICT = 11; /* waiting for inflateSetDictionary() call */ \nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */ \nvar TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */ \nvar STORED = 14; /* i: waiting for stored size (length and complement) */ \nvar COPY_ = 15; /* i/o: same as COPY below, but only first time in */ \nvar COPY = 16; /* i/o: waiting for input or output to copy stored block */ \nvar TABLE = 17; /* i: waiting for dynamic block table lengths */ \nvar LENLENS = 18; /* i: waiting for code length code lengths */ \nvar CODELENS = 19; /* i: waiting for length/lit and distance code lengths */ \nvar LEN_ = 20; /* i: same as LEN below, but only first time in */ \nvar LEN = 21; /* i: waiting for length/lit/eob code */ \nvar LENEXT = 22; /* i: waiting for length extra bits */ \nvar DIST = 23; /* i: waiting for distance code */ \nvar DISTEXT = 24; /* i: waiting for distance extra bits */ \nvar MATCH = 25; /* o: waiting for output space to copy string */ \nvar LIT = 26; /* o: waiting for output space to write literal */ \nvar CHECK = 27; /* i: waiting for 32-bit check value */ \nvar LENGTH = 28; /* i: waiting for 32-bit length (gzip) */ \nvar DONE = 29; /* finished check, done -- remain here until reset */ \nvar BAD = 30; /* got a data error -- remain here until reset */ \nvar MEM = 31; /* got an inflate() memory error -- remain here until reset */ \nvar SYNC = 32; /* looking for synchronization bytes to restart inflate() */ \n/* ===========================================================================*/ var ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */ var DEF_WBITS = MAX_WBITS;\nfunction zswap32(q) {\n    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);\n}\nfunction InflateState() {\n    this.mode = 0; /* current inflate mode */ \n    this.last = false; /* true if processing last block */ \n    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ \n    this.havedict = false; /* true if dictionary provided */ \n    this.flags = 0; /* gzip header method and flags (0 if zlib) */ \n    this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */ \n    this.check = 0; /* protected copy of check value */ \n    this.total = 0; /* protected copy of output count */ \n    // TODO: may be {}\n    this.head = null; /* where to save gzip header information */ \n    /* sliding window */ this.wbits = 0; /* log base 2 of requested window size */ \n    this.wsize = 0; /* window size or zero if not using window */ \n    this.whave = 0; /* valid bytes in the window */ \n    this.wnext = 0; /* window write index */ \n    this.window = null; /* allocated sliding window, if needed */ \n    /* bit accumulator */ this.hold = 0; /* input bit accumulator */ \n    this.bits = 0; /* number of bits in \"in\" */ \n    /* for string and stored block copying */ this.length = 0; /* literal or length of data to copy */ \n    this.offset = 0; /* distance back to copy string from */ \n    /* for table and code decoding */ this.extra = 0; /* extra bits needed */ \n    /* fixed and dynamic code tables */ this.lencode = null; /* starting table for length/literal codes */ \n    this.distcode = null; /* starting table for distance codes */ \n    this.lenbits = 0; /* index bits for lencode */ \n    this.distbits = 0; /* index bits for distcode */ \n    /* dynamic table building */ this.ncode = 0; /* number of code length code lengths */ \n    this.nlen = 0; /* number of length code lengths */ \n    this.ndist = 0; /* number of distance code lengths */ \n    this.have = 0; /* number of code lengths in lens[] */ \n    this.next = null; /* next available space in codes[] */ \n    this.lens = new utils.Buf16(320); /* temporary storage for code lengths */ \n    this.work = new utils.Buf16(288); /* work area for code table building */ \n    /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */ //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n    this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */ \n    this.distdyn = null; /* dynamic table for distance codes (JS specific) */ \n    this.sane = 0; /* if false, allow invalid distance too far */ \n    this.back = 0; /* bits back of last unprocessed length/lit */ \n    this.was = 0; /* initial length of match */ \n}\nfunction inflateResetKeep(strm) {\n    var state;\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    strm.total_in = strm.total_out = state.total = 0;\n    strm.msg = \"\"; /*Z_NULL*/ \n    if (state.wrap) {\n        strm.adler = state.wrap & 1;\n    }\n    state.mode = HEAD;\n    state.last = 0;\n    state.havedict = 0;\n    state.dmax = 32768;\n    state.head = null /*Z_NULL*/ ;\n    state.hold = 0;\n    state.bits = 0;\n    //state.lencode = state.distcode = state.next = state.codes;\n    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n    state.sane = 1;\n    state.back = -1;\n    //Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}\nfunction inflateReset(strm) {\n    var state;\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    state.wsize = 0;\n    state.whave = 0;\n    state.wnext = 0;\n    return inflateResetKeep(strm);\n}\nfunction inflateReset2(strm, windowBits) {\n    var wrap;\n    var state;\n    /* get the state */ if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    /* extract wrap request from windowBits parameter */ if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    } else {\n        wrap = (windowBits >> 4) + 1;\n        if (windowBits < 48) {\n            windowBits &= 15;\n        }\n    }\n    /* set number of window bits, free window if different */ if (windowBits && (windowBits < 8 || windowBits > 15)) {\n        return Z_STREAM_ERROR;\n    }\n    if (state.window !== null && state.wbits !== windowBits) {\n        state.window = null;\n    }\n    /* update state and reset the rest of it */ state.wrap = wrap;\n    state.wbits = windowBits;\n    return inflateReset(strm);\n}\nfunction inflateInit2(strm, windowBits) {\n    var ret;\n    var state;\n    if (!strm) {\n        return Z_STREAM_ERROR;\n    }\n    //strm.msg = Z_NULL;                 /* in case we return an error */\n    state = new InflateState();\n    //if (state === Z_NULL) return Z_MEM_ERROR;\n    //Tracev((stderr, \"inflate: allocated\\n\"));\n    strm.state = state;\n    state.window = null /*Z_NULL*/ ;\n    ret = inflateReset2(strm, windowBits);\n    if (ret !== Z_OK) {\n        strm.state = null /*Z_NULL*/ ;\n    }\n    return ret;\n}\nfunction inflateInit(strm) {\n    return inflateInit2(strm, DEF_WBITS);\n}\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */ var virgin = true;\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\nfunction fixedtables(state) {\n    /* build fixed huffman tables if first call (may not be thread safe) */ if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512);\n        distfix = new utils.Buf32(32);\n        /* literal/length table */ sym = 0;\n        while(sym < 144){\n            state.lens[sym++] = 8;\n        }\n        while(sym < 256){\n            state.lens[sym++] = 9;\n        }\n        while(sym < 280){\n            state.lens[sym++] = 7;\n        }\n        while(sym < 288){\n            state.lens[sym++] = 8;\n        }\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n            bits: 9\n        });\n        /* distance table */ sym = 0;\n        while(sym < 32){\n            state.lens[sym++] = 5;\n        }\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n            bits: 5\n        });\n        /* do this just once */ virgin = false;\n    }\n    state.lencode = lenfix;\n    state.lenbits = 9;\n    state.distcode = distfix;\n    state.distbits = 5;\n}\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */ function updatewindow(strm, src, end, copy) {\n    var dist;\n    var state = strm.state;\n    /* if it hasn't been done already, allocate space for the window */ if (state.window === null) {\n        state.wsize = 1 << state.wbits;\n        state.wnext = 0;\n        state.whave = 0;\n        state.window = new utils.Buf8(state.wsize);\n    }\n    /* copy state->wsize or less output bytes into the circular window */ if (copy >= state.wsize) {\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n        state.wnext = 0;\n        state.whave = state.wsize;\n    } else {\n        dist = state.wsize - state.wnext;\n        if (dist > copy) {\n            dist = copy;\n        }\n        //zmemcpy(state->window + state->wnext, end - copy, dist);\n        utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n        copy -= dist;\n        if (copy) {\n            //zmemcpy(state->window, end - copy, copy);\n            utils.arraySet(state.window, src, end - copy, copy, 0);\n            state.wnext = copy;\n            state.whave = state.wsize;\n        } else {\n            state.wnext += dist;\n            if (state.wnext === state.wsize) {\n                state.wnext = 0;\n            }\n            if (state.whave < state.wsize) {\n                state.whave += dist;\n            }\n        }\n    }\n    return 0;\n}\nfunction inflate(strm, flush) {\n    var state;\n    var input, output; // input/output buffers\n    var next; /* next input INDEX */ \n    var put; /* next output INDEX */ \n    var have, left; /* available input and output */ \n    var hold; /* bit buffer */ \n    var bits; /* bits in bit buffer */ \n    var _in, _out; /* save starting available input and output */ \n    var copy; /* number of stored or match bytes to copy */ \n    var from; /* where to copy match bytes from */ \n    var from_source;\n    var here = 0; /* current decoding table entry */ \n    var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n    //var last;                   /* parent table entry */\n    var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n    var len; /* length to copy for repeats, bits to drop */ \n    var ret; /* return code */ \n    var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */ \n    var opts;\n    var n; // temporary var for NEED_BITS\n    var order = /* permutation of code lengths */ [\n        16,\n        17,\n        18,\n        0,\n        8,\n        7,\n        9,\n        6,\n        10,\n        5,\n        11,\n        4,\n        12,\n        3,\n        13,\n        2,\n        14,\n        1,\n        15\n    ];\n    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if (state.mode === TYPE) {\n        state.mode = TYPEDO;\n    } /* skip check */ \n    //--- LOAD() ---\n    put = strm.next_out;\n    output = strm.output;\n    left = strm.avail_out;\n    next = strm.next_in;\n    input = strm.input;\n    have = strm.avail_in;\n    hold = state.hold;\n    bits = state.bits;\n    //---\n    _in = have;\n    _out = left;\n    ret = Z_OK;\n    inf_leave: for(;;){\n        switch(state.mode){\n            case HEAD:\n                if (state.wrap === 0) {\n                    state.mode = TYPEDO;\n                    break;\n                }\n                //=== NEEDBITS(16);\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.wrap & 2 && hold === 0x8b1f) {\n                    state.check = 0 /*crc32(0L, Z_NULL, 0)*/ ;\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                    //===//\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                    //===//\n                    state.mode = FLAGS;\n                    break;\n                }\n                state.flags = 0; /* expect zlib header */ \n                if (state.head) {\n                    state.head.done = false;\n                }\n                if (!(state.wrap & 1) || /* check if zlib header allowed */ (((hold & 0xff) << 8) + (hold >> 8)) % 31) {\n                    strm.msg = \"incorrect header check\";\n                    state.mode = BAD;\n                    break;\n                }\n                if ((hold & 0x0f) !== Z_DEFLATED) {\n                    strm.msg = \"unknown compression method\";\n                    state.mode = BAD;\n                    break;\n                }\n                //--- DROPBITS(4) ---//\n                hold >>>= 4;\n                bits -= 4;\n                //---//\n                len = (hold & 0x0f) + 8;\n                if (state.wbits === 0) {\n                    state.wbits = len;\n                } else if (len > state.wbits) {\n                    strm.msg = \"invalid window size\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.dmax = 1 << len;\n                //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n                state.mode = hold & 0x200 ? DICTID : TYPE;\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                break;\n            case FLAGS:\n                //=== NEEDBITS(16); */\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.flags = hold;\n                if ((state.flags & 0xff) !== Z_DEFLATED) {\n                    strm.msg = \"unknown compression method\";\n                    state.mode = BAD;\n                    break;\n                }\n                if (state.flags & 0xe000) {\n                    strm.msg = \"unknown header flags set\";\n                    state.mode = BAD;\n                    break;\n                }\n                if (state.head) {\n                    state.head.text = hold >> 8 & 1;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                //===//\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = TIME;\n            /* falls through */ case TIME:\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.head) {\n                    state.head.time = hold;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC4(state.check, hold)\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    hbuf[2] = hold >>> 16 & 0xff;\n                    hbuf[3] = hold >>> 24 & 0xff;\n                    state.check = crc32(state.check, hbuf, 4, 0);\n                //===\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = OS;\n            /* falls through */ case OS:\n                //=== NEEDBITS(16); */\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.head) {\n                    state.head.xflags = hold & 0xff;\n                    state.head.os = hold >> 8;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                //===//\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = EXLEN;\n            /* falls through */ case EXLEN:\n                if (state.flags & 0x0400) {\n                    //=== NEEDBITS(16); */\n                    while(bits < 16){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.length = hold;\n                    if (state.head) {\n                        state.head.extra_len = hold;\n                    }\n                    if (state.flags & 0x0200) {\n                        //=== CRC2(state.check, hold);\n                        hbuf[0] = hold & 0xff;\n                        hbuf[1] = hold >>> 8 & 0xff;\n                        state.check = crc32(state.check, hbuf, 2, 0);\n                    //===//\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                } else if (state.head) {\n                    state.head.extra = null /*Z_NULL*/ ;\n                }\n                state.mode = EXTRA;\n            /* falls through */ case EXTRA:\n                if (state.flags & 0x0400) {\n                    copy = state.length;\n                    if (copy > have) {\n                        copy = have;\n                    }\n                    if (copy) {\n                        if (state.head) {\n                            len = state.head.extra_len - state.length;\n                            if (!state.head.extra) {\n                                // Use untyped array for more convenient processing later\n                                state.head.extra = new Array(state.head.extra_len);\n                            }\n                            utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes\n                            // - no need for additional size check\n                            copy, /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/ len);\n                        //zmemcpy(state.head.extra + len, next,\n                        //        len + copy > state.head.extra_max ?\n                        //        state.head.extra_max - len : copy);\n                        }\n                        if (state.flags & 0x0200) {\n                            state.check = crc32(state.check, input, copy, next);\n                        }\n                        have -= copy;\n                        next += copy;\n                        state.length -= copy;\n                    }\n                    if (state.length) {\n                        break inf_leave;\n                    }\n                }\n                state.length = 0;\n                state.mode = NAME;\n            /* falls through */ case NAME:\n                if (state.flags & 0x0800) {\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    copy = 0;\n                    do {\n                        // TODO: 2 or 1 bytes?\n                        len = input[next + copy++];\n                        /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.name_max*/ ) {\n                            state.head.name += String.fromCharCode(len);\n                        }\n                    }while (len && copy < have);\n                    if (state.flags & 0x0200) {\n                        state.check = crc32(state.check, input, copy, next);\n                    }\n                    have -= copy;\n                    next += copy;\n                    if (len) {\n                        break inf_leave;\n                    }\n                } else if (state.head) {\n                    state.head.name = null;\n                }\n                state.length = 0;\n                state.mode = COMMENT;\n            /* falls through */ case COMMENT:\n                if (state.flags & 0x1000) {\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    copy = 0;\n                    do {\n                        len = input[next + copy++];\n                        /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.comm_max*/ ) {\n                            state.head.comment += String.fromCharCode(len);\n                        }\n                    }while (len && copy < have);\n                    if (state.flags & 0x0200) {\n                        state.check = crc32(state.check, input, copy, next);\n                    }\n                    have -= copy;\n                    next += copy;\n                    if (len) {\n                        break inf_leave;\n                    }\n                } else if (state.head) {\n                    state.head.comment = null;\n                }\n                state.mode = HCRC;\n            /* falls through */ case HCRC:\n                if (state.flags & 0x0200) {\n                    //=== NEEDBITS(16); */\n                    while(bits < 16){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    if (hold !== (state.check & 0xffff)) {\n                        strm.msg = \"header crc mismatch\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                }\n                if (state.head) {\n                    state.head.hcrc = state.flags >> 9 & 1;\n                    state.head.done = true;\n                }\n                strm.adler = state.check = 0;\n                state.mode = TYPE;\n                break;\n            case DICTID:\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                strm.adler = state.check = zswap32(hold);\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = DICT;\n            /* falls through */ case DICT:\n                if (state.havedict === 0) {\n                    //--- RESTORE() ---\n                    strm.next_out = put;\n                    strm.avail_out = left;\n                    strm.next_in = next;\n                    strm.avail_in = have;\n                    state.hold = hold;\n                    state.bits = bits;\n                    //---\n                    return Z_NEED_DICT;\n                }\n                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n                state.mode = TYPE;\n            /* falls through */ case TYPE:\n                if (flush === Z_BLOCK || flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case TYPEDO:\n                if (state.last) {\n                    //--- BYTEBITS() ---//\n                    hold >>>= bits & 7;\n                    bits -= bits & 7;\n                    //---//\n                    state.mode = CHECK;\n                    break;\n                }\n                //=== NEEDBITS(3); */\n                while(bits < 3){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.last = hold & 0x01 /*BITS(1)*/ ;\n                //--- DROPBITS(1) ---//\n                hold >>>= 1;\n                bits -= 1;\n                //---//\n                switch(hold & 0x03){\n                    case 0:\n                        /* stored block */ //Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = STORED;\n                        break;\n                    case 1:\n                        /* fixed block */ fixedtables(state);\n                        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = LEN_; /* decode codes */ \n                        if (flush === Z_TREES) {\n                            //--- DROPBITS(2) ---//\n                            hold >>>= 2;\n                            bits -= 2;\n                            break inf_leave;\n                        }\n                        break;\n                    case 2:\n                        /* dynamic block */ //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = TABLE;\n                        break;\n                    case 3:\n                        strm.msg = \"invalid block type\";\n                        state.mode = BAD;\n                }\n                //--- DROPBITS(2) ---//\n                hold >>>= 2;\n                bits -= 2;\n                break;\n            case STORED:\n                //--- BYTEBITS() ---// /* go to byte boundary */\n                hold >>>= bits & 7;\n                bits -= bits & 7;\n                //---//\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {\n                    strm.msg = \"invalid stored block lengths\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.length = hold & 0xffff;\n                //Tracev((stderr, \"inflate:       stored length %u\\n\",\n                //        state.length));\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = COPY_;\n                if (flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case COPY_:\n                state.mode = COPY;\n            /* falls through */ case COPY:\n                copy = state.length;\n                if (copy) {\n                    if (copy > have) {\n                        copy = have;\n                    }\n                    if (copy > left) {\n                        copy = left;\n                    }\n                    if (copy === 0) {\n                        break inf_leave;\n                    }\n                    //--- zmemcpy(put, next, copy); ---\n                    utils.arraySet(output, input, next, copy, put);\n                    //---//\n                    have -= copy;\n                    next += copy;\n                    left -= copy;\n                    put += copy;\n                    state.length -= copy;\n                    break;\n                }\n                //Tracev((stderr, \"inflate:       stored end\\n\"));\n                state.mode = TYPE;\n                break;\n            case TABLE:\n                //=== NEEDBITS(14); */\n                while(bits < 14){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.nlen = (hold & 0x1f) + 257;\n                //--- DROPBITS(5) ---//\n                hold >>>= 5;\n                bits -= 5;\n                //---//\n                state.ndist = (hold & 0x1f) + 1;\n                //--- DROPBITS(5) ---//\n                hold >>>= 5;\n                bits -= 5;\n                //---//\n                state.ncode = (hold & 0x0f) + 4;\n                //--- DROPBITS(4) ---//\n                hold >>>= 4;\n                bits -= 4;\n                //---//\n                //#ifndef PKZIP_BUG_WORKAROUND\n                if (state.nlen > 286 || state.ndist > 30) {\n                    strm.msg = \"too many length or distance symbols\";\n                    state.mode = BAD;\n                    break;\n                }\n                //#endif\n                //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n                state.have = 0;\n                state.mode = LENLENS;\n            /* falls through */ case LENLENS:\n                while(state.have < state.ncode){\n                    //=== NEEDBITS(3);\n                    while(bits < 3){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.lens[order[state.have++]] = hold & 0x07; //BITS(3);\n                    //--- DROPBITS(3) ---//\n                    hold >>>= 3;\n                    bits -= 3;\n                //---//\n                }\n                while(state.have < 19){\n                    state.lens[order[state.have++]] = 0;\n                }\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                //state.next = state.codes;\n                //state.lencode = state.next;\n                // Switch to use dynamic table\n                state.lencode = state.lendyn;\n                state.lenbits = 7;\n                opts = {\n                    bits: state.lenbits\n                };\n                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n                state.lenbits = opts.bits;\n                if (ret) {\n                    strm.msg = \"invalid code lengths set\";\n                    state.mode = BAD;\n                    break;\n                }\n                //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n                state.have = 0;\n                state.mode = CODELENS;\n            /* falls through */ case CODELENS:\n                while(state.have < state.nlen + state.ndist){\n                    for(;;){\n                        here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ \n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    if (here_val < 16) {\n                        //--- DROPBITS(here.bits) ---//\n                        hold >>>= here_bits;\n                        bits -= here_bits;\n                        //---//\n                        state.lens[state.have++] = here_val;\n                    } else {\n                        if (here_val === 16) {\n                            //=== NEEDBITS(here.bits + 2);\n                            n = here_bits + 2;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            if (state.have === 0) {\n                                strm.msg = \"invalid bit length repeat\";\n                                state.mode = BAD;\n                                break;\n                            }\n                            len = state.lens[state.have - 1];\n                            copy = 3 + (hold & 0x03); //BITS(2);\n                            //--- DROPBITS(2) ---//\n                            hold >>>= 2;\n                            bits -= 2;\n                        //---//\n                        } else if (here_val === 17) {\n                            //=== NEEDBITS(here.bits + 3);\n                            n = here_bits + 3;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            len = 0;\n                            copy = 3 + (hold & 0x07); //BITS(3);\n                            //--- DROPBITS(3) ---//\n                            hold >>>= 3;\n                            bits -= 3;\n                        //---//\n                        } else {\n                            //=== NEEDBITS(here.bits + 7);\n                            n = here_bits + 7;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            len = 0;\n                            copy = 11 + (hold & 0x7f); //BITS(7);\n                            //--- DROPBITS(7) ---//\n                            hold >>>= 7;\n                            bits -= 7;\n                        //---//\n                        }\n                        if (state.have + copy > state.nlen + state.ndist) {\n                            strm.msg = \"invalid bit length repeat\";\n                            state.mode = BAD;\n                            break;\n                        }\n                        while(copy--){\n                            state.lens[state.have++] = len;\n                        }\n                    }\n                }\n                /* handle error breaks in while */ if (state.mode === BAD) {\n                    break;\n                }\n                /* check for end-of-block code (better have one) */ if (state.lens[256] === 0) {\n                    strm.msg = \"invalid code -- missing end-of-block\";\n                    state.mode = BAD;\n                    break;\n                }\n                /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */ state.lenbits = 9;\n                opts = {\n                    bits: state.lenbits\n                };\n                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                // state.next_index = opts.table_index;\n                state.lenbits = opts.bits;\n                // state.lencode = state.next;\n                if (ret) {\n                    strm.msg = \"invalid literal/lengths set\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.distbits = 6;\n                //state.distcode.copy(state.codes);\n                // Switch to use dynamic table\n                state.distcode = state.distdyn;\n                opts = {\n                    bits: state.distbits\n                };\n                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                // state.next_index = opts.table_index;\n                state.distbits = opts.bits;\n                // state.distcode = state.next;\n                if (ret) {\n                    strm.msg = \"invalid distances set\";\n                    state.mode = BAD;\n                    break;\n                }\n                //Tracev((stderr, 'inflate:       codes ok\\n'));\n                state.mode = LEN_;\n                if (flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case LEN_:\n                state.mode = LEN;\n            /* falls through */ case LEN:\n                if (have >= 6 && left >= 258) {\n                    //--- RESTORE() ---\n                    strm.next_out = put;\n                    strm.avail_out = left;\n                    strm.next_in = next;\n                    strm.avail_in = have;\n                    state.hold = hold;\n                    state.bits = bits;\n                    //---\n                    inflate_fast(strm, _out);\n                    //--- LOAD() ---\n                    put = strm.next_out;\n                    output = strm.output;\n                    left = strm.avail_out;\n                    next = strm.next_in;\n                    input = strm.input;\n                    have = strm.avail_in;\n                    hold = state.hold;\n                    bits = state.bits;\n                    //---\n                    if (state.mode === TYPE) {\n                        state.back = -1;\n                    }\n                    break;\n                }\n                state.back = 0;\n                for(;;){\n                    here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ \n                    here_bits = here >>> 24;\n                    here_op = here >>> 16 & 0xff;\n                    here_val = here & 0xffff;\n                    if (here_bits <= bits) {\n                        break;\n                    }\n                    //--- PULLBYTE() ---//\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                //---//\n                }\n                if (here_op && (here_op & 0xf0) === 0) {\n                    last_bits = here_bits;\n                    last_op = here_op;\n                    last_val = here_val;\n                    for(;;){\n                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (last_bits + here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    //--- DROPBITS(last.bits) ---//\n                    hold >>>= last_bits;\n                    bits -= last_bits;\n                    //---//\n                    state.back += last_bits;\n                }\n                //--- DROPBITS(here.bits) ---//\n                hold >>>= here_bits;\n                bits -= here_bits;\n                //---//\n                state.back += here_bits;\n                state.length = here_val;\n                if (here_op === 0) {\n                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                    //        \"inflate:         literal '%c'\\n\" :\n                    //        \"inflate:         literal 0x%02x\\n\", here.val));\n                    state.mode = LIT;\n                    break;\n                }\n                if (here_op & 32) {\n                    //Tracevv((stderr, \"inflate:         end of block\\n\"));\n                    state.back = -1;\n                    state.mode = TYPE;\n                    break;\n                }\n                if (here_op & 64) {\n                    strm.msg = \"invalid literal/length code\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.extra = here_op & 15;\n                state.mode = LENEXT;\n            /* falls through */ case LENEXT:\n                if (state.extra) {\n                    //=== NEEDBITS(state.extra);\n                    n = state.extra;\n                    while(bits < n){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;\n                    //--- DROPBITS(state.extra) ---//\n                    hold >>>= state.extra;\n                    bits -= state.extra;\n                    //---//\n                    state.back += state.extra;\n                }\n                //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n                state.was = state.length;\n                state.mode = DIST;\n            /* falls through */ case DIST:\n                for(;;){\n                    here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/ \n                    here_bits = here >>> 24;\n                    here_op = here >>> 16 & 0xff;\n                    here_val = here & 0xffff;\n                    if (here_bits <= bits) {\n                        break;\n                    }\n                    //--- PULLBYTE() ---//\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                //---//\n                }\n                if ((here_op & 0xf0) === 0) {\n                    last_bits = here_bits;\n                    last_op = here_op;\n                    last_val = here_val;\n                    for(;;){\n                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (last_bits + here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    //--- DROPBITS(last.bits) ---//\n                    hold >>>= last_bits;\n                    bits -= last_bits;\n                    //---//\n                    state.back += last_bits;\n                }\n                //--- DROPBITS(here.bits) ---//\n                hold >>>= here_bits;\n                bits -= here_bits;\n                //---//\n                state.back += here_bits;\n                if (here_op & 64) {\n                    strm.msg = \"invalid distance code\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.offset = here_val;\n                state.extra = here_op & 15;\n                state.mode = DISTEXT;\n            /* falls through */ case DISTEXT:\n                if (state.extra) {\n                    //=== NEEDBITS(state.extra);\n                    n = state.extra;\n                    while(bits < n){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;\n                    //--- DROPBITS(state.extra) ---//\n                    hold >>>= state.extra;\n                    bits -= state.extra;\n                    //---//\n                    state.back += state.extra;\n                }\n                //#ifdef INFLATE_STRICT\n                if (state.offset > state.dmax) {\n                    strm.msg = \"invalid distance too far back\";\n                    state.mode = BAD;\n                    break;\n                }\n                //#endif\n                //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n                state.mode = MATCH;\n            /* falls through */ case MATCH:\n                if (left === 0) {\n                    break inf_leave;\n                }\n                copy = _out - left;\n                if (state.offset > copy) {\n                    copy = state.offset - copy;\n                    if (copy > state.whave) {\n                        if (state.sane) {\n                            strm.msg = \"invalid distance too far back\";\n                            state.mode = BAD;\n                            break;\n                        }\n                    // (!) This block is disabled in zlib defaults,\n                    // don't enable it for binary compatibility\n                    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    //          Trace((stderr, \"inflate.c too far\\n\"));\n                    //          copy -= state.whave;\n                    //          if (copy > state.length) { copy = state.length; }\n                    //          if (copy > left) { copy = left; }\n                    //          left -= copy;\n                    //          state.length -= copy;\n                    //          do {\n                    //            output[put++] = 0;\n                    //          } while (--copy);\n                    //          if (state.length === 0) { state.mode = LEN; }\n                    //          break;\n                    //#endif\n                    }\n                    if (copy > state.wnext) {\n                        copy -= state.wnext;\n                        from = state.wsize - copy;\n                    } else {\n                        from = state.wnext - copy;\n                    }\n                    if (copy > state.length) {\n                        copy = state.length;\n                    }\n                    from_source = state.window;\n                } else {\n                    from_source = output;\n                    from = put - state.offset;\n                    copy = state.length;\n                }\n                if (copy > left) {\n                    copy = left;\n                }\n                left -= copy;\n                state.length -= copy;\n                do {\n                    output[put++] = from_source[from++];\n                }while (--copy);\n                if (state.length === 0) {\n                    state.mode = LEN;\n                }\n                break;\n            case LIT:\n                if (left === 0) {\n                    break inf_leave;\n                }\n                output[put++] = state.length;\n                left--;\n                state.mode = LEN;\n                break;\n            case CHECK:\n                if (state.wrap) {\n                    //=== NEEDBITS(32);\n                    while(bits < 32){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        // Use '|' instead of '+' to make sure that result is signed\n                        hold |= input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    _out -= left;\n                    strm.total_out += _out;\n                    state.total += _out;\n                    if (_out) {\n                        strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/ state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n                    }\n                    _out = left;\n                    // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n                        strm.msg = \"incorrect data check\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n                }\n                state.mode = LENGTH;\n            /* falls through */ case LENGTH:\n                if (state.wrap && state.flags) {\n                    //=== NEEDBITS(32);\n                    while(bits < 32){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    if (hold !== (state.total & 0xffffffff)) {\n                        strm.msg = \"incorrect length check\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n                }\n                state.mode = DONE;\n            /* falls through */ case DONE:\n                ret = Z_STREAM_END;\n                break inf_leave;\n            case BAD:\n                ret = Z_DATA_ERROR;\n                break inf_leave;\n            case MEM:\n                return Z_MEM_ERROR;\n            case SYNC:\n            /* falls through */ default:\n                return Z_STREAM_ERROR;\n        }\n    }\n    // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n    /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */ //--- RESTORE() ---\n    strm.next_out = put;\n    strm.avail_out = left;\n    strm.next_in = next;\n    strm.avail_in = have;\n    state.hold = hold;\n    state.bits = bits;\n    //---\n    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n            state.mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    }\n    _in -= strm.avail_in;\n    _out -= strm.avail_out;\n    strm.total_in += _in;\n    strm.total_out += _out;\n    state.total += _out;\n    if (state.wrap && _out) {\n        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/ state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n    }\n    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {\n        ret = Z_BUF_ERROR;\n    }\n    return ret;\n}\nfunction inflateEnd(strm) {\n    if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    var state = strm.state;\n    if (state.window) {\n        state.window = null;\n    }\n    strm.state = null;\n    return Z_OK;\n}\nfunction inflateGetHeader(strm, head) {\n    var state;\n    /* check state */ if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if ((state.wrap & 2) === 0) {\n        return Z_STREAM_ERROR;\n    }\n    /* save header structure */ state.head = head;\n    head.done = false;\n    return Z_OK;\n}\nfunction inflateSetDictionary(strm, dictionary) {\n    var dictLength = dictionary.length;\n    var state;\n    var dictid;\n    var ret;\n    /* check state */ if (!strm /* == Z_NULL */  || !strm.state /* == Z_NULL */ ) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if (state.wrap !== 0 && state.mode !== DICT) {\n        return Z_STREAM_ERROR;\n    }\n    /* check for correct dictionary identifier */ if (state.mode === DICT) {\n        dictid = 1; /* adler32(0, null, 0)*/ \n        /* dictid = adler32(dictid, dictionary, dictLength); */ dictid = adler32(dictid, dictionary, dictLength, 0);\n        if (dictid !== state.check) {\n            return Z_DATA_ERROR;\n        }\n    }\n    /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */ ret = updatewindow(strm, dictionary, dictLength, dictLength);\n    if (ret) {\n        state.mode = MEM;\n        return Z_MEM_ERROR;\n    }\n    state.havedict = 1;\n    // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = \"pako inflate (from Nodeca project)\"; /* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLElBQUlBLFFBQWdCQyxtQkFBT0EsQ0FBQztBQUM1QixJQUFJQyxVQUFnQkQsbUJBQU9BLENBQUM7QUFDNUIsSUFBSUUsUUFBZ0JGLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlHLGVBQWdCSCxtQkFBT0EsQ0FBQztBQUM1QixJQUFJSSxnQkFBZ0JKLG1CQUFPQSxDQUFDO0FBRTVCLElBQUlLLFFBQVE7QUFDWixJQUFJQyxPQUFPO0FBQ1gsSUFBSUMsUUFBUTtBQUVaLDhFQUE4RSxHQUM5RSw4RUFBOEUsR0FHOUUsdUVBQXVFLEdBQ3ZFLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixJQUFJQyxXQUFrQjtBQUN0QixJQUFJQyxVQUFrQjtBQUN0QixJQUFJQyxVQUFrQjtBQUd0Qjs7Q0FFQyxHQUNELElBQUlDLE9BQWtCO0FBQ3RCLElBQUlDLGVBQWtCO0FBQ3RCLElBQUlDLGNBQWtCO0FBQ3RCLDJCQUEyQjtBQUMzQixJQUFJQyxpQkFBa0IsQ0FBQztBQUN2QixJQUFJQyxlQUFrQixDQUFDO0FBQ3ZCLElBQUlDLGNBQWtCLENBQUM7QUFDdkIsSUFBSUMsY0FBa0IsQ0FBQztBQUN2QiwyQkFBMkI7QUFFM0Isa0NBQWtDLEdBQ2xDLElB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N0IsTUFBTTtRQUMzQyxPQUFPZjtJQUNUO0lBRUEsMkNBQTJDLEdBQzNDLElBQUlrRixNQUFNdEMsSUFBSSxLQUFLN0IsTUFBTTtRQUN2QndJLFNBQVMsR0FBRyxzQkFBc0I7UUFDbEMscURBQXFELEdBQ3JEQSxTQUFTcEssUUFBUW9LLFFBQVFGLFlBQVlDLFlBQVk7UUFDakQsSUFBSUMsV0FBV3JFLE1BQU1oQyxLQUFLLEVBQUU7WUFDMUIsT0FBT2pEO1FBQ1Q7SUFDRjtJQUNBO3NDQUNvQyxHQUNwQzJGLE1BQU1PLGFBQWFsQixNQUFNb0UsWUFBWUMsWUFBWUE7SUFDakQsSUFBSTFELEtBQUs7UUFDUFYsTUFBTXRDLElBQUksR0FBR1Q7UUFDYixPQUFPakM7SUFDVDtJQUNBZ0YsTUFBTW5DLFFBQVEsR0FBRztJQUNqQixtREFBbUQ7SUFDbkQsT0FBT2xEO0FBQ1Q7QUFFQTJKLG9CQUFvQixHQUFHaEU7QUFDdkJnRSxxQkFBcUIsR0FBRy9EO0FBQ3hCK0Qsd0JBQXdCLEdBQUd4RTtBQUMzQndFLG1CQUFtQixHQUFHM0Q7QUFDdEIyRCxvQkFBb0IsR0FBRzdEO0FBQ3ZCNkQsZUFBZSxHQUFHOUM7QUFDbEI4QyxrQkFBa0IsR0FBR047QUFDckJNLHdCQUF3QixHQUFHTDtBQUMzQkssNEJBQTRCLEdBQUdKO0FBQy9CSSxtQkFBbUIsR0FBRyxzQ0FFdEI7Ozs7Ozs7O0FBUUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcz9kNzM3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImFkbGVyMzIiLCJjcmMzMiIsImluZmxhdGVfZmFzdCIsImluZmxhdGVfdGFibGUiLCJDT0RFUyIsIkxFTlMiLCJESVNUUyIsIlpfRklOSVNIIiwiWl9CTE9DSyIsIlpfVFJFRVMiLCJaX09LIiwiWl9TVFJFQU1fRU5EIiwiWl9ORUVEX0RJQ1QiLCJaX1NUUkVBTV9FUlJPUiIsIlpfREFUQV9FUlJPUiIsIlpfTUVNX0VSUk9SIiwiWl9CVUZfRVJST1IiLCJaX0RFRkxBVEVEIiwiSEVBRCIsIkZMQUdTIiwiVElNRSIsIk9TIiwiRVhMRU4iLCJFWFRSQSIsIk5BTUUiLCJDT01NRU5UIiwiSENSQyIsIkRJQ1RJRCIsIkRJQ1QiLCJUWVBFIiwiVFlQRURPIiwiU1RPUkVEIiwiQ09QWV8iLCJDT1BZIiwiVEFCTEUiLCJMRU5MRU5TIiwiQ09ERUxFTlMiLCJMRU5fIiwiTEVOIiwiTEVORVhUIiwiRElTVCIsIkRJU1RFWFQiLCJNQVRDSCIsIkxJVCIsIkNIRUNLIiwiTEVOR1RIIiwiRE9ORSIsIkJBRCIsIk1FTSIsIlNZTkMiLCJFTk9VR0hfTEVOUyIsIkVOT1VHSF9ESVNUUyIsIk1BWF9XQklUUyIsIkRFRl9XQklUUyIsInpzd2FwMzIiLCJxIiwiSW5mbGF0ZVN0YXRlIiwibW9kZSIsImxhc3QiLCJ3cmFwIiwiaGF2ZWRpY3QiLCJmbGFncyIsImRtYXgiLCJjaGVjayIsInRvdGFsIiwiaGVhZCIsIndiaXRzIiwid3NpemUiLCJ3aGF2ZSIsInduZXh0Iiwid2luZG93IiwiaG9sZCIsImJpdHMiLCJsZW5ndGgiLCJvZmZzZXQiLCJleHRyYSIsImxlbmNvZGUiLCJkaXN0Y29kZSIsImxlbmJpdHMiLCJkaXN0Yml0cyIsIm5jb2RlIiwibmxlbiIsIm5kaXN0IiwiaGF2ZSIsIm5leHQiLCJsZW5zIiwiQnVmMTYiLCJ3b3JrIiwibGVuZHluIiwiZGlzdGR5biIsInNhbmUiLCJiYWNrIiwid2FzIiwiaW5mbGF0ZVJlc2V0S2VlcCIsInN0cm0iLCJzdGF0ZSIsInRvdGFsX2luIiwidG90YWxfb3V0IiwibXNnIiwiYWRsZXIiLCJCdWYzMiIsImluZmxhdGVSZXNldCIsImluZmxhdGVSZXNldDIiLCJ3aW5kb3dCaXRzIiwiaW5mbGF0ZUluaXQyIiwicmV0IiwiaW5mbGF0ZUluaXQiLCJ2aXJnaW4iLCJsZW5maXgiLCJkaXN0Zml4IiwiZml4ZWR0YWJsZXMiLCJzeW0iLCJ1cGRhdGV3aW5kb3ciLCJzcmMiLCJlbmQiLCJjb3B5IiwiZGlzdCIsIkJ1ZjgiLCJhcnJheVNldCIsImluZmxhdGUiLCJmbHVzaCIsImlucHV0Iiwib3V0cHV0IiwicHV0IiwibGVmdCIsIl9pbiIsIl9vdXQiLCJmcm9tIiwiZnJvbV9zb3VyY2UiLCJoZXJlIiwiaGVyZV9iaXRzIiwiaGVyZV9vcCIsImhlcmVfdmFsIiwibGFzdF9iaXRzIiwibGFzdF9vcCIsImxhc3RfdmFsIiwibGVuIiwiaGJ1ZiIsIm9wdHMiLCJuIiwib3JkZXIiLCJhdmFpbF9pbiIsIm5leHRfb3V0IiwiYXZhaWxfb3V0IiwibmV4dF9pbiIsImluZl9sZWF2ZSIsImRvbmUiLCJ0ZXh0IiwidGltZSIsInhmbGFncyIsIm9zIiwiZXh0cmFfbGVuIiwiQXJyYXkiLCJuYW1lIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY29tbWVudCIsImhjcmMiLCJkYXRhX3R5cGUiLCJpbmZsYXRlRW5kIiwiaW5mbGF0ZUdldEhlYWRlciIsImluZmxhdGVTZXREaWN0aW9uYXJ5IiwiZGljdGlvbmFyeSIsImRpY3RMZW5ndGgiLCJkaWN0aWQiLCJleHBvcnRzIiwiaW5mbGF0ZUluZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inftrees.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inftrees.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\nvar lbase = [\n    /* Length codes 257..285 base */ 3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    13,\n    15,\n    17,\n    19,\n    23,\n    27,\n    31,\n    35,\n    43,\n    51,\n    59,\n    67,\n    83,\n    99,\n    115,\n    131,\n    163,\n    195,\n    227,\n    258,\n    0,\n    0\n];\nvar lext = [\n    /* Length codes 257..285 extra */ 16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    17,\n    17,\n    18,\n    18,\n    18,\n    18,\n    19,\n    19,\n    19,\n    19,\n    20,\n    20,\n    20,\n    20,\n    21,\n    21,\n    21,\n    21,\n    16,\n    72,\n    78\n];\nvar dbase = [\n    /* Distance codes 0..29 base */ 1,\n    2,\n    3,\n    4,\n    5,\n    7,\n    9,\n    13,\n    17,\n    25,\n    33,\n    49,\n    65,\n    97,\n    129,\n    193,\n    257,\n    385,\n    513,\n    769,\n    1025,\n    1537,\n    2049,\n    3073,\n    4097,\n    6145,\n    8193,\n    12289,\n    16385,\n    24577,\n    0,\n    0\n];\nvar dext = [\n    /* Distance codes 0..29 extra */ 16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    18,\n    18,\n    19,\n    19,\n    20,\n    20,\n    21,\n    21,\n    22,\n    22,\n    23,\n    23,\n    24,\n    24,\n    25,\n    25,\n    26,\n    26,\n    27,\n    27,\n    28,\n    28,\n    29,\n    29,\n    64,\n    64\n];\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n    var bits = opts.bits;\n    //here = opts.here; /* table entry for duplication */\n    var len = 0; /* a code's length in bits */ \n    var sym = 0; /* index of code symbols */ \n    var min = 0, max = 0; /* minimum and maximum code lengths */ \n    var root = 0; /* number of index bits for root table */ \n    var curr = 0; /* number of index bits for current table */ \n    var drop = 0; /* code bits to drop for sub-table */ \n    var left = 0; /* number of prefix codes available */ \n    var used = 0; /* code entries in table used */ \n    var huff = 0; /* Huffman code */ \n    var incr; /* for incrementing code, index */ \n    var fill; /* index for replicating entries */ \n    var low; /* low bits for current root entry */ \n    var mask; /* mask for low root bits */ \n    var next; /* next available space in table */ \n    var base = null; /* base value table to use */ \n    var base_index = 0;\n    //  var shoextra;    /* extra bits table to use */\n    var end; /* use base and extra for symbol > end */ \n    var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n    var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n    var extra = null;\n    var extra_index = 0;\n    var here_bits, here_op, here_val;\n    /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */ /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */ for(len = 0; len <= MAXBITS; len++){\n        count[len] = 0;\n    }\n    for(sym = 0; sym < codes; sym++){\n        count[lens[lens_index + sym]]++;\n    }\n    /* bound code lengths, force root to be within code lengths */ root = bits;\n    for(max = MAXBITS; max >= 1; max--){\n        if (count[max] !== 0) {\n            break;\n        }\n    }\n    if (root > max) {\n        root = max;\n    }\n    if (max === 0) {\n        //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n        //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n        //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n        table[table_index++] = 1 << 24 | 64 << 16 | 0;\n        //table.op[opts.table_index] = 64;\n        //table.bits[opts.table_index] = 1;\n        //table.val[opts.table_index++] = 0;\n        table[table_index++] = 1 << 24 | 64 << 16 | 0;\n        opts.bits = 1;\n        return 0; /* no symbols, but wait for decoding to report error */ \n    }\n    for(min = 1; min < max; min++){\n        if (count[min] !== 0) {\n            break;\n        }\n    }\n    if (root < min) {\n        root = min;\n    }\n    /* check for an over-subscribed or incomplete set of lengths */ left = 1;\n    for(len = 1; len <= MAXBITS; len++){\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) {\n            return -1;\n        } /* over-subscribed */ \n    }\n    if (left > 0 && (type === CODES || max !== 1)) {\n        return -1; /* incomplete set */ \n    }\n    /* generate offsets into symbol table for each length for sorting */ offs[1] = 0;\n    for(len = 1; len < MAXBITS; len++){\n        offs[len + 1] = offs[len] + count[len];\n    }\n    /* sort symbols by length, by symbol order within each length */ for(sym = 0; sym < codes; sym++){\n        if (lens[lens_index + sym] !== 0) {\n            work[offs[lens[lens_index + sym]]++] = sym;\n        }\n    }\n    /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */ /* set up for code type */ // poor man optimization - use if-else instead of switch,\n    // to avoid deopts in old v8\n    if (type === CODES) {\n        base = extra = work; /* dummy value--not used */ \n        end = 19;\n    } else if (type === LENS) {\n        base = lbase;\n        base_index -= 257;\n        extra = lext;\n        extra_index -= 257;\n        end = 256;\n    } else {\n        base = dbase;\n        extra = dext;\n        end = -1;\n    }\n    /* initialize opts for loop */ huff = 0; /* starting code */ \n    sym = 0; /* starting code symbol */ \n    len = min; /* starting code length */ \n    next = table_index; /* current table to fill in */ \n    curr = root; /* current table index bits */ \n    drop = 0; /* current bits to drop from code for index */ \n    low = -1; /* trigger new sub-table when len > root */ \n    used = 1 << root; /* use root table entries */ \n    mask = used - 1; /* mask for comparing low */ \n    /* check available table space */ if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n        return 1;\n    }\n    /* process all codes and make table entries */ for(;;){\n        /* create table entry */ here_bits = len - drop;\n        if (work[sym] < end) {\n            here_op = 0;\n            here_val = work[sym];\n        } else if (work[sym] > end) {\n            here_op = extra[extra_index + work[sym]];\n            here_val = base[base_index + work[sym]];\n        } else {\n            here_op = 32 + 64; /* end of block */ \n            here_val = 0;\n        }\n        /* replicate for those indices with low len bits equal to huff */ incr = 1 << len - drop;\n        fill = 1 << curr;\n        min = fill; /* save offset to next table */ \n        do {\n            fill -= incr;\n            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n        }while (fill !== 0);\n        /* backwards increment the len-bit code huff */ incr = 1 << len - 1;\n        while(huff & incr){\n            incr >>= 1;\n        }\n        if (incr !== 0) {\n            huff &= incr - 1;\n            huff += incr;\n        } else {\n            huff = 0;\n        }\n        /* go to next symbol, update count, len */ sym++;\n        if (--count[len] === 0) {\n            if (len === max) {\n                break;\n            }\n            len = lens[lens_index + work[sym]];\n        }\n        /* create new sub-table if needed */ if (len > root && (huff & mask) !== low) {\n            /* if first time, transition to sub-tables */ if (drop === 0) {\n                drop = root;\n            }\n            /* increment past last table */ next += min; /* here min is 1 << curr */ \n            /* determine length of next table */ curr = len - drop;\n            left = 1 << curr;\n            while(curr + drop < max){\n                left -= count[curr + drop];\n                if (left <= 0) {\n                    break;\n                }\n                curr++;\n                left <<= 1;\n            }\n            /* check for enough space */ used += 1 << curr;\n            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n                return 1;\n            }\n            /* point entry in root table to sub-table */ low = huff & mask;\n            /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/ table[low] = root << 24 | curr << 16 | next - table_index | 0;\n        }\n    }\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */ if (huff !== 0) {\n        //table.op[next + huff] = 64;            /* invalid code marker */\n        //table.bits[next + huff] = len - drop;\n        //table.val[next + huff] = 0;\n        table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n    }\n    /* set return parameters */ //opts.table_index += used;\n    opts.bits = root;\n    return 0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQixJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxlQUFlO0FBQ25CLDBDQUEwQztBQUUxQyxJQUFJQyxRQUFRO0FBQ1osSUFBSUMsT0FBTztBQUNYLElBQUlDLFFBQVE7QUFFWixJQUFJQyxRQUFRO0lBQUUsOEJBQThCLEdBQzFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQ3JEO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBRztDQUM5RDtBQUVELElBQUlDLE9BQU87SUFBRSwrQkFBK0IsR0FDMUM7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFDNUQ7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0NBQ3pEO0FBRUQsSUFBSUMsUUFBUTtJQUFFLDZCQUE2QixH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QzFDZ0MsTUFBTUgsT0FBT0k7WUFDYjs7K0NBRXlDLEdBQ3pDbEIsS0FBSyxDQUFDaUIsSUFBSSxHQUFHLFFBQVMsS0FBT1AsUUFBUSxLQUFPUyxPQUFPbEIsY0FBYztRQUNuRTtJQUNGO0lBRUE7O29FQUVrRSxHQUNsRSxJQUFJYSxTQUFTLEdBQUc7UUFDZCxrRUFBa0U7UUFDbEUsdUNBQXVDO1FBQ3ZDLDZCQUE2QjtRQUM3QmQsS0FBSyxDQUFDbUIsT0FBT0wsS0FBSyxHQUFHLE1BQVFILFFBQVMsS0FBTyxNQUFNLEtBQUs7SUFDMUQ7SUFFQSx5QkFBeUIsR0FDekIsMkJBQTJCO0lBQzNCUixLQUFLQyxJQUFJLEdBQUdLO0lBQ1osT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzP2U0MWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIk1BWEJJVFMiLCJFTk9VR0hfTEVOUyIsIkVOT1VHSF9ESVNUUyIsIkNPREVTIiwiTEVOUyIsIkRJU1RTIiwibGJhc2UiLCJsZXh0IiwiZGJhc2UiLCJkZXh0IiwibW9kdWxlIiwiZXhwb3J0cyIsImluZmxhdGVfdGFibGUiLCJ0eXBlIiwibGVucyIsImxlbnNfaW5kZXgiLCJjb2RlcyIsInRhYmxlIiwidGFibGVfaW5kZXgiLCJ3b3JrIiwib3B0cyIsImJpdHMiLCJsZW4iLCJzeW0iLCJtaW4iLCJtYXgiLCJyb290IiwiY3VyciIsImRyb3AiLCJsZWZ0IiwidXNlZCIsImh1ZmYiLCJpbmNyIiwiZmlsbCIsImxvdyIsIm1hc2siLCJuZXh0IiwiYmFzZSIsImJhc2VfaW5kZXgiLCJlbmQiLCJjb3VudCIsIkJ1ZjE2Iiwib2ZmcyIsImV4dHJhIiwiZXh0cmFfaW5kZXgiLCJoZXJlX2JpdHMiLCJoZXJlX29wIiwiaGVyZV92YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inftrees.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nmodule.exports = {\n    2: \"need dictionary\",\n    /* Z_NEED_DICT       2  */ 1: \"stream end\",\n    /* Z_STREAM_END      1  */ 0: \"\",\n    /* Z_OK              0  */ \"-1\": \"file error\",\n    /* Z_ERRNO         (-1) */ \"-2\": \"stream error\",\n    /* Z_STREAM_ERROR  (-2) */ \"-3\": \"data error\",\n    /* Z_DATA_ERROR    (-3) */ \"-4\": \"insufficient memory\",\n    /* Z_MEM_ERROR     (-4) */ \"-5\": \"buffer error\",\n    /* Z_BUF_ERROR     (-5) */ \"-6\": \"incompatible version\" /* Z_VERSION_ERROR (-6) */ \n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2YsR0FBUTtJQUF1Qix3QkFBd0IsR0FDdkQsR0FBUTtJQUF1Qix3QkFBd0IsR0FDdkQsR0FBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUSx1QkFBdUIsd0JBQXdCO0FBQ3pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzP2FhYTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/trees.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/trees.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n/* eslint-disable space-unary-ops */ var utils = __webpack_require__(/*! ../utils/common */ \"(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\n/* Public constants ==========================================================*/ /* ===========================================================================*/ //var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n/* Possible values of the data_type field (though see inflate()) */ var Z_BINARY = 0;\nvar Z_TEXT = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN = 2;\n/*============================================================================*/ function zero(buf) {\n    var len = buf.length;\n    while(--len >= 0){\n        buf[len] = 0;\n    }\n}\n// From zutil.h\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES = 2;\n/* The three kinds of block type */ var MIN_MATCH = 3;\nvar MAX_MATCH = 258;\n/* The minimum and maximum match lengths */ // From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */ var LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;\n/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;\n/* number of distance codes */ var BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */ var MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */ var Buf_size = 16;\n/* size of bit buffer in bi_buf */ /* ===========================================================================\n * Constants\n */ var MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */ var END_BLOCK = 256;\n/* end of block literal code */ var REP_3_6 = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */ var REPZ_3_10 = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */ var REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */ /* eslint-disable comma-spacing,array-bracket-spacing */ var extra_lbits = /* extra bits for each length code */ [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0\n];\nvar extra_dbits = /* extra bits for each distance code */ [\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13\n];\nvar extra_blbits = /* extra bits for each bit length code */ [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    3,\n    7\n];\nvar bl_order = [\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n];\n/* eslint-enable comma-spacing,array-bracket-spacing */ /* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */ /* ===========================================================================\n * Local data. These are initialized only once.\n */ // We pre-fill arrays with 0 to avoid uninitialized gaps\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */ \n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */ var static_dtree = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */ var _dist_code = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */ var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */ var base_length = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */ var base_dist = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */ function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n    this.static_tree = static_tree; /* static tree or NULL */ \n    this.extra_bits = extra_bits; /* extra bits for each code or NULL */ \n    this.extra_base = extra_base; /* base index for extra_bits */ \n    this.elems = elems; /* max number of elements in the tree */ \n    this.max_length = max_length; /* max bit length for the codes */ \n    // show if `static_tree` has data or dummy - needed for monomorphic objects\n    this.has_stree = static_tree && static_tree.length;\n}\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\nfunction TreeDesc(dyn_tree, stat_desc) {\n    this.dyn_tree = dyn_tree; /* the dynamic tree */ \n    this.max_code = 0; /* largest code with non zero frequency */ \n    this.stat_desc = stat_desc; /* the corresponding static tree */ \n}\nfunction d_code(dist) {\n    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */ function put_short(s, w) {\n    //    put_byte(s, (uch)((w) & 0xff));\n    //    put_byte(s, (uch)((ush)(w) >> 8));\n    s.pending_buf[s.pending++] = w & 0xff;\n    s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n}\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */ function send_bits(s, value, length) {\n    if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> Buf_size - s.bi_valid;\n        s.bi_valid += length - Buf_size;\n    } else {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        s.bi_valid += length;\n    }\n}\nfunction send_code(s, c, tree) {\n    send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n}\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */ function bi_reverse(code, len) {\n    var res = 0;\n    do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n    }while (--len > 0);\n    return res >>> 1;\n}\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */ function bi_flush(s) {\n    if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n    } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n    }\n}\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */ function gen_bitlen(s, desc) //    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n    var tree = desc.dyn_tree;\n    var max_code = desc.max_code;\n    var stree = desc.stat_desc.static_tree;\n    var has_stree = desc.stat_desc.has_stree;\n    var extra = desc.stat_desc.extra_bits;\n    var base = desc.stat_desc.extra_base;\n    var max_length = desc.stat_desc.max_length;\n    var h; /* heap index */ \n    var n, m; /* iterate over the tree elements */ \n    var bits; /* bit length */ \n    var xbits; /* extra bits */ \n    var f; /* frequency */ \n    var overflow = 0; /* number of elements with bit length too large */ \n    for(bits = 0; bits <= MAX_BITS; bits++){\n        s.bl_count[bits] = 0;\n    }\n    /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */ tree[s.heap[s.heap_max] * 2 + 1] = 0; /* root of the heap */ \n    for(h = s.heap_max + 1; h < HEAP_SIZE; h++){\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n        if (bits > max_length) {\n            bits = max_length;\n            overflow++;\n        }\n        tree[n * 2 + 1] = bits;\n        /* We overwrite tree[n].Dad which is no longer needed */ if (n > max_code) {\n            continue;\n        } /* not a leaf node */ \n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n            xbits = extra[n - base];\n        }\n        f = tree[n * 2] /*.Freq*/ ;\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n            s.static_len += f * (stree[n * 2 + 1] + xbits);\n        }\n    }\n    if (overflow === 0) {\n        return;\n    }\n    // Trace((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */ /* Find the first bit length which could increase: */ do {\n        bits = max_length - 1;\n        while(s.bl_count[bits] === 0){\n            bits--;\n        }\n        s.bl_count[bits]--; /* move one leaf down the tree */ \n        s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */ \n        s.bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */ overflow -= 2;\n    }while (overflow > 0);\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */ for(bits = max_length; bits !== 0; bits--){\n        n = s.bl_count[bits];\n        while(n !== 0){\n            m = s.heap[--h];\n            if (m > max_code) {\n                continue;\n            }\n            if (tree[m * 2 + 1] !== bits) {\n                // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2] /*.Freq*/ ;\n                tree[m * 2 + 1] = bits;\n            }\n            n--;\n        }\n    }\n}\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */ function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n    var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */ \n    var code = 0; /* running code value */ \n    var bits; /* bit index */ \n    var n; /* code index */ \n    /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */ for(bits = 1; bits <= MAX_BITS; bits++){\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */ //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n    //        \"inconsistent bit counts\");\n    //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n    for(n = 0; n <= max_code; n++){\n        var len = tree[n * 2 + 1] /*.Len*/ ;\n        if (len === 0) {\n            continue;\n        }\n        /* Now reverse the bits */ tree[n * 2] = bi_reverse(next_code[len]++, len);\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n}\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */ function tr_static_init() {\n    var n; /* iterates over tree elements */ \n    var bits; /* bit counter */ \n    var length; /* length value */ \n    var code; /* code value */ \n    var dist; /* distance index */ \n    var bl_count = new Array(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */ // do check in _tr_init()\n    //if (static_init_done) return;\n    /* For some embedded targets, global variables are not initialized: */ /*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/ /* Initialize the mapping length (0..255) -> length code (0..28) */ length = 0;\n    for(code = 0; code < LENGTH_CODES - 1; code++){\n        base_length[code] = length;\n        for(n = 0; n < 1 << extra_lbits[code]; n++){\n            _length_code[length++] = code;\n        }\n    }\n    //Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */ _length_code[length - 1] = code;\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */ dist = 0;\n    for(code = 0; code < 16; code++){\n        base_dist[code] = dist;\n        for(n = 0; n < 1 << extra_dbits[code]; n++){\n            _dist_code[dist++] = code;\n        }\n    }\n    //Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */ \n    for(; code < D_CODES; code++){\n        base_dist[code] = dist << 7;\n        for(n = 0; n < 1 << extra_dbits[code] - 7; n++){\n            _dist_code[256 + dist++] = code;\n        }\n    }\n    //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n    /* Construct the codes of the static literal tree */ for(bits = 0; bits <= MAX_BITS; bits++){\n        bl_count[bits] = 0;\n    }\n    n = 0;\n    while(n <= 143){\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n    }\n    while(n <= 255){\n        static_ltree[n * 2 + 1] = 9;\n        n++;\n        bl_count[9]++;\n    }\n    while(n <= 279){\n        static_ltree[n * 2 + 1] = 7;\n        n++;\n        bl_count[7]++;\n    }\n    while(n <= 287){\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n    }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */ gen_codes(static_ltree, L_CODES + 1, bl_count);\n    /* The static distance tree is trivial: */ for(n = 0; n < D_CODES; n++){\n        static_dtree[n * 2 + 1] = 5;\n        static_dtree[n * 2] = bi_reverse(n, 5);\n    }\n    // Now data ready and we can init static trees\n    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n//static_init_done = true;\n}\n/* ===========================================================================\n * Initialize a new block.\n */ function init_block(s) {\n    var n; /* iterates over tree elements */ \n    /* Initialize the trees. */ for(n = 0; n < L_CODES; n++){\n        s.dyn_ltree[n * 2] = 0;\n    }\n    for(n = 0; n < D_CODES; n++){\n        s.dyn_dtree[n * 2] = 0;\n    }\n    for(n = 0; n < BL_CODES; n++){\n        s.bl_tree[n * 2] = 0;\n    }\n    s.dyn_ltree[END_BLOCK * 2] = 1;\n    s.opt_len = s.static_len = 0;\n    s.last_lit = s.matches = 0;\n}\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */ function bi_windup(s) {\n    if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n    } else if (s.bi_valid > 0) {\n        //put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf;\n    }\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n}\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */ function copy_block(s, buf, len, header) //DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n    bi_windup(s); /* align on byte boundary */ \n    if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n    }\n    //  while (len--) {\n    //    put_byte(s, *buf++);\n    //  }\n    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n    s.pending += len;\n}\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */ function smaller(tree, n, m, depth) {\n    var _n2 = n * 2;\n    var _m2 = m * 2;\n    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n}\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */ function pqdownheap(s, tree, k) //    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n    var v = s.heap[k];\n    var j = k << 1; /* left son of k */ \n    while(j <= s.heap_len){\n        /* Set j to the smallest of the two sons: */ if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */ if (smaller(tree, v, s.heap[j], s.depth)) {\n            break;\n        }\n        /* Exchange v with the smallest son */ s.heap[k] = s.heap[j];\n        k = j;\n        /* And continue down the tree, setting j to the left son of k */ j <<= 1;\n    }\n    s.heap[k] = v;\n}\n// inlined manually\n// var SMALLEST = 1;\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */ function compress_block(s, ltree, dtree) //    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n    var dist; /* distance of matched string */ \n    var lc; /* match length or unmatched char (if dist == 0) */ \n    var lx = 0; /* running index in l_buf */ \n    var code; /* the code to send */ \n    var extra; /* number of extra bits to send */ \n    if (s.last_lit !== 0) {\n        do {\n            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n            lc = s.pending_buf[s.l_buf + lx];\n            lx++;\n            if (dist === 0) {\n                send_code(s, lc, ltree); /* send a literal byte */ \n            //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n            } else {\n                /* Here, lc is the match length - MIN_MATCH */ code = _length_code[lc];\n                send_code(s, code + LITERALS + 1, ltree); /* send the length code */ \n                extra = extra_lbits[code];\n                if (extra !== 0) {\n                    lc -= base_length[code];\n                    send_bits(s, lc, extra); /* send the extra length bits */ \n                }\n                dist--; /* dist is now the match distance - 1 */ \n                code = d_code(dist);\n                //Assert (code < D_CODES, \"bad d_code\");\n                send_code(s, code, dtree); /* send the distance code */ \n                extra = extra_dbits[code];\n                if (extra !== 0) {\n                    dist -= base_dist[code];\n                    send_bits(s, dist, extra); /* send the extra distance bits */ \n                }\n            } /* literal or match pair ? */ \n        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */ //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n        //       \"pendingBuf overflow\");\n        }while (lx < s.last_lit);\n    }\n    send_code(s, END_BLOCK, ltree);\n}\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */ function build_tree(s, desc) //    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n    var tree = desc.dyn_tree;\n    var stree = desc.stat_desc.static_tree;\n    var has_stree = desc.stat_desc.has_stree;\n    var elems = desc.stat_desc.elems;\n    var n, m; /* iterate over heap elements */ \n    var max_code = -1; /* largest code with non zero frequency */ \n    var node; /* new node being created */ \n    /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */ s.heap_len = 0;\n    s.heap_max = HEAP_SIZE;\n    for(n = 0; n < elems; n++){\n        if (tree[n * 2] !== 0) {\n            s.heap[++s.heap_len] = max_code = n;\n            s.depth[n] = 0;\n        } else {\n            tree[n * 2 + 1] = 0;\n        }\n    }\n    /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */ while(s.heap_len < 2){\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (has_stree) {\n            s.static_len -= stree[node * 2 + 1] /*.Len*/ ;\n        }\n    /* node is 0 or 1 so it does not have extra bits */ }\n    desc.max_code = max_code;\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */ for(n = s.heap_len >> 1 /*int /2*/ ; n >= 1; n--){\n        pqdownheap(s, tree, n);\n    }\n    /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */ node = elems; /* next internal node of the tree */ \n    do {\n        //pqremove(s, tree, n);  /* n = node of least frequency */\n        /*** pqremove ***/ n = s.heap[1 /*SMALLEST*/ ];\n        s.heap[1 /*SMALLEST*/ ] = s.heap[s.heap_len--];\n        pqdownheap(s, tree, 1 /*SMALLEST*/ );\n        /***/ m = s.heap[1 /*SMALLEST*/ ]; /* m = node of next least frequency */ \n        s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */ \n        s.heap[--s.heap_max] = m;\n        /* Create a new node father of n and m */ tree[node * 2] = tree[n * 2] + tree[m * 2] /*.Freq*/ ;\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n        /* and insert the new node in the heap */ s.heap[1 /*SMALLEST*/ ] = node++;\n        pqdownheap(s, tree, 1 /*SMALLEST*/ );\n    }while (s.heap_len >= 2);\n    s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/ ];\n    /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */ gen_bitlen(s, desc);\n    /* The field len is now set, we can generate the bit codes */ gen_codes(tree, max_code, s.bl_count);\n}\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */ function scan_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n    var n; /* iterates over all tree elements */ \n    var prevlen = -1; /* last emitted length */ \n    var curlen; /* length of current code */ \n    var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */ \n    var count = 0; /* repeat count of the current code */ \n    var max_count = 7; /* max repeat count */ \n    var min_count = 4; /* min repeat count */ \n    if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n    }\n    tree[(max_code + 1) * 2 + 1] = 0xffff; /* guard */ \n    for(n = 0; n <= max_code; n++){\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n        if (++count < max_count && curlen === nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s.bl_tree[curlen * 2] += count;\n        } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n                s.bl_tree[curlen * 2]++;\n            }\n            s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10) {\n            s.bl_tree[REPZ_3_10 * 2]++;\n        } else {\n            s.bl_tree[REPZ_11_138 * 2]++;\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n    }\n}\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */ function send_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n    var n; /* iterates over all tree elements */ \n    var prevlen = -1; /* last emitted length */ \n    var curlen; /* length of current code */ \n    var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */ \n    var count = 0; /* repeat count of the current code */ \n    var max_count = 7; /* max repeat count */ \n    var min_count = 4; /* min repeat count */ \n    /* tree[max_code+1].Len = -1; */ /* guard already set */ if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n    }\n    for(n = 0; n <= max_code; n++){\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n        if (++count < max_count && curlen === nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do {\n                send_code(s, curlen, s.bl_tree);\n            }while (--count !== 0);\n        } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n                send_code(s, curlen, s.bl_tree);\n                count--;\n            }\n            //Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s.bl_tree);\n            send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s.bl_tree);\n            send_bits(s, count - 3, 3);\n        } else {\n            send_code(s, REPZ_11_138, s.bl_tree);\n            send_bits(s, count - 11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n    }\n}\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */ function build_bl_tree(s) {\n    var max_blindex; /* index of last bit length code of non zero freq */ \n    /* Determine the bit length frequencies for literal and distance trees */ scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n    /* Build the bit length tree: */ build_tree(s, s.bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */ /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */ for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n            break;\n        }\n    }\n    /* Update opt_len to include the bit length tree and counts */ s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n    //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n    //        s->opt_len, s->static_len));\n    return max_blindex;\n}\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */ function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n    var rank; /* index in bl_order */ \n    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n    //        \"too many codes\");\n    //Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */ \n    send_bits(s, dcodes - 1, 5);\n    send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */ \n    for(rank = 0; rank < blcodes; rank++){\n        //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n    }\n    //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */ \n    //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */ \n//Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */ function detect_data_type(s) {\n    /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */ var black_mask = 0xf3ffc07f;\n    var n;\n    /* Check for non-textual (\"black-listed\") bytes. */ for(n = 0; n <= 31; n++, black_mask >>>= 1){\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n            return Z_BINARY;\n        }\n    }\n    /* Check for textual (\"white-listed\") bytes. */ if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n        return Z_TEXT;\n    }\n    for(n = 32; n < LITERALS; n++){\n        if (s.dyn_ltree[n * 2] !== 0) {\n            return Z_TEXT;\n        }\n    }\n    /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */ return Z_BINARY;\n}\nvar static_init_done = false;\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */ function _tr_init(s) {\n    if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n    }\n    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n    /* Initialize the first block of the first file: */ init_block(s);\n}\n/* ===========================================================================\n * Send a stored block\n */ function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */ \n    copy_block(s, buf, stored_len, true); /* with header */ \n}\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */ function _tr_align(s) {\n    send_bits(s, STATIC_TREES << 1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n    bi_flush(s);\n}\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */ function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n    var opt_lenb, static_lenb; /* opt_len and static_len in bytes */ \n    var max_blindex = 0; /* index of last bit length code of non zero freq */ \n    /* Build the Huffman trees unless a stored block is forced */ if (s.level > 0) {\n        /* Check if the file is binary or text */ if (s.strm.data_type === Z_UNKNOWN) {\n            s.strm.data_type = detect_data_type(s);\n        }\n        /* Construct the literal and distance trees */ build_tree(s, s.l_desc);\n        // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        build_tree(s, s.d_desc);\n        // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */ /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */ max_blindex = build_bl_tree(s);\n        /* Determine the best encoding. Compute the block lengths in bytes. */ opt_lenb = s.opt_len + 3 + 7 >>> 3;\n        static_lenb = s.static_len + 3 + 7 >>> 3;\n        // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n        if (static_lenb <= opt_lenb) {\n            opt_lenb = static_lenb;\n        }\n    } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */ \n    }\n    if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */ /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */ _tr_stored_block(s, buf, stored_len, last);\n    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n    } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n    }\n    // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */ init_block(s);\n    if (last) {\n        bi_windup(s);\n    }\n// Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n//       s->compressed_len-7*last));\n}\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */ function _tr_tally(s, dist, lc) //    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n    //var out_length, in_length, dcode;\n    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n    s.last_lit++;\n    if (dist === 0) {\n        /* lc is the unmatched char */ s.dyn_ltree[lc * 2]++;\n    } else {\n        s.matches++;\n        /* Here, lc is the match length - MIN_MATCH */ dist--; /* dist = match distance - 1 */ \n        //Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n        s.dyn_dtree[d_code(dist) * 2]++;\n    }\n    // (!) This block is disabled in zlib defaults,\n    // don't enable it for binary compatibility\n    //#ifdef TRUNCATE_BLOCK\n    //  /* Try to guess if it is profitable to stop the current block here */\n    //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n    //    /* Compute an upper bound for the compressed length */\n    //    out_length = s.last_lit*8;\n    //    in_length = s.strstart - s.block_start;\n    //\n    //    for (dcode = 0; dcode < D_CODES; dcode++) {\n    //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n    //    }\n    //    out_length >>>= 3;\n    //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n    //    //       s->last_lit, in_length, out_length,\n    //    //       100L - out_length*100L/in_length));\n    //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n    //      return true;\n    //    }\n    //  }\n    //#endif\n    return s.last_lit === s.lit_bufsize - 1;\n/* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */ }\nexports._tr_init = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RSxrQ0FBa0MsR0FFbEMsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFFcEIsOEVBQThFLEdBQzlFLDhFQUE4RSxHQUc5RSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixJQUFJQyxVQUF3QjtBQUM1Qiw4QkFBOEI7QUFFOUIsaUVBQWlFLEdBQ2pFLElBQUlDLFdBQXdCO0FBQzVCLElBQUlDLFNBQXdCO0FBQzVCLDBDQUEwQztBQUMxQyxJQUFJQyxZQUF3QjtBQUU1Qiw4RUFBOEUsR0FHOUUsU0FBU0MsS0FBS0MsR0FBRztJQUFJLElBQUlDLE1BQU1ELElBQUlFLE1BQU07SUFBRSxNQUFPLEVBQUVELE9BQU8sRUFBRztRQUFFRCxHQUFHLENBQUNDLElBQUksR0FBRztJQUFHO0FBQUU7QUFFaEYsZUFBZTtBQUVmLElBQUlFLGVBQWU7QUFDbkIsSUFBSUMsZUFBZTtBQUNuQixJQUFJQyxZQUFlO0FBQ25CLGlDQUFpQyxHQUVqQyxJQUFJQyxZQUFlO0FBQ25CLElBQUlDLFlBQWU7QUFDbkIseUNBQXlDLEdBRXpDLGlCQUFpQjtBQUNqQjs7Q0FFQyxHQUVELElBQUlDLGVBQWdCO0FBQ3BCLG1FQUFtRSxHQUVuRSxJQUFJQyxXQUFnQjtBQUNwQixrQ0FBa0MsR0FF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T0FBTztJQUNQLHdCQUF3QjtJQUN4QixpRUFBaUU7SUFDakUsa0RBQWtEO0lBQ2xELGtEQUFrRDtJQUNsRCwyRkFBMkY7SUFDM0Ysb0JBQW9CO0lBQ3BCLE9BQU87SUFDUCxLQUFLO0lBQ0wsUUFBUTtJQUVOLE9BQVFFLEVBQUV1QyxRQUFRLEtBQUt2QyxFQUFFa0csV0FBVyxHQUFHO0FBQ3ZDOzs7R0FHQyxHQUNIO0FBRUFDLGdCQUFnQixHQUFJZDtBQUNwQmMsd0JBQXdCLEdBQUdiO0FBQzNCYSx1QkFBdUIsR0FBSVQ7QUFDM0JTLGlCQUFpQixHQUFHRjtBQUNwQkUsaUJBQWlCLEdBQUdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzP2Y4NjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiWl9GSVhFRCIsIlpfQklOQVJZIiwiWl9URVhUIiwiWl9VTktOT1dOIiwiemVybyIsImJ1ZiIsImxlbiIsImxlbmd0aCIsIlNUT1JFRF9CTE9DSyIsIlNUQVRJQ19UUkVFUyIsIkRZTl9UUkVFUyIsIk1JTl9NQVRDSCIsIk1BWF9NQVRDSCIsIkxFTkdUSF9DT0RFUyIsIkxJVEVSQUxTIiwiTF9DT0RFUyIsIkRfQ09ERVMiLCJCTF9DT0RFUyIsIkhFQVBfU0laRSIsIk1BWF9CSVRTIiwiQnVmX3NpemUiLCJNQVhfQkxfQklUUyIsIkVORF9CTE9DSyIsIlJFUF8zXzYiLCJSRVBaXzNfMTAiLCJSRVBaXzExXzEzOCIsImV4dHJhX2xiaXRzIiwiZXh0cmFfZGJpdHMiLCJleHRyYV9ibGJpdHMiLCJibF9vcmRlciIsIkRJU1RfQ09ERV9MRU4iLCJzdGF0aWNfbHRyZWUiLCJBcnJheSIsInN0YXRpY19kdHJlZSIsIl9kaXN0X2NvZGUiLCJfbGVuZ3RoX2NvZGUiLCJiYXNlX2xlbmd0aCIsImJhc2VfZGlzdCIsIlN0YXRpY1RyZWVEZXNjIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsInN0YXRpY19sX2Rlc2MiLCJzdGF0aWNfZF9kZXNjIiwic3RhdGljX2JsX2Rlc2MiLCJUcmVlRGVzYyIsImR5bl90cmVlIiwic3RhdF9kZXNjIiwibWF4X2NvZGUiLCJkX2NvZGUiLCJkaXN0IiwicHV0X3Nob3J0IiwicyIsInciLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmciLCJzZW5kX2JpdHMiLCJ2YWx1ZSIsImJpX3ZhbGlkIiwiYmlfYnVmIiwic2VuZF9jb2RlIiwiYyIsInRyZWUiLCJiaV9yZXZlcnNlIiwiY29kZSIsInJlcyIsImJpX2ZsdXNoIiwiZ2VuX2JpdGxlbiIsImRlc2MiLCJzdHJlZSIsImV4dHJhIiwiYmFzZSIsImgiLCJuIiwibSIsImJpdHMiLCJ4Yml0cyIsImYiLCJvdmVyZmxvdyIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbWF4Iiwib3B0X2xlbiIsInN0YXRpY19sZW4iLCJnZW5fY29kZXMiLCJuZXh0X2NvZGUiLCJ0cl9zdGF0aWNfaW5pdCIsImluaXRfYmxvY2siLCJkeW5fbHRyZWUiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwibGFzdF9saXQiLCJtYXRjaGVzIiwiYmlfd2luZHVwIiwiY29weV9ibG9jayIsImhlYWRlciIsImFycmF5U2V0Iiwid2luZG93Iiwic21hbGxlciIsImRlcHRoIiwiX24yIiwiX20yIiwicHFkb3duaGVhcCIsImsiLCJ2IiwiaiIsImhlYXBfbGVuIiwiY29tcHJlc3NfYmxvY2siLCJsdHJlZSIsImR0cmVlIiwibGMiLCJseCIsImRfYnVmIiwibF9idWYiLCJidWlsZF90cmVlIiwibm9kZSIsInNjYW5fdHJlZSIsInByZXZsZW4iLCJjdXJsZW4iLCJuZXh0bGVuIiwiY291bnQiLCJtYXhfY291bnQiLCJtaW5fY291bnQiLCJzZW5kX3RyZWUiLCJidWlsZF9ibF90cmVlIiwibWF4X2JsaW5kZXgiLCJsX2Rlc2MiLCJkX2Rlc2MiLCJibF9kZXNjIiwic2VuZF9hbGxfdHJlZXMiLCJsY29kZXMiLCJkY29kZXMiLCJibGNvZGVzIiwicmFuayIsImRldGVjdF9kYXRhX3R5cGUiLCJibGFja19tYXNrIiwic3RhdGljX2luaXRfZG9uZSIsIl90cl9pbml0IiwiX3RyX3N0b3JlZF9ibG9jayIsInN0b3JlZF9sZW4iLCJsYXN0IiwiX3RyX2FsaWduIiwiX3RyX2ZsdXNoX2Jsb2NrIiwib3B0X2xlbmIiLCJzdGF0aWNfbGVuYiIsImxldmVsIiwic3RybSIsImRhdGFfdHlwZSIsInN0cmF0ZWd5IiwiX3RyX3RhbGx5IiwibGl0X2J1ZnNpemUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/trees.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction ZStream() {\n    /* next input byte */ this.input = null; // JS specific, because we have no pointers\n    this.next_in = 0;\n    /* number of bytes available at input */ this.avail_in = 0;\n    /* total number of input bytes read so far */ this.total_in = 0;\n    /* next output byte should be put there */ this.output = null; // JS specific, because we have no pointers\n    this.next_out = 0;\n    /* remaining free space at output */ this.avail_out = 0;\n    /* total number of bytes output so far */ this.total_out = 0;\n    /* last error message, NULL if no error */ this.msg = \"\" /*Z_NULL*/ ;\n    /* not visible by applications */ this.state = null;\n    /* best guess about the data type: binary or text */ this.data_type = 2 /*Z_UNKNOWN*/ ;\n    /* adler32 value of the uncompressed data */ this.adler = 0;\n}\nmodule.exports = ZStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLFNBQVNBO0lBQ1AsbUJBQW1CLEdBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHLE1BQU0sMkNBQTJDO0lBQzlELElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2Ysc0NBQXNDLEdBQ3RDLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLDJDQUEyQyxHQUMzQyxJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQix3Q0FBd0MsR0FDeEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsTUFBTSwyQ0FBMkM7SUFDL0QsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsa0NBQWtDLEdBQ2xDLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLHVDQUF1QyxHQUN2QyxJQUFJLENBQUNDLFNBQVMsR0FBRztJQUNqQix3Q0FBd0MsR0FDeEMsSUFBSSxDQUFDQyxHQUFHLEdBQUcsR0FBRSxRQUFRO0lBQ3JCLCtCQUErQixHQUMvQixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNiLGtEQUFrRCxHQUNsRCxJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFDLFdBQVc7SUFDN0IsMENBQTBDLEdBQzFDLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0FBQ2Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHZCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzP2M1ODAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiJdLCJuYW1lcyI6WyJaU3RyZWFtIiwiaW5wdXQiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJ0b3RhbF9pbiIsIm91dHB1dCIsIm5leHRfb3V0IiwiYXZhaWxfb3V0IiwidG90YWxfb3V0IiwibXNnIiwic3RhdGUiLCJkYXRhX3R5cGUiLCJhZGxlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/UPNG.js":
/*!********************************************!*\
  !*** ./node_modules/@pdf-lib/upng/UPNG.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_0__);\n\nvar UPNG = {};\nUPNG.toRGBA8 = function(out) {\n    var w = out.width, h = out.height;\n    if (out.tabs.acTL == null) return [\n        UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer\n    ];\n    var frms = [];\n    if (out.frames[0].data == null) out.frames[0].data = out.data;\n    var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);\n    for(var i = 0; i < out.frames.length; i++){\n        var frm = out.frames[i];\n        var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;\n        var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);\n        if (i != 0) for(var j = 0; j < len; j++)prev[j] = img[j];\n        if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\n        else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n        frms.push(img.buffer.slice(0));\n        if (frm.dispose == 0) {} else if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\n        else if (frm.dispose == 2) for(var j = 0; j < len; j++)img[j] = prev[j];\n    }\n    return frms;\n};\nUPNG.toRGBA8.decodeImage = function(data, w, h, out) {\n    var area = w * h, bpp = UPNG.decode._getBPP(out);\n    var bpl = Math.ceil(w * bpp / 8); // bytes per line\n    var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);\n    var ctype = out.ctype, depth = out.depth;\n    var rs = UPNG._bin.readUshort;\n    //console.log(ctype, depth);\n    var time = Date.now();\n    if (ctype == 6) {\n        var qarea = area << 2;\n        if (depth == 8) for(var i = 0; i < qarea; i += 4){\n            bf[i] = data[i];\n            bf[i + 1] = data[i + 1];\n            bf[i + 2] = data[i + 2];\n            bf[i + 3] = data[i + 3];\n        }\n        if (depth == 16) for(var i = 0; i < qarea; i++){\n            bf[i] = data[i << 1];\n        }\n    } else if (ctype == 2) {\n        var ts = out.tabs[\"tRNS\"];\n        if (ts == null) {\n            if (depth == 8) for(var i = 0; i < area; i++){\n                var ti = i * 3;\n                bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n            }\n            if (depth == 16) for(var i = 0; i < area; i++){\n                var ti = i * 6;\n                bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n            }\n        } else {\n            var tr = ts[0], tg = ts[1], tb = ts[2];\n            if (depth == 8) for(var i = 0; i < area; i++){\n                var qi = i << 2, ti = i * 3;\n                bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n                if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\n            }\n            if (depth == 16) for(var i = 0; i < area; i++){\n                var qi = i << 2, ti = i * 6;\n                bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n                if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\n            }\n        }\n    } else if (ctype == 3) {\n        var p = out.tabs[\"PLTE\"], ap = out.tabs[\"tRNS\"], tl = ap ? ap.length : 0;\n        //console.log(p, ap);\n        if (depth == 1) for(var y = 0; y < h; y++){\n            var s0 = y * bpl, t0 = y * w;\n            for(var i = 0; i < w; i++){\n                var qi = t0 + i << 2, j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;\n                bf[qi] = p[cj];\n                bf[qi + 1] = p[cj + 1];\n                bf[qi + 2] = p[cj + 2];\n                bf[qi + 3] = j < tl ? ap[j] : 255;\n            }\n        }\n        if (depth == 2) for(var y = 0; y < h; y++){\n            var s0 = y * bpl, t0 = y * w;\n            for(var i = 0; i < w; i++){\n                var qi = t0 + i << 2, j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;\n                bf[qi] = p[cj];\n                bf[qi + 1] = p[cj + 1];\n                bf[qi + 2] = p[cj + 2];\n                bf[qi + 3] = j < tl ? ap[j] : 255;\n            }\n        }\n        if (depth == 4) for(var y = 0; y < h; y++){\n            var s0 = y * bpl, t0 = y * w;\n            for(var i = 0; i < w; i++){\n                var qi = t0 + i << 2, j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;\n                bf[qi] = p[cj];\n                bf[qi + 1] = p[cj + 1];\n                bf[qi + 2] = p[cj + 2];\n                bf[qi + 3] = j < tl ? ap[j] : 255;\n            }\n        }\n        if (depth == 8) for(var i = 0; i < area; i++){\n            var qi = i << 2, j = data[i], cj = 3 * j;\n            bf[qi] = p[cj];\n            bf[qi + 1] = p[cj + 1];\n            bf[qi + 2] = p[cj + 2];\n            bf[qi + 3] = j < tl ? ap[j] : 255;\n        }\n    } else if (ctype == 4) {\n        if (depth == 8) for(var i = 0; i < area; i++){\n            var qi = i << 2, di = i << 1, gr = data[di];\n            bf[qi] = gr;\n            bf[qi + 1] = gr;\n            bf[qi + 2] = gr;\n            bf[qi + 3] = data[di + 1];\n        }\n        if (depth == 16) for(var i = 0; i < area; i++){\n            var qi = i << 2, di = i << 2, gr = data[di];\n            bf[qi] = gr;\n            bf[qi + 1] = gr;\n            bf[qi + 2] = gr;\n            bf[qi + 3] = data[di + 2];\n        }\n    } else if (ctype == 0) {\n        var tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\n        for(var y = 0; y < h; y++){\n            var off = y * bpl, to = y * w;\n            if (depth == 1) for(var x = 0; x < w; x++){\n                var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n            else if (depth == 2) for(var x = 0; x < w; x++){\n                var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n            else if (depth == 4) for(var x = 0; x < w; x++){\n                var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n            else if (depth == 8) for(var x = 0; x < w; x++){\n                var gr = data[off + x], al = gr == tr ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n            else if (depth == 16) for(var x = 0; x < w; x++){\n                var gr = data[off + (x << 1)], al = rs(data, off + (x << i)) == tr ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n        }\n    }\n    //console.log(Date.now()-time);\n    return bf;\n};\nUPNG.decode = function(buff) {\n    var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;\n    var out = {\n        tabs: {},\n        frames: []\n    };\n    var dd = new Uint8Array(data.length), doff = 0; // put all IDAT data into it\n    var fd, foff = 0; // frames\n    var mgck = [\n        0x89,\n        0x50,\n        0x4e,\n        0x47,\n        0x0d,\n        0x0a,\n        0x1a,\n        0x0a\n    ];\n    for(var i = 0; i < 8; i++)if (data[i] != mgck[i]) throw \"The input is not a PNG file!\";\n    while(offset < data.length){\n        var len = bin.readUint(data, offset);\n        offset += 4;\n        var type = bin.readASCII(data, offset, 4);\n        offset += 4;\n        //console.log(type,len);\n        if (type == \"IHDR\") {\n            UPNG.decode._IHDR(data, offset, out);\n        } else if (type == \"IDAT\") {\n            for(var i = 0; i < len; i++)dd[doff + i] = data[offset + i];\n            doff += len;\n        } else if (type == \"acTL\") {\n            out.tabs[type] = {\n                num_frames: rUi(data, offset),\n                num_plays: rUi(data, offset + 4)\n            };\n            fd = new Uint8Array(data.length);\n        } else if (type == \"fcTL\") {\n            if (foff != 0) {\n                var fr = out.frames[out.frames.length - 1];\n                fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n                foff = 0;\n            }\n            var rct = {\n                x: rUi(data, offset + 12),\n                y: rUi(data, offset + 16),\n                width: rUi(data, offset + 4),\n                height: rUi(data, offset + 8)\n            };\n            var del = rUs(data, offset + 22);\n            del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\n            var frm = {\n                rect: rct,\n                delay: Math.round(del * 1000),\n                dispose: data[offset + 24],\n                blend: data[offset + 25]\n            };\n            //console.log(frm);\n            out.frames.push(frm);\n        } else if (type == \"fdAT\") {\n            for(var i = 0; i < len - 4; i++)fd[foff + i] = data[offset + i + 4];\n            foff += len - 4;\n        } else if (type == \"pHYs\") {\n            out.tabs[type] = [\n                bin.readUint(data, offset),\n                bin.readUint(data, offset + 4),\n                data[offset + 8]\n            ];\n        } else if (type == \"cHRM\") {\n            out.tabs[type] = [];\n            for(var i = 0; i < 8; i++)out.tabs[type].push(bin.readUint(data, offset + i * 4));\n        } else if (type == \"tEXt\") {\n            if (out.tabs[type] == null) out.tabs[type] = {};\n            var nz = bin.nextZero(data, offset);\n            var keyw = bin.readASCII(data, offset, nz - offset);\n            var text = bin.readASCII(data, nz + 1, offset + len - nz - 1);\n            out.tabs[type][keyw] = text;\n        } else if (type == \"iTXt\") {\n            if (out.tabs[type] == null) out.tabs[type] = {};\n            var nz = 0, off = offset;\n            nz = bin.nextZero(data, off);\n            var keyw = bin.readASCII(data, off, nz - off);\n            off = nz + 1;\n            var cflag = data[off], cmeth = data[off + 1];\n            off += 2;\n            nz = bin.nextZero(data, off);\n            var ltag = bin.readASCII(data, off, nz - off);\n            off = nz + 1;\n            nz = bin.nextZero(data, off);\n            var tkeyw = bin.readUTF8(data, off, nz - off);\n            off = nz + 1;\n            var text = bin.readUTF8(data, off, len - (off - offset));\n            out.tabs[type][keyw] = text;\n        } else if (type == \"PLTE\") {\n            out.tabs[type] = bin.readBytes(data, offset, len);\n        } else if (type == \"hIST\") {\n            var pl = out.tabs[\"PLTE\"].length / 3;\n            out.tabs[type] = [];\n            for(var i = 0; i < pl; i++)out.tabs[type].push(rUs(data, offset + i * 2));\n        } else if (type == \"tRNS\") {\n            if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);\n            else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);\n            else if (out.ctype == 2) out.tabs[type] = [\n                rUs(data, offset),\n                rUs(data, offset + 2),\n                rUs(data, offset + 4)\n            ];\n        //else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n        } else if (type == \"gAMA\") out.tabs[type] = bin.readUint(data, offset) / 100000;\n        else if (type == \"sRGB\") out.tabs[type] = data[offset];\n        else if (type == \"bKGD\") {\n            if (out.ctype == 0 || out.ctype == 4) out.tabs[type] = [\n                rUs(data, offset)\n            ];\n            else if (out.ctype == 2 || out.ctype == 6) out.tabs[type] = [\n                rUs(data, offset),\n                rUs(data, offset + 2),\n                rUs(data, offset + 4)\n            ];\n            else if (out.ctype == 3) out.tabs[type] = data[offset];\n        } else if (type == \"IEND\") {\n            break;\n        }\n        //else {  log(\"unknown chunk type\", type, len);  }\n        offset += len;\n        var crc = bin.readUint(data, offset);\n        offset += 4;\n    }\n    if (foff != 0) {\n        var fr = out.frames[out.frames.length - 1];\n        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n        foff = 0;\n    }\n    out.data = UPNG.decode._decompress(out, dd, out.width, out.height);\n    delete out.compress;\n    delete out.interlace;\n    delete out.filter;\n    return out;\n};\nUPNG.decode._decompress = function(out, dd, w, h) {\n    var time = Date.now();\n    var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);\n    dd = UPNG.decode._inflate(dd, buff);\n    //console.log(dd.length, buff.length);\n    //console.log(Date.now()-time);\n    var time = Date.now();\n    if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);\n    else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out);\n    //console.log(Date.now()-time);\n    return dd;\n};\nUPNG.decode._inflate = function(data, buff) {\n    var out = UPNG[\"inflateRaw\"](new Uint8Array(data.buffer, 2, data.length - 6), buff);\n    return out;\n};\nUPNG.inflateRaw = function() {\n    var H = {};\n    H.H = {};\n    H.H.N = function(N, W) {\n        var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C;\n        if (N[0] == 3 && N[1] == 0) return W ? W : new R(0);\n        var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null;\n        if (Z) W = new R(N.length >>> 2 << 3);\n        while(i == 0){\n            i = n(N, d, 1);\n            m = n(N, d + 1, 2);\n            d += 3;\n            if (m == 0) {\n                if ((d & 7) != 0) d += 8 - (d & 7);\n                var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;\n                if (Z) W = H.H.W(W, w + q);\n                W.set(new R(N.buffer, N.byteOffset + D, q), w);\n                d = D + q << 3;\n                w += q;\n                continue;\n            }\n            if (Z) W = H.H.W(W, w + (1 << 17));\n            if (m == 1) {\n                v = b.J;\n                C = b.h;\n                X = (1 << 9) - 1;\n                u = (1 << 5) - 1;\n            }\n            if (m == 2) {\n                J = A(N, d, 5) + 257;\n                h = A(N, d + 5, 5) + 1;\n                Q = A(N, d + 10, 4) + 4;\n                d += 14;\n                var E = d, j = 1;\n                for(var c = 0; c < 38; c += 2){\n                    b.Q[c] = 0;\n                    b.Q[c + 1] = 0;\n                }\n                for(var c = 0; c < Q; c++){\n                    var K = A(N, d + c * 3, 3);\n                    b.Q[(b.X[c] << 1) + 1] = K;\n                    if (K > j) j = K;\n                }\n                d += 3 * Q;\n                M(b.Q, j);\n                I(b.Q, j, b.u);\n                v = b.w;\n                C = b.d;\n                d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);\n                var r = V.V(b.v, 0, J, b.C);\n                X = (1 << r) - 1;\n                var S = V.V(b.v, J, h, b.D);\n                u = (1 << S) - 1;\n                M(b.C, r);\n                I(b.C, r, v);\n                M(b.D, S);\n                I(b.D, S, C);\n            }\n            while(!0){\n                var T = v[e(N, d) & X];\n                d += T & 15;\n                var p = T >>> 4;\n                if (p >>> 8 == 0) {\n                    W[w++] = p;\n                } else if (p == 256) {\n                    break;\n                } else {\n                    var z = w + p - 254;\n                    if (p > 264) {\n                        var _ = b.q[p - 257];\n                        z = w + (_ >>> 3) + A(N, d, _ & 7);\n                        d += _ & 7;\n                    }\n                    var $ = C[e(N, d) & u];\n                    d += $ & 15;\n                    var s = $ >>> 4, Y = b.c[s], a = (Y >>> 4) + n(N, d, Y & 15);\n                    d += Y & 15;\n                    while(w < z){\n                        W[w] = W[w++ - a];\n                        W[w] = W[w++ - a];\n                        W[w] = W[w++ - a];\n                        W[w] = W[w++ - a];\n                    }\n                    w = z;\n                }\n            }\n        }\n        return W.length == w ? W : W.slice(0, w);\n    };\n    H.H.W = function(N, W) {\n        var R = N.length;\n        if (W <= R) return N;\n        var V = new Uint8Array(R << 1);\n        V.set(N, 0);\n        return V;\n    };\n    H.H.R = function(N, W, R, V, n, A) {\n        var l = H.H.e, M = H.H.Z, I = 0;\n        while(I < R){\n            var e = N[M(V, n) & W];\n            n += e & 15;\n            var b = e >>> 4;\n            if (b <= 15) {\n                A[I] = b;\n                I++;\n            } else {\n                var Z = 0, m = 0;\n                if (b == 16) {\n                    m = 3 + l(V, n, 2);\n                    n += 2;\n                    Z = A[I - 1];\n                } else if (b == 17) {\n                    m = 3 + l(V, n, 3);\n                    n += 3;\n                } else if (b == 18) {\n                    m = 11 + l(V, n, 7);\n                    n += 7;\n                }\n                var J = I + m;\n                while(I < J){\n                    A[I] = Z;\n                    I++;\n                }\n            }\n        }\n        return n;\n    };\n    H.H.V = function(N, W, R, V) {\n        var n = 0, A = 0, l = V.length >>> 1;\n        while(A < R){\n            var M = N[A + W];\n            V[A << 1] = 0;\n            V[(A << 1) + 1] = M;\n            if (M > n) n = M;\n            A++;\n        }\n        while(A < l){\n            V[A << 1] = 0;\n            V[(A << 1) + 1] = 0;\n            A++;\n        }\n        return n;\n    };\n    H.H.n = function(N, W) {\n        var R = H.H.m, V = N.length, n, A, l, M, I, e = R.j;\n        for(var M = 0; M <= W; M++)e[M] = 0;\n        for(M = 1; M < V; M += 2)e[N[M]]++;\n        var b = R.K;\n        n = 0;\n        e[0] = 0;\n        for(A = 1; A <= W; A++){\n            n = n + e[A - 1] << 1;\n            b[A] = n;\n        }\n        for(l = 0; l < V; l += 2){\n            I = N[l + 1];\n            if (I != 0) {\n                N[l] = b[I];\n                b[I]++;\n            }\n        }\n    };\n    H.H.A = function(N, W, R) {\n        var V = N.length, n = H.H.m, A = n.r;\n        for(var l = 0; l < V; l += 2)if (N[l + 1] != 0) {\n            var M = l >> 1, I = N[l + 1], e = M << 4 | I, b = W - I, Z = N[l] << b, m = Z + (1 << b);\n            while(Z != m){\n                var J = A[Z] >>> 15 - W;\n                R[J] = e;\n                Z++;\n            }\n        }\n    };\n    H.H.l = function(N, W) {\n        var R = H.H.m.r, V = 15 - W;\n        for(var n = 0; n < N.length; n += 2){\n            var A = N[n] << W - N[n + 1];\n            N[n] = R[A] >>> V;\n        }\n    };\n    H.H.M = function(N, W, R) {\n        R = R << (W & 7);\n        var V = W >>> 3;\n        N[V] |= R;\n        N[V + 1] |= R >>> 8;\n    };\n    H.H.I = function(N, W, R) {\n        R = R << (W & 7);\n        var V = W >>> 3;\n        N[V] |= R;\n        N[V + 1] |= R >>> 8;\n        N[V + 2] |= R >>> 16;\n    };\n    H.H.e = function(N, W, R) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;\n    };\n    H.H.b = function(N, W, R) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;\n    };\n    H.H.Z = function(N, W) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);\n    };\n    H.H.i = function(N, W) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);\n    };\n    H.H.m = function() {\n        var N = Uint16Array, W = Uint32Array;\n        return {\n            K: new N(16),\n            j: new N(16),\n            X: [\n                16,\n                17,\n                18,\n                0,\n                8,\n                7,\n                9,\n                6,\n                10,\n                5,\n                11,\n                4,\n                12,\n                3,\n                13,\n                2,\n                14,\n                1,\n                15\n            ],\n            S: [\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                13,\n                15,\n                17,\n                19,\n                23,\n                27,\n                31,\n                35,\n                43,\n                51,\n                59,\n                67,\n                83,\n                99,\n                115,\n                131,\n                163,\n                195,\n                227,\n                258,\n                999,\n                999,\n                999\n            ],\n            T: [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                1,\n                1,\n                2,\n                2,\n                2,\n                2,\n                3,\n                3,\n                3,\n                3,\n                4,\n                4,\n                4,\n                4,\n                5,\n                5,\n                5,\n                5,\n                0,\n                0,\n                0,\n                0\n            ],\n            q: new N(32),\n            p: [\n                1,\n                2,\n                3,\n                4,\n                5,\n                7,\n                9,\n                13,\n                17,\n                25,\n                33,\n                49,\n                65,\n                97,\n                129,\n                193,\n                257,\n                385,\n                513,\n                769,\n                1025,\n                1537,\n                2049,\n                3073,\n                4097,\n                6145,\n                8193,\n                12289,\n                16385,\n                24577,\n                65535,\n                65535\n            ],\n            z: [\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                2,\n                2,\n                3,\n                3,\n                4,\n                4,\n                5,\n                5,\n                6,\n                6,\n                7,\n                7,\n                8,\n                8,\n                9,\n                9,\n                10,\n                10,\n                11,\n                11,\n                12,\n                12,\n                13,\n                13,\n                0,\n                0\n            ],\n            c: new W(32),\n            J: new N(512),\n            _: [],\n            h: new N(32),\n            $: [],\n            w: new N(32768),\n            C: [],\n            v: [],\n            d: new N(32768),\n            D: [],\n            u: new N(512),\n            Q: [],\n            r: new N(1 << 15),\n            s: new W(286),\n            Y: new W(30),\n            a: new W(19),\n            t: new W(15e3),\n            k: new N(1 << 16),\n            g: new N(1 << 15)\n        };\n    }();\n    (function() {\n        var N = H.H.m, W = 1 << 15;\n        for(var R = 0; R < W; R++){\n            var V = R;\n            V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\n            V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;\n            V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;\n            V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\n            N.r[R] = (V >>> 16 | V << 16) >>> 17;\n        }\n        function n(A, l, M) {\n            while(l-- != 0)A.push(0, M);\n        }\n        for(var R = 0; R < 32; R++){\n            N.q[R] = N.S[R] << 3 | N.T[R];\n            N.c[R] = N.p[R] << 4 | N.z[R];\n        }\n        n(N._, 144, 8);\n        n(N._, 255 - 143, 9);\n        n(N._, 279 - 255, 7);\n        n(N._, 287 - 279, 8);\n        H.H.n(N._, 9);\n        H.H.A(N._, 9, N.J);\n        H.H.l(N._, 9);\n        n(N.$, 32, 5);\n        H.H.n(N.$, 5);\n        H.H.A(N.$, 5, N.h);\n        H.H.l(N.$, 5);\n        n(N.Q, 19, 0);\n        n(N.C, 286, 0);\n        n(N.D, 30, 0);\n        n(N.v, 320, 0);\n    })();\n    return H.H.N;\n}();\nUPNG.decode._readInterlace = function(data, out) {\n    var w = out.width, h = out.height;\n    var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);\n    var img = new Uint8Array(h * bpl);\n    var di = 0;\n    var starting_row = [\n        0,\n        0,\n        4,\n        0,\n        2,\n        0,\n        1\n    ];\n    var starting_col = [\n        0,\n        4,\n        0,\n        2,\n        0,\n        1,\n        0\n    ];\n    var row_increment = [\n        8,\n        8,\n        8,\n        4,\n        4,\n        2,\n        2\n    ];\n    var col_increment = [\n        8,\n        8,\n        4,\n        4,\n        2,\n        2,\n        1\n    ];\n    var pass = 0;\n    while(pass < 7){\n        var ri = row_increment[pass], ci = col_increment[pass];\n        var sw = 0, sh = 0;\n        var cr = starting_row[pass];\n        while(cr < h){\n            cr += ri;\n            sh++;\n        }\n        var cc = starting_col[pass];\n        while(cc < w){\n            cc += ci;\n            sw++;\n        }\n        var bpll = Math.ceil(sw * bpp / 8);\n        UPNG.decode._filterZero(data, out, di, sw, sh);\n        var y = 0, row = starting_row[pass];\n        while(row < h){\n            var col = starting_col[pass];\n            var cdi = di + y * bpll << 3;\n            while(col < w){\n                if (bpp == 1) {\n                    var val = data[cdi >> 3];\n                    val = val >> 7 - (cdi & 7) & 1;\n                    img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);\n                }\n                if (bpp == 2) {\n                    var val = data[cdi >> 3];\n                    val = val >> 6 - (cdi & 7) & 3;\n                    img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);\n                }\n                if (bpp == 4) {\n                    var val = data[cdi >> 3];\n                    val = val >> 4 - (cdi & 7) & 15;\n                    img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);\n                }\n                if (bpp >= 8) {\n                    var ii = row * bpl + col * cbpp;\n                    for(var j = 0; j < cbpp; j++)img[ii + j] = data[(cdi >> 3) + j];\n                }\n                cdi += bpp;\n                col += ci;\n            }\n            y++;\n            row += ri;\n        }\n        if (sw * sh != 0) di += sh * (1 + bpll);\n        pass = pass + 1;\n    }\n    return img;\n};\nUPNG.decode._getBPP = function(out) {\n    var noc = [\n        1,\n        null,\n        3,\n        1,\n        2,\n        null,\n        4\n    ][out.ctype];\n    return noc * out.depth;\n};\nUPNG.decode._filterZero = function(data, out, off, w, h) {\n    var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;\n    bpp = Math.ceil(bpp / 8);\n    var i = 0, di = 1, type = data[off], x = 0;\n    if (type > 1) data[off] = [\n        0,\n        0,\n        1\n    ][type - 2];\n    if (type == 3) for(x = bpp; x < bpl; x++)data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;\n    for(var y = 0; y < h; y++){\n        i = off + y * bpl;\n        di = i + y + 1;\n        type = data[di - 1];\n        x = 0;\n        if (type == 0) for(; x < bpl; x++)data[i + x] = data[di + x];\n        else if (type == 1) {\n            for(; x < bpp; x++)data[i + x] = data[di + x];\n            for(; x < bpl; x++)data[i + x] = data[di + x] + data[i + x - bpp];\n        } else if (type == 2) {\n            for(; x < bpl; x++)data[i + x] = data[di + x] + data[i + x - bpl];\n        } else if (type == 3) {\n            for(; x < bpp; x++)data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);\n            for(; x < bpl; x++)data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);\n        } else {\n            for(; x < bpp; x++)data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);\n            for(; x < bpl; x++)data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);\n        }\n    }\n    return data;\n};\nUPNG.decode._paeth = function(a, b, c) {\n    var p = a + b - c, pa = p - a, pb = p - b, pc = p - c;\n    if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;\n    else if (pb * pb <= pc * pc) return b;\n    return c;\n};\nUPNG.decode._IHDR = function(data, offset, out) {\n    var bin = UPNG._bin;\n    out.width = bin.readUint(data, offset);\n    offset += 4;\n    out.height = bin.readUint(data, offset);\n    offset += 4;\n    out.depth = data[offset];\n    offset++;\n    out.ctype = data[offset];\n    offset++;\n    out.compress = data[offset];\n    offset++;\n    out.filter = data[offset];\n    offset++;\n    out.interlace = data[offset];\n    offset++;\n};\nUPNG._bin = {\n    nextZero: function(data, p) {\n        while(data[p] != 0)p++;\n        return p;\n    },\n    readUshort: function(buff, p) {\n        return buff[p] << 8 | buff[p + 1];\n    },\n    writeUshort: function(buff, p, n) {\n        buff[p] = n >> 8 & 255;\n        buff[p + 1] = n & 255;\n    },\n    readUint: function(buff, p) {\n        return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);\n    },\n    writeUint: function(buff, p, n) {\n        buff[p] = n >> 24 & 255;\n        buff[p + 1] = n >> 16 & 255;\n        buff[p + 2] = n >> 8 & 255;\n        buff[p + 3] = n & 255;\n    },\n    readASCII: function(buff, p, l) {\n        var s = \"\";\n        for(var i = 0; i < l; i++)s += String.fromCharCode(buff[p + i]);\n        return s;\n    },\n    writeASCII: function(data, p, s) {\n        for(var i = 0; i < s.length; i++)data[p + i] = s.charCodeAt(i);\n    },\n    readBytes: function(buff, p, l) {\n        var arr = [];\n        for(var i = 0; i < l; i++)arr.push(buff[p + i]);\n        return arr;\n    },\n    pad: function(n) {\n        return n.length < 2 ? \"0\" + n : n;\n    },\n    readUTF8: function(buff, p, l) {\n        var s = \"\", ns;\n        for(var i = 0; i < l; i++)s += \"%\" + UPNG._bin.pad(buff[p + i].toString(16));\n        try {\n            ns = decodeURIComponent(s);\n        } catch (e) {\n            return UPNG._bin.readASCII(buff, p, l);\n        }\n        return ns;\n    }\n};\nUPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\n    var w = Math.min(sw, tw), h = Math.min(sh, th);\n    var si = 0, ti = 0;\n    for(var y = 0; y < h; y++)for(var x = 0; x < w; x++){\n        if (xoff >= 0 && yoff >= 0) {\n            si = y * sw + x << 2;\n            ti = (yoff + y) * tw + xoff + x << 2;\n        } else {\n            si = (-yoff + y) * sw - xoff + x << 2;\n            ti = y * tw + x << 2;\n        }\n        if (mode == 0) {\n            tb[ti] = sb[si];\n            tb[ti + 1] = sb[si + 1];\n            tb[ti + 2] = sb[si + 2];\n            tb[ti + 3] = sb[si + 3];\n        } else if (mode == 1) {\n            var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;\n            var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;\n            var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;\n            tb[ti + 3] = 255 * oa;\n            tb[ti + 0] = (fr + br * ifa) * ioa;\n            tb[ti + 1] = (fg + bg * ifa) * ioa;\n            tb[ti + 2] = (fb + bb * ifa) * ioa;\n        } else if (mode == 2) {\n            var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];\n            var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];\n            if (fa == ba && fr == br && fg == bg && fb == bb) {\n                tb[ti] = 0;\n                tb[ti + 1] = 0;\n                tb[ti + 2] = 0;\n                tb[ti + 3] = 0;\n            } else {\n                tb[ti] = fr;\n                tb[ti + 1] = fg;\n                tb[ti + 2] = fb;\n                tb[ti + 3] = fa;\n            }\n        } else if (mode == 3) {\n            var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];\n            var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];\n            if (fa == ba && fr == br && fg == bg && fb == bb) continue;\n            //if(fa!=255 && ba!=0) return false;\n            if (fa < 220 && ba > 20) return false;\n        }\n    }\n    return true;\n};\nUPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte) {\n    if (ps == null) ps = 0;\n    if (forbidPlte == null) forbidPlte = false;\n    var nimg = UPNG.encode.compress(bufs, w, h, ps, [\n        false,\n        false,\n        false,\n        0,\n        forbidPlte\n    ]);\n    UPNG.encode.compressPNG(nimg, -1);\n    return UPNG.encode._main(nimg, w, h, dels, tabs);\n};\nUPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {\n    var nimg = {\n        ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4),\n        depth: depth,\n        frames: []\n    };\n    var time = Date.now();\n    var bipp = (cc + ac) * depth, bipl = bipp * w;\n    for(var i = 0; i < bufs.length; i++)nimg.frames.push({\n        rect: {\n            x: 0,\n            y: 0,\n            width: w,\n            height: h\n        },\n        img: new Uint8Array(bufs[i]),\n        blend: 0,\n        dispose: 1,\n        bpp: Math.ceil(bipp / 8),\n        bpl: Math.ceil(bipl / 8)\n    });\n    UPNG.encode.compressPNG(nimg, 0, true);\n    var out = UPNG.encode._main(nimg, w, h, dels, tabs);\n    return out;\n};\nUPNG.encode._main = function(nimg, w, h, dels, tabs) {\n    if (tabs == null) tabs = {};\n    var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;\n    var offset = 8, anim = nimg.frames.length > 1, pltAlpha = false;\n    var leng = 8 + (16 + 5 + 4) + (anim ? 20 : 0);\n    if (tabs[\"sRGB\"] != null) leng += 8 + 1 + 4;\n    if (tabs[\"pHYs\"] != null) leng += 8 + 9 + 4;\n    if (nimg.ctype == 3) {\n        var dl = nimg.plte.length;\n        for(var i = 0; i < dl; i++)if (nimg.plte[i] >>> 24 != 255) pltAlpha = true;\n        leng += 8 + dl * 3 + 4 + (pltAlpha ? 8 + dl * 1 + 4 : 0);\n    }\n    for(var j = 0; j < nimg.frames.length; j++){\n        var fr = nimg.frames[j];\n        if (anim) leng += 38;\n        leng += fr.cimg.length + 12;\n        if (j != 0) leng += 4;\n    }\n    leng += 12;\n    var data = new Uint8Array(leng);\n    var wr = [\n        0x89,\n        0x50,\n        0x4e,\n        0x47,\n        0x0d,\n        0x0a,\n        0x1a,\n        0x0a\n    ];\n    for(var i = 0; i < 8; i++)data[i] = wr[i];\n    wUi(data, offset, 13);\n    offset += 4;\n    wAs(data, offset, \"IHDR\");\n    offset += 4;\n    wUi(data, offset, w);\n    offset += 4;\n    wUi(data, offset, h);\n    offset += 4;\n    data[offset] = nimg.depth;\n    offset++; // depth\n    data[offset] = nimg.ctype;\n    offset++; // ctype\n    data[offset] = 0;\n    offset++; // compress\n    data[offset] = 0;\n    offset++; // filter\n    data[offset] = 0;\n    offset++; // interlace\n    wUi(data, offset, crc(data, offset - 17, 17));\n    offset += 4; // crc\n    // 13 bytes to say, that it is sRGB\n    if (tabs[\"sRGB\"] != null) {\n        wUi(data, offset, 1);\n        offset += 4;\n        wAs(data, offset, \"sRGB\");\n        offset += 4;\n        data[offset] = tabs[\"sRGB\"];\n        offset++;\n        wUi(data, offset, crc(data, offset - 5, 5));\n        offset += 4; // crc\n    }\n    if (tabs[\"pHYs\"] != null) {\n        wUi(data, offset, 9);\n        offset += 4;\n        wAs(data, offset, \"pHYs\");\n        offset += 4;\n        wUi(data, offset, tabs[\"pHYs\"][0]);\n        offset += 4;\n        wUi(data, offset, tabs[\"pHYs\"][1]);\n        offset += 4;\n        data[offset] = tabs[\"pHYs\"][2];\n        offset++;\n        wUi(data, offset, crc(data, offset - 13, 13));\n        offset += 4; // crc\n    }\n    if (anim) {\n        wUi(data, offset, 8);\n        offset += 4;\n        wAs(data, offset, \"acTL\");\n        offset += 4;\n        wUi(data, offset, nimg.frames.length);\n        offset += 4;\n        wUi(data, offset, tabs[\"loop\"] != null ? tabs[\"loop\"] : 0);\n        offset += 4;\n        wUi(data, offset, crc(data, offset - 12, 12));\n        offset += 4; // crc\n    }\n    if (nimg.ctype == 3) {\n        var dl = nimg.plte.length;\n        wUi(data, offset, dl * 3);\n        offset += 4;\n        wAs(data, offset, \"PLTE\");\n        offset += 4;\n        for(var i = 0; i < dl; i++){\n            var ti = i * 3, c = nimg.plte[i], r = c & 255, g = c >>> 8 & 255, b = c >>> 16 & 255;\n            data[offset + ti + 0] = r;\n            data[offset + ti + 1] = g;\n            data[offset + ti + 2] = b;\n        }\n        offset += dl * 3;\n        wUi(data, offset, crc(data, offset - dl * 3 - 4, dl * 3 + 4));\n        offset += 4; // crc\n        if (pltAlpha) {\n            wUi(data, offset, dl);\n            offset += 4;\n            wAs(data, offset, \"tRNS\");\n            offset += 4;\n            for(var i = 0; i < dl; i++)data[offset + i] = nimg.plte[i] >>> 24 & 255;\n            offset += dl;\n            wUi(data, offset, crc(data, offset - dl - 4, dl + 4));\n            offset += 4; // crc\n        }\n    }\n    var fi = 0;\n    for(var j = 0; j < nimg.frames.length; j++){\n        var fr = nimg.frames[j];\n        if (anim) {\n            wUi(data, offset, 26);\n            offset += 4;\n            wAs(data, offset, \"fcTL\");\n            offset += 4;\n            wUi(data, offset, fi++);\n            offset += 4;\n            wUi(data, offset, fr.rect.width);\n            offset += 4;\n            wUi(data, offset, fr.rect.height);\n            offset += 4;\n            wUi(data, offset, fr.rect.x);\n            offset += 4;\n            wUi(data, offset, fr.rect.y);\n            offset += 4;\n            wUs(data, offset, dels[j]);\n            offset += 2;\n            wUs(data, offset, 1000);\n            offset += 2;\n            data[offset] = fr.dispose;\n            offset++; // dispose\n            data[offset] = fr.blend;\n            offset++; // blend\n            wUi(data, offset, crc(data, offset - 30, 30));\n            offset += 4; // crc\n        }\n        var imgd = fr.cimg, dl = imgd.length;\n        wUi(data, offset, dl + (j == 0 ? 0 : 4));\n        offset += 4;\n        var ioff = offset;\n        wAs(data, offset, j == 0 ? \"IDAT\" : \"fdAT\");\n        offset += 4;\n        if (j != 0) {\n            wUi(data, offset, fi++);\n            offset += 4;\n        }\n        data.set(imgd, offset);\n        offset += dl;\n        wUi(data, offset, crc(data, ioff, offset - ioff));\n        offset += 4; // crc\n    }\n    wUi(data, offset, 0);\n    offset += 4;\n    wAs(data, offset, \"IEND\");\n    offset += 4;\n    wUi(data, offset, crc(data, offset - 4, 4));\n    offset += 4; // crc\n    return data.buffer;\n};\nUPNG.encode.compressPNG = function(out, filter, levelZero) {\n    for(var i = 0; i < out.frames.length; i++){\n        var frm = out.frames[i], nw = frm.rect.width, nh = frm.rect.height;\n        var fdata = new Uint8Array(nh * frm.bpl + nh);\n        frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);\n    }\n};\nUPNG.encode.compress = function(bufs, w, h, ps, prms) {\n    //var time = Date.now();\n    var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];\n    var ctype = 6, depth = 8, alphaAnd = 255;\n    for(var j = 0; j < bufs.length; j++){\n        var img = new Uint8Array(bufs[j]), ilen = img.length;\n        for(var i = 0; i < ilen; i += 4)alphaAnd &= img[i + 3];\n    }\n    var gotAlpha = alphaAnd != 255;\n    //console.log(\"alpha check\", Date.now()-time);  time = Date.now();\n    //var brute = gotAlpha && forGIF;\t\t// brute : frames can only be copied, not \"blended\"\n    var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);\n    //console.log(\"framize\", Date.now()-time);  time = Date.now();\n    var cmap = {}, plte = [], inds = [];\n    if (ps != 0) {\n        var nbufs = [];\n        for(var i = 0; i < frms.length; i++)nbufs.push(frms[i].img.buffer);\n        var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);\n        var cof = 0, bb = new Uint8Array(qres.abuf);\n        for(var i = 0; i < frms.length; i++){\n            var ti = frms[i].img, bln = ti.length;\n            inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));\n            for(var j = 0; j < bln; j += 4){\n                ti[j] = bb[cof + j];\n                ti[j + 1] = bb[cof + j + 1];\n                ti[j + 2] = bb[cof + j + 2];\n                ti[j + 3] = bb[cof + j + 3];\n            }\n            cof += bln;\n        }\n        for(var i = 0; i < qres.plte.length; i++)plte.push(qres.plte[i].est.rgba);\n    //console.log(\"quantize\", Date.now()-time);  time = Date.now();\n    } else {\n        // what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n        for(var j = 0; j < frms.length; j++){\n            var frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw = frm.rect.width, ilen = img32.length;\n            var ind = new Uint8Array(ilen);\n            inds.push(ind);\n            for(var i = 0; i < ilen; i++){\n                var c = img32[i];\n                if (i != 0 && c == img32[i - 1]) ind[i] = ind[i - 1];\n                else if (i > nw && c == img32[i - nw]) ind[i] = ind[i - nw];\n                else {\n                    var cmc = cmap[c];\n                    if (cmc == null) {\n                        cmap[c] = cmc = plte.length;\n                        plte.push(c);\n                        if (plte.length >= 300) break;\n                    }\n                    ind[i] = cmc;\n                }\n            }\n        }\n    //console.log(\"make palette\", Date.now()-time);  time = Date.now();\n    }\n    var cc = plte.length; //console.log(\"colors:\",cc);\n    if (cc <= 256 && forbidPlte == false) {\n        if (cc <= 2) depth = 1;\n        else if (cc <= 4) depth = 2;\n        else if (cc <= 16) depth = 4;\n        else depth = 8;\n        depth = Math.max(depth, minBits);\n    }\n    for(var j = 0; j < frms.length; j++){\n        var frm = frms[j], nx = frm.rect.x, ny = frm.rect.y, nw = frm.rect.width, nh = frm.rect.height;\n        var cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);\n        var bpl = 4 * nw, bpp = 4;\n        if (cc <= 256 && forbidPlte == false) {\n            bpl = Math.ceil(depth * nw / 8);\n            var nimg = new Uint8Array(bpl * nh);\n            var inj = inds[j];\n            for(var y = 0; y < nh; y++){\n                var i = y * bpl, ii = y * nw;\n                if (depth == 8) for(var x = 0; x < nw; x++)nimg[i + x] = inj[ii + x];\n                else if (depth == 4) for(var x = 0; x < nw; x++)nimg[i + (x >> 1)] |= inj[ii + x] << 4 - (x & 1) * 4;\n                else if (depth == 2) for(var x = 0; x < nw; x++)nimg[i + (x >> 2)] |= inj[ii + x] << 6 - (x & 3) * 2;\n                else if (depth == 1) for(var x = 0; x < nw; x++)nimg[i + (x >> 3)] |= inj[ii + x] << 7 - (x & 7) * 1;\n            }\n            cimg = nimg;\n            ctype = 3;\n            bpp = 1;\n        } else if (gotAlpha == false && frms.length == 1) {\n            var nimg = new Uint8Array(nw * nh * 3), area = nw * nh;\n            for(var i = 0; i < area; i++){\n                var ti = i * 3, qi = i * 4;\n                nimg[ti] = cimg[qi];\n                nimg[ti + 1] = cimg[qi + 1];\n                nimg[ti + 2] = cimg[qi + 2];\n            }\n            cimg = nimg;\n            ctype = 2;\n            bpp = 3;\n            bpl = 3 * nw;\n        }\n        frm.img = cimg;\n        frm.bpl = bpl;\n        frm.bpp = bpp;\n    }\n    //console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\n    return {\n        ctype: ctype,\n        depth: depth,\n        plte: plte,\n        frames: frms\n    };\n};\nUPNG.encode.framize = function(bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {\n    /*  DISPOSE\n\t    - 0 : no change\n\t\t- 1 : clear to transparent\n\t\t- 2 : retstore to content before rendering (previous frame disposed)\n\t\tBLEND\n\t\t- 0 : replace\n\t\t- 1 : blend\n\t*/ var frms = [];\n    for(var j = 0; j < bufs.length; j++){\n        var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);\n        var nimg;\n        var nx = 0, ny = 0, nw = w, nh = h, blend = alwaysBlend ? 1 : 0;\n        if (j != 0) {\n            var tlim = forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0 ? 1 : 2, tstp = 0, tarea = 1e9;\n            for(var it = 0; it < tlim; it++){\n                var pimg = new Uint8Array(bufs[j - 1 - it]), p32 = new Uint32Array(bufs[j - 1 - it]);\n                var mix = w, miy = h, max = -1, may = -1;\n                for(var y = 0; y < h; y++)for(var x = 0; x < w; x++){\n                    var i = y * w + x;\n                    if (cimg32[i] != p32[i]) {\n                        if (x < mix) mix = x;\n                        if (x > max) max = x;\n                        if (y < miy) miy = y;\n                        if (y > may) may = y;\n                    }\n                }\n                if (max == -1) mix = miy = max = may = 0;\n                if (evenCrd) {\n                    if ((mix & 1) == 1) mix--;\n                    if ((miy & 1) == 1) miy--;\n                }\n                var sarea = (max - mix + 1) * (may - miy + 1);\n                if (sarea < tarea) {\n                    tarea = sarea;\n                    tstp = it;\n                    nx = mix;\n                    ny = miy;\n                    nw = max - mix + 1;\n                    nh = may - miy + 1;\n                }\n            }\n            // alwaysBlend: pokud zjistm, e blendit nelze, nastavm pedchozmu snmku dispose=1. Zajistm, aby obsahoval mj obdlnk.\n            var pimg = new Uint8Array(bufs[j - 1 - tstp]);\n            if (tstp == 1) frms[j - 1].dispose = 2;\n            nimg = new Uint8Array(nw * nh * 4);\n            UPNG._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n            blend = UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;\n            if (blend == 1) UPNG.encode._prepareDiff(cimg, w, h, nimg, {\n                x: nx,\n                y: ny,\n                width: nw,\n                height: nh\n            });\n            else UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n        //UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, blend==1?2:0);\n        } else nimg = cimg.slice(0); // img may be rewritten further ... don't rewrite input\n        frms.push({\n            rect: {\n                x: nx,\n                y: ny,\n                width: nw,\n                height: nh\n            },\n            img: nimg,\n            blend: blend,\n            dispose: 0\n        });\n    }\n    if (alwaysBlend) for(var j = 0; j < frms.length; j++){\n        var frm = frms[j];\n        if (frm.blend == 1) continue;\n        var r0 = frm.rect, r1 = frms[j - 1].rect;\n        var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);\n        var maX = Math.max(r0.x + r0.width, r1.x + r1.width), maY = Math.max(r0.y + r0.height, r1.y + r1.height);\n        var r = {\n            x: miX,\n            y: miY,\n            width: maX - miX,\n            height: maY - miY\n        };\n        frms[j - 1].dispose = 1;\n        if (j - 1 != 0) UPNG.encode._updateFrame(bufs, w, h, frms, j - 1, r, evenCrd);\n        UPNG.encode._updateFrame(bufs, w, h, frms, j, r, evenCrd);\n    }\n    var area = 0;\n    if (bufs.length != 1) for(var i = 0; i < frms.length; i++){\n        var frm = frms[i];\n        area += frm.rect.width * frm.rect.height;\n    //if(i==0 || frm.blend!=1) continue;\n    //var ob = new Uint8Array(\n    //console.log(frm.blend, frm.dispose, frm.rect);\n    }\n    //if(area!=0) console.log(area);\n    return frms;\n};\nUPNG.encode._updateFrame = function(bufs, w, h, frms, i, r, evenCrd) {\n    var U8 = Uint8Array, U32 = Uint32Array;\n    var pimg = new U8(bufs[i - 1]), pimg32 = new U32(bufs[i - 1]), nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;\n    var cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);\n    var mix = w, miy = h, max = -1, may = -1;\n    for(var y = 0; y < r.height; y++)for(var x = 0; x < r.width; x++){\n        var cx = r.x + x, cy = r.y + y;\n        var j = cy * w + cx, cc = cimg32[j];\n        // no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.\n        if (cc == 0 || frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0)) {} else {\n            if (cx < mix) mix = cx;\n            if (cx > max) max = cx;\n            if (cy < miy) miy = cy;\n            if (cy > may) may = cy;\n        }\n    }\n    if (max == -1) mix = miy = max = may = 0;\n    if (evenCrd) {\n        if ((mix & 1) == 1) mix--;\n        if ((miy & 1) == 1) miy--;\n    }\n    r = {\n        x: mix,\n        y: miy,\n        width: max - mix + 1,\n        height: may - miy + 1\n    };\n    var fr = frms[i];\n    fr.rect = r;\n    fr.blend = 1;\n    fr.img = new Uint8Array(r.width * r.height * 4);\n    if (frms[i - 1].dispose == 0) {\n        UPNG._copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n        UPNG.encode._prepareDiff(cimg, w, h, fr.img, r);\n    //UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 2);\n    } else UPNG._copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n};\nUPNG.encode._prepareDiff = function(cimg, w, h, nimg, rec) {\n    UPNG._copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);\n/*\n\tvar n32 = new Uint32Array(nimg.buffer);\n\tvar og = new Uint8Array(rec.width*rec.height*4), o32 = new Uint32Array(og.buffer);\n\tUPNG._copyTile(cimg,w,h, og,rec.width,rec.height, -rec.x,-rec.y, 0);\n\tfor(var i=4; i<nimg.length; i+=4) {\n\t\tif(nimg[i-1]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)-1]) {\n\t\t\tn32[i>>>2]=o32[i>>>2];\n\t\t\t//var j = i, c=p32[(i>>>2)-1];\n\t\t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n\t\t}\n\t}\n\tfor(var i=nimg.length-8; i>0; i-=4) {\n\t\tif(nimg[i+7]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)+1]) {\n\t\t\tn32[i>>>2]=o32[i>>>2];\n\t\t\t//var j = i, c=p32[(i>>>2)-1];\n\t\t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n\t\t}\n\t}*/ };\nUPNG.encode._filterZero = function(img, h, bpp, bpl, data, filter, levelZero) {\n    var fls = [], ftry = [\n        0,\n        1,\n        2,\n        3,\n        4\n    ];\n    if (filter != -1) ftry = [\n        filter\n    ];\n    else if (h * bpl > 500000 || bpp == 1) ftry = [\n        0\n    ];\n    var opts;\n    if (levelZero) opts = {\n        level: 0\n    };\n    var CMPR = levelZero && UZIP != null ? UZIP : (pako__WEBPACK_IMPORTED_MODULE_0___default());\n    for(var i = 0; i < ftry.length; i++){\n        for(var y = 0; y < h; y++)UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);\n        //var nimg = new Uint8Array(data.length);\n        //var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));\n        //var dfl = pako[\"deflate\"](data), dl=dfl.length-4;\n        //var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);\n        //console.log(crc, UZIP.adler(data,2,data.length-6));\n        fls.push(CMPR[\"deflate\"](data, opts));\n    }\n    var ti, tsize = 1e9;\n    for(var i = 0; i < fls.length; i++)if (fls[i].length < tsize) {\n        ti = i;\n        tsize = fls[i].length;\n    }\n    return fls[ti];\n};\nUPNG.encode._filterLine = function(data, img, y, bpl, bpp, type) {\n    var i = y * bpl, di = i + y, paeth = UPNG.decode._paeth;\n    data[di] = type;\n    di++;\n    if (type == 0) {\n        if (bpl < 500) for(var x = 0; x < bpl; x++)data[di + x] = img[i + x];\n        else data.set(new Uint8Array(img.buffer, i, bpl), di);\n    } else if (type == 1) {\n        for(var x = 0; x < bpp; x++)data[di + x] = img[i + x];\n        for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] - img[i + x - bpp] + 256 & 255;\n    } else if (y == 0) {\n        for(var x = 0; x < bpp; x++)data[di + x] = img[i + x];\n        if (type == 2) for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x];\n        if (type == 3) for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] - (img[i + x - bpp] >> 1) + 256 & 255;\n        if (type == 4) for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256 & 255;\n    } else {\n        if (type == 2) {\n            for(var x = 0; x < bpl; x++)data[di + x] = img[i + x] + 256 - img[i + x - bpl] & 255;\n        }\n        if (type == 3) {\n            for(var x = 0; x < bpp; x++)data[di + x] = img[i + x] + 256 - (img[i + x - bpl] >> 1) & 255;\n            for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] + 256 - (img[i + x - bpl] + img[i + x - bpp] >> 1) & 255;\n        }\n        if (type == 4) {\n            for(var x = 0; x < bpp; x++)data[di + x] = img[i + x] + 256 - paeth(0, img[i + x - bpl], 0) & 255;\n            for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl]) & 255;\n        }\n    }\n};\nUPNG.crc = {\n    table: function() {\n        var tab = new Uint32Array(256);\n        for(var n = 0; n < 256; n++){\n            var c = n;\n            for(var k = 0; k < 8; k++){\n                if (c & 1) c = 0xedb88320 ^ c >>> 1;\n                else c = c >>> 1;\n            }\n            tab[n] = c;\n        }\n        return tab;\n    }(),\n    update: function(c, buf, off, len) {\n        for(var i = 0; i < len; i++)c = UPNG.crc.table[(c ^ buf[off + i]) & 0xff] ^ c >>> 8;\n        return c;\n    },\n    crc: function(b, o, l) {\n        return UPNG.crc.update(0xffffffff, b, o, l) ^ 0xffffffff;\n    }\n};\nUPNG.quantize = function(abuf, ps) {\n    var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);\n    var KD = UPNG.quantize.getKDtree(nimg, ps);\n    var root = KD[0], leafs = KD[1];\n    var planeDst = UPNG.quantize.planeDst;\n    var sb = oimg, tb = nimg32, len = sb.length;\n    var inds = new Uint8Array(oimg.length >> 2);\n    for(var i = 0; i < len; i += 4){\n        var r = sb[i] * (1 / 255), g = sb[i + 1] * (1 / 255), b = sb[i + 2] * (1 / 255), a = sb[i + 3] * (1 / 255);\n        //  exact, but too slow :(\n        var nd = UPNG.quantize.getNearest(root, r, g, b, a);\n        //var nd = root;\n        //while(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\n        inds[i >> 2] = nd.ind;\n        tb[i >> 2] = nd.est.rgba;\n    }\n    return {\n        abuf: nimg.buffer,\n        inds: inds,\n        plte: leafs\n    };\n};\nUPNG.quantize.getKDtree = function(nimg, ps, err) {\n    if (err == null) err = 0.0001;\n    var nimg32 = new Uint32Array(nimg.buffer);\n    var root = {\n        i0: 0,\n        i1: nimg.length,\n        bst: null,\n        est: null,\n        tdst: 0,\n        left: null,\n        right: null\n    }; // basic statistic, extra statistic\n    root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1);\n    root.est = UPNG.quantize.estats(root.bst);\n    var leafs = [\n        root\n    ];\n    while(leafs.length < ps){\n        var maxL = 0, mi = 0;\n        for(var i = 0; i < leafs.length; i++)if (leafs[i].est.L > maxL) {\n            maxL = leafs[i].est.L;\n            mi = i;\n        }\n        if (maxL < err) break;\n        var node = leafs[mi];\n        var s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n        var s0wrong = node.i0 >= s0 || node.i1 <= s0;\n        //console.log(maxL, leafs.length, mi);\n        if (s0wrong) {\n            node.est.L = 0;\n            continue;\n        }\n        var ln = {\n            i0: node.i0,\n            i1: s0,\n            bst: null,\n            est: null,\n            tdst: 0,\n            left: null,\n            right: null\n        };\n        ln.bst = UPNG.quantize.stats(nimg, ln.i0, ln.i1);\n        ln.est = UPNG.quantize.estats(ln.bst);\n        var rn = {\n            i0: s0,\n            i1: node.i1,\n            bst: null,\n            est: null,\n            tdst: 0,\n            left: null,\n            right: null\n        };\n        rn.bst = {\n            R: [],\n            m: [],\n            N: node.bst.N - ln.bst.N\n        };\n        for(var i = 0; i < 16; i++)rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];\n        for(var i = 0; i < 4; i++)rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];\n        rn.est = UPNG.quantize.estats(rn.bst);\n        node.left = ln;\n        node.right = rn;\n        leafs[mi] = ln;\n        leafs.push(rn);\n    }\n    leafs.sort(function(a, b) {\n        return b.bst.N - a.bst.N;\n    });\n    for(var i = 0; i < leafs.length; i++)leafs[i].ind = i;\n    return [\n        root,\n        leafs\n    ];\n};\nUPNG.quantize.getNearest = function(nd, r, g, b, a) {\n    if (nd.left == null) {\n        nd.tdst = UPNG.quantize.dist(nd.est.q, r, g, b, a);\n        return nd;\n    }\n    var planeDst = UPNG.quantize.planeDst(nd.est, r, g, b, a);\n    var node0 = nd.left, node1 = nd.right;\n    if (planeDst > 0) {\n        node0 = nd.right;\n        node1 = nd.left;\n    }\n    var ln = UPNG.quantize.getNearest(node0, r, g, b, a);\n    if (ln.tdst <= planeDst * planeDst) return ln;\n    var rn = UPNG.quantize.getNearest(node1, r, g, b, a);\n    return rn.tdst < ln.tdst ? rn : ln;\n};\nUPNG.quantize.planeDst = function(est, r, g, b, a) {\n    var e = est.e;\n    return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq;\n};\nUPNG.quantize.dist = function(q, r, g, b, a) {\n    var d0 = r - q[0], d1 = g - q[1], d2 = b - q[2], d3 = a - q[3];\n    return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;\n};\nUPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq) {\n    var vecDot = UPNG.quantize.vecDot;\n    i1 -= 4;\n    var shfs = 0;\n    while(i0 < i1){\n        while(vecDot(nimg, i0, e) <= eMq)i0 += 4;\n        while(vecDot(nimg, i1, e) > eMq)i1 -= 4;\n        if (i0 >= i1) break;\n        var t = nimg32[i0 >> 2];\n        nimg32[i0 >> 2] = nimg32[i1 >> 2];\n        nimg32[i1 >> 2] = t;\n        i0 += 4;\n        i1 -= 4;\n    }\n    while(vecDot(nimg, i0, e) > eMq)i0 -= 4;\n    return i0 + 4;\n};\nUPNG.quantize.vecDot = function(nimg, i, e) {\n    return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];\n};\nUPNG.quantize.stats = function(nimg, i0, i1) {\n    var R = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n    var m = [\n        0,\n        0,\n        0,\n        0\n    ];\n    var N = i1 - i0 >> 2;\n    for(var i = i0; i < i1; i += 4){\n        var r = nimg[i] * (1 / 255), g = nimg[i + 1] * (1 / 255), b = nimg[i + 2] * (1 / 255), a = nimg[i + 3] * (1 / 255);\n        //var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n        m[0] += r;\n        m[1] += g;\n        m[2] += b;\n        m[3] += a;\n        R[0] += r * r;\n        R[1] += r * g;\n        R[2] += r * b;\n        R[3] += r * a;\n        R[5] += g * g;\n        R[6] += g * b;\n        R[7] += g * a;\n        R[10] += b * b;\n        R[11] += b * a;\n        R[15] += a * a;\n    }\n    R[4] = R[1];\n    R[8] = R[2];\n    R[9] = R[6];\n    R[12] = R[3];\n    R[13] = R[7];\n    R[14] = R[11];\n    return {\n        R: R,\n        m: m,\n        N: N\n    };\n};\nUPNG.quantize.estats = function(stats) {\n    var R = stats.R, m = stats.m, N = stats.N;\n    // when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\n    var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = N == 0 ? 0 : 1 / N;\n    var Rj = [\n        R[0] - m0 * m0 * iN,\n        R[1] - m0 * m1 * iN,\n        R[2] - m0 * m2 * iN,\n        R[3] - m0 * m3 * iN,\n        R[4] - m1 * m0 * iN,\n        R[5] - m1 * m1 * iN,\n        R[6] - m1 * m2 * iN,\n        R[7] - m1 * m3 * iN,\n        R[8] - m2 * m0 * iN,\n        R[9] - m2 * m1 * iN,\n        R[10] - m2 * m2 * iN,\n        R[11] - m2 * m3 * iN,\n        R[12] - m3 * m0 * iN,\n        R[13] - m3 * m1 * iN,\n        R[14] - m3 * m2 * iN,\n        R[15] - m3 * m3 * iN\n    ];\n    var A = Rj, M = UPNG.M4;\n    var b = [\n        0.5,\n        0.5,\n        0.5,\n        0.5\n    ], mi = 0, tmi = 0;\n    if (N != 0) for(var i = 0; i < 10; i++){\n        b = M.multVec(A, b);\n        tmi = Math.sqrt(M.dot(b, b));\n        b = M.sml(1 / tmi, b);\n        if (Math.abs(tmi - mi) < 1e-9) break;\n        mi = tmi;\n    }\n    //b = [0,0,1,0];  mi=N;\n    var q = [\n        m0 * iN,\n        m1 * iN,\n        m2 * iN,\n        m3 * iN\n    ];\n    var eMq255 = M.dot(M.sml(255, q), b);\n    return {\n        Cov: Rj,\n        q: q,\n        e: b,\n        L: mi,\n        eMq255: eMq255,\n        eMq: M.dot(b, q),\n        rgba: (Math.round(255 * q[3]) << 24 | Math.round(255 * q[2]) << 16 | Math.round(255 * q[1]) << 8 | Math.round(255 * q[0]) << 0) >>> 0\n    };\n};\nUPNG.M4 = {\n    multVec: function(m, v) {\n        return [\n            m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],\n            m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],\n            m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],\n            m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]\n        ];\n    },\n    dot: function(x, y) {\n        return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];\n    },\n    sml: function(a, y) {\n        return [\n            a * y[0],\n            a * y[1],\n            a * y[2],\n            a * y[3]\n        ];\n    }\n};\nUPNG.encode.concatRGBA = function(bufs) {\n    var tlen = 0;\n    for(var i = 0; i < bufs.length; i++)tlen += bufs[i].byteLength;\n    var nimg = new Uint8Array(tlen), noff = 0;\n    for(var i = 0; i < bufs.length; i++){\n        var img = new Uint8Array(bufs[i]), il = img.length;\n        for(var j = 0; j < il; j += 4){\n            var r = img[j], g = img[j + 1], b = img[j + 2], a = img[j + 3];\n            if (a == 0) r = g = b = 0;\n            nimg[noff + j] = r;\n            nimg[noff + j + 1] = g;\n            nimg[noff + j + 2] = b;\n            nimg[noff + j + 3] = a;\n        }\n        noff += il;\n    }\n    return nimg.buffer;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UPNG);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9VUE5HLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QjtBQUV4QixJQUFJQyxPQUFPLENBQUM7QUFJWkEsS0FBS0MsT0FBTyxHQUFHLFNBQVNDLEdBQUc7SUFFMUIsSUFBSUMsSUFBSUQsSUFBSUUsS0FBSyxFQUFFQyxJQUFJSCxJQUFJSSxNQUFNO0lBQ2pDLElBQUdKLElBQUlLLElBQUksQ0FBQ0MsSUFBSSxJQUFFLE1BQU0sT0FBTztRQUFDUixLQUFLQyxPQUFPLENBQUNRLFdBQVcsQ0FBQ1AsSUFBSVEsSUFBSSxFQUFFUCxHQUFHRSxHQUFHSCxLQUFLUyxNQUFNO0tBQUM7SUFFckYsSUFBSUMsT0FBTyxFQUFFO0lBQ2IsSUFBR1YsSUFBSVcsTUFBTSxDQUFDLEVBQUUsQ0FBQ0gsSUFBSSxJQUFFLE1BQU1SLElBQUlXLE1BQU0sQ0FBQyxFQUFFLENBQUNILElBQUksR0FBR1IsSUFBSVEsSUFBSTtJQUUxRCxJQUFJSSxNQUFNWCxJQUFFRSxJQUFFLEdBQUdVLE1BQU0sSUFBSUMsV0FBV0YsTUFBTUcsUUFBUSxJQUFJRCxXQUFXRixNQUFNSSxPQUFLLElBQUlGLFdBQVdGO0lBQzdGLElBQUksSUFBSUssSUFBRSxHQUFHQSxJQUFFakIsSUFBSVcsTUFBTSxDQUFDTyxNQUFNLEVBQUVELElBQ2xDO1FBQ0MsSUFBSUUsTUFBTW5CLElBQUlXLE1BQU0sQ0FBQ00sRUFBRTtRQUN2QixJQUFJRyxLQUFHRCxJQUFJRSxJQUFJLENBQUNDLENBQUMsRUFBRUMsS0FBR0osSUFBSUUsSUFBSSxDQUFDRyxDQUFDLEVBQUVDLEtBQUtOLElBQUlFLElBQUksQ0FBQ25CLEtBQUssRUFBRXdCLEtBQUtQLElBQUlFLElBQUksQ0FBQ2pCLE1BQU07UUFDM0UsSUFBSXVCLFFBQVE3QixLQUFLQyxPQUFPLENBQUNRLFdBQVcsQ0FBQ1ksSUFBSVgsSUFBSSxFQUFFaUIsSUFBR0MsSUFBSTFCO1FBRXRELElBQUdpQixLQUFHLEdB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QUMsU0FBU2YsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBRSxPQUFNLENBQUNGLENBQUMsQ0FBQ0MsTUFBSSxFQUFFLEdBQUNELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLE9BQU1BLENBQUFBLElBQUUsS0FBRyxDQUFDLEtBQUdDLENBQUFBLElBQUc7SUFBQztJQUMxSkgsRUFBRUEsQ0FBQyxDQUFDYyxDQUFDLEdBQUMsU0FBU2IsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBRSxPQUFNLENBQUNGLENBQUMsQ0FBQ0MsTUFBSSxFQUFFLEdBQUNELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLElBQUVELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLEVBQUMsTUFBTUEsQ0FBQUEsSUFBRSxLQUFHLENBQUMsS0FBR0MsQ0FBQUEsSUFBRztJQUFDO0lBQUVILEVBQUVBLENBQUMsQ0FBQ29CLENBQUMsR0FBQyxTQUFTbkIsQ0FBQyxFQUFDQyxDQUFDO1FBQUUsT0FBTSxDQUFDRCxDQUFDLENBQUNDLE1BQUksRUFBRSxHQUFDRCxDQUFDLENBQUMsQ0FBQ0MsTUFBSSxLQUFHLEVBQUUsSUFBRSxJQUFFRCxDQUFDLENBQUMsQ0FBQ0MsTUFBSSxLQUFHLEVBQUUsSUFBRSxFQUFDLE1BQU1BLENBQUFBLElBQUU7SUFBRTtJQUN2S0YsRUFBRUEsQ0FBQyxDQUFDOUYsQ0FBQyxHQUFDLFNBQVMrRixDQUFDLEVBQUNDLENBQUM7UUFBRSxPQUFNLENBQUNELENBQUMsQ0FBQ0MsTUFBSSxFQUFFLEdBQUNELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLElBQUVELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLEtBQUdELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLEVBQUMsTUFBTUEsQ0FBQUEsSUFBRTtJQUFFO0lBQUVGLEVBQUVBLENBQUMsQ0FBQ0ksQ0FBQyxHQUFDO1FBQVcsSUFB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VVBORy5qcz9iOGFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYWtvIGZyb20gJ3Bha28nO1xuXG52YXIgVVBORyA9IHt9O1xuXG5cdFxuXG5VUE5HLnRvUkdCQTggPSBmdW5jdGlvbihvdXQpXG57XG5cdHZhciB3ID0gb3V0LndpZHRoLCBoID0gb3V0LmhlaWdodDtcblx0aWYob3V0LnRhYnMuYWNUTD09bnVsbCkgcmV0dXJuIFtVUE5HLnRvUkdCQTguZGVjb2RlSW1hZ2Uob3V0LmRhdGEsIHcsIGgsIG91dCkuYnVmZmVyXTtcblx0XG5cdHZhciBmcm1zID0gW107XG5cdGlmKG91dC5mcmFtZXNbMF0uZGF0YT09bnVsbCkgb3V0LmZyYW1lc1swXS5kYXRhID0gb3V0LmRhdGE7XG5cdFxuXHR2YXIgbGVuID0gdypoKjQsIGltZyA9IG5ldyBVaW50OEFycmF5KGxlbiksIGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkobGVuKSwgcHJldj1uZXcgVWludDhBcnJheShsZW4pO1xuXHRmb3IodmFyIGk9MDsgaTxvdXQuZnJhbWVzLmxlbmd0aDsgaSsrKVxuXHR7XG5cdFx0dmFyIGZybSA9IG91dC5mcmFtZXNbaV07XG5cdFx0dmFyIGZ4PWZybS5yZWN0LngsIGZ5PWZybS5yZWN0LnksIGZ3ID0gZnJtLnJlY3Qud2lkdGgsIGZoID0gZnJtLnJlY3QuaGVpZ2h0O1xuXHRcdHZhciBmZGF0YSA9IFVQTkcudG9SR0JBOC5kZWNvZGVJbWFnZShmcm0uZGF0YSwgZncsZmgsIG91dCk7XG5cdFx0XG5cdFx0aWYoaSE9MCkgZm9yKHZhciBqPTA7IGo8bGVuOyBqKyspIHByZXZbal09aW1nW2pdO1xuXHRcdFxuXHRcdGlmICAgICAoZnJtLmJsZW5kPT0wKSBVUE5HLl9jb3B5VGlsZShmZGF0YSwgZncsIGZoLCBpbWcsIHcsIGgsIGZ4LCBmeSwgMCk7XG5cdFx0ZWxzZSBpZihmcm0uYmxlbmQ9PTEpIFVQTkcuX2NvcHlUaWxlKGZkYXRhLCBmdywgZmgsIGltZywgdywgaCwgZngsIGZ5LCAxKTtcblx0XHRcblx0XHRmcm1zLnB1c2goaW1nLmJ1ZmZlci5zbGljZSgwKSk7XG5cdFx0XG5cdFx0aWYgICAgIChmcm0uZGlzcG9zZT09MCkge31cblx0XHRlbHNlIGlmKGZybS5kaXNwb3NlPT0xKSBVUE5HLl9jb3B5VGlsZShlbXB0eSwgZncsIGZoLCBpbWcsIHcsIGgsIGZ4LCBmeSwgMCk7XG5cdFx0ZWxzZSBpZihmcm0uZGlzcG9zZT09MikgZm9yKHZhciBqPTA7IGo8bGVuOyBqKyspIGltZ1tqXT1wcmV2W2pdO1xuXHR9XG5cdHJldHVybiBmcm1zO1xufVxuVVBORy50b1JHQkE4LmRlY29kZUltYWdlID0gZnVuY3Rpb24oZGF0YSwgdywgaCwgb3V0KVxue1xuXHR2YXIgYXJlYSA9IHcqaCwgYnBwID0gVVBORy5kZWNvZGUuX2dldEJQUChvdXQpO1xuXHR2YXIgYnBsID0gTWF0aC5jZWlsKHcqYnBwLzgpO1x0Ly8gYnl0ZXMgcGVyIGxpbmVcblxuXHR2YXIgYmYgPSBuZXcgVWludDhBcnJheShhcmVhKjQpLCBiZjMyID0gbmV3IFVpbnQzMkFycmF5KGJmLmJ1ZmZlcik7XG5cdHZhciBjdHlwZSA9IG91dC5jdHlwZSwgZGVwdGggPSBvdXQuZGVwdGg7XG5cdHZhciBycyA9IFVQTkcuX2Jpbi5yZWFkVXNob3J0O1xuXHRcblx0Ly9jb25zb2xlLmxvZyhjdHlwZSwgZGVwdGgpO1xuXHR2YXIgdGltZSA9IERhdGUubm93KCk7XG5cblx0aWYgICAgIChjdHlwZT09NikgeyAvLyBSR0IgKyBhbHBoYVxuXHRcdHZhciBxYXJlYSA9IGFyZWE8PDI7XG5cdFx0aWYoZGVwdGg9PSA4KSBmb3IodmFyIGk9MDsgaTxxYXJlYTtpKz00KSB7ICBiZltpXSA9IGRhdGFbaV07ICBiZltpKzFdID0gZGF0YVtpKzFdOyAgYmZbaSsyXSA9IGRhdGFbaSsyXTsgIGJmW2krM10gPSBkYXRhW2krM107IH1cblx0XHRpZihkZXB0aD09MTYpIGZvcih2YXIgaT0wOyBpPHFhcmVhO2krKyApIHsgIGJmW2ldID0gZGF0YVtpPDwxXTsgIH1cblx0fVxuXHRlbHNlIGlmKGN0eXBlPT0yKSB7XHQvLyBSR0Jcblx0XHR2YXIgdHM9b3V0LnRhYnNbXCJ0Uk5TXCJdO1xuXHRcdGlmKHRzPT1udWxsKSB7XG5cdFx0XHRpZihkZXB0aD09IDgpIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHRpPWkqMzsgIGJmMzJbaV0gPSAoMjU1PDwyNCl8KGRhdGFbdGkrMl08PDE2KXwoZGF0YVt0aSsxXTw8OCl8ZGF0YVt0aV07ICB9XG5cdFx0XHRpZihkZXB0aD09MTYpIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHRpPWkqNjsgIGJmMzJbaV0gPSAoMjU1PDwyNCl8KGRhdGFbdGkrNF08PDE2KXwoZGF0YVt0aSsyXTw8OCl8ZGF0YVt0aV07ICB9XG5cdFx0fVxuXHRcdGVsc2UgeyAgdmFyIHRyPXRzWzBdLCB0Zz10c1sxXSwgdGI9dHNbMl07XG5cdFx0XHRpZihkZXB0aD09IDgpIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIHRpPWkqMzsgIGJmMzJbaV0gPSAoMjU1PDwyNCl8KGRhdGFbdGkrMl08PDE2KXwoZGF0YVt0aSsxXTw8OCl8ZGF0YVt0aV07XG5cdFx0XHRcdGlmKGRhdGFbdGldICAgPT10ciAmJiBkYXRhW3RpKzFdICAgPT10ZyAmJiBkYXRhW3RpKzJdICAgPT10YikgYmZbcWkrM10gPSAwOyAgfVxuXHRcdFx0aWYoZGVwdGg9PTE2KSBmb3IodmFyIGk9MDsgaTxhcmVhOyBpKyspIHsgIHZhciBxaT1pPDwyLCB0aT1pKjY7ICBiZjMyW2ldID0gKDI1NTw8MjQpfChkYXRhW3RpKzRdPDwxNil8KGRhdGFbdGkrMl08PDgpfGRhdGFbdGldO1xuXHRcdFx0XHRpZihycyhkYXRhLHRpKT09dHIgJiYgcnMoZGF0YSx0aSsyKT09dGcgJiYgcnMoZGF0YSx0aSs0KT09dGIpIGJmW3FpKzNdID0gMDsgIH1cblx0XHR9XG5cdH1cblx0ZWxzZSBpZihjdHlwZT09Mykge1x0Ly8gcGFsZXR0ZVxuXHRcdHZhciBwPW91dC50YWJzW1wiUExURVwiXSwgYXA9b3V0LnRhYnNbXCJ0Uk5TXCJdLCB0bD1hcD9hcC5sZW5ndGg6MDtcblx0XHQvL2NvbnNvbGUubG9nKHAsIGFwKTtcblx0XHRpZihkZXB0aD09MSkgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSB7ICB2YXIgczAgPSB5KmJwbCwgdDAgPSB5Knc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgdmFyIHFpPSh0MCtpKTw8Miwgaj0oKGRhdGFbczArKGk+PjMpXT4+KDctKChpJjcpPDwwKSkpJiAxKSwgY2o9MypqOyAgYmZbcWldPXBbY2pdOyAgYmZbcWkrMV09cFtjaisxXTsgIGJmW3FpKzJdPXBbY2orMl07ICBiZltxaSszXT0oajx0bCk/YXBbal06MjU1OyAgfVxuXHRcdH1cblx0XHRpZihkZXB0aD09MikgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSB7ICB2YXIgczAgPSB5KmJwbCwgdDAgPSB5Knc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgdmFyIHFpPSh0MCtpKTw8Miwgaj0oKGRhdGFbczArKGk+PjIpXT4+KDYtKChpJjMpPDwxKSkpJiAzKSwgY2o9MypqOyAgYmZbcWldPXBbY2pdOyAgYmZbcWkrMV09cFtjaisxXTsgIGJmW3FpKzJdPXBbY2orMl07ICBiZltxaSszXT0oajx0bCk/YXBbal06MjU1OyAgfVxuXHRcdH1cblx0XHRpZihkZXB0aD09NCkgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSB7ICB2YXIgczAgPSB5KmJwbCwgdDAgPSB5Knc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgdmFyIHFpPSh0MCtpKTw8Miwgaj0oKGRhdGFbczArKGk+PjEpXT4+KDQtKChpJjEpPDwyKSkpJjE1KSwgY2o9MypqOyAgYmZbcWldPXBbY2pdOyAgYmZbcWkrMV09cFtjaisxXTsgIGJmW3FpKzJdPXBbY2orMl07ICBiZltxaSszXT0oajx0bCk/YXBbal06MjU1OyAgfVxuXHRcdH1cblx0XHRpZihkZXB0aD09OCkgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrICkgeyAgdmFyIHFpPWk8PDIsIGo9ZGF0YVtpXSAgICAgICAgICAgICAgICAgICAgICAsIGNqPTMqajsgIGJmW3FpXT1wW2NqXTsgIGJmW3FpKzFdPXBbY2orMV07ICBiZltxaSsyXT1wW2NqKzJdOyAgYmZbcWkrM109KGo8dGwpP2FwW2pdOjI1NTsgIH1cblx0fVxuXHRlbHNlIGlmKGN0eXBlPT00KSB7XHQvLyBncmF5ICsgYWxwaGFcblx0XHRpZihkZXB0aD09IDgpICBmb3IodmFyIGk9MDsgaTxhcmVhOyBpKyspIHsgIHZhciBxaT1pPDwyLCBkaT1pPDwxLCBncj1kYXRhW2RpXTsgIGJmW3FpXT1ncjsgIGJmW3FpKzFdPWdyOyAgYmZbcWkrMl09Z3I7ICBiZltxaSszXT1kYXRhW2RpKzFdOyAgfVxuXHRcdGlmKGRlcHRoPT0xNikgIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIGRpPWk8PDIsIGdyPWRhdGFbZGldOyAgYmZbcWldPWdyOyAgYmZbcWkrMV09Z3I7ICBiZltxaSsyXT1ncjsgIGJmW3FpKzNdPWRhdGFbZGkrMl07ICB9XG5cdH1cblx0ZWxzZSBpZihjdHlwZT09MCkge1x0Ly8gZ3JheVxuXHRcdHZhciB0ciA9IG91dC50YWJzW1widFJOU1wiXSA/IG91dC50YWJzW1widFJOU1wiXSA6IC0xO1xuXHRcdGZvcih2YXIgeT0wOyB5PGg7IHkrKykge1xuXHRcdFx0dmFyIG9mZiA9IHkqYnBsLCB0byA9IHkqdztcblx0XHRcdGlmICAgICAoZGVwdGg9PSAxKSBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHsgIHZhciBncj0yNTUqKChkYXRhW29mZisoeD4+PjMpXT4+Pig3IC0oKHgmNykgICApKSkmIDEpLCBhbD0oZ3I9PXRyKjI1NSk/MDoyNTU7ICBiZjMyW3RvK3hdPShhbDw8MjQpfChncjw8MTYpfChncjw8OCl8Z3I7ICB9XG5cdFx0XHRlbHNlIGlmKGRlcHRoPT0gMikgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7ICB2YXIgZ3I9IDg1KigoZGF0YVtvZmYrKHg+Pj4yKV0+Pj4oNiAtKCh4JjMpPDwxKSkpJiAzKSwgYWw9KGdyPT10ciogODUpPzA6MjU1OyAgYmYzMlt0byt4XT0oYWw8PDI0KXwoZ3I8PDE2KXwoZ3I8PDgpfGdyOyAgfVxuXHRcdFx0ZWxzZSBpZihkZXB0aD09IDQpIGZvcih2YXIgeD0wOyB4PHc7IHgrKykgeyAgdmFyIGdyPSAxNyooKGRhdGFbb2ZmKyh4Pj4+MSldPj4+KDQgLSgoeCYxKTw8MikpKSYxNSksIGFsPShncj09dHIqIDE3KT8wOjI1NTsgIGJmMzJbdG8reF09KGFsPDwyNCl8KGdyPDwxNil8KGdyPDw4KXxncjsgIH1cblx0XHRcdGVsc2UgaWYoZGVwdGg9PSA4KSBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHsgIHZhciBncj1kYXRhW29mZisgICAgIHhdLCBhbD0oZ3IgICAgICAgICAgICAgICAgID09dHIpPzA6MjU1OyAgYmYzMlt0byt4XT0oYWw8PDI0KXwoZ3I8PDE2KXwoZ3I8PDgpfGdyOyAgfVxuXHRcdFx0ZWxzZSBpZihkZXB0aD09MTYpIGZvcih2YXIgeD0wOyB4PHc7IHgrKykgeyAgdmFyIGdyPWRhdGFbb2ZmKyh4PDwxKV0sIGFsPShycyhkYXRhLG9mZisoeDw8aSkpPT10cik/MDoyNTU7ICBiZjMyW3RvK3hdPShhbDw8MjQpfChncjw8MTYpfChncjw8OCl8Z3I7ICB9XG5cdFx0fVxuXHR9XG5cdC8vY29uc29sZS5sb2coRGF0ZS5ub3coKS10aW1lKTtcblx0cmV0dXJuIGJmO1xufVxuXG5cblxuVVBORy5kZWNvZGUgPSBmdW5jdGlvbihidWZmKVxue1xuXHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpLCBvZmZzZXQgPSA4LCBiaW4gPSBVUE5HLl9iaW4sIHJVcyA9IGJpbi5yZWFkVXNob3J0LCByVWkgPSBiaW4ucmVhZFVpbnQ7XG5cdHZhciBvdXQgPSB7dGFiczp7fSwgZnJhbWVzOltdfTtcblx0dmFyIGRkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpLCBkb2ZmID0gMDtcdCAvLyBwdXQgYWxsIElEQVQgZGF0YSBpbnRvIGl0XG5cdHZhciBmZCwgZm9mZiA9IDA7XHQvLyBmcmFtZXNcblx0XG5cdHZhciBtZ2NrID0gWzB4ODksIDB4NTAsIDB4NGUsIDB4NDcsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdO1xuXHRmb3IodmFyIGk9MDsgaTw4OyBpKyspIGlmKGRhdGFbaV0hPW1nY2tbaV0pIHRocm93IFwiVGhlIGlucHV0IGlzIG5vdCBhIFBORyBmaWxlIVwiO1xuXG5cdHdoaWxlKG9mZnNldDxkYXRhLmxlbmd0aClcblx0e1xuXHRcdHZhciBsZW4gID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0XHR2YXIgdHlwZSA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0LCA0KTsgIG9mZnNldCArPSA0O1xuXHRcdC8vY29uc29sZS5sb2codHlwZSxsZW4pO1xuXHRcdFxuXHRcdGlmICAgICAodHlwZT09XCJJSERSXCIpICB7ICBVUE5HLmRlY29kZS5fSUhEUihkYXRhLCBvZmZzZXQsIG91dCk7ICB9XG5cdFx0ZWxzZSBpZih0eXBlPT1cIklEQVRcIikge1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGVuOyBpKyspIGRkW2RvZmYraV0gPSBkYXRhW29mZnNldCtpXTtcblx0XHRcdGRvZmYgKz0gbGVuO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiYWNUTFwiKSAge1xuXHRcdFx0b3V0LnRhYnNbdHlwZV0gPSB7ICBudW1fZnJhbWVzOnJVaShkYXRhLCBvZmZzZXQpLCBudW1fcGxheXM6clVpKGRhdGEsIG9mZnNldCs0KSAgfTtcblx0XHRcdGZkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiZmNUTFwiKSAge1xuXHRcdFx0aWYoZm9mZiE9MCkgeyAgdmFyIGZyID0gb3V0LmZyYW1lc1tvdXQuZnJhbWVzLmxlbmd0aC0xXTtcblx0XHRcdFx0ZnIuZGF0YSA9IFVQTkcuZGVjb2RlLl9kZWNvbXByZXNzKG91dCwgZmQuc2xpY2UoMCxmb2ZmKSwgZnIucmVjdC53aWR0aCwgZnIucmVjdC5oZWlnaHQpOyAgZm9mZj0wO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJjdCA9IHt4OnJVaShkYXRhLCBvZmZzZXQrMTIpLHk6clVpKGRhdGEsIG9mZnNldCsxNiksd2lkdGg6clVpKGRhdGEsIG9mZnNldCs0KSxoZWlnaHQ6clVpKGRhdGEsIG9mZnNldCs4KX07XG5cdFx0XHR2YXIgZGVsID0gclVzKGRhdGEsIG9mZnNldCsyMik7ICBkZWwgPSByVXMoZGF0YSwgb2Zmc2V0KzIwKSAvIChkZWw9PTA/MTAwOmRlbCk7XG5cdFx0XHR2YXIgZnJtID0ge3JlY3Q6cmN0LCBkZWxheTpNYXRoLnJvdW5kKGRlbCoxMDAwKSwgZGlzcG9zZTpkYXRhW29mZnNldCsyNF0sIGJsZW5kOmRhdGFbb2Zmc2V0KzI1XX07XG5cdFx0XHQvL2NvbnNvbGUubG9nKGZybSk7XG5cdFx0XHRvdXQuZnJhbWVzLnB1c2goZnJtKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cImZkQVRcIikge1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGVuLTQ7IGkrKykgZmRbZm9mZitpXSA9IGRhdGFbb2Zmc2V0K2krNF07XG5cdFx0XHRmb2ZmICs9IGxlbi00O1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwicEhZc1wiKSB7XG5cdFx0XHRvdXQudGFic1t0eXBlXSA9IFtiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KSwgYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCs0KSwgZGF0YVtvZmZzZXQrOF1dO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiY0hSTVwiKSB7XG5cdFx0XHRvdXQudGFic1t0eXBlXSA9IFtdO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8ODsgaSsrKSBvdXQudGFic1t0eXBlXS5wdXNoKGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQraSo0KSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJ0RVh0XCIpIHtcblx0XHRcdGlmKG91dC50YWJzW3R5cGVdPT1udWxsKSBvdXQudGFic1t0eXBlXSA9IHt9O1xuXHRcdFx0dmFyIG56ID0gYmluLm5leHRaZXJvKGRhdGEsIG9mZnNldCk7XG5cdFx0XHR2YXIga2V5dyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0LCBuei1vZmZzZXQpO1xuXHRcdFx0dmFyIHRleHQgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG56KzEsIG9mZnNldCtsZW4tbnotMSk7XG5cdFx0XHRvdXQudGFic1t0eXBlXVtrZXl3XSA9IHRleHQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJpVFh0XCIpIHtcblx0XHRcdGlmKG91dC50YWJzW3R5cGVdPT1udWxsKSBvdXQudGFic1t0eXBlXSA9IHt9O1xuXHRcdFx0dmFyIG56ID0gMCwgb2ZmID0gb2Zmc2V0O1xuXHRcdFx0bnogPSBiaW4ubmV4dFplcm8oZGF0YSwgb2ZmKTtcblx0XHRcdHZhciBrZXl3ID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmYsIG56LW9mZik7ICBvZmYgPSBueiArIDE7XG5cdFx0XHR2YXIgY2ZsYWcgPSBkYXRhW29mZl0sIGNtZXRoID0gZGF0YVtvZmYrMV07ICBvZmYrPTI7XG5cdFx0XHRueiA9IGJpbi5uZXh0WmVybyhkYXRhLCBvZmYpO1xuXHRcdFx0dmFyIGx0YWcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZiwgbnotb2ZmKTsgIG9mZiA9IG56ICsgMTtcblx0XHRcdG56ID0gYmluLm5leHRaZXJvKGRhdGEsIG9mZik7XG5cdFx0XHR2YXIgdGtleXcgPSBiaW4ucmVhZFVURjgoZGF0YSwgb2ZmLCBuei1vZmYpOyAgb2ZmID0gbnogKyAxO1xuXHRcdFx0dmFyIHRleHQgID0gYmluLnJlYWRVVEY4KGRhdGEsIG9mZiwgbGVuLShvZmYtb2Zmc2V0KSk7XG5cdFx0XHRvdXQudGFic1t0eXBlXVtrZXl3XSA9IHRleHQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJQTFRFXCIpIHtcblx0XHRcdG91dC50YWJzW3R5cGVdID0gYmluLnJlYWRCeXRlcyhkYXRhLCBvZmZzZXQsIGxlbik7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJoSVNUXCIpIHtcblx0XHRcdHZhciBwbCA9IG91dC50YWJzW1wiUExURVwiXS5sZW5ndGgvMztcblx0XHRcdG91dC50YWJzW3R5cGVdID0gW107ICBmb3IodmFyIGk9MDsgaTxwbDsgaSsrKSBvdXQudGFic1t0eXBlXS5wdXNoKHJVcyhkYXRhLCBvZmZzZXQraSoyKSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJ0Uk5TXCIpIHtcblx0XHRcdGlmICAgICAob3V0LmN0eXBlPT0zKSBvdXQudGFic1t0eXBlXSA9IGJpbi5yZWFkQnl0ZXMoZGF0YSwgb2Zmc2V0LCBsZW4pO1xuXHRcdFx0ZWxzZSBpZihvdXQuY3R5cGU9PTApIG91dC50YWJzW3R5cGVdID0gclVzKGRhdGEsIG9mZnNldCk7XG5cdFx0XHRlbHNlIGlmKG91dC5jdHlwZT09Mikgb3V0LnRhYnNbdHlwZV0gPSBbIHJVcyhkYXRhLG9mZnNldCksclVzKGRhdGEsb2Zmc2V0KzIpLHJVcyhkYXRhLG9mZnNldCs0KSBdO1xuXHRcdFx0Ly9lbHNlIGNvbnNvbGUubG9nKFwidFJOUyBmb3IgdW5zdXBwb3J0ZWQgY29sb3IgdHlwZVwiLG91dC5jdHlwZSwgbGVuKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cImdBTUFcIikgb3V0LnRhYnNbdHlwZV0gPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KS8xMDAwMDA7XG5cdFx0ZWxzZSBpZih0eXBlPT1cInNSR0JcIikgb3V0LnRhYnNbdHlwZV0gPSBkYXRhW29mZnNldF07XG5cdFx0ZWxzZSBpZih0eXBlPT1cImJLR0RcIilcblx0XHR7XG5cdFx0XHRpZiAgICAgKG91dC5jdHlwZT09MCB8fCBvdXQuY3R5cGU9PTQpIG91dC50YWJzW3R5cGVdID0gW3JVcyhkYXRhLCBvZmZzZXQpXTtcblx0XHRcdGVsc2UgaWYob3V0LmN0eXBlPT0yIHx8IG91dC5jdHlwZT09Nikgb3V0LnRhYnNbdHlwZV0gPSBbclVzKGRhdGEsIG9mZnNldCksIHJVcyhkYXRhLCBvZmZzZXQrMiksIHJVcyhkYXRhLCBvZmZzZXQrNCldO1xuXHRcdFx0ZWxzZSBpZihvdXQuY3R5cGU9PTMpIG91dC50YWJzW3R5cGVdID0gZGF0YVtvZmZzZXRdO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiSUVORFwiKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Ly9lbHNlIHsgIGxvZyhcInVua25vd24gY2h1bmsgdHlwZVwiLCB0eXBlLCBsZW4pOyAgfVxuXHRcdG9mZnNldCArPSBsZW47XG5cdFx0dmFyIGNyYyA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG5cdH1cblx0aWYoZm9mZiE9MCkgeyAgdmFyIGZyID0gb3V0LmZyYW1lc1tvdXQuZnJhbWVzLmxlbmd0aC0xXTtcblx0XHRmci5kYXRhID0gVVBORy5kZWNvZGUuX2RlY29tcHJlc3Mob3V0LCBmZC5zbGljZSgwLGZvZmYpLCBmci5yZWN0LndpZHRoLCBmci5yZWN0LmhlaWdodCk7ICBmb2ZmPTA7XG5cdH1cdFxuXHRvdXQuZGF0YSA9IFVQTkcuZGVjb2RlLl9kZWNvbXByZXNzKG91dCwgZGQsIG91dC53aWR0aCwgb3V0LmhlaWdodCk7XG5cdFxuXHRkZWxldGUgb3V0LmNvbXByZXNzOyAgZGVsZXRlIG91dC5pbnRlcmxhY2U7ICBkZWxldGUgb3V0LmZpbHRlcjtcblx0cmV0dXJuIG91dDtcbn1cblxuVVBORy5kZWNvZGUuX2RlY29tcHJlc3MgPSBmdW5jdGlvbihvdXQsIGRkLCB3LCBoKSB7XG5cdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0dmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSwgYnBsID0gTWF0aC5jZWlsKHcqYnBwLzgpLCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoKGJwbCsxK291dC5pbnRlcmxhY2UpKmgpO1xuXHRkZCA9IFVQTkcuZGVjb2RlLl9pbmZsYXRlKGRkLGJ1ZmYpO1xuXHQvL2NvbnNvbGUubG9nKGRkLmxlbmd0aCwgYnVmZi5sZW5ndGgpO1xuXHQvL2NvbnNvbGUubG9nKERhdGUubm93KCktdGltZSk7XG5cblx0dmFyIHRpbWU9RGF0ZS5ub3coKTtcblx0aWYgICAgIChvdXQuaW50ZXJsYWNlPT0wKSBkZCA9IFVQTkcuZGVjb2RlLl9maWx0ZXJaZXJvKGRkLCBvdXQsIDAsIHcsIGgpO1xuXHRlbHNlIGlmKG91dC5pbnRlcmxhY2U9PTEpIGRkID0gVVBORy5kZWNvZGUuX3JlYWRJbnRlcmxhY2UoZGQsIG91dCk7XG5cdC8vY29uc29sZS5sb2coRGF0ZS5ub3coKS10aW1lKTtcblx0cmV0dXJuIGRkO1xufVxuXG5VUE5HLmRlY29kZS5faW5mbGF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGJ1ZmYpIHsgIHZhciBvdXQ9VVBOR1tcImluZmxhdGVSYXdcIl0obmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIDIsZGF0YS5sZW5ndGgtNiksYnVmZik7ICByZXR1cm4gb3V0OyAgfVxuVVBORy5pbmZsYXRlUmF3PWZ1bmN0aW9uKCl7dmFyIEg9e307SC5IPXt9O0guSC5OPWZ1bmN0aW9uKE4sVyl7dmFyIFI9VWludDhBcnJheSxpPTAsbT0wLEo9MCxoPTAsUT0wLFg9MCx1PTAsdz0wLGQ9MCx2LEM7XG5pZihOWzBdPT0zJiZOWzFdPT0wKXJldHVybiBXP1c6bmV3IFIoMCk7dmFyIFY9SC5ILG49Vi5iLEE9Vi5lLGw9Vi5SLE09Vi5uLEk9Vi5BLGU9Vi5aLGI9Vi5tLFo9Vz09bnVsbDtcbmlmKFopVz1uZXcgUihOLmxlbmd0aD4+PjI8PDMpO3doaWxlKGk9PTApe2k9bihOLGQsMSk7bT1uKE4sZCsxLDIpO2QrPTM7aWYobT09MCl7aWYoKGQmNykhPTApZCs9OC0oZCY3KTtcbnZhciBEPShkPj4+MykrNCxxPU5bRC00XXxOW0QtM108PDg7aWYoWilXPUguSC5XKFcsdytxKTtXLnNldChuZXcgUihOLmJ1ZmZlcixOLmJ5dGVPZmZzZXQrRCxxKSx3KTtkPUQrcTw8MztcbncrPXE7Y29udGludWV9aWYoWilXPUguSC5XKFcsdysoMTw8MTcpKTtpZihtPT0xKXt2PWIuSjtDPWIuaDtYPSgxPDw5KS0xO3U9KDE8PDUpLTF9aWYobT09Mil7Sj1BKE4sZCw1KSsyNTc7XG5oPUEoTixkKzUsNSkrMTtRPUEoTixkKzEwLDQpKzQ7ZCs9MTQ7dmFyIEU9ZCxqPTE7Zm9yKHZhciBjPTA7YzwzODtjKz0yKXtiLlFbY109MDtiLlFbYysxXT0wfWZvcih2YXIgYz0wO1xuYzxRO2MrKyl7dmFyIEs9QShOLGQrYyozLDMpO2IuUVsoYi5YW2NdPDwxKSsxXT1LO2lmKEs+ailqPUt9ZCs9MypRO00oYi5RLGopO0koYi5RLGosYi51KTt2PWIudztDPWIuZDtcbmQ9bChiLnUsKDE8PGopLTEsSitoLE4sZCxiLnYpO3ZhciByPVYuVihiLnYsMCxKLGIuQyk7WD0oMTw8ciktMTt2YXIgUz1WLlYoYi52LEosaCxiLkQpO3U9KDE8PFMpLTE7TShiLkMscik7XG5JKGIuQyxyLHYpO00oYi5ELFMpO0koYi5ELFMsQyl9d2hpbGUoITApe3ZhciBUPXZbZShOLGQpJlhdO2QrPVQmMTU7dmFyIHA9VD4+PjQ7aWYocD4+Pjg9PTApe1dbdysrXT1wfWVsc2UgaWYocD09MjU2KXticmVha31lbHNle3ZhciB6PXcrcC0yNTQ7XG5pZihwPjI2NCl7dmFyIF89Yi5xW3AtMjU3XTt6PXcrKF8+Pj4zKStBKE4sZCxfJjcpO2QrPV8mN312YXIgJD1DW2UoTixkKSZ1XTtkKz0kJjE1O3ZhciBzPSQ+Pj40LFk9Yi5jW3NdLGE9KFk+Pj40KStuKE4sZCxZJjE1KTtcbmQrPVkmMTU7d2hpbGUodzx6KXtXW3ddPVdbdysrLWFdO1dbd109V1t3KystYV07V1t3XT1XW3crKy1hXTtXW3ddPVdbdysrLWFdfXc9en19fXJldHVybiBXLmxlbmd0aD09dz9XOlcuc2xpY2UoMCx3KX07XG5ILkguVz1mdW5jdGlvbihOLFcpe3ZhciBSPU4ubGVuZ3RoO2lmKFc8PVIpcmV0dXJuIE47dmFyIFY9bmV3IFVpbnQ4QXJyYXkoUjw8MSk7Vi5zZXQoTiwwKTtyZXR1cm4gVn07XG5ILkguUj1mdW5jdGlvbihOLFcsUixWLG4sQSl7dmFyIGw9SC5ILmUsTT1ILkguWixJPTA7d2hpbGUoSTxSKXt2YXIgZT1OW00oVixuKSZXXTtuKz1lJjE1O3ZhciBiPWU+Pj40O1xuaWYoYjw9MTUpe0FbSV09YjtJKyt9ZWxzZXt2YXIgWj0wLG09MDtpZihiPT0xNil7bT0zK2woVixuLDIpO24rPTI7Wj1BW0ktMV19ZWxzZSBpZihiPT0xNyl7bT0zK2woVixuLDMpO1xubis9M31lbHNlIGlmKGI9PTE4KXttPTExK2woVixuLDcpO24rPTd9dmFyIEo9SSttO3doaWxlKEk8Sil7QVtJXT1aO0krK319fXJldHVybiBufTtILkguVj1mdW5jdGlvbihOLFcsUixWKXt2YXIgbj0wLEE9MCxsPVYubGVuZ3RoPj4+MTtcbndoaWxlKEE8Uil7dmFyIE09TltBK1ddO1ZbQTw8MV09MDtWWyhBPDwxKSsxXT1NO2lmKE0+biluPU07QSsrfXdoaWxlKEE8bCl7VltBPDwxXT0wO1ZbKEE8PDEpKzFdPTA7QSsrfXJldHVybiBufTtcbkguSC5uPWZ1bmN0aW9uKE4sVyl7dmFyIFI9SC5ILm0sVj1OLmxlbmd0aCxuLEEsbCxNLEksZT1SLmo7Zm9yKHZhciBNPTA7TTw9VztNKyspZVtNXT0wO2ZvcihNPTE7TTxWO00rPTIpZVtOW01dXSsrO1xudmFyIGI9Ui5LO249MDtlWzBdPTA7Zm9yKEE9MTtBPD1XO0ErKyl7bj1uK2VbQS0xXTw8MTtiW0FdPW59Zm9yKGw9MDtsPFY7bCs9Mil7ST1OW2wrMV07aWYoSSE9MCl7TltsXT1iW0ldO1xuYltJXSsrfX19O0guSC5BPWZ1bmN0aW9uKE4sVyxSKXt2YXIgVj1OLmxlbmd0aCxuPUguSC5tLEE9bi5yO2Zvcih2YXIgbD0wO2w8VjtsKz0yKWlmKE5bbCsxXSE9MCl7dmFyIE09bD4+MSxJPU5bbCsxXSxlPU08PDR8SSxiPVctSSxaPU5bbF08PGIsbT1aKygxPDxiKTtcbndoaWxlKFohPW0pe3ZhciBKPUFbWl0+Pj4xNS1XO1JbSl09ZTtaKyt9fX07SC5ILmw9ZnVuY3Rpb24oTixXKXt2YXIgUj1ILkgubS5yLFY9MTUtVztmb3IodmFyIG49MDtuPE4ubGVuZ3RoO1xubis9Mil7dmFyIEE9TltuXTw8Vy1OW24rMV07TltuXT1SW0FdPj4+Vn19O0guSC5NPWZ1bmN0aW9uKE4sVyxSKXtSPVI8PChXJjcpO3ZhciBWPVc+Pj4zO05bVl18PVI7TltWKzFdfD1SPj4+OH07XG5ILkguST1mdW5jdGlvbihOLFcsUil7Uj1SPDwoVyY3KTt2YXIgVj1XPj4+MztOW1ZdfD1SO05bVisxXXw9Uj4+Pjg7TltWKzJdfD1SPj4+MTZ9O0guSC5lPWZ1bmN0aW9uKE4sVyxSKXtyZXR1cm4oTltXPj4+M118TlsoVz4+PjMpKzFdPDw4KT4+PihXJjcpJigxPDxSKS0xfTtcbkguSC5iPWZ1bmN0aW9uKE4sVyxSKXtyZXR1cm4oTltXPj4+M118TlsoVz4+PjMpKzFdPDw4fE5bKFc+Pj4zKSsyXTw8MTYpPj4+KFcmNykmKDE8PFIpLTF9O0guSC5aPWZ1bmN0aW9uKE4sVyl7cmV0dXJuKE5bVz4+PjNdfE5bKFc+Pj4zKSsxXTw8OHxOWyhXPj4+MykrMl08PDE2KT4+PihXJjcpfTtcbkguSC5pPWZ1bmN0aW9uKE4sVyl7cmV0dXJuKE5bVz4+PjNdfE5bKFc+Pj4zKSsxXTw8OHxOWyhXPj4+MykrMl08PDE2fE5bKFc+Pj4zKSszXTw8MjQpPj4+KFcmNyl9O0guSC5tPWZ1bmN0aW9uKCl7dmFyIE49VWludDE2QXJyYXksVz1VaW50MzJBcnJheTtcbnJldHVybntLOm5ldyBOKDE2KSxqOm5ldyBOKDE2KSxYOlsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSxTOlszLDQsNSw2LDcsOCw5LDEwLDExLDEzLDE1LDE3LDE5LDIzLDI3LDMxLDM1LDQzLDUxLDU5LDY3LDgzLDk5LDExNSwxMzEsMTYzLDE5NSwyMjcsMjU4LDk5OSw5OTksOTk5XSxUOlswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdLHE6bmV3IE4oMzIpLHA6WzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3Nyw2NTUzNSw2NTUzNV0sejpbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdLGM6bmV3IFcoMzIpLEo6bmV3IE4oNTEyKSxfOltdLGg6bmV3IE4oMzIpLCQ6W10sdzpuZXcgTigzMjc2OCksQzpbXSx2OltdLGQ6bmV3IE4oMzI3NjgpLEQ6W10sdTpuZXcgTig1MTIpLFE6W10scjpuZXcgTigxPDwxNSksczpuZXcgVygyODYpLFk6bmV3IFcoMzApLGE6bmV3IFcoMTkpLHQ6bmV3IFcoMTVlMyksazpuZXcgTigxPDwxNiksZzpuZXcgTigxPDwxNSl9fSgpO1xuKGZ1bmN0aW9uKCl7dmFyIE49SC5ILm0sVz0xPDwxNTtmb3IodmFyIFI9MDtSPFc7UisrKXt2YXIgVj1SO1Y9KFYmMjg2MzMxMTUzMCk+Pj4xfChWJjE0MzE2NTU3NjUpPDwxO1xuVj0oViYzNDM1OTczODM2KT4+PjJ8KFYmODU4OTkzNDU5KTw8MjtWPShWJjQwNDIzMjIxNjApPj4+NHwoViYyNTI2NDUxMzUpPDw0O1Y9KFYmNDI3ODI1NTM2MCk+Pj44fChWJjE2NzExOTM1KTw8ODtcbk4ucltSXT0oVj4+PjE2fFY8PDE2KT4+PjE3fWZ1bmN0aW9uIG4oQSxsLE0pe3doaWxlKGwtLSE9MClBLnB1c2goMCxNKX1mb3IodmFyIFI9MDtSPDMyO1IrKyl7Ti5xW1JdPU4uU1tSXTw8M3xOLlRbUl07XG5OLmNbUl09Ti5wW1JdPDw0fE4ueltSXX1uKE4uXywxNDQsOCk7bihOLl8sMjU1LTE0Myw5KTtuKE4uXywyNzktMjU1LDcpO24oTi5fLDI4Ny0yNzksOCk7SC5ILm4oTi5fLDkpO1xuSC5ILkEoTi5fLDksTi5KKTtILkgubChOLl8sOSk7bihOLiQsMzIsNSk7SC5ILm4oTi4kLDUpO0guSC5BKE4uJCw1LE4uaCk7SC5ILmwoTi4kLDUpO24oTi5RLDE5LDApO24oTi5DLDI4NiwwKTtcbm4oTi5ELDMwLDApO24oTi52LDMyMCwwKX0oKSk7cmV0dXJuIEguSC5OfSgpXG5cblxuVVBORy5kZWNvZGUuX3JlYWRJbnRlcmxhY2UgPSBmdW5jdGlvbihkYXRhLCBvdXQpXG57XG5cdHZhciB3ID0gb3V0LndpZHRoLCBoID0gb3V0LmhlaWdodDtcblx0dmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSwgY2JwcCA9IGJwcD4+MywgYnBsID0gTWF0aC5jZWlsKHcqYnBwLzgpO1xuXHR2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkoIGggKiBicGwgKTtcblx0dmFyIGRpID0gMDtcblxuXHR2YXIgc3RhcnRpbmdfcm93ICA9IFsgMCwgMCwgNCwgMCwgMiwgMCwgMSBdO1xuXHR2YXIgc3RhcnRpbmdfY29sICA9IFsgMCwgNCwgMCwgMiwgMCwgMSwgMCBdO1xuXHR2YXIgcm93X2luY3JlbWVudCA9IFsgOCwgOCwgOCwgNCwgNCwgMiwgMiBdO1xuXHR2YXIgY29sX2luY3JlbWVudCA9IFsgOCwgOCwgNCwgNCwgMiwgMiwgMSBdO1xuXG5cdHZhciBwYXNzPTA7XG5cdHdoaWxlKHBhc3M8Nylcblx0e1xuXHRcdHZhciByaSA9IHJvd19pbmNyZW1lbnRbcGFzc10sIGNpID0gY29sX2luY3JlbWVudFtwYXNzXTtcblx0XHR2YXIgc3cgPSAwLCBzaCA9IDA7XG5cdFx0dmFyIGNyID0gc3RhcnRpbmdfcm93W3Bhc3NdOyAgd2hpbGUoY3I8aCkgeyAgY3IrPXJpOyAgc2grKzsgIH1cblx0XHR2YXIgY2MgPSBzdGFydGluZ19jb2xbcGFzc107ICB3aGlsZShjYzx3KSB7ICBjYys9Y2k7ICBzdysrOyAgfVxuXHRcdHZhciBicGxsID0gTWF0aC5jZWlsKHN3KmJwcC84KTtcblx0XHRVUE5HLmRlY29kZS5fZmlsdGVyWmVybyhkYXRhLCBvdXQsIGRpLCBzdywgc2gpO1xuXG5cdFx0dmFyIHk9MCwgcm93ID0gc3RhcnRpbmdfcm93W3Bhc3NdO1xuXHRcdHdoaWxlKHJvdzxoKVxuXHRcdHtcblx0XHRcdHZhciBjb2wgPSBzdGFydGluZ19jb2xbcGFzc107XG5cdFx0XHR2YXIgY2RpID0gKGRpK3kqYnBsbCk8PDM7XG5cblx0XHRcdHdoaWxlKGNvbDx3KVxuXHRcdFx0e1xuXHRcdFx0XHRpZihicHA9PTEpIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZGF0YVtjZGk+PjNdOyAgdmFsID0gKHZhbD4+KDctKGNkaSY3KSkpJjE7XG5cdFx0XHRcdFx0aW1nW3JvdypicGwgKyAoY29sPj4zKV0gfD0gKHZhbCA8PCAoNy0oKGNvbCY3KTw8MCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicHA9PTIpIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZGF0YVtjZGk+PjNdOyAgdmFsID0gKHZhbD4+KDYtKGNkaSY3KSkpJjM7XG5cdFx0XHRcdFx0aW1nW3JvdypicGwgKyAoY29sPj4yKV0gfD0gKHZhbCA8PCAoNi0oKGNvbCYzKTw8MSkpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicHA9PTQpIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZGF0YVtjZGk+PjNdOyAgdmFsID0gKHZhbD4+KDQtKGNkaSY3KSkpJjE1O1xuXHRcdFx0XHRcdGltZ1tyb3cqYnBsICsgKGNvbD4+MSldIHw9ICh2YWwgPDwgKDQtKChjb2wmMSk8PDIpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoYnBwPj04KSB7XG5cdFx0XHRcdFx0dmFyIGlpID0gcm93KmJwbCtjb2wqY2JwcDtcblx0XHRcdFx0XHRmb3IodmFyIGo9MDsgajxjYnBwOyBqKyspIGltZ1tpaStqXSA9IGRhdGFbKGNkaT4+Mykral07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2RpKz1icHA7ICBjb2wrPWNpO1xuXHRcdFx0fVxuXHRcdFx0eSsrOyAgcm93ICs9IHJpO1xuXHRcdH1cblx0XHRpZihzdypzaCE9MCkgZGkgKz0gc2ggKiAoMSArIGJwbGwpO1xuXHRcdHBhc3MgPSBwYXNzICsgMTtcblx0fVxuXHRyZXR1cm4gaW1nO1xufVxuXG5VUE5HLmRlY29kZS5fZ2V0QlBQID0gZnVuY3Rpb24ob3V0KSB7XG5cdHZhciBub2MgPSBbMSxudWxsLDMsMSwyLG51bGwsNF1bb3V0LmN0eXBlXTtcblx0cmV0dXJuIG5vYyAqIG91dC5kZXB0aDtcbn1cblxuVVBORy5kZWNvZGUuX2ZpbHRlclplcm8gPSBmdW5jdGlvbihkYXRhLCBvdXQsIG9mZiwgdywgaClcbntcblx0dmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSwgYnBsID0gTWF0aC5jZWlsKHcqYnBwLzgpLCBwYWV0aCA9IFVQTkcuZGVjb2RlLl9wYWV0aDtcblx0YnBwID0gTWF0aC5jZWlsKGJwcC84KTtcblx0XG5cdHZhciBpPTAsIGRpPTEsIHR5cGU9ZGF0YVtvZmZdLCB4PTA7XG5cdFxuXHRpZih0eXBlPjEpIGRhdGFbb2ZmXT1bMCwwLDFdW3R5cGUtMl07ICBcblx0aWYodHlwZT09MykgZm9yKHg9YnBwOyB4PGJwbDsgeCsrKSBkYXRhW3grMV0gPSAoZGF0YVt4KzFdICsgKGRhdGFbeCsxLWJwcF0+Pj4xKSApJjI1NTtcblxuXHRmb3IodmFyIHk9MDsgeTxoOyB5KyspICB7XG5cdFx0aSA9IG9mZit5KmJwbDsgZGkgPSBpK3krMTtcblx0XHR0eXBlID0gZGF0YVtkaS0xXTsgeD0wO1xuXG5cdFx0aWYgICAgICh0eXBlPT0wKSAgIGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IGRhdGFbZGkreF07XG5cdFx0ZWxzZSBpZih0eXBlPT0xKSB7IGZvcig7IHg8YnBwOyB4KyspIGRhdGFbaSt4XSA9IGRhdGFbZGkreF07XG5cdFx0XHRcdFx0XHQgICBmb3IoOyB4PGJwbDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArIGRhdGFbaSt4LWJwcF0pOyAgfVxuXHRcdGVsc2UgaWYodHlwZT09MikgeyBmb3IoOyB4PGJwbDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArIGRhdGFbaSt4LWJwbF0pOyAgfVxuXHRcdGVsc2UgaWYodHlwZT09MykgeyBmb3IoOyB4PGJwcDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArICggZGF0YVtpK3gtYnBsXT4+PjEpKTtcblx0XHRcdCAgICAgICAgICAgICAgIGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgKChkYXRhW2kreC1icGxdK2RhdGFbaSt4LWJwcF0pPj4+MSkgKTsgIH1cblx0XHRlbHNlICAgICAgICAgICAgIHsgZm9yKDsgeDxicHA7IHgrKykgZGF0YVtpK3hdID0gKGRhdGFbZGkreF0gKyBwYWV0aCgwLCBkYXRhW2kreC1icGxdLCAwKSk7XG5cdFx0XHRcdFx0XHQgICBmb3IoOyB4PGJwbDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArIHBhZXRoKGRhdGFbaSt4LWJwcF0sIGRhdGFbaSt4LWJwbF0sIGRhdGFbaSt4LWJwcC1icGxdKSApOyAgfVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5VUE5HLmRlY29kZS5fcGFldGggPSBmdW5jdGlvbihhLGIsYylcbntcblx0dmFyIHAgPSBhK2ItYywgcGEgPSAocC1hKSwgcGIgPSAocC1iKSwgcGMgPSAocC1jKTtcblx0aWYgKHBhKnBhIDw9IHBiKnBiICYmIHBhKnBhIDw9IHBjKnBjKSAgcmV0dXJuIGE7XG5cdGVsc2UgaWYgKHBiKnBiIDw9IHBjKnBjKSAgcmV0dXJuIGI7XG5cdHJldHVybiBjO1xufVxuXG5VUE5HLmRlY29kZS5fSUhEUiA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgb3V0KVxue1xuXHR2YXIgYmluID0gVVBORy5fYmluO1xuXHRvdXQud2lkdGggID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0b3V0LmhlaWdodCA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG5cdG91dC5kZXB0aCAgICAgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0b3V0LmN0eXBlICAgICA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRvdXQuY29tcHJlc3MgID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG5cdG91dC5maWx0ZXIgICAgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0b3V0LmludGVybGFjZSA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xufVxuXG5VUE5HLl9iaW4gPSB7XG5cdG5leHRaZXJvICAgOiBmdW5jdGlvbihkYXRhLHApICB7ICB3aGlsZShkYXRhW3BdIT0wKSBwKys7ICByZXR1cm4gcDsgIH0sXG5cdHJlYWRVc2hvcnQgOiBmdW5jdGlvbihidWZmLHApICB7ICByZXR1cm4gKGJ1ZmZbcF08PCA4KSB8IGJ1ZmZbcCsxXTsgIH0sXG5cdHdyaXRlVXNob3J0OiBmdW5jdGlvbihidWZmLHAsbil7ICBidWZmW3BdID0gKG4+PjgpJjI1NTsgIGJ1ZmZbcCsxXSA9IG4mMjU1OyAgfSxcblx0cmVhZFVpbnQgICA6IGZ1bmN0aW9uKGJ1ZmYscCkgIHsgIHJldHVybiAoYnVmZltwXSooMjU2KjI1NioyNTYpKSArICgoYnVmZltwKzFdPDwxNikgfCAoYnVmZltwKzJdPDwgOCkgfCBidWZmW3ArM10pOyAgfSxcblx0d3JpdGVVaW50ICA6IGZ1bmN0aW9uKGJ1ZmYscCxuKXsgIGJ1ZmZbcF09KG4+PjI0KSYyNTU7ICBidWZmW3ArMV09KG4+PjE2KSYyNTU7ICBidWZmW3ArMl09KG4+PjgpJjI1NTsgIGJ1ZmZbcCszXT1uJjI1NTsgIH0sXG5cdHJlYWRBU0NJSSAgOiBmdW5jdGlvbihidWZmLHAsbCl7ICB2YXIgcyA9IFwiXCI7ICBmb3IodmFyIGk9MDsgaTxsOyBpKyspIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmW3AraV0pOyAgcmV0dXJuIHM7ICAgIH0sXG5cdHdyaXRlQVNDSUkgOiBmdW5jdGlvbihkYXRhLHAscyl7ICBmb3IodmFyIGk9MDsgaTxzLmxlbmd0aDsgaSsrKSBkYXRhW3AraV0gPSBzLmNoYXJDb2RlQXQoaSk7ICB9LFxuXHRyZWFkQnl0ZXMgIDogZnVuY3Rpb24oYnVmZixwLGwpeyAgdmFyIGFyciA9IFtdOyAgIGZvcih2YXIgaT0wOyBpPGw7IGkrKykgYXJyLnB1c2goYnVmZltwK2ldKTsgICByZXR1cm4gYXJyOyAgfSxcblx0cGFkIDogZnVuY3Rpb24obikgeyByZXR1cm4gbi5sZW5ndGggPCAyID8gXCIwXCIgKyBuIDogbjsgfSxcblx0cmVhZFVURjggOiBmdW5jdGlvbihidWZmLCBwLCBsKSB7XG5cdFx0dmFyIHMgPSBcIlwiLCBucztcblx0XHRmb3IodmFyIGk9MDsgaTxsOyBpKyspIHMgKz0gXCIlXCIgKyBVUE5HLl9iaW4ucGFkKGJ1ZmZbcCtpXS50b1N0cmluZygxNikpO1xuXHRcdHRyeSB7ICBucyA9IGRlY29kZVVSSUNvbXBvbmVudChzKTsgfVxuXHRcdGNhdGNoKGUpIHsgIHJldHVybiBVUE5HLl9iaW4ucmVhZEFTQ0lJKGJ1ZmYsIHAsIGwpOyAgfVxuXHRcdHJldHVybiAgbnM7XG5cdH1cbn1cblVQTkcuX2NvcHlUaWxlID0gZnVuY3Rpb24oc2IsIHN3LCBzaCwgdGIsIHR3LCB0aCwgeG9mZiwgeW9mZiwgbW9kZSlcbntcblx0dmFyIHcgPSBNYXRoLm1pbihzdyx0dyksIGggPSBNYXRoLm1pbihzaCx0aCk7XG5cdHZhciBzaT0wLCB0aT0wO1xuXHRmb3IodmFyIHk9MDsgeTxoOyB5KyspXG5cdFx0Zm9yKHZhciB4PTA7IHg8dzsgeCsrKVxuXHRcdHtcblx0XHRcdGlmKHhvZmY+PTAgJiYgeW9mZj49MCkgeyAgc2kgPSAoeSpzdyt4KTw8MjsgIHRpID0gKCggeW9mZit5KSp0dyt4b2ZmK3gpPDwyOyAgfVxuXHRcdFx0ZWxzZSAgICAgICAgICAgICAgICAgICB7ICBzaSA9ICgoLXlvZmYreSkqc3cteG9mZit4KTw8MjsgIHRpID0gKHkqdHcreCk8PDI7ICB9XG5cdFx0XHRcblx0XHRcdGlmICAgICAobW9kZT09MCkgeyAgdGJbdGldID0gc2Jbc2ldOyAgdGJbdGkrMV0gPSBzYltzaSsxXTsgIHRiW3RpKzJdID0gc2Jbc2krMl07ICB0Ylt0aSszXSA9IHNiW3NpKzNdOyAgfVxuXHRcdFx0ZWxzZSBpZihtb2RlPT0xKSB7XG5cdFx0XHRcdHZhciBmYSA9IHNiW3NpKzNdKigxLzI1NSksIGZyPXNiW3NpXSpmYSwgZmc9c2Jbc2krMV0qZmEsIGZiPXNiW3NpKzJdKmZhOyBcblx0XHRcdFx0dmFyIGJhID0gdGJbdGkrM10qKDEvMjU1KSwgYnI9dGJbdGldKmJhLCBiZz10Ylt0aSsxXSpiYSwgYmI9dGJbdGkrMl0qYmE7IFxuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGlmYT0xLWZhLCBvYSA9IGZhK2JhKmlmYSwgaW9hID0gKG9hPT0wPzA6MS9vYSk7XG5cdFx0XHRcdHRiW3RpKzNdID0gMjU1Km9hOyAgXG5cdFx0XHRcdHRiW3RpKzBdID0gKGZyK2JyKmlmYSkqaW9hOyAgXG5cdFx0XHRcdHRiW3RpKzFdID0gKGZnK2JnKmlmYSkqaW9hOyAgIFxuXHRcdFx0XHR0Ylt0aSsyXSA9IChmYitiYippZmEpKmlvYTsgIFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihtb2RlPT0yKXtcdC8vIGNvcHkgb25seSBkaWZmZXJlbmNlcywgb3RoZXJ3aXNlIHplcm9cblx0XHRcdFx0dmFyIGZhID0gc2Jbc2krM10sIGZyPXNiW3NpXSwgZmc9c2Jbc2krMV0sIGZiPXNiW3NpKzJdOyBcblx0XHRcdFx0dmFyIGJhID0gdGJbdGkrM10sIGJyPXRiW3RpXSwgYmc9dGJbdGkrMV0sIGJiPXRiW3RpKzJdOyBcblx0XHRcdFx0aWYoZmE9PWJhICYmIGZyPT1iciAmJiBmZz09YmcgJiYgZmI9PWJiKSB7ICB0Ylt0aV09MDsgIHRiW3RpKzFdPTA7ICB0Ylt0aSsyXT0wOyAgdGJbdGkrM109MDsgIH1cblx0XHRcdFx0ZWxzZSB7ICB0Ylt0aV09ZnI7ICB0Ylt0aSsxXT1mZzsgIHRiW3RpKzJdPWZiOyAgdGJbdGkrM109ZmE7ICB9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKG1vZGU9PTMpe1x0Ly8gY2hlY2sgaWYgY2FuIGJlIGJsZW5kZWRcblx0XHRcdFx0dmFyIGZhID0gc2Jbc2krM10sIGZyPXNiW3NpXSwgZmc9c2Jbc2krMV0sIGZiPXNiW3NpKzJdOyBcblx0XHRcdFx0dmFyIGJhID0gdGJbdGkrM10sIGJyPXRiW3RpXSwgYmc9dGJbdGkrMV0sIGJiPXRiW3RpKzJdOyBcblx0XHRcdFx0aWYoZmE9PWJhICYmIGZyPT1iciAmJiBmZz09YmcgJiYgZmI9PWJiKSBjb250aW51ZTtcblx0XHRcdFx0Ly9pZihmYSE9MjU1ICYmIGJhIT0wKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlmKGZhPDIyMCAmJiBiYT4yMCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0cmV0dXJuIHRydWU7XG59XG5cblxuXG5cblVQTkcuZW5jb2RlID0gZnVuY3Rpb24oYnVmcywgdywgaCwgcHMsIGRlbHMsIHRhYnMsIGZvcmJpZFBsdGUpXG57XG5cdGlmKHBzPT1udWxsKSBwcz0wO1xuXHRpZihmb3JiaWRQbHRlPT1udWxsKSBmb3JiaWRQbHRlID0gZmFsc2U7XG5cblx0dmFyIG5pbWcgPSBVUE5HLmVuY29kZS5jb21wcmVzcyhidWZzLCB3LCBoLCBwcywgW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIGZvcmJpZFBsdGVdKTtcblx0VVBORy5lbmNvZGUuY29tcHJlc3NQTkcobmltZywgLTEpO1xuXHRcblx0cmV0dXJuIFVQTkcuZW5jb2RlLl9tYWluKG5pbWcsIHcsIGgsIGRlbHMsIHRhYnMpO1xufVxuXG5VUE5HLmVuY29kZUxMID0gZnVuY3Rpb24oYnVmcywgdywgaCwgY2MsIGFjLCBkZXB0aCwgZGVscywgdGFicykge1xuXHR2YXIgbmltZyA9IHsgIGN0eXBlOiAwICsgKGNjPT0xID8gMCA6IDIpICsgKGFjPT0wID8gMCA6IDQpLCAgICAgIGRlcHRoOiBkZXB0aCwgIGZyYW1lczogW10gIH07XG5cdFxuXHR2YXIgdGltZSA9IERhdGUubm93KCk7XG5cdHZhciBiaXBwID0gKGNjK2FjKSpkZXB0aCwgYmlwbCA9IGJpcHAgKiB3O1xuXHRmb3IodmFyIGk9MDsgaTxidWZzLmxlbmd0aDsgaSsrKVxuXHRcdG5pbWcuZnJhbWVzLnB1c2goeyAgcmVjdDp7eDowLHk6MCx3aWR0aDp3LGhlaWdodDpofSwgIGltZzpuZXcgVWludDhBcnJheShidWZzW2ldKSwgYmxlbmQ6MCwgZGlzcG9zZToxLCBicHA6TWF0aC5jZWlsKGJpcHAvOCksIGJwbDpNYXRoLmNlaWwoYmlwbC84KSAgfSk7XG5cdFxuXHRVUE5HLmVuY29kZS5jb21wcmVzc1BORyhuaW1nLCAwLCB0cnVlKTtcblx0XG5cdHZhciBvdXQgPSBVUE5HLmVuY29kZS5fbWFpbihuaW1nLCB3LCBoLCBkZWxzLCB0YWJzKTtcblx0cmV0dXJuIG91dDtcbn1cblxuVVBORy5lbmNvZGUuX21haW4gPSBmdW5jdGlvbihuaW1nLCB3LCBoLCBkZWxzLCB0YWJzKSB7XG5cdGlmKHRhYnM9PW51bGwpIHRhYnM9e307XG5cdHZhciBjcmMgPSBVUE5HLmNyYy5jcmMsIHdVaSA9IFVQTkcuX2Jpbi53cml0ZVVpbnQsIHdVcyA9IFVQTkcuX2Jpbi53cml0ZVVzaG9ydCwgd0FzID0gVVBORy5fYmluLndyaXRlQVNDSUk7XG5cdHZhciBvZmZzZXQgPSA4LCBhbmltID0gbmltZy5mcmFtZXMubGVuZ3RoPjEsIHBsdEFscGhhID0gZmFsc2U7XG5cdFxuXHR2YXIgbGVuZyA9IDggKyAoMTYrNSs0KSAvKisgKDkrNCkqLyArIChhbmltID8gMjAgOiAwKTtcblx0aWYodGFic1tcInNSR0JcIl0hPW51bGwpIGxlbmcgKz0gOCsxKzQ7XG5cdGlmKHRhYnNbXCJwSFlzXCJdIT1udWxsKSBsZW5nICs9IDgrOSs0O1xuXHRpZihuaW1nLmN0eXBlPT0zKSB7XG5cdFx0dmFyIGRsID0gbmltZy5wbHRlLmxlbmd0aDtcblx0XHRmb3IodmFyIGk9MDsgaTxkbDsgaSsrKSBpZigobmltZy5wbHRlW2ldPj4+MjQpIT0yNTUpIHBsdEFscGhhID0gdHJ1ZTtcblx0XHRsZW5nICs9ICg4ICsgZGwqMyArIDQpICsgKHBsdEFscGhhID8gKDggKyBkbCoxICsgNCkgOiAwKTtcblx0fVxuXHRmb3IodmFyIGo9MDsgajxuaW1nLmZyYW1lcy5sZW5ndGg7IGorKylcblx0e1xuXHRcdHZhciBmciA9IG5pbWcuZnJhbWVzW2pdO1xuXHRcdGlmKGFuaW0pIGxlbmcgKz0gMzg7XG5cdFx0bGVuZyArPSBmci5jaW1nLmxlbmd0aCArIDEyO1xuXHRcdGlmKGohPTApIGxlbmcrPTQ7XG5cdH1cblx0bGVuZyArPSAxMjsgXG5cdFxuXHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmcpO1xuXHR2YXIgd3I9WzB4ODksIDB4NTAsIDB4NGUsIDB4NDcsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdO1xuXHRmb3IodmFyIGk9MDsgaTw4OyBpKyspIGRhdGFbaV09d3JbaV07XG5cdFxuXHR3VWkoZGF0YSxvZmZzZXQsIDEzKTsgICAgIG9mZnNldCs9NDtcblx0d0FzKGRhdGEsb2Zmc2V0LFwiSUhEUlwiKTsgIG9mZnNldCs9NDtcblx0d1VpKGRhdGEsb2Zmc2V0LHcpOyAgb2Zmc2V0Kz00O1xuXHR3VWkoZGF0YSxvZmZzZXQsaCk7ICBvZmZzZXQrPTQ7XG5cdGRhdGFbb2Zmc2V0XSA9IG5pbWcuZGVwdGg7ICBvZmZzZXQrKzsgIC8vIGRlcHRoXG5cdGRhdGFbb2Zmc2V0XSA9IG5pbWcuY3R5cGU7ICBvZmZzZXQrKzsgIC8vIGN0eXBlXG5cdGRhdGFbb2Zmc2V0XSA9IDA7ICBvZmZzZXQrKzsgIC8vIGNvbXByZXNzXG5cdGRhdGFbb2Zmc2V0XSA9IDA7ICBvZmZzZXQrKzsgIC8vIGZpbHRlclxuXHRkYXRhW29mZnNldF0gPSAwOyAgb2Zmc2V0Kys7ICAvLyBpbnRlcmxhY2Vcblx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLG9mZnNldC0xNywxNykpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblxuXHQvLyAxMyBieXRlcyB0byBzYXksIHRoYXQgaXQgaXMgc1JHQlxuXHRpZih0YWJzW1wic1JHQlwiXSE9bnVsbCkge1xuXHRcdHdVaShkYXRhLG9mZnNldCwgMSk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdBcyhkYXRhLG9mZnNldCxcInNSR0JcIik7ICBvZmZzZXQrPTQ7XG5cdFx0ZGF0YVtvZmZzZXRdID0gdGFic1tcInNSR0JcIl07ICBvZmZzZXQrKztcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTUsNSkpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblx0fVxuXHRpZih0YWJzW1wicEhZc1wiXSE9bnVsbCkge1xuXHRcdHdVaShkYXRhLG9mZnNldCwgOSk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdBcyhkYXRhLG9mZnNldCxcInBIWXNcIik7ICBvZmZzZXQrPTQ7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCB0YWJzW1wicEhZc1wiXVswXSk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdVaShkYXRhLG9mZnNldCwgdGFic1tcInBIWXNcIl1bMV0pOyAgICAgIG9mZnNldCs9NDtcblx0XHRkYXRhW29mZnNldF09dGFic1tcInBIWXNcIl1bMl07XHRcdFx0b2Zmc2V0Kys7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLG9mZnNldC0xMywxMykpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblx0fVxuXG5cdGlmKGFuaW0pIHtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIDgpOyAgICAgIG9mZnNldCs9NDtcblx0XHR3QXMoZGF0YSxvZmZzZXQsXCJhY1RMXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdHdVaShkYXRhLG9mZnNldCwgbmltZy5mcmFtZXMubGVuZ3RoKTsgICAgIG9mZnNldCs9NDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIHRhYnNbXCJsb29wXCJdIT1udWxsP3RhYnNbXCJsb29wXCJdOjApOyAgICAgIG9mZnNldCs9NDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTEyLDEyKSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHR9XG5cblx0aWYobmltZy5jdHlwZT09Mykge1xuXHRcdHZhciBkbCA9IG5pbWcucGx0ZS5sZW5ndGg7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCBkbCozKTsgIG9mZnNldCs9NDtcblx0XHR3QXMoZGF0YSxvZmZzZXQsXCJQTFRFXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdGZvcih2YXIgaT0wOyBpPGRsOyBpKyspe1xuXHRcdFx0dmFyIHRpPWkqMywgYz1uaW1nLnBsdGVbaV0sIHI9KGMpJjI1NSwgZz0oYz4+PjgpJjI1NSwgYj0oYz4+PjE2KSYyNTU7XG5cdFx0XHRkYXRhW29mZnNldCt0aSswXT1yOyAgZGF0YVtvZmZzZXQrdGkrMV09ZzsgIGRhdGFbb2Zmc2V0K3RpKzJdPWI7XG5cdFx0fVxuXHRcdG9mZnNldCs9ZGwqMztcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LWRsKjMtNCxkbCozKzQpKTsgIG9mZnNldCs9NDsgLy8gY3JjXG5cblx0XHRpZihwbHRBbHBoYSkge1xuXHRcdFx0d1VpKGRhdGEsb2Zmc2V0LCBkbCk7ICBvZmZzZXQrPTQ7XG5cdFx0XHR3QXMoZGF0YSxvZmZzZXQsXCJ0Uk5TXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8ZGw7IGkrKykgIGRhdGFbb2Zmc2V0K2ldPShuaW1nLnBsdGVbaV0+Pj4yNCkmMjU1O1xuXHRcdFx0b2Zmc2V0Kz1kbDtcblx0XHRcdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtZGwtNCxkbCs0KSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHRcdH1cblx0fVxuXHRcblx0dmFyIGZpID0gMDtcblx0Zm9yKHZhciBqPTA7IGo8bmltZy5mcmFtZXMubGVuZ3RoOyBqKyspXG5cdHtcblx0XHR2YXIgZnIgPSBuaW1nLmZyYW1lc1tqXTtcblx0XHRpZihhbmltKSB7XG5cdFx0XHR3VWkoZGF0YSwgb2Zmc2V0LCAyNik7ICAgICBvZmZzZXQrPTQ7XG5cdFx0XHR3QXMoZGF0YSwgb2Zmc2V0LFwiZmNUTFwiKTsgIG9mZnNldCs9NDtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIGZpKyspOyAgIG9mZnNldCs9NDtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIGZyLnJlY3Qud2lkdGggKTsgICBvZmZzZXQrPTQ7XG5cdFx0XHR3VWkoZGF0YSwgb2Zmc2V0LCBmci5yZWN0LmhlaWdodCk7ICAgb2Zmc2V0Kz00O1xuXHRcdFx0d1VpKGRhdGEsIG9mZnNldCwgZnIucmVjdC54KTsgICBvZmZzZXQrPTQ7XG5cdFx0XHR3VWkoZGF0YSwgb2Zmc2V0LCBmci5yZWN0LnkpOyAgIG9mZnNldCs9NDtcblx0XHRcdHdVcyhkYXRhLCBvZmZzZXQsIGRlbHNbal0pOyAgIG9mZnNldCs9Mjtcblx0XHRcdHdVcyhkYXRhLCBvZmZzZXQsICAxMDAwKTsgICBvZmZzZXQrPTI7XG5cdFx0XHRkYXRhW29mZnNldF0gPSBmci5kaXNwb3NlOyAgb2Zmc2V0Kys7XHQvLyBkaXNwb3NlXG5cdFx0XHRkYXRhW29mZnNldF0gPSBmci5ibGVuZCAgOyAgb2Zmc2V0Kys7XHQvLyBibGVuZFxuXHRcdFx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLG9mZnNldC0zMCwzMCkpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblx0XHR9XG5cdFx0XHRcdFxuXHRcdHZhciBpbWdkID0gZnIuY2ltZywgZGwgPSBpbWdkLmxlbmd0aDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIGRsKyhqPT0wPzA6NCkpOyAgICAgb2Zmc2V0Kz00O1xuXHRcdHZhciBpb2ZmID0gb2Zmc2V0O1xuXHRcdHdBcyhkYXRhLG9mZnNldCwoaj09MCk/XCJJREFUXCI6XCJmZEFUXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdGlmKGohPTApIHsgIHdVaShkYXRhLCBvZmZzZXQsIGZpKyspOyAgb2Zmc2V0Kz00OyAgfVxuXHRcdGRhdGEuc2V0KGltZ2Qsb2Zmc2V0KTtcblx0XHRvZmZzZXQgKz0gZGw7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLGlvZmYsb2Zmc2V0LWlvZmYpKTsgIG9mZnNldCs9NDsgLy8gY3JjXG5cdH1cblxuXHR3VWkoZGF0YSxvZmZzZXQsIDApOyAgICAgb2Zmc2V0Kz00O1xuXHR3QXMoZGF0YSxvZmZzZXQsXCJJRU5EXCIpOyAgb2Zmc2V0Kz00O1xuXHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTQsNCkpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblxuXHRyZXR1cm4gZGF0YS5idWZmZXI7XG59XG5cblVQTkcuZW5jb2RlLmNvbXByZXNzUE5HID0gZnVuY3Rpb24ob3V0LCBmaWx0ZXIsIGxldmVsWmVybykge1xuXHRmb3IodmFyIGk9MDsgaTxvdXQuZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGZybSA9IG91dC5mcmFtZXNbaV0sIG53PWZybS5yZWN0LndpZHRoLCBuaD1mcm0ucmVjdC5oZWlnaHQ7XG5cdFx0dmFyIGZkYXRhID0gbmV3IFVpbnQ4QXJyYXkobmgqZnJtLmJwbCtuaCk7XG5cdFx0ZnJtLmNpbWcgPSBVUE5HLmVuY29kZS5fZmlsdGVyWmVybyhmcm0uaW1nLG5oLGZybS5icHAsZnJtLmJwbCxmZGF0YSwgZmlsdGVyLCBsZXZlbFplcm8pO1xuXHR9XG59XG5cblxuXG5VUE5HLmVuY29kZS5jb21wcmVzcyA9IGZ1bmN0aW9uKGJ1ZnMsIHcsIGgsIHBzLCBwcm1zKSAvLyBwcm1zOiAgb25seUJsZW5kLCBtaW5CaXRzLCBmb3JiaWRQbHRlXG57XG5cdC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR2YXIgb25seUJsZW5kID0gcHJtc1swXSwgZXZlbkNyZCA9IHBybXNbMV0sIGZvcmJpZFByZXYgPSBwcm1zWzJdLCBtaW5CaXRzID0gcHJtc1szXSwgZm9yYmlkUGx0ZSA9IHBybXNbNF07XG5cdFxuXHR2YXIgY3R5cGUgPSA2LCBkZXB0aCA9IDgsIGFscGhhQW5kPTI1NVxuXHRcblx0Zm9yKHZhciBqPTA7IGo8YnVmcy5sZW5ndGg7IGorKykgIHsgIC8vIHdoZW4gbm90IHF1YW50aXplZCwgb3RoZXIgZnJhbWVzIGNhbiBjb250YWluIGNvbG9ycywgdGhhdCBhcmUgbm90IGluIGFuIGluaXRpYWwgZnJhbWVcblx0XHR2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqXSksIGlsZW4gPSBpbWcubGVuZ3RoO1xuXHRcdGZvcih2YXIgaT0wOyBpPGlsZW47IGkrPTQpIGFscGhhQW5kICY9IGltZ1tpKzNdO1xuXHR9XG5cdHZhciBnb3RBbHBoYSA9IChhbHBoYUFuZCE9MjU1KTtcblx0XG5cdC8vY29uc29sZS5sb2coXCJhbHBoYSBjaGVja1wiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG5cdFxuXHQvL3ZhciBicnV0ZSA9IGdvdEFscGhhICYmIGZvckdJRjtcdFx0Ly8gYnJ1dGUgOiBmcmFtZXMgY2FuIG9ubHkgYmUgY29waWVkLCBub3QgXCJibGVuZGVkXCJcblx0dmFyIGZybXMgPSBVUE5HLmVuY29kZS5mcmFtaXplKGJ1ZnMsIHcsIGgsIG9ubHlCbGVuZCwgZXZlbkNyZCwgZm9yYmlkUHJldik7XG5cdC8vY29uc29sZS5sb2coXCJmcmFtaXplXCIsIERhdGUubm93KCktdGltZSk7ICB0aW1lID0gRGF0ZS5ub3coKTtcblx0XG5cdHZhciBjbWFwPXt9LCBwbHRlPVtdLCBpbmRzPVtdOyAgXG5cdFxuXHRpZihwcyE9MCkge1xuXHRcdHZhciBuYnVmcyA9IFtdOyAgZm9yKHZhciBpPTA7IGk8ZnJtcy5sZW5ndGg7IGkrKykgbmJ1ZnMucHVzaChmcm1zW2ldLmltZy5idWZmZXIpO1xuXHRcdFxuXHRcdHZhciBhYnVmID0gVVBORy5lbmNvZGUuY29uY2F0UkdCQShuYnVmcyksIHFyZXMgPSBVUE5HLnF1YW50aXplKGFidWYsIHBzKTsgIFxuXHRcdHZhciBjb2YgPSAwLCBiYiA9IG5ldyBVaW50OEFycmF5KHFyZXMuYWJ1Zik7XG5cdFx0Zm9yKHZhciBpPTA7IGk8ZnJtcy5sZW5ndGg7IGkrKykgeyAgdmFyIHRpPWZybXNbaV0uaW1nLCBibG49dGkubGVuZ3RoOyAgaW5kcy5wdXNoKG5ldyBVaW50OEFycmF5KHFyZXMuaW5kcy5idWZmZXIsIGNvZj4+MiwgYmxuPj4yKSk7XG5cdFx0XHRmb3IodmFyIGo9MDsgajxibG47IGorPTQpIHsgIHRpW2pdPWJiW2NvZitqXTsgIHRpW2orMV09YmJbY29mK2orMV07ICB0aVtqKzJdPWJiW2NvZitqKzJdOyAgdGlbaiszXT1iYltjb2YraiszXTsgIH0gICAgY29mKz1ibG47ICB9XG5cdFx0XG5cdFx0Zm9yKHZhciBpPTA7IGk8cXJlcy5wbHRlLmxlbmd0aDsgaSsrKSBwbHRlLnB1c2gocXJlcy5wbHRlW2ldLmVzdC5yZ2JhKTtcblx0XHQvL2NvbnNvbGUubG9nKFwicXVhbnRpemVcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIHdoYXQgaWYgcHM9PTAsIGJ1dCB0aGVyZSBhcmUgPD0yNTYgY29sb3JzPyAgd2Ugc3RpbGwgbmVlZCB0byBkZXRlY3QsIGlmIHRoZSBwYWxldHRlIGNvdWxkIGJlIHVzZWRcblx0XHRmb3IodmFyIGo9MDsgajxmcm1zLmxlbmd0aDsgaisrKSAgeyAgLy8gd2hlbiBub3QgcXVhbnRpemVkLCBvdGhlciBmcmFtZXMgY2FuIGNvbnRhaW4gY29sb3JzLCB0aGF0IGFyZSBub3QgaW4gYW4gaW5pdGlhbCBmcmFtZVxuXHRcdFx0dmFyIGZybSA9IGZybXNbal0sIGltZzMyID0gbmV3IFVpbnQzMkFycmF5KGZybS5pbWcuYnVmZmVyKSwgbnc9ZnJtLnJlY3Qud2lkdGgsIGlsZW4gPSBpbWczMi5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kID0gbmV3IFVpbnQ4QXJyYXkoaWxlbik7ICBpbmRzLnB1c2goaW5kKTtcblx0XHRcdGZvcih2YXIgaT0wOyBpPGlsZW47IGkrKykge1xuXHRcdFx0XHR2YXIgYyA9IGltZzMyW2ldO1xuXHRcdFx0XHRpZiAgICAgKGkhPTAgJiYgYz09aW1nMzJbaS0gMV0pIGluZFtpXT1pbmRbaS0xXTtcblx0XHRcdFx0ZWxzZSBpZihpPm53ICYmIGM9PWltZzMyW2ktbnddKSBpbmRbaV09aW5kW2ktbnddO1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgY21jID0gY21hcFtjXTtcblx0XHRcdFx0XHRpZihjbWM9PW51bGwpIHsgIGNtYXBbY109Y21jPXBsdGUubGVuZ3RoOyAgcGx0ZS5wdXNoKGMpOyAgaWYocGx0ZS5sZW5ndGg+PTMwMCkgYnJlYWs7ICB9XG5cdFx0XHRcdFx0aW5kW2ldPWNtYztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvL2NvbnNvbGUubG9nKFwibWFrZSBwYWxldHRlXCIsIERhdGUubm93KCktdGltZSk7ICB0aW1lID0gRGF0ZS5ub3coKTtcblx0fVxuXHRcblx0dmFyIGNjPXBsdGUubGVuZ3RoOyAvL2NvbnNvbGUubG9nKFwiY29sb3JzOlwiLGNjKTtcblx0aWYoY2M8PTI1NiAmJiBmb3JiaWRQbHRlPT1mYWxzZSkge1xuXHRcdGlmKGNjPD0gMikgZGVwdGg9MTsgIGVsc2UgaWYoY2M8PSA0KSBkZXB0aD0yOyAgZWxzZSBpZihjYzw9MTYpIGRlcHRoPTQ7ICBlbHNlIGRlcHRoPTg7XG5cdFx0ZGVwdGggPSAgTWF0aC5tYXgoZGVwdGgsIG1pbkJpdHMpO1xuXHR9XG5cdFxuXHRmb3IodmFyIGo9MDsgajxmcm1zLmxlbmd0aDsgaisrKVxuXHR7XG5cdFx0dmFyIGZybSA9IGZybXNbal0sIG54PWZybS5yZWN0LngsIG55PWZybS5yZWN0LnksIG53PWZybS5yZWN0LndpZHRoLCBuaD1mcm0ucmVjdC5oZWlnaHQ7XG5cdFx0dmFyIGNpbWcgPSBmcm0uaW1nLCBjaW1nMzIgPSBuZXcgVWludDMyQXJyYXkoY2ltZy5idWZmZXIpO1xuXHRcdHZhciBicGwgPSA0Km53LCBicHA9NDtcblx0XHRpZihjYzw9MjU2ICYmIGZvcmJpZFBsdGU9PWZhbHNlKSB7XG5cdFx0XHRicGwgPSBNYXRoLmNlaWwoZGVwdGgqbncvOCk7XG5cdFx0XHR2YXIgbmltZyA9IG5ldyBVaW50OEFycmF5KGJwbCpuaCk7XG5cdFx0XHR2YXIgaW5qID0gaW5kc1tqXTtcblx0XHRcdGZvcih2YXIgeT0wOyB5PG5oOyB5KyspIHsgIHZhciBpPXkqYnBsLCBpaT15Km53O1xuXHRcdFx0XHRpZiAgICAgKGRlcHRoPT04KSBmb3IodmFyIHg9MDsgeDxudzsgeCsrKSBuaW1nW2krKHgpICAgXSAgID0gIChpbmpbaWkreF0gICAgICAgICAgICAgKTtcblx0XHRcdFx0ZWxzZSBpZihkZXB0aD09NCkgZm9yKHZhciB4PTA7IHg8bnc7IHgrKykgbmltZ1tpKyh4Pj4xKV0gIHw9ICAoaW5qW2lpK3hdPDwoNC0oeCYxKSo0KSk7XG5cdFx0XHRcdGVsc2UgaWYoZGVwdGg9PTIpIGZvcih2YXIgeD0wOyB4PG53OyB4KyspIG5pbWdbaSsoeD4+MildICB8PSAgKGlualtpaSt4XTw8KDYtKHgmMykqMikpO1xuXHRcdFx0XHRlbHNlIGlmKGRlcHRoPT0xKSBmb3IodmFyIHg9MDsgeDxudzsgeCsrKSBuaW1nW2krKHg+PjMpXSAgfD0gIChpbmpbaWkreF08PCg3LSh4JjcpKjEpKTtcblx0XHRcdH1cblx0XHRcdGNpbWc9bmltZzsgIGN0eXBlPTM7ICBicHA9MTtcblx0XHR9XG5cdFx0ZWxzZSBpZihnb3RBbHBoYT09ZmFsc2UgJiYgZnJtcy5sZW5ndGg9PTEpIHtcdC8vIHNvbWUgbmV4dCBcInJlZHVjZWRcIiBmcmFtZXMgbWF5IGNvbnRhaW4gYWxwaGEgZm9yIGJsZW5kaW5nXG5cdFx0XHR2YXIgbmltZyA9IG5ldyBVaW50OEFycmF5KG53Km5oKjMpLCBhcmVhPW53Km5oO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7IHZhciB0aT1pKjMsIHFpPWkqNDsgIG5pbWdbdGldPWNpbWdbcWldOyAgbmltZ1t0aSsxXT1jaW1nW3FpKzFdOyAgbmltZ1t0aSsyXT1jaW1nW3FpKzJdOyAgfVxuXHRcdFx0Y2ltZz1uaW1nOyAgY3R5cGU9MjsgIGJwcD0zOyAgYnBsPTMqbnc7XG5cdFx0fVxuXHRcdGZybS5pbWc9Y2ltZzsgIGZybS5icGw9YnBsOyAgZnJtLmJwcD1icHA7XG5cdH1cblx0Ly9jb25zb2xlLmxvZyhcImNvbG9ycyA9PiBwYWxldHRlIGluZGljZXNcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHRcblx0cmV0dXJuIHtjdHlwZTpjdHlwZSwgZGVwdGg6ZGVwdGgsIHBsdGU6cGx0ZSwgZnJhbWVzOmZybXMgIH07XG59XG5VUE5HLmVuY29kZS5mcmFtaXplID0gZnVuY3Rpb24oYnVmcyx3LGgsYWx3YXlzQmxlbmQsZXZlbkNyZCxmb3JiaWRQcmV2KSB7XG5cdC8qICBESVNQT1NFXG5cdCAgICAtIDAgOiBubyBjaGFuZ2Vcblx0XHQtIDEgOiBjbGVhciB0byB0cmFuc3BhcmVudFxuXHRcdC0gMiA6IHJldHN0b3JlIHRvIGNvbnRlbnQgYmVmb3JlIHJlbmRlcmluZyAocHJldmlvdXMgZnJhbWUgZGlzcG9zZWQpXG5cdFx0QkxFTkRcblx0XHQtIDAgOiByZXBsYWNlXG5cdFx0LSAxIDogYmxlbmRcblx0Ki9cblx0dmFyIGZybXMgPSBbXTtcblx0Zm9yKHZhciBqPTA7IGo8YnVmcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBjaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqXSksIGNpbWczMiA9IG5ldyBVaW50MzJBcnJheShjaW1nLmJ1ZmZlcik7XG5cdFx0dmFyIG5pbWc7XG5cdFx0XG5cdFx0dmFyIG54PTAsIG55PTAsIG53PXcsIG5oPWgsIGJsZW5kPWFsd2F5c0JsZW5kPzE6MDtcblx0XHRpZihqIT0wKSB7XG5cdFx0XHR2YXIgdGxpbSA9IChmb3JiaWRQcmV2IHx8IGFsd2F5c0JsZW5kIHx8IGo9PTEgfHwgZnJtc1tqLTJdLmRpc3Bvc2UhPTApPzE6MiwgdHN0cCA9IDAsIHRhcmVhID0gMWU5O1xuXHRcdFx0Zm9yKHZhciBpdD0wOyBpdDx0bGltOyBpdCsrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcGltZyA9IG5ldyBVaW50OEFycmF5KGJ1ZnNbai0xLWl0XSksIHAzMiA9IG5ldyBVaW50MzJBcnJheShidWZzW2otMS1pdF0pO1xuXHRcdFx0XHR2YXIgbWl4PXcsbWl5PWgsbWF4PS0xLG1heT0tMTtcblx0XHRcdFx0Zm9yKHZhciB5PTA7IHk8aDsgeSsrKSBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHtcblx0XHRcdFx0XHR2YXIgaSA9IHkqdyt4O1xuXHRcdFx0XHRcdGlmKGNpbWczMltpXSE9cDMyW2ldKSB7XG5cdFx0XHRcdFx0XHRpZih4PG1peCkgbWl4PXg7ICBpZih4Pm1heCkgbWF4PXg7XG5cdFx0XHRcdFx0XHRpZih5PG1peSkgbWl5PXk7ICBpZih5Pm1heSkgbWF5PXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKG1heD09LTEpIG1peD1taXk9bWF4PW1heT0wO1xuXHRcdFx0XHRpZihldmVuQ3JkKSB7ICBpZigobWl4JjEpPT0xKW1peC0tOyAgaWYoKG1peSYxKT09MSltaXktLTsgIH1cblx0XHRcdFx0dmFyIHNhcmVhID0gKG1heC1taXgrMSkqKG1heS1taXkrMSk7XG5cdFx0XHRcdGlmKHNhcmVhPHRhcmVhKSB7XG5cdFx0XHRcdFx0dGFyZWEgPSBzYXJlYTsgIHRzdHAgPSBpdDtcblx0XHRcdFx0XHRueCA9IG1peDsgbnkgPSBtaXk7IG53ID0gbWF4LW1peCsxOyBuaCA9IG1heS1taXkrMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBhbHdheXNCbGVuZDogcG9rdWQgemppc3TDrW0sIMW+ZSBibGVuZGl0IG5lbHplLCBuYXN0YXbDrW0gcMWZZWRjaG96w61tdSBzbsOtbWt1IGRpc3Bvc2U9MS4gWmFqaXN0w61tLCBhYnkgb2JzYWhvdmFsIG3Fr2ogb2Jkw6lsbsOtay5cblx0XHRcdHZhciBwaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqLTEtdHN0cF0pO1xuXHRcdFx0aWYodHN0cD09MSkgZnJtc1tqLTFdLmRpc3Bvc2UgPSAyO1xuXHRcdFx0XG5cdFx0XHRuaW1nID0gbmV3IFVpbnQ4QXJyYXkobncqbmgqNCk7XG5cdFx0XHRVUE5HLl9jb3B5VGlsZShwaW1nLHcsaCwgbmltZyxudyxuaCwgLW54LC1ueSwgMCk7XG5cdFx0XHRcblx0XHRcdGJsZW5kID0gIFVQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBuaW1nLG53LG5oLCAtbngsLW55LCAzKSA/IDEgOiAwO1xuXHRcdFx0aWYoYmxlbmQ9PTEpIFVQTkcuZW5jb2RlLl9wcmVwYXJlRGlmZihjaW1nLHcsaCxuaW1nLHt4Om54LHk6bnksd2lkdGg6bncsaGVpZ2h0Om5ofSk7XG5cdFx0XHRlbHNlICAgICAgICAgVVBORy5fY29weVRpbGUoY2ltZyx3LGgsIG5pbWcsbncsbmgsIC1ueCwtbnksIDApO1xuXHRcdFx0Ly9VUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgbmltZyxudyxuaCwgLW54LC1ueSwgYmxlbmQ9PTE/MjowKTtcblx0XHR9XG5cdFx0ZWxzZSBuaW1nID0gY2ltZy5zbGljZSgwKTtcdC8vIGltZyBtYXkgYmUgcmV3cml0dGVuIGZ1cnRoZXIgLi4uIGRvbid0IHJld3JpdGUgaW5wdXRcblx0XHRcblx0XHRmcm1zLnB1c2goe3JlY3Q6e3g6bngseTpueSx3aWR0aDpudyxoZWlnaHQ6bmh9LCBpbWc6bmltZywgYmxlbmQ6YmxlbmQsIGRpc3Bvc2U6MH0pO1xuXHR9XG5cdFxuXHRcblx0aWYoYWx3YXlzQmxlbmQpIGZvcih2YXIgaj0wOyBqPGZybXMubGVuZ3RoOyBqKyspIHtcblx0XHR2YXIgZnJtID0gZnJtc1tqXTsgIGlmKGZybS5ibGVuZD09MSkgY29udGludWU7XG5cdFx0dmFyIHIwID0gZnJtLnJlY3QsIHIxID0gZnJtc1tqLTFdLnJlY3Rcblx0XHR2YXIgbWlYID0gTWF0aC5taW4ocjAueCwgcjEueCksIG1pWSA9IE1hdGgubWluKHIwLnksIHIxLnkpO1xuXHRcdHZhciBtYVggPSBNYXRoLm1heChyMC54K3IwLndpZHRoLCByMS54K3IxLndpZHRoKSwgbWFZID0gTWF0aC5tYXgocjAueStyMC5oZWlnaHQsIHIxLnkrcjEuaGVpZ2h0KTtcblx0XHR2YXIgciA9IHt4Om1pWCwgeTptaVksIHdpZHRoOm1hWC1taVgsIGhlaWdodDptYVktbWlZfTtcblx0XHRcblx0XHRmcm1zW2otMV0uZGlzcG9zZSA9IDE7XG5cdFx0aWYoai0xIT0wKSBcblx0XHRVUE5HLmVuY29kZS5fdXBkYXRlRnJhbWUoYnVmcywgdyxoLGZybXMsIGotMSxyLCBldmVuQ3JkKTtcblx0XHRVUE5HLmVuY29kZS5fdXBkYXRlRnJhbWUoYnVmcywgdyxoLGZybXMsIGogICxyLCBldmVuQ3JkKTtcblx0fVxuXHR2YXIgYXJlYSA9IDA7XG5cdGlmKGJ1ZnMubGVuZ3RoIT0xKSBmb3IodmFyIGk9MDsgaTxmcm1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGZybSA9IGZybXNbaV07XG5cdFx0YXJlYSArPSBmcm0ucmVjdC53aWR0aCpmcm0ucmVjdC5oZWlnaHQ7XG5cdFx0Ly9pZihpPT0wIHx8IGZybS5ibGVuZCE9MSkgY29udGludWU7XG5cdFx0Ly92YXIgb2IgPSBuZXcgVWludDhBcnJheShcblx0XHQvL2NvbnNvbGUubG9nKGZybS5ibGVuZCwgZnJtLmRpc3Bvc2UsIGZybS5yZWN0KTtcblx0fVxuXHQvL2lmKGFyZWEhPTApIGNvbnNvbGUubG9nKGFyZWEpO1xuXHRyZXR1cm4gZnJtcztcbn1cblVQTkcuZW5jb2RlLl91cGRhdGVGcmFtZSA9IGZ1bmN0aW9uKGJ1ZnMsIHcsaCwgZnJtcywgaSwgciwgZXZlbkNyZCkge1xuXHR2YXIgVTggPSBVaW50OEFycmF5LCBVMzIgPSBVaW50MzJBcnJheTtcblx0dmFyIHBpbWcgPSBuZXcgVTgoYnVmc1tpLTFdKSwgcGltZzMyID0gbmV3IFUzMihidWZzW2ktMV0pLCBuaW1nID0gaSsxPGJ1ZnMubGVuZ3RoID8gbmV3IFU4KGJ1ZnNbaSsxXSk6bnVsbDtcblx0dmFyIGNpbWcgPSBuZXcgVTgoYnVmc1tpXSksIGNpbWczMiA9IG5ldyBVMzIoY2ltZy5idWZmZXIpO1xuXHRcblx0dmFyIG1peD13LG1peT1oLG1heD0tMSxtYXk9LTE7XG5cdGZvcih2YXIgeT0wOyB5PHIuaGVpZ2h0OyB5KyspIGZvcih2YXIgeD0wOyB4PHIud2lkdGg7IHgrKykge1xuXHRcdHZhciBjeCA9IHIueCt4LCBjeSA9IHIueSt5O1xuXHRcdHZhciBqID0gY3kqdytjeCwgY2MgPSBjaW1nMzJbal07XG5cdFx0Ly8gbm8gbmVlZCB0byBkcmF3IHRyYW5zcGFyZW5jeSwgb3IgdG8gZGlzcG9zZSBpdC4gT3IsIGlmIHdyaXRpbmcgdGhlIHNhbWUgY29sb3IgYW5kIHRoZSBuZXh0IG9uZSBkb2VzIG5vdCBuZWVkIHRyYW5zcGFyZW5jeS5cblx0XHRpZihjYz09MCB8fCAoZnJtc1tpLTFdLmRpc3Bvc2U9PTAgJiYgcGltZzMyW2pdPT1jYyAmJiAobmltZz09bnVsbCB8fCBuaW1nW2oqNCszXSE9MCkpLyoqLykge31cblx0XHRlbHNlIHtcblx0XHRcdGlmKGN4PG1peCkgbWl4PWN4OyAgaWYoY3g+bWF4KSBtYXg9Y3g7XG5cdFx0XHRpZihjeTxtaXkpIG1peT1jeTsgIGlmKGN5Pm1heSkgbWF5PWN5O1xuXHRcdH1cblx0fVxuXHRpZihtYXg9PS0xKSBtaXg9bWl5PW1heD1tYXk9MDtcblx0aWYoZXZlbkNyZCkgeyAgaWYoKG1peCYxKT09MSltaXgtLTsgIGlmKChtaXkmMSk9PTEpbWl5LS07ICB9XG5cdHIgPSB7eDptaXgsIHk6bWl5LCB3aWR0aDptYXgtbWl4KzEsIGhlaWdodDptYXktbWl5KzF9O1xuXHRcblx0dmFyIGZyID0gZnJtc1tpXTsgIGZyLnJlY3QgPSByOyAgZnIuYmxlbmQgPSAxOyAgZnIuaW1nID0gbmV3IFVpbnQ4QXJyYXkoci53aWR0aCpyLmhlaWdodCo0KTtcblx0aWYoZnJtc1tpLTFdLmRpc3Bvc2U9PTApIHtcblx0XHRVUE5HLl9jb3B5VGlsZShwaW1nLHcsaCwgZnIuaW1nLHIud2lkdGgsci5oZWlnaHQsIC1yLngsLXIueSwgMCk7XG5cdFx0VVBORy5lbmNvZGUuX3ByZXBhcmVEaWZmKGNpbWcsdyxoLGZyLmltZyxyKTtcblx0XHQvL1VQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBmci5pbWcsci53aWR0aCxyLmhlaWdodCwgLXIueCwtci55LCAyKTtcblx0fVxuXHRlbHNlXG5cdFx0VVBORy5fY29weVRpbGUoY2ltZyx3LGgsIGZyLmltZyxyLndpZHRoLHIuaGVpZ2h0LCAtci54LC1yLnksIDApO1xufVxuVVBORy5lbmNvZGUuX3ByZXBhcmVEaWZmID0gZnVuY3Rpb24oY2ltZywgdyxoLCBuaW1nLCByZWMpIHtcblx0VVBORy5fY29weVRpbGUoY2ltZyx3LGgsIG5pbWcscmVjLndpZHRoLHJlYy5oZWlnaHQsIC1yZWMueCwtcmVjLnksIDIpO1xuXHQvKlxuXHR2YXIgbjMyID0gbmV3IFVpbnQzMkFycmF5KG5pbWcuYnVmZmVyKTtcblx0dmFyIG9nID0gbmV3IFVpbnQ4QXJyYXkocmVjLndpZHRoKnJlYy5oZWlnaHQqNCksIG8zMiA9IG5ldyBVaW50MzJBcnJheShvZy5idWZmZXIpO1xuXHRVUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgb2cscmVjLndpZHRoLHJlYy5oZWlnaHQsIC1yZWMueCwtcmVjLnksIDApO1xuXHRmb3IodmFyIGk9NDsgaTxuaW1nLmxlbmd0aDsgaSs9NCkge1xuXHRcdGlmKG5pbWdbaS0xXSE9MCAmJiBuaW1nW2krM109PTAgJiYgbzMyW2k+Pj4yXT09bzMyWyhpPj4+MiktMV0pIHtcblx0XHRcdG4zMltpPj4+Ml09bzMyW2k+Pj4yXTtcblx0XHRcdC8vdmFyIGogPSBpLCBjPXAzMlsoaT4+PjIpLTFdO1xuXHRcdFx0Ly93aGlsZShwMzJbaj4+PjJdPT1jKSB7ICBuMzJbaj4+PjJdPWM7ICBqKz00OyAgfVxuXHRcdH1cblx0fVxuXHRmb3IodmFyIGk9bmltZy5sZW5ndGgtODsgaT4wOyBpLT00KSB7XG5cdFx0aWYobmltZ1tpKzddIT0wICYmIG5pbWdbaSszXT09MCAmJiBvMzJbaT4+PjJdPT1vMzJbKGk+Pj4yKSsxXSkge1xuXHRcdFx0bjMyW2k+Pj4yXT1vMzJbaT4+PjJdO1xuXHRcdFx0Ly92YXIgaiA9IGksIGM9cDMyWyhpPj4+MiktMV07XG5cdFx0XHQvL3doaWxlKHAzMltqPj4+Ml09PWMpIHsgIG4zMltqPj4+Ml09YzsgIGorPTQ7ICB9XG5cdFx0fVxuXHR9Ki9cbn1cblxuVVBORy5lbmNvZGUuX2ZpbHRlclplcm8gPSBmdW5jdGlvbihpbWcsaCxicHAsYnBsLGRhdGEsIGZpbHRlciwgbGV2ZWxaZXJvKVxue1xuXHR2YXIgZmxzID0gW10sIGZ0cnk9WzAsMSwyLDMsNF07XG5cdGlmICAgICAoZmlsdGVyIT0tMSkgICAgICAgICAgICAgZnRyeT1bZmlsdGVyXTtcblx0ZWxzZSBpZihoKmJwbD41MDAwMDAgfHwgYnBwPT0xKSBmdHJ5PVswXTtcblx0dmFyIG9wdHM7ICBpZihsZXZlbFplcm8pIG9wdHM9e2xldmVsOjB9O1xuXHRcblx0dmFyIENNUFIgPSAobGV2ZWxaZXJvICYmIFVaSVAhPW51bGwpID8gVVpJUCA6IHBha287XG5cdFxuXHRmb3IodmFyIGk9MDsgaTxmdHJ5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Zm9yKHZhciB5PTA7IHk8aDsgeSsrKSBVUE5HLmVuY29kZS5fZmlsdGVyTGluZShkYXRhLCBpbWcsIHksIGJwbCwgYnBwLCBmdHJ5W2ldKTtcblx0XHQvL3ZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuXHRcdC8vdmFyIHN6ID0gVVpJUC5GLmRlZmxhdGUoZGF0YSwgbmltZyk7ICBmbHMucHVzaChuaW1nLnNsaWNlKDAsc3opKTtcblx0XHQvL3ZhciBkZmwgPSBwYWtvW1wiZGVmbGF0ZVwiXShkYXRhKSwgZGw9ZGZsLmxlbmd0aC00O1xuXHRcdC8vdmFyIGNyYyA9IChkZmxbZGwrM108PDI0KXwoZGZsW2RsKzJdPDwxNil8KGRmbFtkbCsxXTw8OCl8KGRmbFtkbCswXTw8MCk7XG5cdFx0Ly9jb25zb2xlLmxvZyhjcmMsIFVaSVAuYWRsZXIoZGF0YSwyLGRhdGEubGVuZ3RoLTYpKTtcblx0XHRmbHMucHVzaChDTVBSW1wiZGVmbGF0ZVwiXShkYXRhLG9wdHMpKTtcblx0fVxuXHR2YXIgdGksIHRzaXplPTFlOTtcblx0Zm9yKHZhciBpPTA7IGk8ZmxzLmxlbmd0aDsgaSsrKSBpZihmbHNbaV0ubGVuZ3RoPHRzaXplKSB7ICB0aT1pOyAgdHNpemU9ZmxzW2ldLmxlbmd0aDsgIH1cblx0cmV0dXJuIGZsc1t0aV07XG59XG5VUE5HLmVuY29kZS5fZmlsdGVyTGluZSA9IGZ1bmN0aW9uKGRhdGEsIGltZywgeSwgYnBsLCBicHAsIHR5cGUpXG57XG5cdHZhciBpID0geSpicGwsIGRpID0gaSt5LCBwYWV0aCA9IFVQTkcuZGVjb2RlLl9wYWV0aFxuXHRkYXRhW2RpXT10eXBlOyAgZGkrKztcblxuXHRpZih0eXBlPT0wKSB7XG5cdFx0aWYoYnBsPDUwMCkgZm9yKHZhciB4PTA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSBpbWdbaSt4XTtcblx0XHRlbHNlIGRhdGEuc2V0KG5ldyBVaW50OEFycmF5KGltZy5idWZmZXIsaSxicGwpLGRpKTtcblx0fVxuXHRlbHNlIGlmKHR5cGU9PTEpIHtcblx0XHRmb3IodmFyIHg9ICAwOyB4PGJwcDsgeCsrKSBkYXRhW2RpK3hdID0gIGltZ1tpK3hdO1xuXHRcdGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0taW1nW2kreC1icHBdKzI1NikmMjU1O1xuXHR9XG5cdGVsc2UgaWYoeT09MCkge1xuXHRcdGZvcih2YXIgeD0gIDA7IHg8YnBwOyB4KyspIGRhdGFbZGkreF0gPSBpbWdbaSt4XTtcblxuXHRcdGlmKHR5cGU9PTIpIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSBpbWdbaSt4XTtcblx0XHRpZih0eXBlPT0zKSBmb3IodmFyIHg9YnBwOyB4PGJwbDsgeCsrKSBkYXRhW2RpK3hdID0gKGltZ1tpK3hdIC0gKGltZ1tpK3gtYnBwXT4+MSkgKzI1NikmMjU1O1xuXHRcdGlmKHR5cGU9PTQpIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0gLSBwYWV0aChpbWdbaSt4LWJwcF0sIDAsIDApICsyNTYpJjI1NTtcblx0fVxuXHRlbHNlIHtcblx0XHRpZih0eXBlPT0yKSB7IGZvcih2YXIgeD0gIDA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gaW1nW2kreC1icGxdKSYyNTU7ICB9XG5cdFx0aWYodHlwZT09MykgeyBmb3IodmFyIHg9ICAwOyB4PGJwcDsgeCsrKSBkYXRhW2RpK3hdID0gKGltZ1tpK3hdKzI1NiAtIChpbWdbaSt4LWJwbF0+PjEpKSYyNTU7XG5cdFx0XHRcdFx0ICBmb3IodmFyIHg9YnBwOyB4PGJwbDsgeCsrKSBkYXRhW2RpK3hdID0gKGltZ1tpK3hdKzI1NiAtICgoaW1nW2kreC1icGxdK2ltZ1tpK3gtYnBwXSk+PjEpKSYyNTU7ICB9XG5cdFx0aWYodHlwZT09NCkgeyBmb3IodmFyIHg9ICAwOyB4PGJwcDsgeCsrKSBkYXRhW2RpK3hdID0gKGltZ1tpK3hdKzI1NiAtIHBhZXRoKDAsIGltZ1tpK3gtYnBsXSwgMCkpJjI1NTtcblx0XHRcdFx0XHQgIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gcGFldGgoaW1nW2kreC1icHBdLCBpbWdbaSt4LWJwbF0sIGltZ1tpK3gtYnBwLWJwbF0pKSYyNTU7ICB9XG5cdH1cbn1cblxuVVBORy5jcmMgPSB7XG5cdHRhYmxlIDogKCBmdW5jdGlvbigpIHtcblx0ICAgdmFyIHRhYiA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuXHQgICBmb3IgKHZhciBuPTA7IG48MjU2OyBuKyspIHtcblx0XHRcdHZhciBjID0gbjtcblx0XHRcdGZvciAodmFyIGs9MDsgazw4OyBrKyspIHtcblx0XHRcdFx0aWYgKGMgJiAxKSAgYyA9IDB4ZWRiODgzMjAgXiAoYyA+Pj4gMSk7XG5cdFx0XHRcdGVsc2UgICAgICAgIGMgPSBjID4+PiAxO1xuXHRcdFx0fVxuXHRcdFx0dGFiW25dID0gYzsgIH1cblx0XHRyZXR1cm4gdGFiOyAgfSkoKSxcblx0dXBkYXRlIDogZnVuY3Rpb24oYywgYnVmLCBvZmYsIGxlbikge1xuXHRcdGZvciAodmFyIGk9MDsgaTxsZW47IGkrKykgIGMgPSBVUE5HLmNyYy50YWJsZVsoYyBeIGJ1ZltvZmYraV0pICYgMHhmZl0gXiAoYyA+Pj4gOCk7XG5cdFx0cmV0dXJuIGM7XG5cdH0sXG5cdGNyYyA6IGZ1bmN0aW9uKGIsbyxsKSAgeyAgcmV0dXJuIFVQTkcuY3JjLnVwZGF0ZSgweGZmZmZmZmZmLGIsbyxsKSBeIDB4ZmZmZmZmZmY7ICB9XG59XG5cblxuVVBORy5xdWFudGl6ZSA9IGZ1bmN0aW9uKGFidWYsIHBzKVxue1x0XG5cdHZhciBvaW1nID0gbmV3IFVpbnQ4QXJyYXkoYWJ1ZiksIG5pbWcgPSBvaW1nLnNsaWNlKDApLCBuaW1nMzIgPSBuZXcgVWludDMyQXJyYXkobmltZy5idWZmZXIpO1xuXHRcblx0dmFyIEtEID0gVVBORy5xdWFudGl6ZS5nZXRLRHRyZWUobmltZywgcHMpO1xuXHR2YXIgcm9vdCA9IEtEWzBdLCBsZWFmcyA9IEtEWzFdO1xuXHRcblx0dmFyIHBsYW5lRHN0ID0gVVBORy5xdWFudGl6ZS5wbGFuZURzdDtcblx0dmFyIHNiID0gb2ltZywgdGIgPSBuaW1nMzIsIGxlbj1zYi5sZW5ndGg7XG5cdFx0XG5cdHZhciBpbmRzID0gbmV3IFVpbnQ4QXJyYXkob2ltZy5sZW5ndGg+PjIpO1xuXHRmb3IodmFyIGk9MDsgaTxsZW47IGkrPTQpIHtcblx0XHR2YXIgcj1zYltpXSooMS8yNTUpLCBnPXNiW2krMV0qKDEvMjU1KSwgYj1zYltpKzJdKigxLzI1NSksIGE9c2JbaSszXSooMS8yNTUpO1xuXHRcdFxuXHRcdC8vICBleGFjdCwgYnV0IHRvbyBzbG93IDooXG5cdFx0dmFyIG5kID0gVVBORy5xdWFudGl6ZS5nZXROZWFyZXN0KHJvb3QsIHIsIGcsIGIsIGEpO1xuXHRcdC8vdmFyIG5kID0gcm9vdDtcblx0XHQvL3doaWxlKG5kLmxlZnQpIG5kID0gKHBsYW5lRHN0KG5kLmVzdCxyLGcsYixhKTw9MCkgPyBuZC5sZWZ0IDogbmQucmlnaHQ7XG5cdFx0XG5cdFx0aW5kc1tpPj4yXSA9IG5kLmluZDtcblx0XHR0YltpPj4yXSA9IG5kLmVzdC5yZ2JhO1xuXHR9XG5cdHJldHVybiB7ICBhYnVmOm5pbWcuYnVmZmVyLCBpbmRzOmluZHMsIHBsdGU6bGVhZnMgIH07XG59XG5cblVQTkcucXVhbnRpemUuZ2V0S0R0cmVlID0gZnVuY3Rpb24obmltZywgcHMsIGVycikge1xuXHRpZihlcnI9PW51bGwpIGVyciA9IDAuMDAwMTtcblx0dmFyIG5pbWczMiA9IG5ldyBVaW50MzJBcnJheShuaW1nLmJ1ZmZlcik7XG5cdFxuXHR2YXIgcm9vdCA9IHtpMDowLCBpMTpuaW1nLmxlbmd0aCwgYnN0Om51bGwsIGVzdDpudWxsLCB0ZHN0OjAsIGxlZnQ6bnVsbCwgcmlnaHQ6bnVsbCB9OyAgLy8gYmFzaWMgc3RhdGlzdGljLCBleHRyYSBzdGF0aXN0aWNcblx0cm9vdC5ic3QgPSBVUE5HLnF1YW50aXplLnN0YXRzKCAgbmltZyxyb290LmkwLCByb290LmkxICApOyAgcm9vdC5lc3QgPSBVUE5HLnF1YW50aXplLmVzdGF0cyggcm9vdC5ic3QgKTtcblx0dmFyIGxlYWZzID0gW3Jvb3RdO1xuXHRcblx0d2hpbGUobGVhZnMubGVuZ3RoPHBzKVxuXHR7XG5cdFx0dmFyIG1heEwgPSAwLCBtaT0wO1xuXHRcdGZvcih2YXIgaT0wOyBpPGxlYWZzLmxlbmd0aDsgaSsrKSBpZihsZWFmc1tpXS5lc3QuTCA+IG1heEwpIHsgIG1heEw9bGVhZnNbaV0uZXN0Lkw7ICBtaT1pOyAgfVxuXHRcdGlmKG1heEw8ZXJyKSBicmVhaztcblx0XHR2YXIgbm9kZSA9IGxlYWZzW21pXTtcblx0XHRcblx0XHR2YXIgczAgPSBVUE5HLnF1YW50aXplLnNwbGl0UGl4ZWxzKG5pbWcsbmltZzMyLCBub2RlLmkwLCBub2RlLmkxLCBub2RlLmVzdC5lLCBub2RlLmVzdC5lTXEyNTUpO1xuXHRcdHZhciBzMHdyb25nID0gKG5vZGUuaTA+PXMwIHx8IG5vZGUuaTE8PXMwKTtcblx0XHQvL2NvbnNvbGUubG9nKG1heEwsIGxlYWZzLmxlbmd0aCwgbWkpO1xuXHRcdGlmKHMwd3JvbmcpIHsgIG5vZGUuZXN0Lkw9MDsgIGNvbnRpbnVlOyAgfVxuXHRcdFxuXHRcdFxuXHRcdHZhciBsbiA9IHtpMDpub2RlLmkwLCBpMTpzMCwgYnN0Om51bGwsIGVzdDpudWxsLCB0ZHN0OjAsIGxlZnQ6bnVsbCwgcmlnaHQ6bnVsbCB9OyAgbG4uYnN0ID0gVVBORy5xdWFudGl6ZS5zdGF0cyggbmltZywgbG4uaTAsIGxuLmkxICk7ICBcblx0XHRsbi5lc3QgPSBVUE5HLnF1YW50aXplLmVzdGF0cyggbG4uYnN0ICk7XG5cdFx0dmFyIHJuID0ge2kwOnMwLCBpMTpub2RlLmkxLCBic3Q6bnVsbCwgZXN0Om51bGwsIHRkc3Q6MCwgbGVmdDpudWxsLCByaWdodDpudWxsIH07ICBybi5ic3QgPSB7UjpbXSwgbTpbXSwgTjpub2RlLmJzdC5OLWxuLmJzdC5OfTtcblx0XHRmb3IodmFyIGk9MDsgaTwxNjsgaSsrKSBybi5ic3QuUltpXSA9IG5vZGUuYnN0LlJbaV0tbG4uYnN0LlJbaV07XG5cdFx0Zm9yKHZhciBpPTA7IGk8IDQ7IGkrKykgcm4uYnN0Lm1baV0gPSBub2RlLmJzdC5tW2ldLWxuLmJzdC5tW2ldO1xuXHRcdHJuLmVzdCA9IFVQTkcucXVhbnRpemUuZXN0YXRzKCBybi5ic3QgKTtcblx0XHRcblx0XHRub2RlLmxlZnQgPSBsbjsgIG5vZGUucmlnaHQgPSBybjtcblx0XHRsZWFmc1ttaV09bG47ICBsZWFmcy5wdXNoKHJuKTtcblx0fVxuXHRsZWFmcy5zb3J0KGZ1bmN0aW9uKGEsYikgeyAgcmV0dXJuIGIuYnN0Lk4tYS5ic3QuTjsgIH0pO1xuXHRmb3IodmFyIGk9MDsgaTxsZWFmcy5sZW5ndGg7IGkrKykgbGVhZnNbaV0uaW5kPWk7XG5cdHJldHVybiBbcm9vdCwgbGVhZnNdO1xufVxuXG5VUE5HLnF1YW50aXplLmdldE5lYXJlc3QgPSBmdW5jdGlvbihuZCwgcixnLGIsYSlcbntcblx0aWYobmQubGVmdD09bnVsbCkgeyAgbmQudGRzdCA9IFVQTkcucXVhbnRpemUuZGlzdChuZC5lc3QucSxyLGcsYixhKTsgIHJldHVybiBuZDsgIH1cblx0dmFyIHBsYW5lRHN0ID0gVVBORy5xdWFudGl6ZS5wbGFuZURzdChuZC5lc3QscixnLGIsYSk7XG5cdFxuXHR2YXIgbm9kZTAgPSBuZC5sZWZ0LCBub2RlMSA9IG5kLnJpZ2h0O1xuXHRpZihwbGFuZURzdD4wKSB7ICBub2RlMD1uZC5yaWdodDsgIG5vZGUxPW5kLmxlZnQ7ICB9XG5cdFxuXHR2YXIgbG4gPSBVUE5HLnF1YW50aXplLmdldE5lYXJlc3Qobm9kZTAsIHIsZyxiLGEpO1xuXHRpZihsbi50ZHN0PD1wbGFuZURzdCpwbGFuZURzdCkgcmV0dXJuIGxuO1xuXHR2YXIgcm4gPSBVUE5HLnF1YW50aXplLmdldE5lYXJlc3Qobm9kZTEsIHIsZyxiLGEpO1xuXHRyZXR1cm4gcm4udGRzdDxsbi50ZHN0ID8gcm4gOiBsbjtcbn1cblVQTkcucXVhbnRpemUucGxhbmVEc3QgPSBmdW5jdGlvbihlc3QsIHIsZyxiLGEpIHsgIHZhciBlID0gZXN0LmU7ICByZXR1cm4gZVswXSpyICsgZVsxXSpnICsgZVsyXSpiICsgZVszXSphIC0gZXN0LmVNcTsgIH1cblVQTkcucXVhbnRpemUuZGlzdCAgICAgPSBmdW5jdGlvbihxLCAgIHIsZyxiLGEpIHsgIHZhciBkMD1yLXFbMF0sIGQxPWctcVsxXSwgZDI9Yi1xWzJdLCBkMz1hLXFbM107ICByZXR1cm4gZDAqZDArZDEqZDErZDIqZDIrZDMqZDM7ICB9XG5cblVQTkcucXVhbnRpemUuc3BsaXRQaXhlbHMgPSBmdW5jdGlvbihuaW1nLCBuaW1nMzIsIGkwLCBpMSwgZSwgZU1xKVxue1xuXHR2YXIgdmVjRG90ID0gVVBORy5xdWFudGl6ZS52ZWNEb3Q7XG5cdGkxLT00O1xuXHR2YXIgc2hmcyA9IDA7XG5cdHdoaWxlKGkwPGkxKVxuXHR7XG5cdFx0d2hpbGUodmVjRG90KG5pbWcsIGkwLCBlKTw9ZU1xKSBpMCs9NDtcblx0XHR3aGlsZSh2ZWNEb3QobmltZywgaTEsIGUpPiBlTXEpIGkxLT00O1xuXHRcdGlmKGkwPj1pMSkgYnJlYWs7XG5cdFx0XG5cdFx0dmFyIHQgPSBuaW1nMzJbaTA+PjJdOyAgbmltZzMyW2kwPj4yXSA9IG5pbWczMltpMT4+Ml07ICBuaW1nMzJbaTE+PjJdPXQ7XG5cdFx0XG5cdFx0aTArPTQ7ICBpMS09NDtcblx0fVxuXHR3aGlsZSh2ZWNEb3QobmltZywgaTAsIGUpPmVNcSkgaTAtPTQ7XG5cdHJldHVybiBpMCs0O1xufVxuVVBORy5xdWFudGl6ZS52ZWNEb3QgPSBmdW5jdGlvbihuaW1nLCBpLCBlKVxue1xuXHRyZXR1cm4gbmltZ1tpXSplWzBdICsgbmltZ1tpKzFdKmVbMV0gKyBuaW1nW2krMl0qZVsyXSArIG5pbWdbaSszXSplWzNdO1xufVxuVVBORy5xdWFudGl6ZS5zdGF0cyA9IGZ1bmN0aW9uKG5pbWcsIGkwLCBpMSl7XG5cdHZhciBSID0gWzAsMCwwLDAsICAwLDAsMCwwLCAgMCwwLDAsMCwgIDAsMCwwLDBdO1xuXHR2YXIgbSA9IFswLDAsMCwwXTtcblx0dmFyIE4gPSAoaTEtaTApPj4yO1xuXHRmb3IodmFyIGk9aTA7IGk8aTE7IGkrPTQpXG5cdHtcblx0XHR2YXIgciA9IG5pbWdbaV0qKDEvMjU1KSwgZyA9IG5pbWdbaSsxXSooMS8yNTUpLCBiID0gbmltZ1tpKzJdKigxLzI1NSksIGEgPSBuaW1nW2krM10qKDEvMjU1KTtcblx0XHQvL3ZhciByID0gbmltZ1tpXSwgZyA9IG5pbWdbaSsxXSwgYiA9IG5pbWdbaSsyXSwgYSA9IG5pbWdbaSszXTtcblx0XHRtWzBdKz1yOyAgbVsxXSs9ZzsgIG1bMl0rPWI7ICBtWzNdKz1hO1xuXHRcdFxuXHRcdFJbIDBdICs9IHIqcjsgIFJbIDFdICs9IHIqZzsgIFJbIDJdICs9IHIqYjsgIFJbIDNdICs9IHIqYTsgIFxuXHRcdCAgICAgICAgICAgICAgIFJbIDVdICs9IGcqZzsgIFJbIDZdICs9IGcqYjsgIFJbIDddICs9IGcqYTsgXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUlsxMF0gKz0gYipiOyAgUlsxMV0gKz0gYiphOyAgXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUlsxNV0gKz0gYSphOyAgXG5cdH1cblx0Uls0XT1SWzFdOyAgUls4XT1SWzJdOyAgUls5XT1SWzZdOyAgUlsxMl09UlszXTsgIFJbMTNdPVJbN107ICBSWzE0XT1SWzExXTtcblx0XG5cdHJldHVybiB7UjpSLCBtOm0sIE46Tn07XG59XG5VUE5HLnF1YW50aXplLmVzdGF0cyA9IGZ1bmN0aW9uKHN0YXRzKXtcblx0dmFyIFIgPSBzdGF0cy5SLCBtID0gc3RhdHMubSwgTiA9IHN0YXRzLk47XG5cdFxuXHQvLyB3aGVuIGFsbCBzYW1wbGVzIGFyZSBlcXVhbCwgYnV0IE4gaXMgbGFyZ2UgKG1pbGxpb25zKSwgdGhlIFJqIGNhbiBiZSBub24temVybyAoIDAuMDAwMy4uLi4gLSBwcmVjaXNzaW9uIGVycm9yKVxuXHR2YXIgbTAgPSBtWzBdLCBtMSA9IG1bMV0sIG0yID0gbVsyXSwgbTMgPSBtWzNdLCBpTiA9IChOPT0wID8gMCA6IDEvTik7XG5cdHZhciBSaiA9IFtcblx0XHRSWyAwXSAtIG0wKm0wKmlOLCAgUlsgMV0gLSBtMCptMSppTiwgIFJbIDJdIC0gbTAqbTIqaU4sICBSWyAzXSAtIG0wKm0zKmlOLCAgXG5cdFx0UlsgNF0gLSBtMSptMCppTiwgIFJbIDVdIC0gbTEqbTEqaU4sICBSWyA2XSAtIG0xKm0yKmlOLCAgUlsgN10gLSBtMSptMyppTixcblx0XHRSWyA4XSAtIG0yKm0wKmlOLCAgUlsgOV0gLSBtMiptMSppTiwgIFJbMTBdIC0gbTIqbTIqaU4sICBSWzExXSAtIG0yKm0zKmlOLCAgXG5cdFx0UlsxMl0gLSBtMyptMCppTiwgIFJbMTNdIC0gbTMqbTEqaU4sICBSWzE0XSAtIG0zKm0yKmlOLCAgUlsxNV0gLSBtMyptMyppTiBcblx0XTtcblx0XG5cdHZhciBBID0gUmosIE0gPSBVUE5HLk00O1xuXHR2YXIgYiA9IFswLjUsMC41LDAuNSwwLjVdLCBtaSA9IDAsIHRtaSA9IDA7XG5cdFxuXHRpZihOIT0wKVxuXHRmb3IodmFyIGk9MDsgaTwxMDsgaSsrKSB7XG5cdFx0YiA9IE0ubXVsdFZlYyhBLCBiKTsgIHRtaSA9IE1hdGguc3FydChNLmRvdChiLGIpKTsgIGIgPSBNLnNtbCgxL3RtaSwgIGIpO1xuXHRcdGlmKE1hdGguYWJzKHRtaS1taSk8MWUtOSkgYnJlYWs7ICBtaSA9IHRtaTtcblx0fVx0XG5cdC8vYiA9IFswLDAsMSwwXTsgIG1pPU47XG5cdHZhciBxID0gW20wKmlOLCBtMSppTiwgbTIqaU4sIG0zKmlOXTtcblx0dmFyIGVNcTI1NSA9IE0uZG90KE0uc21sKDI1NSxxKSxiKTtcblx0XG5cdHJldHVybiB7ICBDb3Y6UmosIHE6cSwgZTpiLCBMOm1pLCAgZU1xMjU1OmVNcTI1NSwgZU1xIDogTS5kb3QoYixxKSxcblx0XHRcdFx0cmdiYTogKCgoTWF0aC5yb3VuZCgyNTUqcVszXSk8PDI0KSB8IChNYXRoLnJvdW5kKDI1NSpxWzJdKTw8MTYpIHwgIChNYXRoLnJvdW5kKDI1NSpxWzFdKTw8OCkgfCAoTWF0aC5yb3VuZCgyNTUqcVswXSk8PDApKT4+PjApICB9O1xufVxuVVBORy5NNCA9IHtcblx0bXVsdFZlYyA6IGZ1bmN0aW9uKG0sdikge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bVsgMF0qdlswXSArIG1bIDFdKnZbMV0gKyBtWyAyXSp2WzJdICsgbVsgM10qdlszXSxcblx0XHRcdFx0bVsgNF0qdlswXSArIG1bIDVdKnZbMV0gKyBtWyA2XSp2WzJdICsgbVsgN10qdlszXSxcblx0XHRcdFx0bVsgOF0qdlswXSArIG1bIDldKnZbMV0gKyBtWzEwXSp2WzJdICsgbVsxMV0qdlszXSxcblx0XHRcdFx0bVsxMl0qdlswXSArIG1bMTNdKnZbMV0gKyBtWzE0XSp2WzJdICsgbVsxNV0qdlszXVxuXHRcdFx0XTtcblx0fSxcblx0ZG90IDogZnVuY3Rpb24oeCx5KSB7ICByZXR1cm4gIHhbMF0qeVswXSt4WzFdKnlbMV0reFsyXSp5WzJdK3hbM10qeVszXTsgIH0sXG5cdHNtbCA6IGZ1bmN0aW9uKGEseSkgeyAgcmV0dXJuIFthKnlbMF0sYSp5WzFdLGEqeVsyXSxhKnlbM11dOyAgfVxufVxuXG5VUE5HLmVuY29kZS5jb25jYXRSR0JBID0gZnVuY3Rpb24oYnVmcykge1xuXHR2YXIgdGxlbiA9IDA7XG5cdGZvcih2YXIgaT0wOyBpPGJ1ZnMubGVuZ3RoOyBpKyspIHRsZW4gKz0gYnVmc1tpXS5ieXRlTGVuZ3RoO1xuXHR2YXIgbmltZyA9IG5ldyBVaW50OEFycmF5KHRsZW4pLCBub2ZmPTA7XG5cdGZvcih2YXIgaT0wOyBpPGJ1ZnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tpXSksIGlsID0gaW1nLmxlbmd0aDtcblx0XHRmb3IodmFyIGo9MDsgajxpbDsgais9NCkgeyAgXG5cdFx0XHR2YXIgcj1pbWdbal0sIGc9aW1nW2orMV0sIGI9aW1nW2orMl0sIGEgPSBpbWdbaiszXTtcblx0XHRcdGlmKGE9PTApIHI9Zz1iPTA7XG5cdFx0XHRuaW1nW25vZmYral09cjsgIG5pbWdbbm9mZitqKzFdPWc7ICBuaW1nW25vZmYraisyXT1iOyAgbmltZ1tub2ZmK2orM109YTsgIH1cblx0XHRub2ZmICs9IGlsO1xuXHR9XG5cdHJldHVybiBuaW1nLmJ1ZmZlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVVBORztcblxuIl0sIm5hbWVzIjpbInBha28iLCJVUE5HIiwidG9SR0JBOCIsIm91dCIsInciLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJ0YWJzIiwiYWNUTCIsImRlY29kZUltYWdlIiwiZGF0YSIsImJ1ZmZlciIsImZybXMiLCJmcmFtZXMiLCJsZW4iLCJpbWciLCJVaW50OEFycmF5IiwiZW1wdHkiLCJwcmV2IiwiaSIsImxlbmd0aCIsImZybSIsImZ4IiwicmVjdCIsIngiLCJmeSIsInkiLCJmdyIsImZoIiwiZmRhdGEiLCJqIiwiYmxlbmQiLCJfY29weVRpbGUiLCJwdXNoIiwic2xpY2UiLCJkaXNwb3NlIiwiYXJlYSIsImJwcCIsImRlY29kZSIsIl9nZXRCUFAiLCJicGwiLCJNYXRoIiwiY2VpbCIsImJmIiwiYmYzMiIsIlVpbnQzMkFycmF5IiwiY3R5cGUiLCJkZXB0aCIsInJzIiwiX2JpbiIsInJlYWRVc2hvcnQiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsInFhcmVhIiwidHMiLCJ0aSIsInRyIiwidGciLCJ0YiIsInFpIiwicCIsImFwIiwidGwiLCJzMCIsInQwIiwiY2oiLCJkaSIsImdyIiwib2ZmIiwidG8iLCJhbCIsImJ1ZmYiLCJvZmZzZXQiLCJiaW4iLCJyVXMiLCJyVWkiLCJyZWFkVWludCIsImRkIiwiZG9mZiIsImZkIiwiZm9mZiIsIm1nY2siLCJ0eXBlIiwicmVhZEFTQ0lJIiwiX0lIRFIiLCJudW1fZnJhbWVzIiwibnVtX3BsYXlzIiwiZnIiLCJfZGVjb21wcmVzcyIsInJjdCIsImRlbCIsImRlbGF5Iiwicm91bmQiLCJueiIsIm5leHRaZXJvIiwia2V5dyIsInRleHQiLCJjZmxhZyIsImNtZXRoIiwibHRhZyIsInRrZXl3IiwicmVhZFVURjgiLCJyZWFkQnl0ZXMiLCJwbCIsImNyYyIsImNvbXByZXNzIiwiaW50ZXJsYWNlIiwiZmlsdGVyIiwiX2luZmxhdGUiLCJfZmlsdGVyWmVybyIsIl9yZWFkSW50ZXJsYWNlIiwiaW5mbGF0ZVJhdyIsIkgiLCJOIiwiVyIsIlIiLCJtIiwiSiIsIlEiLCJYIiwidSIsImQiLCJ2IiwiQyIsIlYiLCJuIiwiYiIsIkEiLCJlIiwibCIsIk0iLCJJIiwiWiIsIkQiLCJxIiwic2V0IiwiYnl0ZU9mZnNldCIsIkUiLCJjIiwiSyIsInIiLCJTIiwiVCIsInoiLCJfIiwiJCIsInMiLCJZIiwiYSIsIlVpbnQxNkFycmF5IiwidCIsImsiLCJnIiwiY2JwcCIsInN0YXJ0aW5nX3JvdyIsInN0YXJ0aW5nX2NvbCIsInJvd19pbmNyZW1lbnQiLCJjb2xfaW5jcmVtZW50IiwicGFzcyIsInJpIiwiY2kiLCJzdyIsInNoIiwiY3IiLCJjYyIsImJwbGwiLCJyb3ciLCJjb2wiLCJjZGkiLCJ2YWwiLCJpaSIsIm5vYyIsInBhZXRoIiwiX3BhZXRoIiwicGEiLCJwYiIsInBjIiwid3JpdGVVc2hvcnQiLCJ3cml0ZVVpbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ3cml0ZUFTQ0lJIiwiY2hhckNvZGVBdCIsImFyciIsInBhZCIsIm5zIiwidG9TdHJpbmciLCJkZWNvZGVVUklDb21wb25lbnQiLCJzYiIsInR3IiwidGgiLCJ4b2ZmIiwieW9mZiIsIm1vZGUiLCJtaW4iLCJzaSIsImZhIiwiZmciLCJmYiIsImJhIiwiYnIiLCJiZyIsImJiIiwiaWZhIiwib2EiLCJpb2EiLCJlbmNvZGUiLCJidWZzIiwicHMiLCJkZWxzIiwiZm9yYmlkUGx0ZSIsIm5pbWciLCJjb21wcmVzc1BORyIsIl9tYWluIiwiZW5jb2RlTEwiLCJhYyIsImJpcHAiLCJiaXBsIiwid1VpIiwid1VzIiwid0FzIiwiYW5pbSIsInBsdEFscGhhIiwibGVuZyIsImRsIiwicGx0ZSIsImNpbWciLCJ3ciIsImZpIiwiaW1nZCIsImlvZmYiLCJsZXZlbFplcm8iLCJudyIsIm5oIiwicHJtcyIsIm9ubHlCbGVuZCIsImV2ZW5DcmQiLCJmb3JiaWRQcmV2IiwibWluQml0cyIsImFscGhhQW5kIiwiaWxlbiIsImdvdEFscGhhIiwiZnJhbWl6ZSIsImNtYXAiLCJpbmRzIiwibmJ1ZnMiLCJhYnVmIiwiY29uY2F0UkdCQSIsInFyZXMiLCJxdWFudGl6ZSIsImNvZiIsImJsbiIsImVzdCIsInJnYmEiLCJpbWczMiIsImluZCIsImNtYyIsIm1heCIsIm54IiwibnkiLCJjaW1nMzIiLCJpbmoiLCJhbHdheXNCbGVuZCIsInRsaW0iLCJ0c3RwIiwidGFyZWEiLCJpdCIsInBpbWciLCJwMzIiLCJtaXgiLCJtaXkiLCJtYXkiLCJzYXJlYSIsIl9wcmVwYXJlRGlmZiIsInIwIiwicjEiLCJtaVgiLCJtaVkiLCJtYVgiLCJtYVkiLCJfdXBkYXRlRnJhbWUiLCJVOCIsIlUzMiIsInBpbWczMiIsImN4IiwiY3kiLCJyZWMiLCJmbHMiLCJmdHJ5Iiwib3B0cyIsImxldmVsIiwiQ01QUiIsIlVaSVAiLCJfZmlsdGVyTGluZSIsInRzaXplIiwidGFibGUiLCJ0YWIiLCJ1cGRhdGUiLCJidWYiLCJvIiwib2ltZyIsIm5pbWczMiIsIktEIiwiZ2V0S0R0cmVlIiwicm9vdCIsImxlYWZzIiwicGxhbmVEc3QiLCJuZCIsImdldE5lYXJlc3QiLCJlcnIiLCJpMCIsImkxIiwiYnN0IiwidGRzdCIsImxlZnQiLCJyaWdodCIsInN0YXRzIiwiZXN0YXRzIiwibWF4TCIsIm1pIiwiTCIsIm5vZGUiLCJzcGxpdFBpeGVscyIsImVNcTI1NSIsInMwd3JvbmciLCJsbiIsInJuIiwic29ydCIsImRpc3QiLCJub2RlMCIsIm5vZGUxIiwiZU1xIiwiZDAiLCJkMSIsImQyIiwiZDMiLCJ2ZWNEb3QiLCJzaGZzIiwibTAiLCJtMSIsIm0yIiwibTMiLCJpTiIsIlJqIiwiTTQiLCJ0bWkiLCJtdWx0VmVjIiwic3FydCIsImRvdCIsInNtbCIsImFicyIsIkNvdiIsInRsZW4iLCJieXRlTGVuZ3RoIiwibm9mZiIsImlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/UPNG.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Top level file is just a mixin of submodules & constants\n\nvar assign = (__webpack_require__(/*! ./lib/utils/common */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\").assign);\nvar deflate = __webpack_require__(/*! ./lib/deflate */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/deflate.js\");\nvar inflate = __webpack_require__(/*! ./lib/inflate */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js\");\nvar pako = {};\nassign(pako, deflate, inflate, constants);\nmodule.exports = pako;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyREFBMkQ7QUFDM0Q7QUFFQSxJQUFJQSxTQUFZQyxrSUFBb0M7QUFFcEQsSUFBSUMsVUFBWUQsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUUsVUFBWUYsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUcsWUFBWUgsbUJBQU9BLENBQUM7QUFFeEIsSUFBSUksT0FBTyxDQUFDO0FBRVpMLE9BQU9LLE1BQU1ILFNBQVNDLFNBQVNDO0FBRS9CRSxPQUFPQyxPQUFPLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanM/OTAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMvY29tbW9uJykuYXNzaWduO1xuXG52YXIgZGVmbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xudmFyIGluZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG52YXIgcGFrbyA9IHt9O1xuXG5hc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWtvO1xuIl0sIm5hbWVzIjpbImFzc2lnbiIsInJlcXVpcmUiLCJkZWZsYXRlIiwiaW5mbGF0ZSIsImNvbnN0YW50cyIsInBha28iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/deflate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/deflate.js\");\nvar utils = __webpack_require__(/*! ./utils/common */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar strings = __webpack_require__(/*! ./utils/strings */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js\");\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js\");\nvar toString = Object.prototype.toString;\n/* Public constants ==========================================================*/ /* ===========================================================================*/ var Z_NO_FLUSH = 0;\nvar Z_FINISH = 4;\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_SYNC_FLUSH = 2;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_DEFAULT_STRATEGY = 0;\nvar Z_DEFLATED = 8;\n/* ===========================================================================*/ /**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/ /* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/ /**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/ /**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/ /**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/ /**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/ function Deflate(options) {\n    if (!(this instanceof Deflate)) return new Deflate(options);\n    this.options = utils.assign({\n        level: Z_DEFAULT_COMPRESSION,\n        method: Z_DEFLATED,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY,\n        to: \"\"\n    }, options || {});\n    var opt = this.options;\n    if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits;\n    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16;\n    }\n    this.err = 0; // error code, if happens (0 = Z_OK)\n    this.msg = \"\"; // error message\n    this.ended = false; // used to avoid multiple onEnd() calls\n    this.chunks = []; // chunks of compressed data\n    this.strm = new ZStream();\n    this.strm.avail_out = 0;\n    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n    if (status !== Z_OK) {\n        throw new Error(msg[status]);\n    }\n    if (opt.header) {\n        zlib_deflate.deflateSetHeader(this.strm, opt.header);\n    }\n    if (opt.dictionary) {\n        var dict;\n        // Convert data if needed\n        if (typeof opt.dictionary === \"string\") {\n            // If we need to compress text, change encoding to utf8.\n            dict = strings.string2buf(opt.dictionary);\n        } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n            dict = new Uint8Array(opt.dictionary);\n        } else {\n            dict = opt.dictionary;\n        }\n        status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n        if (status !== Z_OK) {\n            throw new Error(msg[status]);\n        }\n        this._dict_set = true;\n    }\n}\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/ Deflate.prototype.push = function(data, mode) {\n    var strm = this.strm;\n    var chunkSize = this.options.chunkSize;\n    var status, _mode;\n    if (this.ended) {\n        return false;\n    }\n    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;\n    // Convert data if needed\n    if (typeof data === \"string\") {\n        // If we need to compress text, change encoding to utf8.\n        strm.input = strings.string2buf(data);\n    } else if (toString.call(data) === \"[object ArrayBuffer]\") {\n        strm.input = new Uint8Array(data);\n    } else {\n        strm.input = data;\n    }\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n    do {\n        if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n        }\n        status = zlib_deflate.deflate(strm, _mode); /* no bad return value */ \n        if (status !== Z_STREAM_END && status !== Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n        }\n        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {\n            if (this.options.to === \"string\") {\n                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n            } else {\n                this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n            }\n        }\n    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n    // Finalize on the last chunk.\n    if (_mode === Z_FINISH) {\n        status = zlib_deflate.deflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === Z_OK;\n    }\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === Z_SYNC_FLUSH) {\n        this.onEnd(Z_OK);\n        strm.avail_out = 0;\n        return true;\n    }\n    return true;\n};\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/ Deflate.prototype.onData = function(chunk) {\n    this.chunks.push(chunk);\n};\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/ Deflate.prototype.onEnd = function(status) {\n    // On success - join\n    if (status === Z_OK) {\n        if (this.options.to === \"string\") {\n            this.result = this.chunks.join(\"\");\n        } else {\n            this.result = utils.flattenChunks(this.chunks);\n        }\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n};\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/ function deflate(input, options) {\n    var deflator = new Deflate(options);\n    deflator.push(input, true);\n    // That will never happens, if you don't cheat with options :)\n    if (deflator.err) {\n        throw deflator.msg || msg[deflator.err];\n    }\n    return deflator.result;\n}\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/ function deflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return deflate(input, options);\n}\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/ function gzip(input, options) {\n    options = options || {};\n    options.gzip = true;\n    return deflate(input, options);\n}\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUdBLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlDLFFBQWVELG1CQUFPQSxDQUFDO0FBQzNCLElBQUlFLFVBQWVGLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlHLE1BQWVILG1CQUFPQSxDQUFDO0FBQzNCLElBQUlJLFVBQWVKLG1CQUFPQSxDQUFDO0FBRTNCLElBQUlLLFdBQVdDLE9BQU9DLFNBQVMsQ0FBQ0YsUUFBUTtBQUV4Qyw4RUFBOEUsR0FDOUUsOEVBQThFLEdBRTlFLElBQUlHLGFBQWtCO0FBQ3RCLElBQUlDLFdBQWtCO0FBRXRCLElBQUlDLE9BQWtCO0FBQ3RCLElBQUlDLGVBQWtCO0FBQ3RCLElBQUlDLGVBQWtCO0FBRXRCLElBQUlDLHdCQUF3QixDQUFDO0FBRTdCLElBQUlDLHFCQUF3QjtBQUU1QixJQUFJQyxhQUFjO0FBRWxCLDhFQUE4RSxHQUc5RTs7Ozs7O0VBTUUsR0FFRjs7OztFQUlFLEdBRUY7Ozs7Ozs7O0VBUUUsR0FFRjs7Ozs7OztFQU9FLEdBRUY7Ozs7RUFJRSxHQUdGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFnREUsR0FDRixTQUFTQyxRQUFRQyxPQUFPO0lBQ3RCLElBQUksQ0FBRSxLQUFJLFlBQVlELE9BQU0sR0FBSSxPQUFPLElBQUlBLFFBQVFDO0lBRW5ELElBQUksQ0FBQ0EsT0FBTyxHQUFHaEIsTUFBTWlCLE1BQU0sQ0FBQztRQUMxQkMsT0FBT047UUFDUE8sUUFBUUw7UUFDUk0sV0FBVztRQUNYQyxZQUFZO1FBQ1pDLFVBQVU7UUFDVkMsVUFBVVY7UUFDVlcsSUFBSTtJQUNOLEdBQUdSLFdBQVcsQ0FBQztJQUVmLElBQUlTLE1BQU0sSUFBSSxDQUFDVCxPQUFPO0lBRXRCLElBQUlTLElBQUlDLEdBQUcsSUFB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QUFFakMsT0FBTztJQUNoQ0EsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCQSxRQUFRVSxHQUFHLEdBQUc7SUFDZCxPQUFPOEIsUUFBUVAsT0FBT2pDO0FBQ3hCO0FBR0E7Ozs7Ozs7RUFPRSxHQUNGLFNBQVNXLEtBQUtzQixLQUFLLEVBQUVqQyxPQUFPO0lBQzFCQSxVQUFVQSxXQUFXLENBQUM7SUFDdEJBLFFBQVFXLElBQUksR0FBRztJQUNmLE9BQU82QixRQUFRUCxPQUFPakM7QUFDeEI7QUFHQW9ELGVBQWUsR0FBR3JEO0FBQ2xCcUQsZUFBZSxHQUFHWjtBQUNsQlksa0JBQWtCLEdBQUdEO0FBQ3JCQyxZQUFZLEdBQUd6QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzPzViYjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIHZhciBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBkYXRhID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuIl0sIm5hbWVzIjpbInpsaWJfZGVmbGF0ZSIsInJlcXVpcmUiLCJ1dGlscyIsInN0cmluZ3MiLCJtc2ciLCJaU3RyZWFtIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJaX05PX0ZMVVNIIiwiWl9GSU5JU0giLCJaX09LIiwiWl9TVFJFQU1fRU5EIiwiWl9TWU5DX0ZMVVNIIiwiWl9ERUZBVUxUX0NPTVBSRVNTSU9OIiwiWl9ERUZBVUxUX1NUUkFURUdZIiwiWl9ERUZMQVRFRCIsIkRlZmxhdGUiLCJvcHRpb25zIiwiYXNzaWduIiwibGV2ZWwiLCJtZXRob2QiLCJjaHVua1NpemUiLCJ3aW5kb3dCaXRzIiwibWVtTGV2ZWwiLCJzdHJhdGVneSIsInRvIiwib3B0IiwicmF3IiwiZ3ppcCIsImVyciIsImVuZGVkIiwiY2h1bmtzIiwic3RybSIsImF2YWlsX291dCIsInN0YXR1cyIsImRlZmxhdGVJbml0MiIsIkVycm9yIiwiaGVhZGVyIiwiZGVmbGF0ZVNldEhlYWRlciIsImRpY3Rpb25hcnkiLCJkaWN0Iiwic3RyaW5nMmJ1ZiIsImNhbGwiLCJVaW50OEFycmF5IiwiZGVmbGF0ZVNldERpY3Rpb25hcnkiLCJfZGljdF9zZXQiLCJwdXNoIiwiZGF0YSIsIm1vZGUiLCJfbW9kZSIsImlucHV0IiwibmV4dF9pbiIsImF2YWlsX2luIiwibGVuZ3RoIiwib3V0cHV0IiwiQnVmOCIsIm5leHRfb3V0IiwiZGVmbGF0ZSIsIm9uRW5kIiwib25EYXRhIiwiYnVmMmJpbnN0cmluZyIsInNocmlua0J1ZiIsImRlZmxhdGVFbmQiLCJjaHVuayIsInJlc3VsdCIsImpvaW4iLCJmbGF0dGVuQ2h1bmtzIiwiZGVmbGF0b3IiLCJkZWZsYXRlUmF3IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/inflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/inflate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inflate.js\");\nvar utils = __webpack_require__(/*! ./utils/common */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar strings = __webpack_require__(/*! ./utils/strings */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js\");\nvar c = __webpack_require__(/*! ./zlib/constants */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js\");\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader = __webpack_require__(/*! ./zlib/gzheader */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/gzheader.js\");\nvar toString = Object.prototype.toString;\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/ /* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/ /**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/ /**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/ /**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/ /**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/ function Inflate(options) {\n    if (!(this instanceof Inflate)) return new Inflate(options);\n    this.options = utils.assign({\n        chunkSize: 16384,\n        windowBits: 0,\n        to: \"\"\n    }, options || {});\n    var opt = this.options;\n    // Force window size for `raw` data, if not set directly,\n    // because we have no header for autodetect.\n    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n        opt.windowBits = -opt.windowBits;\n        if (opt.windowBits === 0) {\n            opt.windowBits = -15;\n        }\n    }\n    // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {\n        opt.windowBits += 32;\n    }\n    // Gzip header has no info about windows size, we can do autodetect only\n    // for deflate. So, if window size not set, force it to max when gzip possible\n    if (opt.windowBits > 15 && opt.windowBits < 48) {\n        // bit 3 (16) -> gzipped data\n        // bit 4 (32) -> autodetect gzip/deflate\n        if ((opt.windowBits & 15) === 0) {\n            opt.windowBits |= 15;\n        }\n    }\n    this.err = 0; // error code, if happens (0 = Z_OK)\n    this.msg = \"\"; // error message\n    this.ended = false; // used to avoid multiple onEnd() calls\n    this.chunks = []; // chunks of compressed data\n    this.strm = new ZStream();\n    this.strm.avail_out = 0;\n    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n    if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n    }\n    this.header = new GZheader();\n    zlib_inflate.inflateGetHeader(this.strm, this.header);\n    // Setup dictionary\n    if (opt.dictionary) {\n        // Convert data if needed\n        if (typeof opt.dictionary === \"string\") {\n            opt.dictionary = strings.string2buf(opt.dictionary);\n        } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n            opt.dictionary = new Uint8Array(opt.dictionary);\n        }\n        if (opt.raw) {\n            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n            if (status !== c.Z_OK) {\n                throw new Error(msg[status]);\n            }\n        }\n    }\n}\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/ Inflate.prototype.push = function(data, mode) {\n    var strm = this.strm;\n    var chunkSize = this.options.chunkSize;\n    var dictionary = this.options.dictionary;\n    var status, _mode;\n    var next_out_utf8, tail, utf8str;\n    // Flag to properly process Z_BUF_ERROR on testing inflate call\n    // when we check that all output data was flushed.\n    var allowBufError = false;\n    if (this.ended) {\n        return false;\n    }\n    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;\n    // Convert data if needed\n    if (typeof data === \"string\") {\n        // Only binary strings can be decompressed on practice\n        strm.input = strings.binstring2buf(data);\n    } else if (toString.call(data) === \"[object ArrayBuffer]\") {\n        strm.input = new Uint8Array(data);\n    } else {\n        strm.input = data;\n    }\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n    do {\n        if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n        }\n        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */ \n        if (status === c.Z_NEED_DICT && dictionary) {\n            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n        }\n        if (status === c.Z_BUF_ERROR && allowBufError === true) {\n            status = c.Z_OK;\n            allowBufError = false;\n        }\n        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n        }\n        if (strm.next_out) {\n            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {\n                if (this.options.to === \"string\") {\n                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n                    tail = strm.next_out - next_out_utf8;\n                    utf8str = strings.buf2string(strm.output, next_out_utf8);\n                    // move tail\n                    strm.next_out = tail;\n                    strm.avail_out = chunkSize - tail;\n                    if (tail) {\n                        utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);\n                    }\n                    this.onData(utf8str);\n                } else {\n                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n                }\n            }\n        }\n        // When no more input data, we should check that internal inflate buffers\n        // are flushed. The only way to do it when avail_out = 0 - run one more\n        // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n        // Here we set flag to process this error properly.\n        //\n        // NOTE. Deflate does not return error in this case and does not needs such\n        // logic.\n        if (strm.avail_in === 0 && strm.avail_out === 0) {\n            allowBufError = true;\n        }\n    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n    if (status === c.Z_STREAM_END) {\n        _mode = c.Z_FINISH;\n    }\n    // Finalize on the last chunk.\n    if (_mode === c.Z_FINISH) {\n        status = zlib_inflate.inflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === c.Z_OK;\n    }\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === c.Z_SYNC_FLUSH) {\n        this.onEnd(c.Z_OK);\n        strm.avail_out = 0;\n        return true;\n    }\n    return true;\n};\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/ Inflate.prototype.onData = function(chunk) {\n    this.chunks.push(chunk);\n};\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/ Inflate.prototype.onEnd = function(status) {\n    // On success - join\n    if (status === c.Z_OK) {\n        if (this.options.to === \"string\") {\n            // Glue & convert here, until we teach pako to send\n            // utf8 aligned strings to onData\n            this.result = this.chunks.join(\"\");\n        } else {\n            this.result = utils.flattenChunks(this.chunks);\n        }\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n};\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/ function inflate(input, options) {\n    var inflator = new Inflate(options);\n    inflator.push(input, true);\n    // That will never happens, if you don't cheat with options :)\n    if (inflator.err) {\n        throw inflator.msg || msg[inflator.err];\n    }\n    return inflator.result;\n}\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/ function inflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return inflate(input, options);\n}\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/ exports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip = inflate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUdBLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlDLFFBQWVELG1CQUFPQSxDQUFDO0FBQzNCLElBQUlFLFVBQWVGLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlHLElBQWVILG1CQUFPQSxDQUFDO0FBQzNCLElBQUlJLE1BQWVKLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlLLFVBQWVMLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlNLFdBQWVOLG1CQUFPQSxDQUFDO0FBRTNCLElBQUlPLFdBQVdDLE9BQU9DLFNBQVMsQ0FBQ0YsUUFBUTtBQUV4Qzs7Ozs7O0VBTUUsR0FFRjs7OztFQUlFLEdBRUY7Ozs7Ozs7O0VBUUUsR0FFRjs7Ozs7RUFLRSxHQUVGOzs7O0VBSUUsR0FHRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXdDRSxHQUNGLFNBQVNHLFFBQVFDLE9BQU87SUFDdEIsSUFBSSxDQUFFLEtBQUksWUFBWUQsT0FBTSxHQUFJLE9BQU8sSUFBSUEsUUFBUUM7SUFFbkQsSUFBSSxDQUFDQSxPQUFPLEdBQUdWLE1BQU1XLE1BQU0sQ0FBQztRQUMxQkMsV0FBVztRQUNYQyxZQUFZO1FBQ1pDLElBQUk7SUFDTixHQUFHSixXQUFXLENBQUM7SUFFZixJQUFJSyxNQUFNLElBQUksQ0FBQ0wsT0FBTztJQUV0Qix5REFBeUQ7SUFDekQsNENBQTRDO0lBQzVDLElBQUlLLElBQUlDLEdBQUcsSUFBS0QsSUFBSUYsVUFBVSxJQUFJLEtBQU9FLElBQUlGLFVBQVUsR0FBRyxJQUFLO1FBQzdERSxJQUFJRixVQUFVLEdBQUcsQ0FBQ0UsSUFBSUYsVUFBVTtRQUNoQyxJQUFJRSxJQUFJRixVQUFVLEtBQUssR0FBRztZQUFFRSxJQUFJRixVQUFVLEdBQUcsQ0FBQztRQUFJO0lBQ3BEO0lBRUEs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QUFJeUQsV0FBVyxJQUFJMUQsUUFBUUM7SUFFM0J5RCxTQUFTbEMsSUFBSSxDQUFDVSxPQUFPO0lBRXJCLDhEQUE4RDtJQUM5RCxJQUFJd0IsU0FBU2xELEdBQUcsRUFBRTtRQUFFLE1BQU1rRCxTQUFTaEUsR0FBRyxJQUFJQSxHQUFHLENBQUNnRSxTQUFTbEQsR0FBRyxDQUFDO0lBQUU7SUFFN0QsT0FBT2tELFNBQVNILE1BQU07QUFDeEI7QUFHQTs7Ozs7OztFQU9FLEdBQ0YsU0FBU0ksV0FBV3pCLEtBQUssRUFBRWpDLE9BQU87SUFDaENBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QkEsUUFBUU0sR0FBRyxHQUFHO0lBQ2QsT0FBT21DLFFBQVFSLE9BQU9qQztBQUN4QjtBQUdBOzs7Ozs7O0VBT0UsR0FHRjJELGVBQWUsR0FBRzVEO0FBQ2xCNEQsZUFBZSxHQUFHbEI7QUFDbEJrQixrQkFBa0IsR0FBR0Q7QUFDckJDLGNBQWMsR0FBSWxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanM/MTUzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIl0sIm5hbWVzIjpbInpsaWJfaW5mbGF0ZSIsInJlcXVpcmUiLCJ1dGlscyIsInN0cmluZ3MiLCJjIiwibXNnIiwiWlN0cmVhbSIsIkdaaGVhZGVyIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJJbmZsYXRlIiwib3B0aW9ucyIsImFzc2lnbiIsImNodW5rU2l6ZSIsIndpbmRvd0JpdHMiLCJ0byIsIm9wdCIsInJhdyIsImVyciIsImVuZGVkIiwiY2h1bmtzIiwic3RybSIsImF2YWlsX291dCIsInN0YXR1cyIsImluZmxhdGVJbml0MiIsIlpfT0siLCJFcnJvciIsImhlYWRlciIsImluZmxhdGVHZXRIZWFkZXIiLCJkaWN0aW9uYXJ5Iiwic3RyaW5nMmJ1ZiIsImNhbGwiLCJVaW50OEFycmF5IiwiaW5mbGF0ZVNldERpY3Rpb25hcnkiLCJwdXNoIiwiZGF0YSIsIm1vZGUiLCJfbW9kZSIsIm5leHRfb3V0X3V0ZjgiLCJ0YWlsIiwidXRmOHN0ciIsImFsbG93QnVmRXJyb3IiLCJaX0ZJTklTSCIsIlpfTk9fRkxVU0giLCJpbnB1dCIsImJpbnN0cmluZzJidWYiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJsZW5ndGgiLCJvdXRwdXQiLCJCdWY4IiwibmV4dF9vdXQiLCJpbmZsYXRlIiwiWl9ORUVEX0RJQ1QiLCJaX0JVRl9FUlJPUiIsIlpfU1RSRUFNX0VORCIsIm9uRW5kIiwiWl9TWU5DX0ZMVVNIIiwidXRmOGJvcmRlciIsImJ1ZjJzdHJpbmciLCJhcnJheVNldCIsIm9uRGF0YSIsInNocmlua0J1ZiIsImluZmxhdGVFbmQiLCJjaHVuayIsInJlc3VsdCIsImpvaW4iLCJmbGF0dGVuQ2h1bmtzIiwiaW5mbGF0b3IiLCJpbmZsYXRlUmF3IiwiZXhwb3J0cyIsInVuZ3ppcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/inflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nvar TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\nfunction _has(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexports.assign = function(obj /*from1, from2, from3, ...*/ ) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    while(sources.length){\n        var source = sources.shift();\n        if (!source) {\n            continue;\n        }\n        if (typeof source !== \"object\") {\n            throw new TypeError(source + \"must be non-object\");\n        }\n        for(var p in source){\n            if (_has(source, p)) {\n                obj[p] = source[p];\n            }\n        }\n    }\n    return obj;\n};\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function(buf, size) {\n    if (buf.length === size) {\n        return buf;\n    }\n    if (buf.subarray) {\n        return buf.subarray(0, size);\n    }\n    buf.length = size;\n    return buf;\n};\nvar fnTyped = {\n    arraySet: function(dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n            return;\n        }\n        // Fallback to ordinary array\n        for(var i = 0; i < len; i++){\n            dest[dest_offs + i] = src[src_offs + i];\n        }\n    },\n    // Join array of chunks to single array.\n    flattenChunks: function(chunks) {\n        var i, l, len, pos, chunk, result;\n        // calculate data length\n        len = 0;\n        for(i = 0, l = chunks.length; i < l; i++){\n            len += chunks[i].length;\n        }\n        // join chunks\n        result = new Uint8Array(len);\n        pos = 0;\n        for(i = 0, l = chunks.length; i < l; i++){\n            chunk = chunks[i];\n            result.set(chunk, pos);\n            pos += chunk.length;\n        }\n        return result;\n    }\n};\nvar fnUntyped = {\n    arraySet: function(dest, src, src_offs, len, dest_offs) {\n        for(var i = 0; i < len; i++){\n            dest[dest_offs + i] = src[src_offs + i];\n        }\n    },\n    // Join array of chunks to single array.\n    flattenChunks: function(chunks) {\n        return [].concat.apply([], chunks);\n    }\n};\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function(on) {\n    if (on) {\n        exports.Buf8 = Uint8Array;\n        exports.Buf16 = Uint16Array;\n        exports.Buf32 = Int32Array;\n        exports.assign(exports, fnTyped);\n    } else {\n        exports.Buf8 = Array;\n        exports.Buf16 = Array;\n        exports.Buf32 = Array;\n        exports.assign(exports, fnUntyped);\n    }\n};\nexports.setTyped(TYPED_OK);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBR0EsSUFBSUEsV0FBWSxPQUFRQyxlQUFlLGVBQ3RCLE9BQU9DLGdCQUFnQixlQUN2QixPQUFPQyxlQUFlO0FBRXZDLFNBQVNDLEtBQUtDLEdBQUcsRUFBRUMsR0FBRztJQUNwQixPQUFPQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDTCxLQUFLQztBQUNuRDtBQUVBSyxjQUFjLEdBQUcsU0FBVU4sSUFBSSwwQkFBMEIsR0FBM0I7SUFDNUIsSUFBSVEsVUFBVUMsTUFBTU4sU0FBUyxDQUFDTyxLQUFLLENBQUNMLElBQUksQ0FBQ00sV0FBVztJQUNwRCxNQUFPSCxRQUFRSSxNQUFNLENBQUU7UUFDckIsSUFBSUMsU0FBU0wsUUFBUU0sS0FBSztRQUMxQixJQUFJLENBQUNELFFBQVE7WUFBRTtRQUFVO1FBRXpCLElBQUksT0FBT0EsV0FBVyxVQUFVO1lBQzlCLE1BQU0sSUFBSUUsVUFBVUYsU0FBUztRQUMvQjtRQUVBLElBQUssSUFBSUcsS0FBS0gsT0FBUTtZQUNwQixJQUFJZCxLQUFLYyxRQUFRRyxJQUFJO2dCQUNuQmhCLEdBQUcsQ0FBQ2dCLEVBQUUsR0FBR0gsTUFBTSxDQUFDRyxFQUFFO1lBQ3BCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9oQjtBQUNUO0FBR0Esd0NBQXdDO0FBQ3hDTSxpQkFBaUIsR0FBRyxTQUFVWSxHQUFHLEVBQUVDLElBQUk7SUFDckMsSUFBSUQsSUFBSU4sTUFBTSxLQUFLTyxNQUFNO1FBQUUsT0FBT0Q7SUFBSztJQUN2QyxJQUFJQSxJQUFJRSxRQUFRLEVBQUU7UUFBRSxPQUFPRixJQUFJRSxRQUFRLENBQUMsR0FBR0Q7SUFBTztJQUNsREQsSUFBSU4sTUFBTSxHQUFHTztJQUNiLE9BQU9EO0FBQ1Q7QUFHQSxJQUFJRyxVQUFVO0lBQ1pDLFVBQVUsU0FBVUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsR0FBRyxFQUFFQyxTQUFTO1FBQ3JELElBQUlILElBQUlKLFFBQVEsSUFBSUcsS0FBS0gsUUFBUSxFQUFFO1lBQ2pDRyxLQUFLSyxHQUFHLENBQUNKLElBQUlKLFFBQVEsQ0FBQ0ssVUFBVUEsV0FBV0MsTUFBTUM7WUFDakQ7UUFDRjtRQUNBLDZCQUE2QjtRQUM3QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUgsS0FBS0csSUFBSztZQUM1Qk4sSUFBSSxDQUFDSSxZQUFZRSxFQUFFLEdBQUdMLEdBQUcsQ0FBQ0MsV0FBV0ksRUFBRTtRQUN6QztJQUNGO0lBQ0Esd0NBQXdDO0lBQ3hDQyxlQUFlLFNBQVVDLE1BQU07UUFDN0IsSUFBSUYsR0FBR0csR0FBR04sS0FBS08sS0FBS0MsT0FBT0M7UUFFM0Isd0JBQXdCO1FBQ3hCVCxNQUFNO1FBQ04sSUFBS0csSUFBSSxHQUFHRyxJQUFJRCxPQUFPbkIsTUFBTSxFQUFFaUIsSUFBSUcsR0FBR0gsSUFBSztZQUN6Q0gsT0FBT0ssTUFBTSxDQUFDRixFQUFFLENBQUNqQixNQUFNO1FBQ3pCO1FBRUEsY0FBYztRQUNkdUIsU0FBUyxJQUFJdkMsV0FBVzhCO1FBQ3hCTyxNQUFNO1FBQ04sSUFBS0osSUFBSSxHQUFHRyxJQUFJRCxPQUFPbkIsTUFBTSxFQUFFaUIsSUFBSUcsR0FBR0gsSUFBSztZQUN6Q0ssUUFBUUgsTUFBTSxDQUFDRixFQUFFO1lBQ2pCTSxPQUFPUCxHQUFHLENBQUNNLE9BQU9EO1lBQ2xCQSxPQUFPQyxNQUFNdEIsTUFBTTtRQUNyQjtRQUVBLE9BQU91QjtJQUNUO0FBQ0Y7QUFFQSxJQUFJQyxZQUFZO0lBQ2RkLFVBQVUsU0FBVUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsR0FBRyxFQUFFQyxTQUFTO1FBQ3JELElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJSCxLQUFLRyxJQUFLO1lBQzVCTixJQUFJLENBQUNJLFlBQVlFLEVBQUUsR0FBR0wsR0FBRyxDQUFDQyxXQUFXSSxFQUFFO1FBQ3pDO0lBQ0Y7SUFDQSx3Q0FBd0M7SUFDeENDLGVBQWUsU0FBVUMsTUFBTTtRQUM3QixPQUFPLEVBQUUsQ0FBQ00sTUFBTSxDQUFDQyxLQUFLLENBQUMsRUFBRSxFQUFFUDtJQUM3QjtBQUNGO0FBR0EsK0NBQStDO0FBQy9DLEVBQUU7QUFDRnpCLGdCQUFnQixHQUFHLFNBQVVrQyxFQUFFO0lBQzdCLElBQUlBLElBQUk7UUFDTmxDLFlBQVksR0FBSVY7UUFDaEJVLGFBQWEsR0FBR1Q7UUFDaEJTLGFBQWEsR0FBR1I7UUFDaEJRLFFBQVFDLE1BQU0sQ0FBQ0QsU0FBU2U7SUFDMUIsT0FBTztRQUNMZixZQUFZLEdBQUlHO1FBQ2hCSCxhQUFhLEdBQUdHO1FBQ2hCSCxhQUFhLEdBQUdHO1FBQ2hCSCxRQUFRQyxNQUFNLENBQUNELFNBQVM4QjtJQUMxQjtBQUNGO0FBRUE5QixRQUFRaUMsUUFBUSxDQUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzP2Q5YTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iXSwibmFtZXMiOlsiVFlQRURfT0siLCJVaW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiX2hhcyIsIm9iaiIsImtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImV4cG9ydHMiLCJhc3NpZ24iLCJzb3VyY2VzIiwiQXJyYXkiLCJzbGljZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsInNoaWZ0IiwiVHlwZUVycm9yIiwicCIsInNocmlua0J1ZiIsImJ1ZiIsInNpemUiLCJzdWJhcnJheSIsImZuVHlwZWQiLCJhcnJheVNldCIsImRlc3QiLCJzcmMiLCJzcmNfb2ZmcyIsImxlbiIsImRlc3Rfb2ZmcyIsInNldCIsImkiLCJmbGF0dGVuQ2h1bmtzIiwiY2h1bmtzIiwibCIsInBvcyIsImNodW5rIiwicmVzdWx0IiwiZm5VbnR5cGVkIiwiY29uY2F0IiwiYXBwbHkiLCJzZXRUeXBlZCIsIm9uIiwiQnVmOCIsIkJ1ZjE2IiwiQnVmMzIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// String encode/decode helpers\n\nvar utils = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\ntry {\n    String.fromCharCode.apply(null, [\n        0\n    ]);\n} catch (__) {\n    STR_APPLY_OK = false;\n}\ntry {\n    String.fromCharCode.apply(null, new Uint8Array(1));\n} catch (__) {\n    STR_APPLY_UIA_OK = false;\n}\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor(var q = 0; q < 256; q++){\n    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\nexports.string2buf = function(str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n    // count binary size\n    for(m_pos = 0; m_pos < str_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    buf = new utils.Buf8(buf_len);\n    // convert\n    for(i = 0, m_pos = 0; i < buf_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n};\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n    // On Chrome, the arguments in a function call that are allowed is `65534`.\n    // If the length of the buffer is smaller than that, we can use this optimization,\n    // otherwise we will take a slower path.\n    if (len < 65534) {\n        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {\n            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n        }\n    }\n    var result = \"\";\n    for(var i = 0; i < len; i++){\n        result += String.fromCharCode(buf[i]);\n    }\n    return result;\n}\n// Convert byte array to binary string\nexports.buf2binstring = function(buf) {\n    return buf2binstring(buf, buf.length);\n};\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function(str) {\n    var buf = new utils.Buf8(str.length);\n    for(var i = 0, len = buf.length; i < len; i++){\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n};\n// convert array to string\nexports.buf2string = function(buf, max) {\n    var i, out, c, c_len;\n    var len = max || buf.length;\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len * 2);\n    for(out = 0, i = 0; i < len;){\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n        }\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n        }\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while(c_len > 1 && i < len){\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n        }\n        // terminated by end of string?\n        if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n        }\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n        }\n    }\n    return buf2binstring(utf16buf, out);\n};\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function(buf, max) {\n    var pos;\n    max = max || buf.length;\n    if (max > buf.length) {\n        max = buf.length;\n    }\n    // go back from last position, until start of sequence found\n    pos = max - 1;\n    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80){\n        pos--;\n    }\n    // Very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) {\n        return max;\n    }\n    // If we came to start of buffer - that means buffer is too small,\n    // return max too.\n    if (pos === 0) {\n        return max;\n    }\n    return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrQkFBK0I7QUFDL0I7QUFHQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUdwQixnRUFBZ0U7QUFDaEUsRUFBRTtBQUNGLHlDQUF5QztBQUN6QyxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLElBQUlDLGVBQWU7QUFDbkIsSUFBSUMsbUJBQW1CO0FBRXZCLElBQUk7SUFBRUMsT0FBT0MsWUFBWSxDQUFDQyxLQUFLLENBQUMsTUFBTTtRQUFFO0tBQUc7QUFBRyxFQUFFLE9BQU9DLElBQUk7SUFBRUwsZUFBZTtBQUFPO0FBQ25GLElBQUk7SUFBRUUsT0FBT0MsWUFBWSxDQUFDQyxLQUFLLENBQUMsTUFBTSxJQUFJRSxXQUFXO0FBQUssRUFBRSxPQUFPRCxJQUFJO0lBQUVKLG1CQUFtQjtBQUFPO0FBR25HLGlFQUFpRTtBQUNqRSxvRkFBb0Y7QUFDcEYsNkNBQTZDO0FBQzdDLElBQUlNLFdBQVcsSUFBSVQsTUFBTVUsSUFBSSxDQUFDO0FBQzlCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEtBQUtBLElBQUs7SUFDNUJGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUk7QUFDNUY7QUFDQUYsUUFBUSxDQUFDLElBQUksR0FBR0EsUUFBUSxDQUFDLElBQUksR0FBRyxHQUFHLHlCQUF5QjtBQUc1RCxpREFBaUQ7QUFDakRHLGtCQUFrQixHQUFHLFNBQVVFLEdBQUc7SUFDaEMsSUFBSUMsS0FBS0MsR0FBR0MsSUFBSUMsT0FBT0MsR0FBR0MsVUFBVU4sSUFBSU8sTUFBTSxFQUFFQyxVQUFVO0lBRTFELG9CQUFvQjtJQUNwQixJQUFLSixRQUFRLEdBQUdBLFFBQVFFLFNBQVNG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LENBQUNGLE1BQU0sR0FBRyxTQUFVaEIsSUFBSTtRQUNsQztJQUNGO0lBRUEsT0FBT1EsY0FBY1UsVUFBVUY7QUFDakM7QUFHQSxrREFBa0Q7QUFDbEQsdURBQXVEO0FBQ3ZELCtDQUErQztBQUMvQyxFQUFFO0FBQ0YsMkJBQTJCO0FBQzNCLG9DQUFvQztBQUNwQ3BCLGtCQUFrQixHQUFHLFNBQVVHLEdBQUcsRUFBRWdCLEdBQUc7SUFDckMsSUFBSU07SUFFSk4sTUFBTUEsT0FBT2hCLElBQUlNLE1BQU07SUFDdkIsSUFBSVUsTUFBTWhCLElBQUlNLE1BQU0sRUFBRTtRQUFFVSxNQUFNaEIsSUFBSU0sTUFBTTtJQUFFO0lBRTFDLDREQUE0RDtJQUM1RGdCLE1BQU1OLE1BQU07SUFDWixNQUFPTSxPQUFPLEtBQUssQ0FBQ3RCLEdBQUcsQ0FBQ3NCLElBQUksR0FBRyxJQUFHLE1BQU8sS0FBTTtRQUFFQTtJQUFPO0lBRXhELGtDQUFrQztJQUNsQyx5REFBeUQ7SUFDekQsSUFBSUEsTUFBTSxHQUFHO1FBQUUsT0FBT047SUFBSztJQUUzQixrRUFBa0U7SUFDbEUsa0JBQWtCO0lBQ2xCLElBQUlNLFFBQVEsR0FBRztRQUFFLE9BQU9OO0lBQUs7SUFFN0IsT0FBTyxNQUFPdEIsUUFBUSxDQUFDTSxHQUFHLENBQUNzQixJQUFJLENBQUMsR0FBR04sTUFBT00sTUFBTU47QUFDbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcz9kZjNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbnZhciBTVFJfQVBQTFlfT0sgPSB0cnVlO1xudmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlO1xuXG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFsgMCBdKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX09LID0gZmFsc2U7IH1cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7XG5mb3IgKHZhciBxID0gMDsgcSA8IDI1NjsgcSsrKSB7XG4gIF91dGY4bGVuW3FdID0gKHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlciAodXNlZCBpbiAyIHBsYWNlcylcbmZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHtcbiAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuXG4gIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gdGhhdCwgd2UgY2FuIHVzZSB0aGlzIG9wdGltaXphdGlvbixcbiAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLlxuICBpZiAobGVuIDwgNjU1MzQpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIGJ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIlNUUl9BUFBMWV9PSyIsIlNUUl9BUFBMWV9VSUFfT0siLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsIl9fIiwiVWludDhBcnJheSIsIl91dGY4bGVuIiwiQnVmOCIsInEiLCJleHBvcnRzIiwic3RyaW5nMmJ1ZiIsInN0ciIsImJ1ZiIsImMiLCJjMiIsIm1fcG9zIiwiaSIsInN0cl9sZW4iLCJsZW5ndGgiLCJidWZfbGVuIiwiY2hhckNvZGVBdCIsImJ1ZjJiaW5zdHJpbmciLCJsZW4iLCJzdWJhcnJheSIsInNocmlua0J1ZiIsInJlc3VsdCIsImJpbnN0cmluZzJidWYiLCJidWYyc3RyaW5nIiwibWF4Iiwib3V0IiwiY19sZW4iLCJ1dGYxNmJ1ZiIsIkFycmF5IiwidXRmOGJvcmRlciIsInBvcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction adler32(adler, buf, len, pos) {\n    var s1 = adler & 0xffff | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0;\n    while(len !== 0){\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len;\n        len -= n;\n        do {\n            s1 = s1 + buf[pos++] | 0;\n            s2 = s2 + s1 | 0;\n        }while (--n);\n        s1 %= 65521;\n        s2 %= 65521;\n    }\n    return s1 | s2 << 16 | 0;\n}\nmodule.exports = adler32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsMERBQTBEO0FBQzFELHFFQUFxRTtBQUNyRSw0QkFBNEI7QUFFNUIsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsU0FBU0EsUUFBUUMsS0FBSyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztJQUNuQyxJQUFJQyxLQUFLLFFBQVMsU0FBUyxHQUN2QkMsS0FBSyxVQUFZLEtBQU0sU0FBUyxHQUNoQ0MsSUFBSTtJQUVSLE1BQU9KLFFBQVEsRUFBRztRQUNoQiw0Q0FBNEM7UUFDNUMsK0NBQStDO1FBQy9DLDhCQUE4QjtRQUM5QkksSUFBSUosTUFBTSxPQUFPLE9BQU9BO1FBQ3hCQSxPQUFPSTtRQUVQLEdBQUc7WUFDREYsS0FBSyxLQUFNSCxHQUFHLENBQUNFLE1BQU0sR0FBRztZQUN4QkUsS0FBSyxLQUFNRCxLQUFLO1FBQ2xCLFFBQVMsRUFBRUUsR0FBRztRQUVkRixNQUFNO1FBQ05DLE1BQU07SUFDUjtJQUVBLE9BQU8sS0FBT0EsTUFBTSxLQUFNO0FBQzVCO0FBR0FFLE9BQU9DLE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzPzY0OTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIl0sIm5hbWVzIjpbImFkbGVyMzIiLCJhZGxlciIsImJ1ZiIsImxlbiIsInBvcyIsInMxIiwiczIiLCJuIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nmodule.exports = {\n    /* Allowed flush values; see deflate() and inflate() below for details */ Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_TREES: 6,\n    /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */ Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    //Z_MEM_ERROR:     -4,\n    Z_BUF_ERROR: -5,\n    //Z_VERSION_ERROR: -6,\n    /* compression levels */ Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    /* Possible values of the data_type field (though see inflate()) */ Z_BINARY: 0,\n    Z_TEXT: 1,\n    //Z_ASCII:                1, // = Z_TEXT (deprecated)\n    Z_UNKNOWN: 2,\n    /* The deflate compression method */ Z_DEFLATED: 8\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RUEsT0FBT0MsT0FBTyxHQUFHO0lBRWYsdUVBQXVFLEdBQ3ZFQyxZQUFvQjtJQUNwQkMsaUJBQW9CO0lBQ3BCQyxjQUFvQjtJQUNwQkMsY0FBb0I7SUFDcEJDLFVBQW9CO0lBQ3BCQyxTQUFvQjtJQUNwQkMsU0FBb0I7SUFFcEI7O0VBRUEsR0FDQUMsTUFBb0I7SUFDcEJDLGNBQW9CO0lBQ3BCQyxhQUFvQjtJQUNwQkMsU0FBbUIsQ0FBQztJQUNwQkMsZ0JBQW1CLENBQUM7SUFDcEJDLGNBQW1CLENBQUM7SUFDcEIsc0JBQXNCO0lBQ3RCQyxhQUFtQixDQUFDO0lBQ3BCLHNCQUFzQjtJQUV0QixzQkFBc0IsR0FDdEJDLGtCQUEwQjtJQUMxQkMsY0FBMEI7SUFDMUJDLG9CQUEwQjtJQUMxQkMsdUJBQXlCLENBQUM7SUFHMUJDLFlBQTBCO0lBQzFCQyxnQkFBMEI7SUFDMUJDLE9BQTBCO0lBQzFCQyxTQUEwQjtJQUMxQkMsb0JBQTBCO0lBRTFCLGlFQUFpRSxHQUNqRUMsVUFBMEI7SUFDMUJDLFFBQTBCO0lBQzFCLHFEQUFxRDtJQUNyREMsV0FBMEI7SUFFMUIsa0NBQWtDLEdBQ2xDQyxZQUEwQjtBQUU1QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcz9hM2NkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlpfTk9fRkxVU0giLCJaX1BBUlRJQUxfRkxVU0giLCJaX1NZTkNfRkxVU0giLCJaX0ZVTExfRkxVU0giLCJaX0ZJTklTSCIsIlpfQkxPQ0siLCJaX1RSRUVTIiwiWl9PSyIsIlpfU1RSRUFNX0VORCIsIlpfTkVFRF9ESUNUIiwiWl9FUlJOTyIsIlpfU1RSRUFNX0VSUk9SIiwiWl9EQVRBX0VSUk9SIiwiWl9CVUZfRVJST1IiLCJaX05PX0NPTVBSRVNTSU9OIiwiWl9CRVNUX1NQRUVEIiwiWl9CRVNUX0NPTVBSRVNTSU9OIiwiWl9ERUZBVUxUX0NPTVBSRVNTSU9OIiwiWl9GSUxURVJFRCIsIlpfSFVGRk1BTl9PTkxZIiwiWl9STEUiLCJaX0ZJWEVEIiwiWl9ERUZBVUxUX1NUUkFURUdZIiwiWl9CSU5BUlkiLCJaX1RFWFQiLCJaX1VOS05PV04iLCJaX0RFRkxBVEVEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n    for(var n = 0; n < 256; n++){\n        c = n;\n        for(var k = 0; k < 8; k++){\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n        }\n        table[n] = c;\n    }\n    return table;\n}\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc ^= -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\nmodule.exports = crc32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLG1EQUFtRDtBQUNuRCwwREFBMEQ7QUFDMUQsZ0NBQWdDO0FBRWhDLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLHdEQUF3RDtBQUN4RCxTQUFTQTtJQUNQLElBQUlDLEdBQUdDLFFBQVEsRUFBRTtJQUVqQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLQSxJQUFLO1FBQzVCRixJQUFJRTtRQUNKLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUJILElBQUssSUFBSyxJQUFNLGFBQWNBLE1BQU0sSUFBT0EsTUFBTTtRQUNuRDtRQUNBQyxLQUFLLENBQUNDLEVBQUUsR0FBR0Y7SUFDYjtJQUVBLE9BQU9DO0FBQ1Q7QUFFQSw4REFBOEQ7QUFDOUQsSUFBSUcsV0FBV0w7QUFHZixTQUFTTSxNQUFNQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQy9CLElBQUlDLElBQUlOLFVBQ0pPLE1BQU1GLE1BQU1EO0lBRWhCRixPQUFPLENBQUM7SUFFUixJQUFLLElBQUlNLElBQUlILEtBQUtHLElBQUlELEtBQUtDLElBQUs7UUFDOUJOLE1BQU0sUUFBUyxJQUFLSSxDQUFDLENBQUMsQ0FBQ0osTUFBTUMsR0FBRyxDQUFDSyxFQUFFLElBQUksS0FBSztJQUM5QztJQUVBLE9BQVFOLE1BQU8sQ0FBQyxHQUFLLFNBQVM7QUFDaEM7QUFHQU8sT0FBT0MsT0FBTyxHQUFHVCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzPzAzMDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIl0sIm5hbWVzIjpbIm1ha2VUYWJsZSIsImMiLCJ0YWJsZSIsIm4iLCJrIiwiY3JjVGFibGUiLCJjcmMzMiIsImNyYyIsImJ1ZiIsImxlbiIsInBvcyIsInQiLCJlbmQiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/deflate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/deflate.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar trees = __webpack_require__(/*! ./trees */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js\");\nvar msg = __webpack_require__(/*! ./messages */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js\");\n/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ var Z_NO_FLUSH = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\n//var Z_TREES         = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */ var Z_OK = 0;\nvar Z_STREAM_END = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR = -5;\n//var Z_VERSION_ERROR = -6;\n/* compression levels */ //var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_FILTERED = 1;\nvar Z_HUFFMAN_ONLY = 2;\nvar Z_RLE = 3;\nvar Z_FIXED = 4;\nvar Z_DEFAULT_STRATEGY = 0;\n/* Possible values of the data_type field (though see inflate()) */ //var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN = 2;\n/* The deflate compression method */ var Z_DEFLATED = 8;\n/*============================================================================*/ var MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */ var MAX_WBITS = 15;\n/* 32K LZ77 window */ var DEF_MEM_LEVEL = 8;\nvar LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;\n/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;\n/* number of distance codes */ var BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */ var MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */ var MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\nvar PRESET_DICT = 0x20;\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\nvar BS_NEED_MORE = 1; /* block not completed, need more input or more output */ \nvar BS_BLOCK_DONE = 2; /* block flush performed */ \nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */ \nvar BS_FINISH_DONE = 4; /* finish done, accept no more input or output */ \nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\nfunction err(strm, errorCode) {\n    strm.msg = msg[errorCode];\n    return errorCode;\n}\nfunction rank(f) {\n    return (f << 1) - (f > 4 ? 9 : 0);\n}\nfunction zero(buf) {\n    var len = buf.length;\n    while(--len >= 0){\n        buf[len] = 0;\n    }\n}\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */ function flush_pending(strm) {\n    var s = strm.state;\n    //_tr_flush_bits(s);\n    var len = s.pending;\n    if (len > strm.avail_out) {\n        len = strm.avail_out;\n    }\n    if (len === 0) {\n        return;\n    }\n    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n    strm.next_out += len;\n    s.pending_out += len;\n    strm.total_out += len;\n    strm.avail_out -= len;\n    s.pending -= len;\n    if (s.pending === 0) {\n        s.pending_out = 0;\n    }\n}\nfunction flush_block_only(s, last) {\n    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n    s.block_start = s.strstart;\n    flush_pending(s.strm);\n}\nfunction put_byte(s, b) {\n    s.pending_buf[s.pending++] = b;\n}\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */ function putShortMSB(s, b) {\n    //  put_byte(s, (Byte)(b >> 8));\n    //  put_byte(s, (Byte)(b & 0xff));\n    s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n    s.pending_buf[s.pending++] = b & 0xff;\n}\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */ function read_buf(strm, buf, start, size) {\n    var len = strm.avail_in;\n    if (len > size) {\n        len = size;\n    }\n    if (len === 0) {\n        return 0;\n    }\n    strm.avail_in -= len;\n    // zmemcpy(buf, strm->next_in, len);\n    utils.arraySet(buf, strm.input, strm.next_in, len, start);\n    if (strm.state.wrap === 1) {\n        strm.adler = adler32(strm.adler, buf, len, start);\n    } else if (strm.state.wrap === 2) {\n        strm.adler = crc32(strm.adler, buf, len, start);\n    }\n    strm.next_in += len;\n    strm.total_in += len;\n    return len;\n}\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */ function longest_match(s, cur_match) {\n    var chain_length = s.max_chain_length; /* max hash chain length */ \n    var scan = s.strstart; /* current string */ \n    var match; /* matched string */ \n    var len; /* length of current match */ \n    var best_len = s.prev_length; /* best match length so far */ \n    var nice_match = s.nice_match; /* stop if match long enough */ \n    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/ ;\n    var _win = s.window; // shortcut\n    var wmask = s.w_mask;\n    var prev = s.prev;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */ var strend = s.strstart + MAX_MATCH;\n    var scan_end1 = _win[scan + best_len - 1];\n    var scan_end = _win[scan + best_len];\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */ // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n    /* Do not waste too much time if we already have a good match: */ if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */ if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n    }\n    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n    do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match;\n        /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */ if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n            continue;\n        }\n        /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */ scan += 2;\n        match++;\n        // Assert(*scan == *match, \"match[2]?\");\n        /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */ do {\n        /*jshint noempty:false*/ }while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n        // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n        if (len > best_len) {\n            s.match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) {\n                break;\n            }\n            scan_end1 = _win[scan + best_len - 1];\n            scan_end = _win[scan + best_len];\n        }\n    }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n    if (best_len <= s.lookahead) {\n        return best_len;\n    }\n    return s.lookahead;\n}\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */ function fill_window(s) {\n    var _w_size = s.w_size;\n    var p, n, m, more, str;\n    //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n    do {\n        more = s.window_size - s.lookahead - s.strstart;\n        // JS ints have 32 bit, block below not needed\n        /* Deal with !@#$% 64K limit: */ //if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        //}\n        /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */ if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n            s.match_start -= _w_size;\n            s.strstart -= _w_size;\n            /* we now have strstart >= MAX_DIST */ s.block_start -= _w_size;\n            /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */ n = s.hash_size;\n            p = n;\n            do {\n                m = s.head[--p];\n                s.head[p] = m >= _w_size ? m - _w_size : 0;\n            }while (--n);\n            n = _w_size;\n            p = n;\n            do {\n                m = s.prev[--p];\n                s.prev[p] = m >= _w_size ? m - _w_size : 0;\n            /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */ }while (--n);\n            more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n            break;\n        }\n        /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */ //Assert(more >= 2, \"more < 2\");\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        /* Initialize the hash value now that we have some input: */ if (s.lookahead + s.insert >= MIN_MATCH) {\n            str = s.strstart - s.insert;\n            s.ins_h = s.window[str];\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //        Call update_hash() MIN_MATCH-3 more times\n            //#endif\n            while(s.insert){\n                /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n                s.prev[str & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = str;\n                str++;\n                s.insert--;\n                if (s.lookahead + s.insert < MIN_MATCH) {\n                    break;\n                }\n            }\n        }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */ }while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n/* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */ //  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */ function deflate_stored(s, flush) {\n    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */ var max_block_size = 0xffff;\n    if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n    }\n    /* Copy as much as possible from input to output: */ for(;;){\n        /* Fill the window as much as possible: */ if (s.lookahead <= 1) {\n            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n            //  s->block_start >= (long)s->w_size, \"slide too late\");\n            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n            //        s.block_start >= s.w_size)) {\n            //        throw  new Error(\"slide too late\");\n            //      }\n            fill_window(s);\n            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            }\n        /* flush the current block */ }\n        //Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        /* Emit a stored block if pending_buf will be full: */ var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n            /* strstart == 0 is possible when wraparound on 16-bit machine */ s.lookahead = s.strstart - max_start;\n            s.strstart = max_start;\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n        /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */ if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.strstart > s.block_start) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_NEED_MORE;\n}\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */ function deflate_fast(s, flush) {\n    var hash_head; /* head of the hash chain */ \n    var bflush; /* set if current block must be flushed */ \n    for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */ if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break; /* flush the current block */ \n            }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */ hash_head = 0 /*NIL*/ ;\n        if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n        /***/ }\n        /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */ if (hash_head !== 0 /*NIL*/  && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */ s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */ }\n        if (s.match_length >= MIN_MATCH) {\n            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n            /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */ if (s.match_length <= s.max_lazy_match /*max_insert_length*/  && s.lookahead >= MIN_MATCH) {\n                s.match_length--; /* string at strstart already in table */ \n                do {\n                    s.strstart++;\n                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                /***/ /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */ }while (--s.match_length !== 0);\n                s.strstart++;\n            } else {\n                s.strstart += s.match_length;\n                s.match_length = 0;\n                s.ins_h = s.window[s.strstart];\n                /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            //#endif\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */ }\n        } else {\n            /* No match, output a literal byte */ //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n        }\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */ function deflate_slow(s, flush) {\n    var hash_head; /* head of hash chain */ \n    var bflush; /* set if current block must be flushed */ \n    var max_insert;\n    /* Process the input block. */ for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */ if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            } /* flush the current block */ \n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */ hash_head = 0 /*NIL*/ ;\n        if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n        /***/ }\n        /* Find the longest match, discarding those <= prev_length.\n     */ s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH - 1;\n        if (hash_head !== 0 /*NIL*/  && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */ s.match_length = longest_match(s, hash_head);\n            /* longest_match() sets match_start */ if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/ )) {\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */ s.match_length = MIN_MATCH - 1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */ if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n            max_insert = s.strstart + s.lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */ //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/ bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n            /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */ s.lookahead -= s.prev_length - 1;\n            s.prev_length -= 2;\n            do {\n                if (++s.strstart <= max_insert) {\n                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                /***/ }\n            }while (--s.prev_length !== 0);\n            s.match_available = 0;\n            s.match_length = MIN_MATCH - 1;\n            s.strstart++;\n            if (bflush) {\n                /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            /***/ }\n        } else if (s.match_available) {\n            /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */ //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n            if (bflush) {\n                /*** FLUSH_BLOCK_ONLY(s, 0) ***/ flush_block_only(s, false);\n            /***/ }\n            s.strstart++;\n            s.lookahead--;\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        } else {\n            /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */ s.match_available = 1;\n            s.strstart++;\n            s.lookahead--;\n        }\n    }\n    //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s.match_available) {\n        //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */ function deflate_rle(s, flush) {\n    var bflush; /* set if current block must be flushed */ \n    var prev; /* byte at distance one to match */ \n    var scan, strend; /* scan goes up to strend for length of run */ \n    var _win = s.window;\n    for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */ if (s.lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            } /* flush the current block */ \n        }\n        /* See how many times the previous byte repeats */ s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n            scan = s.strstart - 1;\n            prev = _win[scan];\n            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n                strend = s.strstart + MAX_MATCH;\n                do {\n                /*jshint noempty:false*/ }while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n                s.match_length = MAX_MATCH - (strend - scan);\n                if (s.match_length > s.lookahead) {\n                    s.match_length = s.lookahead;\n                }\n            }\n        //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */ if (s.match_length >= MIN_MATCH) {\n            //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            s.strstart += s.match_length;\n            s.match_length = 0;\n        } else {\n            /* No match, output a literal byte */ //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n        }\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */ function deflate_huff(s, flush) {\n    var bflush; /* set if current block must be flushed */ \n    for(;;){\n        /* Make sure that we have a literal to write. */ if (s.lookahead === 0) {\n            fill_window(s);\n            if (s.lookahead === 0) {\n                if (flush === Z_NO_FLUSH) {\n                    return BS_NEED_MORE;\n                }\n                break; /* flush the current block */ \n            }\n        }\n        /* Output a literal byte */ s.match_length = 0;\n        //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */ function Config(good_length, max_lazy, nice_length, max_chain, func) {\n    this.good_length = good_length;\n    this.max_lazy = max_lazy;\n    this.nice_length = nice_length;\n    this.max_chain = max_chain;\n    this.func = func;\n}\nvar configuration_table;\nconfiguration_table = [\n    /*      good lazy nice chain */ new Config(0, 0, 0, 0, deflate_stored),\n    /* 0 store only */ new Config(4, 4, 8, 4, deflate_fast),\n    /* 1 max speed, no lazy matches */ new Config(4, 5, 16, 8, deflate_fast),\n    /* 2 */ new Config(4, 6, 32, 32, deflate_fast),\n    /* 3 */ new Config(4, 4, 16, 16, deflate_slow),\n    /* 4 lazy matches */ new Config(8, 16, 32, 32, deflate_slow),\n    /* 5 */ new Config(8, 16, 128, 128, deflate_slow),\n    /* 6 */ new Config(8, 32, 128, 256, deflate_slow),\n    /* 7 */ new Config(32, 128, 258, 1024, deflate_slow),\n    /* 8 */ new Config(32, 258, 258, 4096, deflate_slow)\n];\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */ function lm_init(s) {\n    s.window_size = 2 * s.w_size;\n    /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);\n    /* Set the default configuration parameters:\n   */ s.max_lazy_match = configuration_table[s.level].max_lazy;\n    s.good_match = configuration_table[s.level].good_length;\n    s.nice_match = configuration_table[s.level].nice_length;\n    s.max_chain_length = configuration_table[s.level].max_chain;\n    s.strstart = 0;\n    s.block_start = 0;\n    s.lookahead = 0;\n    s.insert = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    s.ins_h = 0;\n}\nfunction DeflateState() {\n    this.strm = null; /* pointer back to this zlib stream */ \n    this.status = 0; /* as the name implies */ \n    this.pending_buf = null; /* output still pending */ \n    this.pending_buf_size = 0; /* size of pending_buf */ \n    this.pending_out = 0; /* next pending byte to output to the stream */ \n    this.pending = 0; /* nb of bytes in the pending buffer */ \n    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ \n    this.gzhead = null; /* gzip header information to write */ \n    this.gzindex = 0; /* where in extra, name, or comment */ \n    this.method = Z_DEFLATED; /* can only be DEFLATED */ \n    this.last_flush = -1; /* value of flush param for previous deflate call */ \n    this.w_size = 0; /* LZ77 window size (32K by default) */ \n    this.w_bits = 0; /* log2(w_size)  (8..16) */ \n    this.w_mask = 0; /* w_size - 1 */ \n    this.window = null;\n    /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */ this.window_size = 0;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */ this.prev = null;\n    /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */ this.head = null; /* Heads of the hash chains or NIL. */ \n    this.ins_h = 0; /* hash index of string to be inserted */ \n    this.hash_size = 0; /* number of elements in hash table */ \n    this.hash_bits = 0; /* log2(hash_size) */ \n    this.hash_mask = 0; /* hash_size-1 */ \n    this.hash_shift = 0;\n    /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */ this.block_start = 0;\n    /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */ this.match_length = 0; /* length of best match */ \n    this.prev_match = 0; /* previous match */ \n    this.match_available = 0; /* set if previous match exists */ \n    this.strstart = 0; /* start of string to insert */ \n    this.match_start = 0; /* start of matching string */ \n    this.lookahead = 0; /* number of valid bytes ahead in window */ \n    this.prev_length = 0;\n    /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */ this.max_chain_length = 0;\n    /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */ this.max_lazy_match = 0;\n    /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */ // That's alias to max_lazy_match, don't use directly\n    //this.max_insert_length = 0;\n    /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */ this.level = 0; /* compression level (1..9) */ \n    this.strategy = 0; /* favor or force Huffman coding*/ \n    this.good_match = 0;\n    /* Use a faster search when the previous match is longer than this */ this.nice_match = 0; /* Stop searching when current match exceeds this */ \n    /* used by trees.c: */ /* Didn't use ct_data typedef below to suppress compiler warning */ // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n    // Use flat array of DOUBLE size, with interleaved fata,\n    // because JS does not support effective\n    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n    zero(this.dyn_ltree);\n    zero(this.dyn_dtree);\n    zero(this.bl_tree);\n    this.l_desc = null; /* desc. for literal tree */ \n    this.d_desc = null; /* desc. for distance tree */ \n    this.bl_desc = null; /* desc. for bit length tree */ \n    //ush bl_count[MAX_BITS+1];\n    this.bl_count = new utils.Buf16(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */ //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */ \n    zero(this.heap);\n    this.heap_len = 0; /* number of elements in the heap */ \n    this.heap_max = 0; /* element of largest frequency */ \n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */ this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n    zero(this.depth);\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */ this.l_buf = 0; /* buffer index for literals or lengths */ \n    this.lit_bufsize = 0;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */ this.last_lit = 0; /* running index in l_buf */ \n    this.d_buf = 0;\n    /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */ this.opt_len = 0; /* bit length of current block with optimal trees */ \n    this.static_len = 0; /* bit length of current block with static trees */ \n    this.matches = 0; /* number of string matches in current block */ \n    this.insert = 0; /* bytes at end of window left to insert */ \n    this.bi_buf = 0;\n    /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */ this.bi_valid = 0;\n/* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */ // Used for window memory init. We safely ignore it for JS. That makes\n// sense only for pointers and memory check tools.\n//this.high_water = 0;\n/* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */ }\nfunction deflateResetKeep(strm) {\n    var s;\n    if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    strm.total_in = strm.total_out = 0;\n    strm.data_type = Z_UNKNOWN;\n    s = strm.state;\n    s.pending = 0;\n    s.pending_out = 0;\n    if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */ }\n    s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n    strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n     : 1; // adler32(0, Z_NULL, 0)\n    s.last_flush = Z_NO_FLUSH;\n    trees._tr_init(s);\n    return Z_OK;\n}\nfunction deflateReset(strm) {\n    var ret = deflateResetKeep(strm);\n    if (ret === Z_OK) {\n        lm_init(strm.state);\n    }\n    return ret;\n}\nfunction deflateSetHeader(strm, head) {\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n    }\n    strm.state.gzhead = head;\n    return Z_OK;\n}\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n    if (!strm) {\n        return Z_STREAM_ERROR;\n    }\n    var wrap = 1;\n    if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n    }\n    if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    } else if (windowBits > 15) {\n        wrap = 2; /* write gzip wrapper instead */ \n        windowBits -= 16;\n    }\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    if (windowBits === 8) {\n        windowBits = 9;\n    }\n    /* until 256-byte window bug fixed */ var s = new DeflateState();\n    strm.state = s;\n    s.strm = strm;\n    s.wrap = wrap;\n    s.gzhead = null;\n    s.w_bits = windowBits;\n    s.w_size = 1 << s.w_bits;\n    s.w_mask = s.w_size - 1;\n    s.hash_bits = memLevel + 7;\n    s.hash_size = 1 << s.hash_bits;\n    s.hash_mask = s.hash_size - 1;\n    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n    s.window = new utils.Buf8(s.w_size * 2);\n    s.head = new utils.Buf16(s.hash_size);\n    s.prev = new utils.Buf16(s.w_size);\n    // Don't need mem init magic for JS.\n    //s.high_water = 0;  /* nothing written to s->window yet */\n    s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */ \n    s.pending_buf_size = s.lit_bufsize * 4;\n    //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n    //s->pending_buf = (uchf *) overlay;\n    s.pending_buf = new utils.Buf8(s.pending_buf_size);\n    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n    //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s.d_buf = 1 * s.lit_bufsize;\n    //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n    s.l_buf = (1 + 2) * s.lit_bufsize;\n    s.level = level;\n    s.strategy = strategy;\n    s.method = method;\n    return deflateReset(strm);\n}\nfunction deflateInit(strm, level) {\n    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\nfunction deflate(strm, flush) {\n    var old_flush, s;\n    var beg, val; // for gzip header write only\n    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n    }\n    s = strm.state;\n    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n    }\n    s.strm = strm; /* just in case */ \n    old_flush = s.last_flush;\n    s.last_flush = flush;\n    /* Write the header */ if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n            strm.adler = 0; //crc32(0L, Z_NULL, 0);\n            put_byte(s, 31);\n            put_byte(s, 139);\n            put_byte(s, 8);\n            if (!s.gzhead) {\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                put_byte(s, OS_CODE);\n                s.status = BUSY_STATE;\n            } else {\n                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n                put_byte(s, s.gzhead.time & 0xff);\n                put_byte(s, s.gzhead.time >> 8 & 0xff);\n                put_byte(s, s.gzhead.time >> 16 & 0xff);\n                put_byte(s, s.gzhead.time >> 24 & 0xff);\n                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                put_byte(s, s.gzhead.os & 0xff);\n                if (s.gzhead.extra && s.gzhead.extra.length) {\n                    put_byte(s, s.gzhead.extra.length & 0xff);\n                    put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n                }\n                if (s.gzhead.hcrc) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n                }\n                s.gzindex = 0;\n                s.status = EXTRA_STATE;\n            }\n        } else {\n            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n            var level_flags = -1;\n            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n                level_flags = 0;\n            } else if (s.level < 6) {\n                level_flags = 1;\n            } else if (s.level === 6) {\n                level_flags = 2;\n            } else {\n                level_flags = 3;\n            }\n            header |= level_flags << 6;\n            if (s.strstart !== 0) {\n                header |= PRESET_DICT;\n            }\n            header += 31 - header % 31;\n            s.status = BUSY_STATE;\n            putShortMSB(s, header);\n            /* Save the adler32 of the preset dictionary: */ if (s.strstart !== 0) {\n                putShortMSB(s, strm.adler >>> 16);\n                putShortMSB(s, strm.adler & 0xffff);\n            }\n            strm.adler = 1; // adler32(0L, Z_NULL, 0);\n        }\n    }\n    //#ifdef GZIP\n    if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            while(s.gzindex < (s.gzhead.extra.length & 0xffff)){\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        break;\n                    }\n                }\n                put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n                s.gzindex++;\n            }\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (s.gzindex === s.gzhead.extra.length) {\n                s.gzindex = 0;\n                s.status = NAME_STATE;\n            }\n        } else {\n            s.status = NAME_STATE;\n        }\n    }\n    if (s.status === NAME_STATE) {\n        if (s.gzhead.name /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            //int val;\n            do {\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        val = 1;\n                        break;\n                    }\n                }\n                // JS specific: little magic to add zero terminator to end of string\n                if (s.gzindex < s.gzhead.name.length) {\n                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                    val = 0;\n                }\n                put_byte(s, val);\n            }while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n                s.gzindex = 0;\n                s.status = COMMENT_STATE;\n            }\n        } else {\n            s.status = COMMENT_STATE;\n        }\n    }\n    if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            //int val;\n            do {\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        val = 1;\n                        break;\n                    }\n                }\n                // JS specific: little magic to add zero terminator to end of string\n                if (s.gzindex < s.gzhead.comment.length) {\n                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                    val = 0;\n                }\n                put_byte(s, val);\n            }while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n                s.status = HCRC_STATE;\n            }\n        } else {\n            s.status = HCRC_STATE;\n        }\n    }\n    if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n            if (s.pending + 2 > s.pending_buf_size) {\n                flush_pending(strm);\n            }\n            if (s.pending + 2 <= s.pending_buf_size) {\n                put_byte(s, strm.adler & 0xff);\n                put_byte(s, strm.adler >> 8 & 0xff);\n                strm.adler = 0; //crc32(0L, Z_NULL, 0);\n                s.status = BUSY_STATE;\n            }\n        } else {\n            s.status = BUSY_STATE;\n        }\n    }\n    //#endif\n    /* Flush as much pending output as possible */ if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n            /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */ s.last_flush = -1;\n            return Z_OK;\n        }\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */ } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n    }\n    /* User must not provide more input after the first FINISH: */ if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n    }\n    /* Start a new block or continue the current one.\n   */ if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n            s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n            if (strm.avail_out === 0) {\n                s.last_flush = -1;\n            /* avoid BUF_ERROR next call, see above */ }\n            return Z_OK;\n        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */ }\n        if (bstate === BS_BLOCK_DONE) {\n            if (flush === Z_PARTIAL_FLUSH) {\n                trees._tr_align(s);\n            } else if (flush !== Z_BLOCK) {\n                trees._tr_stored_block(s, 0, 0, false);\n                /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */ if (flush === Z_FULL_FLUSH) {\n                    /*** CLEAR_HASH(s); ***/ /* forget history */ zero(s.head); // Fill with NIL (= 0);\n                    if (s.lookahead === 0) {\n                        s.strstart = 0;\n                        s.block_start = 0;\n                        s.insert = 0;\n                    }\n                }\n            }\n            flush_pending(strm);\n            if (strm.avail_out === 0) {\n                s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */ \n                return Z_OK;\n            }\n        }\n    }\n    //Assert(strm->avail_out > 0, \"bug2\");\n    //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n    if (flush !== Z_FINISH) {\n        return Z_OK;\n    }\n    if (s.wrap <= 0) {\n        return Z_STREAM_END;\n    }\n    /* Write the trailer */ if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        put_byte(s, strm.adler >> 16 & 0xff);\n        put_byte(s, strm.adler >> 24 & 0xff);\n        put_byte(s, strm.total_in & 0xff);\n        put_byte(s, strm.total_in >> 8 & 0xff);\n        put_byte(s, strm.total_in >> 16 & 0xff);\n        put_byte(s, strm.total_in >> 24 & 0xff);\n    } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n    }\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */ if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n    }\n    /* write the trailer only once! */ return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\nfunction deflateEnd(strm) {\n    var status;\n    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    status = strm.state.status;\n    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    strm.state = null;\n    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */ function deflateSetDictionary(strm, dictionary) {\n    var dictLength = dictionary.length;\n    var s;\n    var str, n;\n    var wrap;\n    var avail;\n    var next;\n    var input;\n    var tmpDict;\n    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    s = strm.state;\n    wrap = s.wrap;\n    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n        return Z_STREAM_ERROR;\n    }\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */ if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */ strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n    }\n    s.wrap = 0; /* avoid computing Adler-32 in read_buf */ \n    /* if dictionary would fill window, just replace the history */ if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n            /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n        }\n        /* use the tail */ // dictionary = dictionary.slice(dictLength - s.w_size);\n        tmpDict = new utils.Buf8(s.w_size);\n        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n    }\n    /* insert dictionary into window and hash */ avail = strm.avail_in;\n    next = strm.next_in;\n    input = strm.input;\n    strm.avail_in = dictLength;\n    strm.next_in = 0;\n    strm.input = dictionary;\n    fill_window(s);\n    while(s.lookahead >= MIN_MATCH){\n        str = s.strstart;\n        n = s.lookahead - (MIN_MATCH - 1);\n        do {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n        }while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH - 1;\n        fill_window(s);\n    }\n    s.strstart += s.lookahead;\n    s.block_start = s.strstart;\n    s.insert = s.lookahead;\n    s.lookahead = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    strm.next_in = next;\n    strm.input = input;\n    strm.avail_in = avail;\n    s.wrap = wrap;\n    return Z_OK;\n}\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = \"pako deflate (from Nodeca project)\"; /* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsSUFBSUEsUUFBVUMsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUMsUUFBVUQsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUcsUUFBVUgsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUksTUFBVUosbUJBQU9BLENBQUM7QUFFdEIsOEVBQThFLEdBQzlFLDhFQUE4RSxHQUc5RSx1RUFBdUUsR0FDdkUsSUFBSUssYUFBa0I7QUFDdEIsSUFBSUMsa0JBQWtCO0FBQ3RCLDBCQUEwQjtBQUMxQixJQUFJQyxlQUFrQjtBQUN0QixJQUFJQyxXQUFrQjtBQUN0QixJQUFJQyxVQUFrQjtBQUN0QiwwQkFBMEI7QUFHMUI7O0NBRUMsR0FDRCxJQUFJQyxPQUFrQjtBQUN0QixJQUFJQyxlQUFrQjtBQUN0QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLElBQUlDLGlCQUFrQixDQUFDO0FBQ3ZCLElBQUlDLGVBQWtCLENBQUM7QUFDdkIsMkJBQTJCO0FBQzNCLElBQUlDLGNBQWtCLENBQUM7QUFDdkIsMkJBQTJCO0FBRzNCLHNCQUFzQixHQUN0QixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxJQUFJQyx3QkFBd0IsQ0FBQztBQUc3QixJQUFJQyxh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Q0FBLEVBQUVjLFFBQVEsSUFBSWQsRUFBRStDLFNBQVM7SUFDekIvQyxFQUFFYSxXQUFXLEdBQUdiLEVBQUVjLFFBQVE7SUFDMUJkLEVBQUUyRCxNQUFNLEdBQUczRCxFQUFFK0MsU0FBUztJQUN0Qi9DLEVBQUUrQyxTQUFTLEdBQUc7SUFDZC9DLEVBQUV1RSxZQUFZLEdBQUd2RSxFQUFFa0MsV0FBVyxHQUFHNUQsWUFBWTtJQUM3QzBCLEVBQUUrRSxlQUFlLEdBQUc7SUFDcEJ4RixLQUFLZ0MsT0FBTyxHQUFHaUk7SUFDZmpLLEtBQUsrQixLQUFLLEdBQUdBO0lBQ2IvQixLQUFLOEIsUUFBUSxHQUFHa0k7SUFDaEJ2SixFQUFFd0IsSUFBSSxHQUFHQTtJQUNULE9BQU96RTtBQUNUO0FBR0EyTSxtQkFBbUIsR0FBR3pCO0FBQ3RCeUIsb0JBQW9CLEdBQUc3QjtBQUN2QjZCLG9CQUFvQixHQUFHaEM7QUFDdkJnQyx3QkFBd0IsR0FBR25DO0FBQzNCbUMsd0JBQXdCLEdBQUc5QjtBQUMzQjhCLGVBQWUsR0FBR3hCO0FBQ2xCd0Isa0JBQWtCLEdBQUdQO0FBQ3JCTyw0QkFBNEIsR0FBR047QUFDL0JNLG1CQUFtQixHQUFHLHNDQUV0Qjs7Ozs7OztBQU9BIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcz81YmM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJ0cmVlcyIsImFkbGVyMzIiLCJjcmMzMiIsIm1zZyIsIlpfTk9fRkxVU0giLCJaX1BBUlRJQUxfRkxVU0giLCJaX0ZVTExfRkxVU0giLCJaX0ZJTklTSCIsIlpfQkxPQ0siLCJaX09LIiwiWl9TVFJFQU1fRU5EIiwiWl9TVFJFQU1fRVJST1IiLCJaX0RBVEFfRVJST1IiLCJaX0JVRl9FUlJPUiIsIlpfREVGQVVMVF9DT01QUkVTU0lPTiIsIlpfRklMVEVSRUQiLCJaX0hVRkZNQU5fT05MWSIsIlpfUkxFIiwiWl9GSVhFRCIsIlpfREVGQVVMVF9TVFJBVEVHWSIsIlpfVU5LTk9XTiIsIlpfREVGTEFURUQiLCJNQVhfTUVNX0xFVkVMIiwiTUFYX1dCSVRTIiwiREVGX01FTV9MRVZFTCIsIkxFTkdUSF9DT0RFUyIsIkxJVEVSQUxTIiwiTF9DT0RFUyIsIkRfQ09ERVMiLCJCTF9DT0RFUyIsIkhFQVBfU0laRSIsIk1BWF9CSVRTIiwiTUlOX01BVENIIiwiTUFYX01BVENIIiwiTUlOX0xPT0tBSEVBRCIsIlBSRVNFVF9ESUNUIiwiSU5JVF9TVEFURSIsIkVYVFJBX1NUQVRFIiwiTkFNRV9TVEFURSIsIkNPTU1FTlRfU1RBVEUiLCJIQ1JDX1NUQVRFIiwiQlVTWV9TVEFURSIsIkZJTklTSF9TVEFURSIsIkJTX05FRURfTU9SRSIsIkJTX0JMT0NLX0RPTkUiLCJCU19GSU5JU0hfU1RBUlRFRCIsIkJTX0ZJTklTSF9ET05FIiwiT1NfQ09ERSIsImVyciIsInN0cm0iLCJlcnJvckNvZGUiLCJyYW5rIiwiZiIsInplcm8iLCJidWYiLCJsZW4iLCJsZW5ndGgiLCJmbHVzaF9wZW5kaW5nIiwicyIsInN0YXRlIiwicGVuZGluZyIsImF2YWlsX291dCIsImFycmF5U2V0Iiwib3V0cHV0IiwicGVuZGluZ19idWYiLCJwZW5kaW5nX291dCIsIm5leHRfb3V0IiwidG90YWxfb3V0IiwiZmx1c2hfYmxvY2tfb25seSIsImxhc3QiLCJfdHJfZmx1c2hfYmxvY2siLCJibG9ja19zdGFydCIsInN0cnN0YXJ0IiwicHV0X2J5dGUiLCJiIiwicHV0U2hvcnRNU0IiLCJyZWFkX2J1ZiIsInN0YXJ0Iiwic2l6ZSIsImF2YWlsX2luIiwiaW5wdXQiLCJuZXh0X2luIiwid3JhcCIsImFkbGVyIiwidG90YWxfaW4iLCJsb25nZXN0X21hdGNoIiwiY3VyX21hdGNoIiwiY2hhaW5fbGVuZ3RoIiwibWF4X2NoYWluX2xlbmd0aCIsInNjYW4iLCJtYXRjaCIsImJlc3RfbGVuIiwicHJldl9sZW5ndGgiLCJuaWNlX21hdGNoIiwibGltaXQiLCJ3X3NpemUiLCJfd2luIiwid2luZG93Iiwid21hc2siLCJ3X21hc2siLCJwcmV2Iiwic3RyZW5kIiwic2Nhbl9lbmQxIiwic2Nhbl9lbmQiLCJnb29kX21hdGNoIiwibG9va2FoZWFkIiwibWF0Y2hfc3RhcnQiLCJmaWxsX3dpbmRvdyIsIl93X3NpemUiLCJwIiwibiIsIm0iLCJtb3JlIiwic3RyIiwid2luZG93X3NpemUiLCJoYXNoX3NpemUiLCJoZWFkIiwiaW5zZXJ0IiwiaW5zX2giLCJoYXNoX3NoaWZ0IiwiaGFzaF9tYXNrIiwiZGVmbGF0ZV9zdG9yZWQiLCJmbHVzaCIsIm1heF9ibG9ja19zaXplIiwicGVuZGluZ19idWZfc2l6ZSIsIm1heF9zdGFydCIsImRlZmxhdGVfZmFzdCIsImhhc2hfaGVhZCIsImJmbHVzaCIsIm1hdGNoX2xlbmd0aCIsIl90cl90YWxseSIsIm1heF9sYXp5X21hdGNoIiwibGFzdF9saXQiLCJkZWZsYXRlX3Nsb3ciLCJtYXhfaW5zZXJ0IiwicHJldl9tYXRjaCIsInN0cmF0ZWd5IiwibWF0Y2hfYXZhaWxhYmxlIiwiZGVmbGF0ZV9ybGUiLCJkZWZsYXRlX2h1ZmYiLCJDb25maWciLCJnb29kX2xlbmd0aCIsIm1heF9sYXp5IiwibmljZV9sZW5ndGgiLCJtYXhfY2hhaW4iLCJmdW5jIiwiY29uZmlndXJhdGlvbl90YWJsZSIsImxtX2luaXQiLCJsZXZlbCIsIkRlZmxhdGVTdGF0ZSIsInN0YXR1cyIsImd6aGVhZCIsImd6aW5kZXgiLCJtZXRob2QiLCJsYXN0X2ZsdXNoIiwid19iaXRzIiwiaGFzaF9iaXRzIiwiZHluX2x0cmVlIiwiQnVmMTYiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwibF9kZXNjIiwiZF9kZXNjIiwiYmxfZGVzYyIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbGVuIiwiaGVhcF9tYXgiLCJkZXB0aCIsImxfYnVmIiwibGl0X2J1ZnNpemUiLCJkX2J1ZiIsIm9wdF9sZW4iLCJzdGF0aWNfbGVuIiwibWF0Y2hlcyIsImJpX2J1ZiIsImJpX3ZhbGlkIiwiZGVmbGF0ZVJlc2V0S2VlcCIsImRhdGFfdHlwZSIsIl90cl9pbml0IiwiZGVmbGF0ZVJlc2V0IiwicmV0IiwiZGVmbGF0ZVNldEhlYWRlciIsImRlZmxhdGVJbml0MiIsIndpbmRvd0JpdHMiLCJtZW1MZXZlbCIsIkJ1ZjgiLCJkZWZsYXRlSW5pdCIsImRlZmxhdGUiLCJvbGRfZmx1c2giLCJiZWciLCJ2YWwiLCJ0ZXh0IiwiaGNyYyIsImV4dHJhIiwibmFtZSIsImNvbW1lbnQiLCJ0aW1lIiwib3MiLCJoZWFkZXIiLCJsZXZlbF9mbGFncyIsImNoYXJDb2RlQXQiLCJic3RhdGUiLCJfdHJfYWxpZ24iLCJfdHJfc3RvcmVkX2Jsb2NrIiwiZGVmbGF0ZUVuZCIsImRlZmxhdGVTZXREaWN0aW9uYXJ5IiwiZGljdGlvbmFyeSIsImRpY3RMZW5ndGgiLCJhdmFpbCIsIm5leHQiLCJ0bXBEaWN0IiwiZXhwb3J0cyIsImRlZmxhdGVJbmZvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/gzheader.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/gzheader.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction GZheader() {\n    /* true if compressed data believed to be text */ this.text = 0;\n    /* modification time */ this.time = 0;\n    /* extra flags (not used when writing a gzip file) */ this.xflags = 0;\n    /* operating system */ this.os = 0;\n    /* pointer to extra field or Z_NULL if none */ this.extra = null;\n    /* extra field length (valid if extra != Z_NULL) */ this.extra_len = 0; // Actually, we don't need it in JS,\n    // but leave for few code modifications\n    //\n    // Setup limits is not necessary because in js we should not preallocate memory\n    // for inflate use constant limit in 65536 bytes\n    //\n    /* space at extra (only when reading header) */ // this.extra_max  = 0;\n    /* pointer to zero-terminated file name or Z_NULL */ this.name = \"\";\n    /* space at name (only when reading header) */ // this.name_max   = 0;\n    /* pointer to zero-terminated comment or Z_NULL */ this.comment = \"\";\n    /* space at comment (only when reading header) */ // this.comm_max   = 0;\n    /* true if there was or will be a header crc */ this.hcrc = 0;\n    /* true when done reading gzip header (not used when writing a gzip file) */ this.done = false;\n}\nmodule.exports = GZheader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLFNBQVNBO0lBQ1AsK0NBQStDLEdBQy9DLElBQUksQ0FBQ0MsSUFBSSxHQUFTO0lBQ2xCLHFCQUFxQixHQUNyQixJQUFJLENBQUNDLElBQUksR0FBUztJQUNsQixtREFBbUQsR0FDbkQsSUFBSSxDQUFDQyxNQUFNLEdBQU87SUFDbEIsb0JBQW9CLEdBQ3BCLElBQUksQ0FBQ0MsRUFBRSxHQUFXO0lBQ2xCLDRDQUE0QyxHQUM1QyxJQUFJLENBQUNDLEtBQUssR0FBUTtJQUNsQixpREFBaUQsR0FDakQsSUFBSSxDQUFDQyxTQUFTLEdBQUksR0FBRyxvQ0FBb0M7SUFDcEMsdUNBQXVDO0lBRTVELEVBQUU7SUFDRiwrRUFBK0U7SUFDL0UsZ0RBQWdEO0lBQ2hELEVBQUU7SUFFRiw2Q0FBNkMsR0FDN0MsdUJBQXVCO0lBQ3ZCLGtEQUFrRCxHQUNsRCxJQUFJLENBQUNDLElBQUksR0FBUztJQUNsQiw0Q0FBNEMsR0FDNUMsdUJBQXVCO0lBQ3ZCLGdEQUFnRCxHQUNoRCxJQUFJLENBQUNDLE9BQU8sR0FBTTtJQUNsQiwrQ0FBK0MsR0FDL0MsdUJBQXVCO0lBQ3ZCLDZDQUE2QyxHQUM3QyxJQUFJLENBQUNDLElBQUksR0FBUztJQUNsQiwwRUFBMEUsR0FDMUUsSUFBSSxDQUFDQyxJQUFJLEdBQVM7QUFDcEI7QUFFQUMsT0FBT0MsT0FBTyxHQUFHWiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzPzQwZTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIl0sIm5hbWVzIjpbIkdaaGVhZGVyIiwidGV4dCIsInRpbWUiLCJ4ZmxhZ3MiLCJvcyIsImV4dHJhIiwiZXh0cmFfbGVuIiwibmFtZSIsImNvbW1lbnQiLCJoY3JjIiwiZG9uZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/gzheader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inffast.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inffast.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// See state defs from inflate.js\nvar BAD = 30; /* got a data error -- remain here until reset */ \nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */ \n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */ module.exports = function inflate_fast(strm, start) {\n    var state;\n    var _in; /* local strm.input */ \n    var last; /* have enough input while in < last */ \n    var _out; /* local strm.output */ \n    var beg; /* inflate()'s initial strm.output */ \n    var end; /* while out < end, enough space available */ \n    //#ifdef INFLATE_STRICT\n    var dmax; /* maximum distance from zlib header */ \n    //#endif\n    var wsize; /* window size or zero if not using window */ \n    var whave; /* valid bytes in the window */ \n    var wnext; /* window write index */ \n    // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n    var s_window; /* allocated sliding window, if wsize != 0 */ \n    var hold; /* local strm.hold */ \n    var bits; /* local strm.bits */ \n    var lcode; /* local strm.lencode */ \n    var dcode; /* local strm.distcode */ \n    var lmask; /* mask for first level of length codes */ \n    var dmask; /* mask for first level of distance codes */ \n    var here; /* retrieved table entry */ \n    var op; /* code bits, operation, extra bits, or */ \n    /*  window position, window bytes to copy */ var len; /* match length, unused bytes */ \n    var dist; /* match distance */ \n    var from; /* where to copy match from */ \n    var from_source;\n    var input, output; // JS specific, because we have no pointers\n    /* copy state to local variables */ state = strm.state;\n    //here = state.here;\n    _in = strm.next_in;\n    input = strm.input;\n    last = _in + (strm.avail_in - 5);\n    _out = strm.next_out;\n    output = strm.output;\n    beg = _out - (start - strm.avail_out);\n    end = _out + (strm.avail_out - 257);\n    //#ifdef INFLATE_STRICT\n    dmax = state.dmax;\n    //#endif\n    wsize = state.wsize;\n    whave = state.whave;\n    wnext = state.wnext;\n    s_window = state.window;\n    hold = state.hold;\n    bits = state.bits;\n    lcode = state.lencode;\n    dcode = state.distcode;\n    lmask = (1 << state.lenbits) - 1;\n    dmask = (1 << state.distbits) - 1;\n    /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */ top: do {\n        if (bits < 15) {\n            hold += input[_in++] << bits;\n            bits += 8;\n            hold += input[_in++] << bits;\n            bits += 8;\n        }\n        here = lcode[hold & lmask];\n        dolen: for(;;){\n            op = here >>> 24 /*here.bits*/ ;\n            hold >>>= op;\n            bits -= op;\n            op = here >>> 16 & 0xff /*here.op*/ ;\n            if (op === 0) {\n                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                //        \"inflate:         literal '%c'\\n\" :\n                //        \"inflate:         literal 0x%02x\\n\", here.val));\n                output[_out++] = here & 0xffff /*here.val*/ ;\n            } else if (op & 16) {\n                len = here & 0xffff /*here.val*/ ;\n                op &= 15; /* number of extra bits */ \n                if (op) {\n                    if (bits < op) {\n                        hold += input[_in++] << bits;\n                        bits += 8;\n                    }\n                    len += hold & (1 << op) - 1;\n                    hold >>>= op;\n                    bits -= op;\n                }\n                //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n                if (bits < 15) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                }\n                here = dcode[hold & dmask];\n                dodist: for(;;){\n                    op = here >>> 24 /*here.bits*/ ;\n                    hold >>>= op;\n                    bits -= op;\n                    op = here >>> 16 & 0xff /*here.op*/ ;\n                    if (op & 16) {\n                        dist = here & 0xffff /*here.val*/ ;\n                        op &= 15; /* number of extra bits */ \n                        if (bits < op) {\n                            hold += input[_in++] << bits;\n                            bits += 8;\n                            if (bits < op) {\n                                hold += input[_in++] << bits;\n                                bits += 8;\n                            }\n                        }\n                        dist += hold & (1 << op) - 1;\n                        //#ifdef INFLATE_STRICT\n                        if (dist > dmax) {\n                            strm.msg = \"invalid distance too far back\";\n                            state.mode = BAD;\n                            break top;\n                        }\n                        //#endif\n                        hold >>>= op;\n                        bits -= op;\n                        //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                        op = _out - beg; /* max distance in output */ \n                        if (dist > op) {\n                            op = dist - op; /* distance back in window */ \n                            if (op > whave) {\n                                if (state.sane) {\n                                    strm.msg = \"invalid distance too far back\";\n                                    state.mode = BAD;\n                                    break top;\n                                }\n                            // (!) This block is disabled in zlib defaults,\n                            // don't enable it for binary compatibility\n                            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                            //                if (len <= op - whave) {\n                            //                  do {\n                            //                    output[_out++] = 0;\n                            //                  } while (--len);\n                            //                  continue top;\n                            //                }\n                            //                len -= op - whave;\n                            //                do {\n                            //                  output[_out++] = 0;\n                            //                } while (--op > whave);\n                            //                if (op === 0) {\n                            //                  from = _out - dist;\n                            //                  do {\n                            //                    output[_out++] = output[from++];\n                            //                  } while (--len);\n                            //                  continue top;\n                            //                }\n                            //#endif\n                            }\n                            from = 0; // window index\n                            from_source = s_window;\n                            if (wnext === 0) {\n                                from += wsize - op;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = _out - dist; /* rest from output */ \n                                    from_source = output;\n                                }\n                            } else if (wnext < op) {\n                                from += wsize + wnext - op;\n                                op -= wnext;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = 0;\n                                    if (wnext < len) {\n                                        op = wnext;\n                                        len -= op;\n                                        do {\n                                            output[_out++] = s_window[from++];\n                                        }while (--op);\n                                        from = _out - dist; /* rest from output */ \n                                        from_source = output;\n                                    }\n                                }\n                            } else {\n                                from += wnext - op;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = _out - dist; /* rest from output */ \n                                    from_source = output;\n                                }\n                            }\n                            while(len > 2){\n                                output[_out++] = from_source[from++];\n                                output[_out++] = from_source[from++];\n                                output[_out++] = from_source[from++];\n                                len -= 3;\n                            }\n                            if (len) {\n                                output[_out++] = from_source[from++];\n                                if (len > 1) {\n                                    output[_out++] = from_source[from++];\n                                }\n                            }\n                        } else {\n                            from = _out - dist; /* copy direct from output */ \n                            do {\n                                output[_out++] = output[from++];\n                                output[_out++] = output[from++];\n                                output[_out++] = output[from++];\n                                len -= 3;\n                            }while (len > 2);\n                            if (len) {\n                                output[_out++] = output[from++];\n                                if (len > 1) {\n                                    output[_out++] = output[from++];\n                                }\n                            }\n                        }\n                    } else if ((op & 64) === 0) {\n                        here = dcode[(here & 0xffff) + (hold & (1 << op) - 1)];\n                        continue dodist;\n                    } else {\n                        strm.msg = \"invalid distance code\";\n                        state.mode = BAD;\n                        break top;\n                    }\n                    break; // need to emulate goto via \"continue\"\n                }\n            } else if ((op & 64) === 0) {\n                here = lcode[(here & 0xffff) + (hold & (1 << op) - 1)];\n                continue dolen;\n            } else if (op & 32) {\n                //Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state.mode = TYPE;\n                break top;\n            } else {\n                strm.msg = \"invalid literal/length code\";\n                state.mode = BAD;\n                break top;\n            }\n            break; // need to emulate goto via \"continue\"\n        }\n    }while (_in < last && _out < end);\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */ len = bits >> 3;\n    _in -= len;\n    bits -= len << 3;\n    hold &= (1 << bits) - 1;\n    /* update state and return */ strm.next_in = _in;\n    strm.next_out = _out;\n    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n    state.hold = hold;\n    state.bits = bits;\n    return;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsaUNBQWlDO0FBQ2pDLElBQUlBLE1BQU0sSUFBVSwrQ0FBK0M7QUFDbkUsSUFBSUMsT0FBTyxJQUFTLHFEQUFxRDtBQUV6RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtDQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsYUFBYUMsSUFBSSxFQUFFQyxLQUFLO0lBQ2hELElBQUlDO0lBQ0osSUFBSUMsS0FBd0Isb0JBQW9CO0lBQ2hELElBQUlDLE1BQXdCLHFDQUFxQztJQUNqRSxJQUFJQyxNQUF3QixxQkFBcUI7SUFDakQsSUFBSUMsS0FBd0IsbUNBQW1DO0lBQy9ELElBQUlDLEtBQXdCLDJDQUEyQztJQUN6RSx1QkFBdUI7SUFDckIsSUFBSUMsTUFBd0IscUNBQXFDO0lBQ25FLFFBQVE7SUFDTixJQUFJQyxPQUF3QiwyQ0FBMkM7SUFDdkUsSUFBSUMsT0FBd0IsNkJBQTZCO0lBQ3pELElBQUlDLE9BQXdCLHNCQUFzQjtJQUNsRCw2RUFBNkU7SUFDN0UsSUFBSUMsVUFBd0IsMkNBQTJDO0lBQ3ZFLElBQUlDLE1BQXdCLG1CQUFtQjtJQUMvQyxJQUFJQyxNQUF3QixtQkFBbUI7SUFDL0MsSUFBSUMsT0FBd0Isc0JBQXNCO0lBQ2xELElBQUlDLE9BQXdCLHVCQUF1QjtJ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UjtvQkFFQSxPQUFPLHNDQUFzQztnQkFDL0M7WUFDRixPQUNLLElBQUksQ0FBQ2hCLEtBQUssRUFBQyxNQUFPLEdBQUc7Z0JBQ3hCRCxPQUFPSixLQUFLLENBQUMsQ0FBQ0ksT0FBTyxNQUFLLElBQWtCTixDQUFBQSxPQUFRLENBQUMsS0FBS08sRUFBQyxJQUFLLENBQUMsRUFBRztnQkFDcEUsU0FBU2lCO1lBQ1gsT0FDSyxJQUFJakIsS0FBSyxJQUFJO2dCQUNoQix1REFBdUQ7Z0JBQ3ZEbEIsTUFBTXNDLElBQUksR0FBRzVDO2dCQUNiLE1BQU13QztZQUNSLE9BQ0s7Z0JBQ0hwQyxLQUFLdUMsR0FBRyxHQUFHO2dCQUNYckMsTUFBTXNDLElBQUksR0FBRzdDO2dCQUNiLE1BQU15QztZQUNSO1lBRUEsT0FBTyxzQ0FBc0M7UUFDL0M7SUFDRixRQUFTakMsTUFBTUMsUUFBUUMsT0FBT0UsS0FBSztJQUVuQyx5RUFBeUUsR0FDekVjLE1BQU1QLFFBQVE7SUFDZFgsT0FBT2tCO0lBQ1BQLFFBQVFPLE9BQU87SUFDZlIsUUFBUSxDQUFDLEtBQUtDLElBQUcsSUFBSztJQUV0QiwyQkFBMkIsR0FDM0JkLEtBQUsyQixPQUFPLEdBQUd4QjtJQUNmSCxLQUFLNkIsUUFBUSxHQUFHeEI7SUFDaEJMLEtBQUs0QixRQUFRLEdBQUl6QixNQUFNQyxPQUFPLElBQUtBLENBQUFBLE9BQU9ELEdBQUUsSUFBSyxJQUFLQSxDQUFBQSxNQUFNQyxJQUFHO0lBQy9ESixLQUFLOEIsU0FBUyxHQUFJekIsT0FBT0UsTUFBTSxNQUFPQSxDQUFBQSxNQUFNRixJQUFHLElBQUssTUFBT0EsQ0FBQUEsT0FBT0UsR0FBRTtJQUNwRUwsTUFBTVcsSUFBSSxHQUFHQTtJQUNiWCxNQUFNWSxJQUFJLEdBQUdBO0lBQ2I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanM/OGVkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iXSwibmFtZXMiOlsiQkFEIiwiVFlQRSIsIm1vZHVsZSIsImV4cG9ydHMiLCJpbmZsYXRlX2Zhc3QiLCJzdHJtIiwic3RhcnQiLCJzdGF0ZSIsIl9pbiIsImxhc3QiLCJfb3V0IiwiYmVnIiwiZW5kIiwiZG1heCIsIndzaXplIiwid2hhdmUiLCJ3bmV4dCIsInNfd2luZG93IiwiaG9sZCIsImJpdHMiLCJsY29kZSIsImRjb2RlIiwibG1hc2siLCJkbWFzayIsImhlcmUiLCJvcCIsImxlbiIsImRpc3QiLCJmcm9tIiwiZnJvbV9zb3VyY2UiLCJpbnB1dCIsIm91dHB1dCIsIm5leHRfaW4iLCJhdmFpbF9pbiIsIm5leHRfb3V0IiwiYXZhaWxfb3V0Iiwid2luZG93IiwibGVuY29kZSIsImRpc3Rjb2RlIiwibGVuYml0cyIsImRpc3RiaXRzIiwidG9wIiwiZG9sZW4iLCJkb2Rpc3QiLCJtc2ciLCJtb2RlIiwic2FuZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inffast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inflate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inflate.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast = __webpack_require__(/*! ./inffast */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inftrees.js\");\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ //var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\nvar Z_TREES = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */ var Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_NEED_DICT = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR = -5;\n//var Z_VERSION_ERROR = -6;\n/* The deflate compression method */ var Z_DEFLATED = 8;\n/* STATES ====================================================================*/ /* ===========================================================================*/ var HEAD = 1; /* i: waiting for magic header */ \nvar FLAGS = 2; /* i: waiting for method and flags (gzip) */ \nvar TIME = 3; /* i: waiting for modification time (gzip) */ \nvar OS = 4; /* i: waiting for extra flags and operating system (gzip) */ \nvar EXLEN = 5; /* i: waiting for extra length (gzip) */ \nvar EXTRA = 6; /* i: waiting for extra bytes (gzip) */ \nvar NAME = 7; /* i: waiting for end of file name (gzip) */ \nvar COMMENT = 8; /* i: waiting for end of comment (gzip) */ \nvar HCRC = 9; /* i: waiting for header crc (gzip) */ \nvar DICTID = 10; /* i: waiting for dictionary check value */ \nvar DICT = 11; /* waiting for inflateSetDictionary() call */ \nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */ \nvar TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */ \nvar STORED = 14; /* i: waiting for stored size (length and complement) */ \nvar COPY_ = 15; /* i/o: same as COPY below, but only first time in */ \nvar COPY = 16; /* i/o: waiting for input or output to copy stored block */ \nvar TABLE = 17; /* i: waiting for dynamic block table lengths */ \nvar LENLENS = 18; /* i: waiting for code length code lengths */ \nvar CODELENS = 19; /* i: waiting for length/lit and distance code lengths */ \nvar LEN_ = 20; /* i: same as LEN below, but only first time in */ \nvar LEN = 21; /* i: waiting for length/lit/eob code */ \nvar LENEXT = 22; /* i: waiting for length extra bits */ \nvar DIST = 23; /* i: waiting for distance code */ \nvar DISTEXT = 24; /* i: waiting for distance extra bits */ \nvar MATCH = 25; /* o: waiting for output space to copy string */ \nvar LIT = 26; /* o: waiting for output space to write literal */ \nvar CHECK = 27; /* i: waiting for 32-bit check value */ \nvar LENGTH = 28; /* i: waiting for 32-bit length (gzip) */ \nvar DONE = 29; /* finished check, done -- remain here until reset */ \nvar BAD = 30; /* got a data error -- remain here until reset */ \nvar MEM = 31; /* got an inflate() memory error -- remain here until reset */ \nvar SYNC = 32; /* looking for synchronization bytes to restart inflate() */ \n/* ===========================================================================*/ var ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */ var DEF_WBITS = MAX_WBITS;\nfunction zswap32(q) {\n    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);\n}\nfunction InflateState() {\n    this.mode = 0; /* current inflate mode */ \n    this.last = false; /* true if processing last block */ \n    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ \n    this.havedict = false; /* true if dictionary provided */ \n    this.flags = 0; /* gzip header method and flags (0 if zlib) */ \n    this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */ \n    this.check = 0; /* protected copy of check value */ \n    this.total = 0; /* protected copy of output count */ \n    // TODO: may be {}\n    this.head = null; /* where to save gzip header information */ \n    /* sliding window */ this.wbits = 0; /* log base 2 of requested window size */ \n    this.wsize = 0; /* window size or zero if not using window */ \n    this.whave = 0; /* valid bytes in the window */ \n    this.wnext = 0; /* window write index */ \n    this.window = null; /* allocated sliding window, if needed */ \n    /* bit accumulator */ this.hold = 0; /* input bit accumulator */ \n    this.bits = 0; /* number of bits in \"in\" */ \n    /* for string and stored block copying */ this.length = 0; /* literal or length of data to copy */ \n    this.offset = 0; /* distance back to copy string from */ \n    /* for table and code decoding */ this.extra = 0; /* extra bits needed */ \n    /* fixed and dynamic code tables */ this.lencode = null; /* starting table for length/literal codes */ \n    this.distcode = null; /* starting table for distance codes */ \n    this.lenbits = 0; /* index bits for lencode */ \n    this.distbits = 0; /* index bits for distcode */ \n    /* dynamic table building */ this.ncode = 0; /* number of code length code lengths */ \n    this.nlen = 0; /* number of length code lengths */ \n    this.ndist = 0; /* number of distance code lengths */ \n    this.have = 0; /* number of code lengths in lens[] */ \n    this.next = null; /* next available space in codes[] */ \n    this.lens = new utils.Buf16(320); /* temporary storage for code lengths */ \n    this.work = new utils.Buf16(288); /* work area for code table building */ \n    /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */ //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n    this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */ \n    this.distdyn = null; /* dynamic table for distance codes (JS specific) */ \n    this.sane = 0; /* if false, allow invalid distance too far */ \n    this.back = 0; /* bits back of last unprocessed length/lit */ \n    this.was = 0; /* initial length of match */ \n}\nfunction inflateResetKeep(strm) {\n    var state;\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    strm.total_in = strm.total_out = state.total = 0;\n    strm.msg = \"\"; /*Z_NULL*/ \n    if (state.wrap) {\n        strm.adler = state.wrap & 1;\n    }\n    state.mode = HEAD;\n    state.last = 0;\n    state.havedict = 0;\n    state.dmax = 32768;\n    state.head = null /*Z_NULL*/ ;\n    state.hold = 0;\n    state.bits = 0;\n    //state.lencode = state.distcode = state.next = state.codes;\n    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n    state.sane = 1;\n    state.back = -1;\n    //Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}\nfunction inflateReset(strm) {\n    var state;\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    state.wsize = 0;\n    state.whave = 0;\n    state.wnext = 0;\n    return inflateResetKeep(strm);\n}\nfunction inflateReset2(strm, windowBits) {\n    var wrap;\n    var state;\n    /* get the state */ if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    /* extract wrap request from windowBits parameter */ if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    } else {\n        wrap = (windowBits >> 4) + 1;\n        if (windowBits < 48) {\n            windowBits &= 15;\n        }\n    }\n    /* set number of window bits, free window if different */ if (windowBits && (windowBits < 8 || windowBits > 15)) {\n        return Z_STREAM_ERROR;\n    }\n    if (state.window !== null && state.wbits !== windowBits) {\n        state.window = null;\n    }\n    /* update state and reset the rest of it */ state.wrap = wrap;\n    state.wbits = windowBits;\n    return inflateReset(strm);\n}\nfunction inflateInit2(strm, windowBits) {\n    var ret;\n    var state;\n    if (!strm) {\n        return Z_STREAM_ERROR;\n    }\n    //strm.msg = Z_NULL;                 /* in case we return an error */\n    state = new InflateState();\n    //if (state === Z_NULL) return Z_MEM_ERROR;\n    //Tracev((stderr, \"inflate: allocated\\n\"));\n    strm.state = state;\n    state.window = null /*Z_NULL*/ ;\n    ret = inflateReset2(strm, windowBits);\n    if (ret !== Z_OK) {\n        strm.state = null /*Z_NULL*/ ;\n    }\n    return ret;\n}\nfunction inflateInit(strm) {\n    return inflateInit2(strm, DEF_WBITS);\n}\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */ var virgin = true;\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\nfunction fixedtables(state) {\n    /* build fixed huffman tables if first call (may not be thread safe) */ if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512);\n        distfix = new utils.Buf32(32);\n        /* literal/length table */ sym = 0;\n        while(sym < 144){\n            state.lens[sym++] = 8;\n        }\n        while(sym < 256){\n            state.lens[sym++] = 9;\n        }\n        while(sym < 280){\n            state.lens[sym++] = 7;\n        }\n        while(sym < 288){\n            state.lens[sym++] = 8;\n        }\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n            bits: 9\n        });\n        /* distance table */ sym = 0;\n        while(sym < 32){\n            state.lens[sym++] = 5;\n        }\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n            bits: 5\n        });\n        /* do this just once */ virgin = false;\n    }\n    state.lencode = lenfix;\n    state.lenbits = 9;\n    state.distcode = distfix;\n    state.distbits = 5;\n}\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */ function updatewindow(strm, src, end, copy) {\n    var dist;\n    var state = strm.state;\n    /* if it hasn't been done already, allocate space for the window */ if (state.window === null) {\n        state.wsize = 1 << state.wbits;\n        state.wnext = 0;\n        state.whave = 0;\n        state.window = new utils.Buf8(state.wsize);\n    }\n    /* copy state->wsize or less output bytes into the circular window */ if (copy >= state.wsize) {\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n        state.wnext = 0;\n        state.whave = state.wsize;\n    } else {\n        dist = state.wsize - state.wnext;\n        if (dist > copy) {\n            dist = copy;\n        }\n        //zmemcpy(state->window + state->wnext, end - copy, dist);\n        utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n        copy -= dist;\n        if (copy) {\n            //zmemcpy(state->window, end - copy, copy);\n            utils.arraySet(state.window, src, end - copy, copy, 0);\n            state.wnext = copy;\n            state.whave = state.wsize;\n        } else {\n            state.wnext += dist;\n            if (state.wnext === state.wsize) {\n                state.wnext = 0;\n            }\n            if (state.whave < state.wsize) {\n                state.whave += dist;\n            }\n        }\n    }\n    return 0;\n}\nfunction inflate(strm, flush) {\n    var state;\n    var input, output; // input/output buffers\n    var next; /* next input INDEX */ \n    var put; /* next output INDEX */ \n    var have, left; /* available input and output */ \n    var hold; /* bit buffer */ \n    var bits; /* bits in bit buffer */ \n    var _in, _out; /* save starting available input and output */ \n    var copy; /* number of stored or match bytes to copy */ \n    var from; /* where to copy match bytes from */ \n    var from_source;\n    var here = 0; /* current decoding table entry */ \n    var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n    //var last;                   /* parent table entry */\n    var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n    var len; /* length to copy for repeats, bits to drop */ \n    var ret; /* return code */ \n    var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */ \n    var opts;\n    var n; // temporary var for NEED_BITS\n    var order = /* permutation of code lengths */ [\n        16,\n        17,\n        18,\n        0,\n        8,\n        7,\n        9,\n        6,\n        10,\n        5,\n        11,\n        4,\n        12,\n        3,\n        13,\n        2,\n        14,\n        1,\n        15\n    ];\n    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if (state.mode === TYPE) {\n        state.mode = TYPEDO;\n    } /* skip check */ \n    //--- LOAD() ---\n    put = strm.next_out;\n    output = strm.output;\n    left = strm.avail_out;\n    next = strm.next_in;\n    input = strm.input;\n    have = strm.avail_in;\n    hold = state.hold;\n    bits = state.bits;\n    //---\n    _in = have;\n    _out = left;\n    ret = Z_OK;\n    inf_leave: for(;;){\n        switch(state.mode){\n            case HEAD:\n                if (state.wrap === 0) {\n                    state.mode = TYPEDO;\n                    break;\n                }\n                //=== NEEDBITS(16);\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.wrap & 2 && hold === 0x8b1f) {\n                    state.check = 0 /*crc32(0L, Z_NULL, 0)*/ ;\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                    //===//\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                    //===//\n                    state.mode = FLAGS;\n                    break;\n                }\n                state.flags = 0; /* expect zlib header */ \n                if (state.head) {\n                    state.head.done = false;\n                }\n                if (!(state.wrap & 1) || /* check if zlib header allowed */ (((hold & 0xff) << 8) + (hold >> 8)) % 31) {\n                    strm.msg = \"incorrect header check\";\n                    state.mode = BAD;\n                    break;\n                }\n                if ((hold & 0x0f) !== Z_DEFLATED) {\n                    strm.msg = \"unknown compression method\";\n                    state.mode = BAD;\n                    break;\n                }\n                //--- DROPBITS(4) ---//\n                hold >>>= 4;\n                bits -= 4;\n                //---//\n                len = (hold & 0x0f) + 8;\n                if (state.wbits === 0) {\n                    state.wbits = len;\n                } else if (len > state.wbits) {\n                    strm.msg = \"invalid window size\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.dmax = 1 << len;\n                //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n                state.mode = hold & 0x200 ? DICTID : TYPE;\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                break;\n            case FLAGS:\n                //=== NEEDBITS(16); */\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.flags = hold;\n                if ((state.flags & 0xff) !== Z_DEFLATED) {\n                    strm.msg = \"unknown compression method\";\n                    state.mode = BAD;\n                    break;\n                }\n                if (state.flags & 0xe000) {\n                    strm.msg = \"unknown header flags set\";\n                    state.mode = BAD;\n                    break;\n                }\n                if (state.head) {\n                    state.head.text = hold >> 8 & 1;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                //===//\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = TIME;\n            /* falls through */ case TIME:\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.head) {\n                    state.head.time = hold;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC4(state.check, hold)\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    hbuf[2] = hold >>> 16 & 0xff;\n                    hbuf[3] = hold >>> 24 & 0xff;\n                    state.check = crc32(state.check, hbuf, 4, 0);\n                //===\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = OS;\n            /* falls through */ case OS:\n                //=== NEEDBITS(16); */\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.head) {\n                    state.head.xflags = hold & 0xff;\n                    state.head.os = hold >> 8;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                //===//\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = EXLEN;\n            /* falls through */ case EXLEN:\n                if (state.flags & 0x0400) {\n                    //=== NEEDBITS(16); */\n                    while(bits < 16){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.length = hold;\n                    if (state.head) {\n                        state.head.extra_len = hold;\n                    }\n                    if (state.flags & 0x0200) {\n                        //=== CRC2(state.check, hold);\n                        hbuf[0] = hold & 0xff;\n                        hbuf[1] = hold >>> 8 & 0xff;\n                        state.check = crc32(state.check, hbuf, 2, 0);\n                    //===//\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                } else if (state.head) {\n                    state.head.extra = null /*Z_NULL*/ ;\n                }\n                state.mode = EXTRA;\n            /* falls through */ case EXTRA:\n                if (state.flags & 0x0400) {\n                    copy = state.length;\n                    if (copy > have) {\n                        copy = have;\n                    }\n                    if (copy) {\n                        if (state.head) {\n                            len = state.head.extra_len - state.length;\n                            if (!state.head.extra) {\n                                // Use untyped array for more convenient processing later\n                                state.head.extra = new Array(state.head.extra_len);\n                            }\n                            utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes\n                            // - no need for additional size check\n                            copy, /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/ len);\n                        //zmemcpy(state.head.extra + len, next,\n                        //        len + copy > state.head.extra_max ?\n                        //        state.head.extra_max - len : copy);\n                        }\n                        if (state.flags & 0x0200) {\n                            state.check = crc32(state.check, input, copy, next);\n                        }\n                        have -= copy;\n                        next += copy;\n                        state.length -= copy;\n                    }\n                    if (state.length) {\n                        break inf_leave;\n                    }\n                }\n                state.length = 0;\n                state.mode = NAME;\n            /* falls through */ case NAME:\n                if (state.flags & 0x0800) {\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    copy = 0;\n                    do {\n                        // TODO: 2 or 1 bytes?\n                        len = input[next + copy++];\n                        /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.name_max*/ ) {\n                            state.head.name += String.fromCharCode(len);\n                        }\n                    }while (len && copy < have);\n                    if (state.flags & 0x0200) {\n                        state.check = crc32(state.check, input, copy, next);\n                    }\n                    have -= copy;\n                    next += copy;\n                    if (len) {\n                        break inf_leave;\n                    }\n                } else if (state.head) {\n                    state.head.name = null;\n                }\n                state.length = 0;\n                state.mode = COMMENT;\n            /* falls through */ case COMMENT:\n                if (state.flags & 0x1000) {\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    copy = 0;\n                    do {\n                        len = input[next + copy++];\n                        /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.comm_max*/ ) {\n                            state.head.comment += String.fromCharCode(len);\n                        }\n                    }while (len && copy < have);\n                    if (state.flags & 0x0200) {\n                        state.check = crc32(state.check, input, copy, next);\n                    }\n                    have -= copy;\n                    next += copy;\n                    if (len) {\n                        break inf_leave;\n                    }\n                } else if (state.head) {\n                    state.head.comment = null;\n                }\n                state.mode = HCRC;\n            /* falls through */ case HCRC:\n                if (state.flags & 0x0200) {\n                    //=== NEEDBITS(16); */\n                    while(bits < 16){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    if (hold !== (state.check & 0xffff)) {\n                        strm.msg = \"header crc mismatch\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                }\n                if (state.head) {\n                    state.head.hcrc = state.flags >> 9 & 1;\n                    state.head.done = true;\n                }\n                strm.adler = state.check = 0;\n                state.mode = TYPE;\n                break;\n            case DICTID:\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                strm.adler = state.check = zswap32(hold);\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = DICT;\n            /* falls through */ case DICT:\n                if (state.havedict === 0) {\n                    //--- RESTORE() ---\n                    strm.next_out = put;\n                    strm.avail_out = left;\n                    strm.next_in = next;\n                    strm.avail_in = have;\n                    state.hold = hold;\n                    state.bits = bits;\n                    //---\n                    return Z_NEED_DICT;\n                }\n                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n                state.mode = TYPE;\n            /* falls through */ case TYPE:\n                if (flush === Z_BLOCK || flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case TYPEDO:\n                if (state.last) {\n                    //--- BYTEBITS() ---//\n                    hold >>>= bits & 7;\n                    bits -= bits & 7;\n                    //---//\n                    state.mode = CHECK;\n                    break;\n                }\n                //=== NEEDBITS(3); */\n                while(bits < 3){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.last = hold & 0x01 /*BITS(1)*/ ;\n                //--- DROPBITS(1) ---//\n                hold >>>= 1;\n                bits -= 1;\n                //---//\n                switch(hold & 0x03){\n                    case 0:\n                        /* stored block */ //Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = STORED;\n                        break;\n                    case 1:\n                        /* fixed block */ fixedtables(state);\n                        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = LEN_; /* decode codes */ \n                        if (flush === Z_TREES) {\n                            //--- DROPBITS(2) ---//\n                            hold >>>= 2;\n                            bits -= 2;\n                            break inf_leave;\n                        }\n                        break;\n                    case 2:\n                        /* dynamic block */ //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = TABLE;\n                        break;\n                    case 3:\n                        strm.msg = \"invalid block type\";\n                        state.mode = BAD;\n                }\n                //--- DROPBITS(2) ---//\n                hold >>>= 2;\n                bits -= 2;\n                break;\n            case STORED:\n                //--- BYTEBITS() ---// /* go to byte boundary */\n                hold >>>= bits & 7;\n                bits -= bits & 7;\n                //---//\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {\n                    strm.msg = \"invalid stored block lengths\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.length = hold & 0xffff;\n                //Tracev((stderr, \"inflate:       stored length %u\\n\",\n                //        state.length));\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = COPY_;\n                if (flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case COPY_:\n                state.mode = COPY;\n            /* falls through */ case COPY:\n                copy = state.length;\n                if (copy) {\n                    if (copy > have) {\n                        copy = have;\n                    }\n                    if (copy > left) {\n                        copy = left;\n                    }\n                    if (copy === 0) {\n                        break inf_leave;\n                    }\n                    //--- zmemcpy(put, next, copy); ---\n                    utils.arraySet(output, input, next, copy, put);\n                    //---//\n                    have -= copy;\n                    next += copy;\n                    left -= copy;\n                    put += copy;\n                    state.length -= copy;\n                    break;\n                }\n                //Tracev((stderr, \"inflate:       stored end\\n\"));\n                state.mode = TYPE;\n                break;\n            case TABLE:\n                //=== NEEDBITS(14); */\n                while(bits < 14){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.nlen = (hold & 0x1f) + 257;\n                //--- DROPBITS(5) ---//\n                hold >>>= 5;\n                bits -= 5;\n                //---//\n                state.ndist = (hold & 0x1f) + 1;\n                //--- DROPBITS(5) ---//\n                hold >>>= 5;\n                bits -= 5;\n                //---//\n                state.ncode = (hold & 0x0f) + 4;\n                //--- DROPBITS(4) ---//\n                hold >>>= 4;\n                bits -= 4;\n                //---//\n                //#ifndef PKZIP_BUG_WORKAROUND\n                if (state.nlen > 286 || state.ndist > 30) {\n                    strm.msg = \"too many length or distance symbols\";\n                    state.mode = BAD;\n                    break;\n                }\n                //#endif\n                //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n                state.have = 0;\n                state.mode = LENLENS;\n            /* falls through */ case LENLENS:\n                while(state.have < state.ncode){\n                    //=== NEEDBITS(3);\n                    while(bits < 3){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.lens[order[state.have++]] = hold & 0x07; //BITS(3);\n                    //--- DROPBITS(3) ---//\n                    hold >>>= 3;\n                    bits -= 3;\n                //---//\n                }\n                while(state.have < 19){\n                    state.lens[order[state.have++]] = 0;\n                }\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                //state.next = state.codes;\n                //state.lencode = state.next;\n                // Switch to use dynamic table\n                state.lencode = state.lendyn;\n                state.lenbits = 7;\n                opts = {\n                    bits: state.lenbits\n                };\n                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n                state.lenbits = opts.bits;\n                if (ret) {\n                    strm.msg = \"invalid code lengths set\";\n                    state.mode = BAD;\n                    break;\n                }\n                //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n                state.have = 0;\n                state.mode = CODELENS;\n            /* falls through */ case CODELENS:\n                while(state.have < state.nlen + state.ndist){\n                    for(;;){\n                        here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ \n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    if (here_val < 16) {\n                        //--- DROPBITS(here.bits) ---//\n                        hold >>>= here_bits;\n                        bits -= here_bits;\n                        //---//\n                        state.lens[state.have++] = here_val;\n                    } else {\n                        if (here_val === 16) {\n                            //=== NEEDBITS(here.bits + 2);\n                            n = here_bits + 2;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            if (state.have === 0) {\n                                strm.msg = \"invalid bit length repeat\";\n                                state.mode = BAD;\n                                break;\n                            }\n                            len = state.lens[state.have - 1];\n                            copy = 3 + (hold & 0x03); //BITS(2);\n                            //--- DROPBITS(2) ---//\n                            hold >>>= 2;\n                            bits -= 2;\n                        //---//\n                        } else if (here_val === 17) {\n                            //=== NEEDBITS(here.bits + 3);\n                            n = here_bits + 3;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            len = 0;\n                            copy = 3 + (hold & 0x07); //BITS(3);\n                            //--- DROPBITS(3) ---//\n                            hold >>>= 3;\n                            bits -= 3;\n                        //---//\n                        } else {\n                            //=== NEEDBITS(here.bits + 7);\n                            n = here_bits + 7;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            len = 0;\n                            copy = 11 + (hold & 0x7f); //BITS(7);\n                            //--- DROPBITS(7) ---//\n                            hold >>>= 7;\n                            bits -= 7;\n                        //---//\n                        }\n                        if (state.have + copy > state.nlen + state.ndist) {\n                            strm.msg = \"invalid bit length repeat\";\n                            state.mode = BAD;\n                            break;\n                        }\n                        while(copy--){\n                            state.lens[state.have++] = len;\n                        }\n                    }\n                }\n                /* handle error breaks in while */ if (state.mode === BAD) {\n                    break;\n                }\n                /* check for end-of-block code (better have one) */ if (state.lens[256] === 0) {\n                    strm.msg = \"invalid code -- missing end-of-block\";\n                    state.mode = BAD;\n                    break;\n                }\n                /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */ state.lenbits = 9;\n                opts = {\n                    bits: state.lenbits\n                };\n                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                // state.next_index = opts.table_index;\n                state.lenbits = opts.bits;\n                // state.lencode = state.next;\n                if (ret) {\n                    strm.msg = \"invalid literal/lengths set\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.distbits = 6;\n                //state.distcode.copy(state.codes);\n                // Switch to use dynamic table\n                state.distcode = state.distdyn;\n                opts = {\n                    bits: state.distbits\n                };\n                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                // state.next_index = opts.table_index;\n                state.distbits = opts.bits;\n                // state.distcode = state.next;\n                if (ret) {\n                    strm.msg = \"invalid distances set\";\n                    state.mode = BAD;\n                    break;\n                }\n                //Tracev((stderr, 'inflate:       codes ok\\n'));\n                state.mode = LEN_;\n                if (flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case LEN_:\n                state.mode = LEN;\n            /* falls through */ case LEN:\n                if (have >= 6 && left >= 258) {\n                    //--- RESTORE() ---\n                    strm.next_out = put;\n                    strm.avail_out = left;\n                    strm.next_in = next;\n                    strm.avail_in = have;\n                    state.hold = hold;\n                    state.bits = bits;\n                    //---\n                    inflate_fast(strm, _out);\n                    //--- LOAD() ---\n                    put = strm.next_out;\n                    output = strm.output;\n                    left = strm.avail_out;\n                    next = strm.next_in;\n                    input = strm.input;\n                    have = strm.avail_in;\n                    hold = state.hold;\n                    bits = state.bits;\n                    //---\n                    if (state.mode === TYPE) {\n                        state.back = -1;\n                    }\n                    break;\n                }\n                state.back = 0;\n                for(;;){\n                    here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ \n                    here_bits = here >>> 24;\n                    here_op = here >>> 16 & 0xff;\n                    here_val = here & 0xffff;\n                    if (here_bits <= bits) {\n                        break;\n                    }\n                    //--- PULLBYTE() ---//\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                //---//\n                }\n                if (here_op && (here_op & 0xf0) === 0) {\n                    last_bits = here_bits;\n                    last_op = here_op;\n                    last_val = here_val;\n                    for(;;){\n                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (last_bits + here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    //--- DROPBITS(last.bits) ---//\n                    hold >>>= last_bits;\n                    bits -= last_bits;\n                    //---//\n                    state.back += last_bits;\n                }\n                //--- DROPBITS(here.bits) ---//\n                hold >>>= here_bits;\n                bits -= here_bits;\n                //---//\n                state.back += here_bits;\n                state.length = here_val;\n                if (here_op === 0) {\n                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                    //        \"inflate:         literal '%c'\\n\" :\n                    //        \"inflate:         literal 0x%02x\\n\", here.val));\n                    state.mode = LIT;\n                    break;\n                }\n                if (here_op & 32) {\n                    //Tracevv((stderr, \"inflate:         end of block\\n\"));\n                    state.back = -1;\n                    state.mode = TYPE;\n                    break;\n                }\n                if (here_op & 64) {\n                    strm.msg = \"invalid literal/length code\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.extra = here_op & 15;\n                state.mode = LENEXT;\n            /* falls through */ case LENEXT:\n                if (state.extra) {\n                    //=== NEEDBITS(state.extra);\n                    n = state.extra;\n                    while(bits < n){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;\n                    //--- DROPBITS(state.extra) ---//\n                    hold >>>= state.extra;\n                    bits -= state.extra;\n                    //---//\n                    state.back += state.extra;\n                }\n                //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n                state.was = state.length;\n                state.mode = DIST;\n            /* falls through */ case DIST:\n                for(;;){\n                    here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/ \n                    here_bits = here >>> 24;\n                    here_op = here >>> 16 & 0xff;\n                    here_val = here & 0xffff;\n                    if (here_bits <= bits) {\n                        break;\n                    }\n                    //--- PULLBYTE() ---//\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                //---//\n                }\n                if ((here_op & 0xf0) === 0) {\n                    last_bits = here_bits;\n                    last_op = here_op;\n                    last_val = here_val;\n                    for(;;){\n                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (last_bits + here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    //--- DROPBITS(last.bits) ---//\n                    hold >>>= last_bits;\n                    bits -= last_bits;\n                    //---//\n                    state.back += last_bits;\n                }\n                //--- DROPBITS(here.bits) ---//\n                hold >>>= here_bits;\n                bits -= here_bits;\n                //---//\n                state.back += here_bits;\n                if (here_op & 64) {\n                    strm.msg = \"invalid distance code\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.offset = here_val;\n                state.extra = here_op & 15;\n                state.mode = DISTEXT;\n            /* falls through */ case DISTEXT:\n                if (state.extra) {\n                    //=== NEEDBITS(state.extra);\n                    n = state.extra;\n                    while(bits < n){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;\n                    //--- DROPBITS(state.extra) ---//\n                    hold >>>= state.extra;\n                    bits -= state.extra;\n                    //---//\n                    state.back += state.extra;\n                }\n                //#ifdef INFLATE_STRICT\n                if (state.offset > state.dmax) {\n                    strm.msg = \"invalid distance too far back\";\n                    state.mode = BAD;\n                    break;\n                }\n                //#endif\n                //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n                state.mode = MATCH;\n            /* falls through */ case MATCH:\n                if (left === 0) {\n                    break inf_leave;\n                }\n                copy = _out - left;\n                if (state.offset > copy) {\n                    copy = state.offset - copy;\n                    if (copy > state.whave) {\n                        if (state.sane) {\n                            strm.msg = \"invalid distance too far back\";\n                            state.mode = BAD;\n                            break;\n                        }\n                    // (!) This block is disabled in zlib defaults,\n                    // don't enable it for binary compatibility\n                    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    //          Trace((stderr, \"inflate.c too far\\n\"));\n                    //          copy -= state.whave;\n                    //          if (copy > state.length) { copy = state.length; }\n                    //          if (copy > left) { copy = left; }\n                    //          left -= copy;\n                    //          state.length -= copy;\n                    //          do {\n                    //            output[put++] = 0;\n                    //          } while (--copy);\n                    //          if (state.length === 0) { state.mode = LEN; }\n                    //          break;\n                    //#endif\n                    }\n                    if (copy > state.wnext) {\n                        copy -= state.wnext;\n                        from = state.wsize - copy;\n                    } else {\n                        from = state.wnext - copy;\n                    }\n                    if (copy > state.length) {\n                        copy = state.length;\n                    }\n                    from_source = state.window;\n                } else {\n                    from_source = output;\n                    from = put - state.offset;\n                    copy = state.length;\n                }\n                if (copy > left) {\n                    copy = left;\n                }\n                left -= copy;\n                state.length -= copy;\n                do {\n                    output[put++] = from_source[from++];\n                }while (--copy);\n                if (state.length === 0) {\n                    state.mode = LEN;\n                }\n                break;\n            case LIT:\n                if (left === 0) {\n                    break inf_leave;\n                }\n                output[put++] = state.length;\n                left--;\n                state.mode = LEN;\n                break;\n            case CHECK:\n                if (state.wrap) {\n                    //=== NEEDBITS(32);\n                    while(bits < 32){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        // Use '|' instead of '+' to make sure that result is signed\n                        hold |= input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    _out -= left;\n                    strm.total_out += _out;\n                    state.total += _out;\n                    if (_out) {\n                        strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/ state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n                    }\n                    _out = left;\n                    // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n                        strm.msg = \"incorrect data check\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n                }\n                state.mode = LENGTH;\n            /* falls through */ case LENGTH:\n                if (state.wrap && state.flags) {\n                    //=== NEEDBITS(32);\n                    while(bits < 32){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    if (hold !== (state.total & 0xffffffff)) {\n                        strm.msg = \"incorrect length check\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n                }\n                state.mode = DONE;\n            /* falls through */ case DONE:\n                ret = Z_STREAM_END;\n                break inf_leave;\n            case BAD:\n                ret = Z_DATA_ERROR;\n                break inf_leave;\n            case MEM:\n                return Z_MEM_ERROR;\n            case SYNC:\n            /* falls through */ default:\n                return Z_STREAM_ERROR;\n        }\n    }\n    // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n    /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */ //--- RESTORE() ---\n    strm.next_out = put;\n    strm.avail_out = left;\n    strm.next_in = next;\n    strm.avail_in = have;\n    state.hold = hold;\n    state.bits = bits;\n    //---\n    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n            state.mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    }\n    _in -= strm.avail_in;\n    _out -= strm.avail_out;\n    strm.total_in += _in;\n    strm.total_out += _out;\n    state.total += _out;\n    if (state.wrap && _out) {\n        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/ state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n    }\n    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {\n        ret = Z_BUF_ERROR;\n    }\n    return ret;\n}\nfunction inflateEnd(strm) {\n    if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    var state = strm.state;\n    if (state.window) {\n        state.window = null;\n    }\n    strm.state = null;\n    return Z_OK;\n}\nfunction inflateGetHeader(strm, head) {\n    var state;\n    /* check state */ if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if ((state.wrap & 2) === 0) {\n        return Z_STREAM_ERROR;\n    }\n    /* save header structure */ state.head = head;\n    head.done = false;\n    return Z_OK;\n}\nfunction inflateSetDictionary(strm, dictionary) {\n    var dictLength = dictionary.length;\n    var state;\n    var dictid;\n    var ret;\n    /* check state */ if (!strm /* == Z_NULL */  || !strm.state /* == Z_NULL */ ) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if (state.wrap !== 0 && state.mode !== DICT) {\n        return Z_STREAM_ERROR;\n    }\n    /* check for correct dictionary identifier */ if (state.mode === DICT) {\n        dictid = 1; /* adler32(0, null, 0)*/ \n        /* dictid = adler32(dictid, dictionary, dictLength); */ dictid = adler32(dictid, dictionary, dictLength, 0);\n        if (dictid !== state.check) {\n            return Z_DATA_ERROR;\n        }\n    }\n    /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */ ret = updatewindow(strm, dictionary, dictLength, dictLength);\n    if (ret) {\n        state.mode = MEM;\n        return Z_MEM_ERROR;\n    }\n    state.havedict = 1;\n    // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = \"pako inflate (from Nodeca project)\"; /* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsSUFBSUEsUUFBZ0JDLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlDLFVBQWdCRCxtQkFBT0EsQ0FBQztBQUM1QixJQUFJRSxRQUFnQkYsbUJBQU9BLENBQUM7QUFDNUIsSUFBSUcsZUFBZ0JILG1CQUFPQSxDQUFDO0FBQzVCLElBQUlJLGdCQUFnQkosbUJBQU9BLENBQUM7QUFFNUIsSUFBSUssUUFBUTtBQUNaLElBQUlDLE9BQU87QUFDWCxJQUFJQyxRQUFRO0FBRVosOEVBQThFLEdBQzlFLDhFQUE4RSxHQUc5RSx1RUFBdUUsR0FDdkUsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLElBQUlDLFdBQWtCO0FBQ3RCLElBQUlDLFVBQWtCO0FBQ3RCLElBQUlDLFVBQWtCO0FBR3RCOztDQUVDLEdBQ0QsSUFBSUMsT0FBa0I7QUFDdEIsSUFBSUMsZUFBa0I7QUFDdEIsSUFBSUMsY0FBa0I7QUFDdEIsMkJBQTJCO0FBQzNCLElBQUlDLGlCQUFrQixDQUFDO0FBQ3ZCLElBQUlDLGVBQWtCLENBQUM7QUFDdkIsSUFBSUMsY0FBa0IsQ0FBQztBQUN2QixJQUFJQyxjQUFrQixDQUFDO0FBQ3ZCLDJCQUEyQjtBQUUzQixrQ0FBa0MsR0FDbEMsSUFBSUMsYUFBYztB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QzNDLE9BQU9mO0lBQ1Q7SUFFQSwyQ0FBMkMsR0FDM0MsSUFBSWtGLE1BQU10QyxJQUFJLEtBQUs3QixNQUFNO1FBQ3ZCd0ksU0FBUyxHQUFHLHNCQUFzQjtRQUNsQyxxREFBcUQsR0FDckRBLFNBQVNwSyxRQUFRb0ssUUFBUUYsWUFBWUMsWUFBWTtRQUNqRCxJQUFJQyxXQUFXckUsTUFBTWhDLEtBQUssRUFBRTtZQUMxQixPQUFPakQ7UUFDVDtJQUNGO0lBQ0E7c0NBQ29DLEdBQ3BDMkYsTUFBTU8sYUFBYWxCLE1BQU1vRSxZQUFZQyxZQUFZQTtJQUNqRCxJQUFJMUQsS0FBSztRQUNQVixNQUFNdEMsSUFBSSxHQUFHVDtRQUNiLE9BQU9qQztJQUNUO0lBQ0FnRixNQUFNbkMsUUFBUSxHQUFHO0lBQ2pCLG1EQUFtRDtJQUNuRCxPQUFPbEQ7QUFDVDtBQUVBMkosb0JBQW9CLEdBQUdoRTtBQUN2QmdFLHFCQUFxQixHQUFHL0Q7QUFDeEIrRCx3QkFBd0IsR0FBR3hFO0FBQzNCd0UsbUJBQW1CLEdBQUczRDtBQUN0QjJELG9CQUFvQixHQUFHN0Q7QUFDdkI2RCxlQUFlLEdBQUc5QztBQUNsQjhDLGtCQUFrQixHQUFHTjtBQUNyQk0sd0JBQXdCLEdBQUdMO0FBQzNCSyw0QkFBNEIsR0FBR0o7QUFDL0JJLG1CQUFtQixHQUFHLHNDQUV0Qjs7Ozs7Ozs7QUFRQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanM/YzNlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJhZGxlcjMyIiwiY3JjMzIiLCJpbmZsYXRlX2Zhc3QiLCJpbmZsYXRlX3RhYmxlIiwiQ09ERVMiLCJMRU5TIiwiRElTVFMiLCJaX0ZJTklTSCIsIlpfQkxPQ0siLCJaX1RSRUVTIiwiWl9PSyIsIlpfU1RSRUFNX0VORCIsIlpfTkVFRF9ESUNUIiwiWl9TVFJFQU1fRVJST1IiLCJaX0RBVEFfRVJST1IiLCJaX01FTV9FUlJPUiIsIlpfQlVGX0VSUk9SIiwiWl9ERUZMQVRFRCIsIkhFQUQiLCJGTEFHUyIsIlRJTUUiLCJPUyIsIkVYTEVOIiwiRVhUUkEiLCJOQU1FIiwiQ09NTUVOVCIsIkhDUkMiLCJESUNUSUQiLCJESUNUIiwiVFlQRSIsIlRZUEVETyIsIlNUT1JFRCIsIkNPUFlfIiwiQ09QWSIsIlRBQkxFIiwiTEVOTEVOUyIsIkNPREVMRU5TIiwiTEVOXyIsIkxFTiIsIkxFTkVYVCIsIkRJU1QiLCJESVNURVhUIiwiTUFUQ0giLCJMSVQiLCJDSEVDSyIsIkxFTkdUSCIsIkRPTkUiLCJCQUQiLCJNRU0iLCJTWU5DIiwiRU5PVUdIX0xFTlMiLCJFTk9VR0hfRElTVFMiLCJNQVhfV0JJVFMiLCJERUZfV0JJVFMiLCJ6c3dhcDMyIiwicSIsIkluZmxhdGVTdGF0ZSIsIm1vZGUiLCJsYXN0Iiwid3JhcCIsImhhdmVkaWN0IiwiZmxhZ3MiLCJkbWF4IiwiY2hlY2siLCJ0b3RhbCIsImhlYWQiLCJ3Yml0cyIsIndzaXplIiwid2hhdmUiLCJ3bmV4dCIsIndpbmRvdyIsImhvbGQiLCJiaXRzIiwibGVuZ3RoIiwib2Zmc2V0IiwiZXh0cmEiLCJsZW5jb2RlIiwiZGlzdGNvZGUiLCJsZW5iaXRzIiwiZGlzdGJpdHMiLCJuY29kZSIsIm5sZW4iLCJuZGlzdCIsImhhdmUiLCJuZXh0IiwibGVucyIsIkJ1ZjE2Iiwid29yayIsImxlbmR5biIsImRpc3RkeW4iLCJzYW5lIiwiYmFjayIsIndhcyIsImluZmxhdGVSZXNldEtlZXAiLCJzdHJtIiwic3RhdGUiLCJ0b3RhbF9pbiIsInRvdGFsX291dCIsIm1zZyIsImFkbGVyIiwiQnVmMzIiLCJpbmZsYXRlUmVzZXQiLCJpbmZsYXRlUmVzZXQyIiwid2luZG93Qml0cyIsImluZmxhdGVJbml0MiIsInJldCIsImluZmxhdGVJbml0IiwidmlyZ2luIiwibGVuZml4IiwiZGlzdGZpeCIsImZpeGVkdGFibGVzIiwic3ltIiwidXBkYXRld2luZG93Iiwic3JjIiwiZW5kIiwiY29weSIsImRpc3QiLCJCdWY4IiwiYXJyYXlTZXQiLCJpbmZsYXRlIiwiZmx1c2giLCJpbnB1dCIsIm91dHB1dCIsInB1dCIsImxlZnQiLCJfaW4iLCJfb3V0IiwiZnJvbSIsImZyb21fc291cmNlIiwiaGVyZSIsImhlcmVfYml0cyIsImhlcmVfb3AiLCJoZXJlX3ZhbCIsImxhc3RfYml0cyIsImxhc3Rfb3AiLCJsYXN0X3ZhbCIsImxlbiIsImhidWYiLCJvcHRzIiwibiIsIm9yZGVyIiwiYXZhaWxfaW4iLCJuZXh0X291dCIsImF2YWlsX291dCIsIm5leHRfaW4iLCJpbmZfbGVhdmUiLCJkb25lIiwidGV4dCIsInRpbWUiLCJ4ZmxhZ3MiLCJvcyIsImV4dHJhX2xlbiIsIkFycmF5IiwibmFtZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvbW1lbnQiLCJoY3JjIiwiZGF0YV90eXBlIiwiaW5mbGF0ZUVuZCIsImluZmxhdGVHZXRIZWFkZXIiLCJpbmZsYXRlU2V0RGljdGlvbmFyeSIsImRpY3Rpb25hcnkiLCJkaWN0TGVuZ3RoIiwiZGljdGlkIiwiZXhwb3J0cyIsImluZmxhdGVJbmZvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inftrees.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inftrees.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\nvar lbase = [\n    /* Length codes 257..285 base */ 3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    13,\n    15,\n    17,\n    19,\n    23,\n    27,\n    31,\n    35,\n    43,\n    51,\n    59,\n    67,\n    83,\n    99,\n    115,\n    131,\n    163,\n    195,\n    227,\n    258,\n    0,\n    0\n];\nvar lext = [\n    /* Length codes 257..285 extra */ 16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    17,\n    17,\n    18,\n    18,\n    18,\n    18,\n    19,\n    19,\n    19,\n    19,\n    20,\n    20,\n    20,\n    20,\n    21,\n    21,\n    21,\n    21,\n    16,\n    72,\n    78\n];\nvar dbase = [\n    /* Distance codes 0..29 base */ 1,\n    2,\n    3,\n    4,\n    5,\n    7,\n    9,\n    13,\n    17,\n    25,\n    33,\n    49,\n    65,\n    97,\n    129,\n    193,\n    257,\n    385,\n    513,\n    769,\n    1025,\n    1537,\n    2049,\n    3073,\n    4097,\n    6145,\n    8193,\n    12289,\n    16385,\n    24577,\n    0,\n    0\n];\nvar dext = [\n    /* Distance codes 0..29 extra */ 16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    18,\n    18,\n    19,\n    19,\n    20,\n    20,\n    21,\n    21,\n    22,\n    22,\n    23,\n    23,\n    24,\n    24,\n    25,\n    25,\n    26,\n    26,\n    27,\n    27,\n    28,\n    28,\n    29,\n    29,\n    64,\n    64\n];\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n    var bits = opts.bits;\n    //here = opts.here; /* table entry for duplication */\n    var len = 0; /* a code's length in bits */ \n    var sym = 0; /* index of code symbols */ \n    var min = 0, max = 0; /* minimum and maximum code lengths */ \n    var root = 0; /* number of index bits for root table */ \n    var curr = 0; /* number of index bits for current table */ \n    var drop = 0; /* code bits to drop for sub-table */ \n    var left = 0; /* number of prefix codes available */ \n    var used = 0; /* code entries in table used */ \n    var huff = 0; /* Huffman code */ \n    var incr; /* for incrementing code, index */ \n    var fill; /* index for replicating entries */ \n    var low; /* low bits for current root entry */ \n    var mask; /* mask for low root bits */ \n    var next; /* next available space in table */ \n    var base = null; /* base value table to use */ \n    var base_index = 0;\n    //  var shoextra;    /* extra bits table to use */\n    var end; /* use base and extra for symbol > end */ \n    var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n    var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n    var extra = null;\n    var extra_index = 0;\n    var here_bits, here_op, here_val;\n    /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */ /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */ for(len = 0; len <= MAXBITS; len++){\n        count[len] = 0;\n    }\n    for(sym = 0; sym < codes; sym++){\n        count[lens[lens_index + sym]]++;\n    }\n    /* bound code lengths, force root to be within code lengths */ root = bits;\n    for(max = MAXBITS; max >= 1; max--){\n        if (count[max] !== 0) {\n            break;\n        }\n    }\n    if (root > max) {\n        root = max;\n    }\n    if (max === 0) {\n        //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n        //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n        //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n        table[table_index++] = 1 << 24 | 64 << 16 | 0;\n        //table.op[opts.table_index] = 64;\n        //table.bits[opts.table_index] = 1;\n        //table.val[opts.table_index++] = 0;\n        table[table_index++] = 1 << 24 | 64 << 16 | 0;\n        opts.bits = 1;\n        return 0; /* no symbols, but wait for decoding to report error */ \n    }\n    for(min = 1; min < max; min++){\n        if (count[min] !== 0) {\n            break;\n        }\n    }\n    if (root < min) {\n        root = min;\n    }\n    /* check for an over-subscribed or incomplete set of lengths */ left = 1;\n    for(len = 1; len <= MAXBITS; len++){\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) {\n            return -1;\n        } /* over-subscribed */ \n    }\n    if (left > 0 && (type === CODES || max !== 1)) {\n        return -1; /* incomplete set */ \n    }\n    /* generate offsets into symbol table for each length for sorting */ offs[1] = 0;\n    for(len = 1; len < MAXBITS; len++){\n        offs[len + 1] = offs[len] + count[len];\n    }\n    /* sort symbols by length, by symbol order within each length */ for(sym = 0; sym < codes; sym++){\n        if (lens[lens_index + sym] !== 0) {\n            work[offs[lens[lens_index + sym]]++] = sym;\n        }\n    }\n    /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */ /* set up for code type */ // poor man optimization - use if-else instead of switch,\n    // to avoid deopts in old v8\n    if (type === CODES) {\n        base = extra = work; /* dummy value--not used */ \n        end = 19;\n    } else if (type === LENS) {\n        base = lbase;\n        base_index -= 257;\n        extra = lext;\n        extra_index -= 257;\n        end = 256;\n    } else {\n        base = dbase;\n        extra = dext;\n        end = -1;\n    }\n    /* initialize opts for loop */ huff = 0; /* starting code */ \n    sym = 0; /* starting code symbol */ \n    len = min; /* starting code length */ \n    next = table_index; /* current table to fill in */ \n    curr = root; /* current table index bits */ \n    drop = 0; /* current bits to drop from code for index */ \n    low = -1; /* trigger new sub-table when len > root */ \n    used = 1 << root; /* use root table entries */ \n    mask = used - 1; /* mask for comparing low */ \n    /* check available table space */ if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n        return 1;\n    }\n    /* process all codes and make table entries */ for(;;){\n        /* create table entry */ here_bits = len - drop;\n        if (work[sym] < end) {\n            here_op = 0;\n            here_val = work[sym];\n        } else if (work[sym] > end) {\n            here_op = extra[extra_index + work[sym]];\n            here_val = base[base_index + work[sym]];\n        } else {\n            here_op = 32 + 64; /* end of block */ \n            here_val = 0;\n        }\n        /* replicate for those indices with low len bits equal to huff */ incr = 1 << len - drop;\n        fill = 1 << curr;\n        min = fill; /* save offset to next table */ \n        do {\n            fill -= incr;\n            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n        }while (fill !== 0);\n        /* backwards increment the len-bit code huff */ incr = 1 << len - 1;\n        while(huff & incr){\n            incr >>= 1;\n        }\n        if (incr !== 0) {\n            huff &= incr - 1;\n            huff += incr;\n        } else {\n            huff = 0;\n        }\n        /* go to next symbol, update count, len */ sym++;\n        if (--count[len] === 0) {\n            if (len === max) {\n                break;\n            }\n            len = lens[lens_index + work[sym]];\n        }\n        /* create new sub-table if needed */ if (len > root && (huff & mask) !== low) {\n            /* if first time, transition to sub-tables */ if (drop === 0) {\n                drop = root;\n            }\n            /* increment past last table */ next += min; /* here min is 1 << curr */ \n            /* determine length of next table */ curr = len - drop;\n            left = 1 << curr;\n            while(curr + drop < max){\n                left -= count[curr + drop];\n                if (left <= 0) {\n                    break;\n                }\n                curr++;\n                left <<= 1;\n            }\n            /* check for enough space */ used += 1 << curr;\n            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n                return 1;\n            }\n            /* point entry in root table to sub-table */ low = huff & mask;\n            /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/ table[low] = root << 24 | curr << 16 | next - table_index | 0;\n        }\n    }\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */ if (huff !== 0) {\n        //table.op[next + huff] = 64;            /* invalid code marker */\n        //table.bits[next + huff] = len - drop;\n        //table.val[next + huff] = 0;\n        table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n    }\n    /* set return parameters */ //opts.table_index += used;\n    opts.bits = root;\n    return 0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCLElBQUlDLFVBQVU7QUFDZCxJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGVBQWU7QUFDbkIsMENBQTBDO0FBRTFDLElBQUlDLFFBQVE7QUFDWixJQUFJQyxPQUFPO0FBQ1gsSUFBSUMsUUFBUTtBQUVaLElBQUlDLFFBQVE7SUFBRSw4QkFBOEIsR0FDMUM7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFDckQ7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFHO0NBQzlEO0FBRUQsSUFBSUMsT0FBTztJQUFFLCtCQUErQixHQUMxQztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUM1RDtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7Q0FDekQ7QUFFRCxJQUFJQyxRQUFRO0lBQUUsNkJBQTZCLEdBQ3pDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQ3REO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQ2xEO0lBQU07SUFBTztJQUFPO0lBQU87SUFBRztDQUMvQjtBQUVELElBQUlDLE9BQU87SUFBRSw4QkFBOEIsR0FDekM7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFDNUQ7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFDcEM7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0NBQ3JCO0FBRURDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxjQUFjQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFFbkcsSUFBSUMsT0FBT0QsS0FBS0MsSUFBSTtJQUNoQixxREFBcUQ7SUFFekQsSUFBSUMsTUFBTSxHQUFpQiwyQkFBMkI7SUFDdEQsSUFBSUMsTUFBTSxHQUFpQix5QkFBeUI7SUFDcEQsSUFBSUMsTUFBTSxHQUFHQyxNQUFNLEdBQVksb0NBQW9DO0lBQ25FLElBQUlDLE9BQU8sR0FBZ0IsdUNBQXVDO0lBQ2xFLElBQUlDLE9BQU8sR0FBZ0IsMENBQTBDO0lBQ3JFLElBQUlDLE9BQU8sR0FBZ0IsbUNBQW1DO0lBQzlELElBQUlDLE9BQU8sR0FBcUIsb0NBQW9DO0lBQ3BFLElBQUlDLE9BQU8sR0FBZ0IsOEJBQThCO0lBQ3pELElBQUlDLE9BQU8sR0FBZ0IsZ0JBQWdCO0lBQzNDLElBQUlDLE1BQW1CLGdDQUFnQztJQUN2RCxJQUFJQyxNQUFtQixpQ0FBaUM7SUFDeEQsSUFBSUMsS0FBbUIsbUNBQW1DO0lBQzFELElBQUlDLE1BQW1CLDBCQUEwQjtJQUNqRCxJQUFJQyxNQUFrQixpQ0FBaUM7SUFDdkQsSUFBSUMsT0FBTyxNQUFVLDJCQUEyQjtJQUNoRCxJQUFJQyxhQUFhO0lBQ25CLGtEQUFrRDtJQUNoRCxJQUFJQyxLQUF3Qix1Q0FBdUM7SUFDbkUsSUFBSUMsUUFBUSxJQUFJMUMsTUFBTTJDLEtBQUssQ0FBQ3pDLFVBQVUsSUFBSSxzREFBc0Q7SUFDaEcsSUFBSTBDLE9BQU8sSUFBSTVDLE1BQU0yQyxLQUFLLENBQUN6QyxVQUFVLElBQUkseURBQXlEO0lBQ2xHLElBQUkyQyxRQUFRO0lBQ1osSUFBSUMsY0FBYztJQUVsQixJQUFJQyxXQUFXQyxTQUFTQztJQUV4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2QkMsR0FFRCxtRUFBbUUsR0FDbkUsSUFBS3pCLE1BQU0sR0FBR0EsT0FBT3RCLFNBQVNzQixNQUFPO1FBQ25Da0IsS0FBSyxDQUFDbEIsSUFBSSxHQUFHO0lBQ2Y7SUFDQSxJQUFLQyxNQUFNLEdBQUdBLE1BQU1QLE9BQU9PLE1BQU87UUFDaENpQixLQUFLLENBQUMxQixJQUFJLENBQUNDLGFBQWFRLElBQUksQ0FBQztJQUMvQjtJQUVBLDREQUE0RCxHQUM1REcsT0FBT0w7SUFDUCxJQUFLSSxNQUFNekIsU0FBU3lCLE9BQU8sR0FBR0EsTUFBTztRQUNuQyxJQUFJZSxLQUFLLENBQUNmLElBQUksS0FBSyxHQUFHO1lBQUU7UUFBTztJQUNqQztJQUNBLElBQUlDLE9BQU9ELEtBQUs7UUFDZEMsT0FBT0Q7SUFDVDtJQUNBLElBQUlBLFFBQVEsR0FBRztRQUNiLDBGQUEwRjtRQUMxRixnRUFBZ0U7UUFDaEUsaUVBQWlFO1FBQ2pFUixLQUFLLENBQUNDLGNBQWMsR0FBRyxLQUFNLEtBQU8sTUFBTSxLQUFNO1FBR2hELGtDQUFrQztRQUNsQyxtQ0FBbUM7UUFDbkMsb0NBQW9DO1FBQ3BDRCxLQUFLLENBQUNDLGNBQWMsR0FBRyxLQUFNLEtBQU8sTUFBTSxLQUFNO1FBRWhERSxLQUFLQyxJQUFJLEdBQUc7UUFDWixPQUFPLEdBQU8scURBQXFEO0lBQ3JFO0lBQ0EsSUFBS0csTUFBTSxHQUFHQSxNQUFNQyxLQUFLRCxNQUFPO1FBQzlCLElBQUlnQixLQUFLLENBQUNoQixJQUFJLEtBQUssR0FBRztZQUFFO1FBQU87SUFDakM7SUFDQSxJQUFJRSxPQUFPRixLQUFLO1FBQ2RFLE9BQU9GO0lBQ1Q7SUFFQSw2REFBNkQsR0FDN0RLLE9BQU87SUFDUCxJQUFLUCxNQUFNLEdBQUdBLE9BQU90QixTQUFTc0IsTUFBTztRQUNuQ08sU0FBUztRQUNUQSxRQUFRVyxLQUFLLENBQUNsQixJQUFJO1FBQ2xCLElBQUlPLE9BQU8sR0FBRztZQUNaLE9BQU8sQ0FBQztRQUNWLEVBQVMsbUJBQW1CO0lBQzlCO0lBQ0EsSUFBSUEsT0FBTyxLQUFNaEIsQ0FBQUEsU0FBU1YsU0FBU3NCLFFBQVEsSUFBSTtRQUM3QyxPQUFPLENBQUMsR0FBd0Isa0JBQWtCO0lBQ3BEO0lBRUEsa0VBQWtFLEdBQ2xFaUIsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUNWLElBQUtwQixNQUFNLEdBQUdBLE1BQU10QixTQUFTc0IsTUFBTztRQUNsQ29CLElBQUksQ0FBQ3BCLE1BQU0sRUFBRSxHQUFHb0IsSUFBSSxDQUFDcEIsSUFBSSxHQUFHa0IsS0FBSyxDQUFDbEIsSUFBSTtJQUN4QztJQUVBLDhEQUE4RCxHQUM5RCxJQUFLQyxNQUFNLEdBQUdBLE1BQU1QLE9BQU9PLE1BQU87UUFDaEMsSUFBSVQsSUFBSSxDQUFDQyxhQUFhUSxJQUFJLEtBQUssR0FBRztZQUNoQ0osSUFBSSxDQUFDdUIsSUFBSSxDQUFDNUIsSUFBSSxDQUFDQyxhQUFhUSxJQUFJLENBQUMsR0FBRyxHQUFHQTtRQUN6QztJQUNGO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJDLEdBRUQsd0JBQXdCLEdBQ3hCLHlEQUF5RDtJQUN6RCw0QkFBNEI7SUFDNUIsSUFBSVYsU0FBU1YsT0FBTztRQUNsQmtDLE9BQU9NLFFBQVF4QixNQUFTLHlCQUF5QjtRQUNqRG9CLE1BQU07SUFFUixPQUFPLElBQUkxQixTQUFTVCxNQUFNO1FBQ3hCaUMsT0FBTy9CO1FBQ1BnQyxjQUFjO1FBQ2RLLFFBQVFwQztRQUNScUMsZUFBZTtRQUNmTCxNQUFNO0lBRVIsT0FBTztRQUNMRixPQUFPN0I7UUFDUG1DLFFBQVFsQztRQUNSOEIsTUFBTSxDQUFDO0lBQ1Q7SUFFQSw0QkFBNEIsR0FDNUJSLE9BQU8sR0FBcUIsaUJBQWlCO0lBQzdDUixNQUFNLEdBQXNCLHdCQUF3QjtJQUNwREQsTUFBTUUsS0FBc0Isd0JBQXdCO0lBQ3BEWSxPQUFPbEIsYUFBMEIsNEJBQTRCO0lBQzdEUyxPQUFPRCxNQUFxQiw0QkFBNEI7SUFDeERFLE9BQU8sR0FBcUIsNENBQTRDO0lBQ3hFTSxNQUFNLENBQUMsR0FBcUIseUNBQXlDO0lBQ3JFSixPQUFPLEtBQUtKLE1BQWUsMEJBQTBCO0lBQ3JEUyxPQUFPTCxPQUFPLEdBQWMsMEJBQTBCO0lBRXRELCtCQUErQixHQUMvQixJQUFJLFNBQVUxQixRQUFRMEIsT0FBTzdCLGVBQzFCWSxTQUFTUixTQUFTeUIsT0FBTzVCLGNBQWU7UUFDekMsT0FBTztJQUNUO0lBRUEsNENBQTRDLEdBQzVDLE9BQVM7UUFDUCxzQkFBc0IsR0FDdEIyQyxZQUFZdkIsTUFBTU07UUFDbEIsSUFBSVQsSUFBSSxDQUFDSSxJQUFJLEdBQUdnQixLQUFLO1lBQ25CTyxVQUFVO1lBQ1ZDLFdBQVc1QixJQUFJLENBQUNJLElBQUk7UUFDdEIsT0FDSyxJQUFJSixJQUFJLENBQUNJLElBQUksR0FBR2dCLEtBQUs7WUFDeEJPLFVBQVVILEtBQUssQ0FBQ0MsY0FBY3pCLElBQUksQ0FBQ0ksSUFBSSxDQUFDO1lBQ3hDd0IsV0FBV1YsSUFBSSxDQUFDQyxhQUFhbkIsSUFBSSxDQUFDSSxJQUFJLENBQUM7UUFDekMsT0FDSztZQUNIdUIsVUFBVSxLQUFLLElBQVksZ0JBQWdCO1lBQzNDQyxXQUFXO1FBQ2I7UUFFQSwrREFBK0QsR0FDL0RmLE9BQU8sS0FBTVYsTUFBTU07UUFDbkJLLE9BQU8sS0FBS047UUFDWkgsTUFBTVMsTUFBc0IsNkJBQTZCO1FBQ3pELEdBQUc7WUFDREEsUUFBUUQ7WUFDUmYsS0FBSyxDQUFDbUIsT0FBUUwsQ0FBQUEsUUFBUUgsSUFBRyxJQUFLSyxLQUFLLEdBQUcsYUFBYyxLQUFPYSxXQUFXLEtBQU1DLFdBQVU7UUFDeEYsUUFBU2QsU0FBUyxHQUFHO1FBRXJCLDZDQUE2QyxHQUM3Q0QsT0FBTyxLQUFNVixNQUFNO1FBQ25CLE1BQU9TLE9BQU9DLEtBQU07WUFDbEJBLFNBQVM7UUFDWDtRQUNBLElBQUlBLFNBQVMsR0FBRztZQUNkRCxRQUFRQyxPQUFPO1lBQ2ZELFFBQVFDO1FBQ1YsT0FBTztZQUNMRCxPQUFPO1FBQ1Q7UUFFQSx3Q0FBd0MsR0FDeENSO1FBQ0EsSUFBSSxFQUFFaUIsS0FBSyxDQUFDbEIsSUFBSSxLQUFLLEdBQUc7WUFDdEIsSUFBSUEsUUFBUUcsS0FBSztnQkFBRTtZQUFPO1lBQzFCSCxNQUFNUixJQUFJLENBQUNDLGFBQWFJLElBQUksQ0FBQ0ksSUFBSSxDQUFDO1FBQ3BDO1FBRUEsa0NBQWtDLEdBQ2xDLElBQUlELE1BQU1JLFFBQVEsQ0FBQ0ssT0FBT0ksSUFBRyxNQUFPRCxLQUFLO1lBQ3ZDLDJDQUEyQyxHQUMzQyxJQUFJTixTQUFTLEdBQUc7Z0JBQ2RBLE9BQU9GO1lBQ1Q7WUFFQSw2QkFBNkIsR0FDN0JVLFFBQVFaLEtBQWdCLHlCQUF5QjtZQUVqRCxrQ0FBa0MsR0FDbENHLE9BQU9MLE1BQU1NO1lBQ2JDLE9BQU8sS0FBS0Y7WUFDWixNQUFPQSxPQUFPQyxPQUFPSCxJQUFLO2dCQUN4QkksUUFBUVcsS0FBSyxDQUFDYixPQUFPQyxLQUFLO2dCQUMxQixJQUFJQyxRQUFRLEdBQUc7b0JBQUU7Z0JBQU87Z0JBQ3hCRjtnQkFDQUUsU0FBUztZQUNYO1lBRUEsMEJBQTBCLEdBQzFCQyxRQUFRLEtBQUtIO1lBQ2IsSUFBSSxTQUFVdkIsUUFBUTBCLE9BQU83QixlQUMxQlksU0FBU1IsU0FBU3lCLE9BQU81QixjQUFlO2dCQUN6QyxPQUFPO1lBQ1Q7WUFFQSwwQ0FBMEMsR0FDMUNnQyxNQUFNSCxPQUFPSTtZQUNiOzsrQ0FFeUMsR0FDekNsQixLQUFLLENBQUNpQixJQUFJLEdBQUcsUUFBUyxLQUFPUCxRQUFRLEtBQU9TLE9BQU9sQixjQUFjO1FBQ25FO0lBQ0Y7SUFFQTs7b0VBRWtFLEdBQ2xFLElBQUlhLFNBQVMsR0FBRztRQUNkLGtFQUFrRTtRQUNsRSx1Q0FBdUM7UUFDdkMsNkJBQTZCO1FBQzdCZCxLQUFLLENBQUNtQixPQUFPTCxLQUFLLEdBQUcsTUFBUUgsUUFBUyxLQUFPLE1BQU0sS0FBSztJQUMxRDtJQUVBLHlCQUF5QixHQUN6QiwyQkFBMkI7SUFDM0JSLEtBQUtDLElBQUksR0FBR0s7SUFDWixPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcz9mNTZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJNQVhCSVRTIiwiRU5PVUdIX0xFTlMiLCJFTk9VR0hfRElTVFMiLCJDT0RFUyIsIkxFTlMiLCJESVNUUyIsImxiYXNlIiwibGV4dCIsImRiYXNlIiwiZGV4dCIsIm1vZHVsZSIsImV4cG9ydHMiLCJpbmZsYXRlX3RhYmxlIiwidHlwZSIsImxlbnMiLCJsZW5zX2luZGV4IiwiY29kZXMiLCJ0YWJsZSIsInRhYmxlX2luZGV4Iiwid29yayIsIm9wdHMiLCJiaXRzIiwibGVuIiwic3ltIiwibWluIiwibWF4Iiwicm9vdCIsImN1cnIiLCJkcm9wIiwibGVmdCIsInVzZWQiLCJodWZmIiwiaW5jciIsImZpbGwiLCJsb3ciLCJtYXNrIiwibmV4dCIsImJhc2UiLCJiYXNlX2luZGV4IiwiZW5kIiwiY291bnQiLCJCdWYxNiIsIm9mZnMiLCJleHRyYSIsImV4dHJhX2luZGV4IiwiaGVyZV9iaXRzIiwiaGVyZV9vcCIsImhlcmVfdmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inftrees.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nmodule.exports = {\n    2: \"need dictionary\",\n    /* Z_NEED_DICT       2  */ 1: \"stream end\",\n    /* Z_STREAM_END      1  */ 0: \"\",\n    /* Z_OK              0  */ \"-1\": \"file error\",\n    /* Z_ERRNO         (-1) */ \"-2\": \"stream error\",\n    /* Z_STREAM_ERROR  (-2) */ \"-3\": \"data error\",\n    /* Z_DATA_ERROR    (-3) */ \"-4\": \"insufficient memory\",\n    /* Z_MEM_ERROR     (-4) */ \"-5\": \"buffer error\",\n    /* Z_BUF_ERROR     (-5) */ \"-6\": \"incompatible version\" /* Z_VERSION_ERROR (-6) */ \n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFQSxPQUFPQyxPQUFPLEdBQUc7SUFDZixHQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxHQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxHQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRLHVCQUF1Qix3QkFBd0I7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcz9hNmRjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/trees.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/trees.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n/* eslint-disable space-unary-ops */ var utils = __webpack_require__(/*! ../utils/common */ \"(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\n/* Public constants ==========================================================*/ /* ===========================================================================*/ //var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n/* Possible values of the data_type field (though see inflate()) */ var Z_BINARY = 0;\nvar Z_TEXT = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN = 2;\n/*============================================================================*/ function zero(buf) {\n    var len = buf.length;\n    while(--len >= 0){\n        buf[len] = 0;\n    }\n}\n// From zutil.h\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES = 2;\n/* The three kinds of block type */ var MIN_MATCH = 3;\nvar MAX_MATCH = 258;\n/* The minimum and maximum match lengths */ // From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */ var LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;\n/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;\n/* number of distance codes */ var BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */ var MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */ var Buf_size = 16;\n/* size of bit buffer in bi_buf */ /* ===========================================================================\n * Constants\n */ var MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */ var END_BLOCK = 256;\n/* end of block literal code */ var REP_3_6 = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */ var REPZ_3_10 = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */ var REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */ /* eslint-disable comma-spacing,array-bracket-spacing */ var extra_lbits = /* extra bits for each length code */ [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0\n];\nvar extra_dbits = /* extra bits for each distance code */ [\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13\n];\nvar extra_blbits = /* extra bits for each bit length code */ [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    3,\n    7\n];\nvar bl_order = [\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n];\n/* eslint-enable comma-spacing,array-bracket-spacing */ /* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */ /* ===========================================================================\n * Local data. These are initialized only once.\n */ // We pre-fill arrays with 0 to avoid uninitialized gaps\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */ \n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */ var static_dtree = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */ var _dist_code = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */ var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */ var base_length = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */ var base_dist = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */ function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n    this.static_tree = static_tree; /* static tree or NULL */ \n    this.extra_bits = extra_bits; /* extra bits for each code or NULL */ \n    this.extra_base = extra_base; /* base index for extra_bits */ \n    this.elems = elems; /* max number of elements in the tree */ \n    this.max_length = max_length; /* max bit length for the codes */ \n    // show if `static_tree` has data or dummy - needed for monomorphic objects\n    this.has_stree = static_tree && static_tree.length;\n}\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\nfunction TreeDesc(dyn_tree, stat_desc) {\n    this.dyn_tree = dyn_tree; /* the dynamic tree */ \n    this.max_code = 0; /* largest code with non zero frequency */ \n    this.stat_desc = stat_desc; /* the corresponding static tree */ \n}\nfunction d_code(dist) {\n    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */ function put_short(s, w) {\n    //    put_byte(s, (uch)((w) & 0xff));\n    //    put_byte(s, (uch)((ush)(w) >> 8));\n    s.pending_buf[s.pending++] = w & 0xff;\n    s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n}\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */ function send_bits(s, value, length) {\n    if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> Buf_size - s.bi_valid;\n        s.bi_valid += length - Buf_size;\n    } else {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        s.bi_valid += length;\n    }\n}\nfunction send_code(s, c, tree) {\n    send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n}\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */ function bi_reverse(code, len) {\n    var res = 0;\n    do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n    }while (--len > 0);\n    return res >>> 1;\n}\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */ function bi_flush(s) {\n    if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n    } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n    }\n}\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */ function gen_bitlen(s, desc) //    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n    var tree = desc.dyn_tree;\n    var max_code = desc.max_code;\n    var stree = desc.stat_desc.static_tree;\n    var has_stree = desc.stat_desc.has_stree;\n    var extra = desc.stat_desc.extra_bits;\n    var base = desc.stat_desc.extra_base;\n    var max_length = desc.stat_desc.max_length;\n    var h; /* heap index */ \n    var n, m; /* iterate over the tree elements */ \n    var bits; /* bit length */ \n    var xbits; /* extra bits */ \n    var f; /* frequency */ \n    var overflow = 0; /* number of elements with bit length too large */ \n    for(bits = 0; bits <= MAX_BITS; bits++){\n        s.bl_count[bits] = 0;\n    }\n    /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */ tree[s.heap[s.heap_max] * 2 + 1] = 0; /* root of the heap */ \n    for(h = s.heap_max + 1; h < HEAP_SIZE; h++){\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n        if (bits > max_length) {\n            bits = max_length;\n            overflow++;\n        }\n        tree[n * 2 + 1] = bits;\n        /* We overwrite tree[n].Dad which is no longer needed */ if (n > max_code) {\n            continue;\n        } /* not a leaf node */ \n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n            xbits = extra[n - base];\n        }\n        f = tree[n * 2] /*.Freq*/ ;\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n            s.static_len += f * (stree[n * 2 + 1] + xbits);\n        }\n    }\n    if (overflow === 0) {\n        return;\n    }\n    // Trace((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */ /* Find the first bit length which could increase: */ do {\n        bits = max_length - 1;\n        while(s.bl_count[bits] === 0){\n            bits--;\n        }\n        s.bl_count[bits]--; /* move one leaf down the tree */ \n        s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */ \n        s.bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */ overflow -= 2;\n    }while (overflow > 0);\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */ for(bits = max_length; bits !== 0; bits--){\n        n = s.bl_count[bits];\n        while(n !== 0){\n            m = s.heap[--h];\n            if (m > max_code) {\n                continue;\n            }\n            if (tree[m * 2 + 1] !== bits) {\n                // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2] /*.Freq*/ ;\n                tree[m * 2 + 1] = bits;\n            }\n            n--;\n        }\n    }\n}\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */ function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n    var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */ \n    var code = 0; /* running code value */ \n    var bits; /* bit index */ \n    var n; /* code index */ \n    /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */ for(bits = 1; bits <= MAX_BITS; bits++){\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */ //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n    //        \"inconsistent bit counts\");\n    //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n    for(n = 0; n <= max_code; n++){\n        var len = tree[n * 2 + 1] /*.Len*/ ;\n        if (len === 0) {\n            continue;\n        }\n        /* Now reverse the bits */ tree[n * 2] = bi_reverse(next_code[len]++, len);\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n}\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */ function tr_static_init() {\n    var n; /* iterates over tree elements */ \n    var bits; /* bit counter */ \n    var length; /* length value */ \n    var code; /* code value */ \n    var dist; /* distance index */ \n    var bl_count = new Array(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */ // do check in _tr_init()\n    //if (static_init_done) return;\n    /* For some embedded targets, global variables are not initialized: */ /*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/ /* Initialize the mapping length (0..255) -> length code (0..28) */ length = 0;\n    for(code = 0; code < LENGTH_CODES - 1; code++){\n        base_length[code] = length;\n        for(n = 0; n < 1 << extra_lbits[code]; n++){\n            _length_code[length++] = code;\n        }\n    }\n    //Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */ _length_code[length - 1] = code;\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */ dist = 0;\n    for(code = 0; code < 16; code++){\n        base_dist[code] = dist;\n        for(n = 0; n < 1 << extra_dbits[code]; n++){\n            _dist_code[dist++] = code;\n        }\n    }\n    //Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */ \n    for(; code < D_CODES; code++){\n        base_dist[code] = dist << 7;\n        for(n = 0; n < 1 << extra_dbits[code] - 7; n++){\n            _dist_code[256 + dist++] = code;\n        }\n    }\n    //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n    /* Construct the codes of the static literal tree */ for(bits = 0; bits <= MAX_BITS; bits++){\n        bl_count[bits] = 0;\n    }\n    n = 0;\n    while(n <= 143){\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n    }\n    while(n <= 255){\n        static_ltree[n * 2 + 1] = 9;\n        n++;\n        bl_count[9]++;\n    }\n    while(n <= 279){\n        static_ltree[n * 2 + 1] = 7;\n        n++;\n        bl_count[7]++;\n    }\n    while(n <= 287){\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n    }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */ gen_codes(static_ltree, L_CODES + 1, bl_count);\n    /* The static distance tree is trivial: */ for(n = 0; n < D_CODES; n++){\n        static_dtree[n * 2 + 1] = 5;\n        static_dtree[n * 2] = bi_reverse(n, 5);\n    }\n    // Now data ready and we can init static trees\n    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n//static_init_done = true;\n}\n/* ===========================================================================\n * Initialize a new block.\n */ function init_block(s) {\n    var n; /* iterates over tree elements */ \n    /* Initialize the trees. */ for(n = 0; n < L_CODES; n++){\n        s.dyn_ltree[n * 2] = 0;\n    }\n    for(n = 0; n < D_CODES; n++){\n        s.dyn_dtree[n * 2] = 0;\n    }\n    for(n = 0; n < BL_CODES; n++){\n        s.bl_tree[n * 2] = 0;\n    }\n    s.dyn_ltree[END_BLOCK * 2] = 1;\n    s.opt_len = s.static_len = 0;\n    s.last_lit = s.matches = 0;\n}\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */ function bi_windup(s) {\n    if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n    } else if (s.bi_valid > 0) {\n        //put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf;\n    }\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n}\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */ function copy_block(s, buf, len, header) //DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n    bi_windup(s); /* align on byte boundary */ \n    if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n    }\n    //  while (len--) {\n    //    put_byte(s, *buf++);\n    //  }\n    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n    s.pending += len;\n}\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */ function smaller(tree, n, m, depth) {\n    var _n2 = n * 2;\n    var _m2 = m * 2;\n    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n}\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */ function pqdownheap(s, tree, k) //    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n    var v = s.heap[k];\n    var j = k << 1; /* left son of k */ \n    while(j <= s.heap_len){\n        /* Set j to the smallest of the two sons: */ if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */ if (smaller(tree, v, s.heap[j], s.depth)) {\n            break;\n        }\n        /* Exchange v with the smallest son */ s.heap[k] = s.heap[j];\n        k = j;\n        /* And continue down the tree, setting j to the left son of k */ j <<= 1;\n    }\n    s.heap[k] = v;\n}\n// inlined manually\n// var SMALLEST = 1;\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */ function compress_block(s, ltree, dtree) //    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n    var dist; /* distance of matched string */ \n    var lc; /* match length or unmatched char (if dist == 0) */ \n    var lx = 0; /* running index in l_buf */ \n    var code; /* the code to send */ \n    var extra; /* number of extra bits to send */ \n    if (s.last_lit !== 0) {\n        do {\n            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n            lc = s.pending_buf[s.l_buf + lx];\n            lx++;\n            if (dist === 0) {\n                send_code(s, lc, ltree); /* send a literal byte */ \n            //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n            } else {\n                /* Here, lc is the match length - MIN_MATCH */ code = _length_code[lc];\n                send_code(s, code + LITERALS + 1, ltree); /* send the length code */ \n                extra = extra_lbits[code];\n                if (extra !== 0) {\n                    lc -= base_length[code];\n                    send_bits(s, lc, extra); /* send the extra length bits */ \n                }\n                dist--; /* dist is now the match distance - 1 */ \n                code = d_code(dist);\n                //Assert (code < D_CODES, \"bad d_code\");\n                send_code(s, code, dtree); /* send the distance code */ \n                extra = extra_dbits[code];\n                if (extra !== 0) {\n                    dist -= base_dist[code];\n                    send_bits(s, dist, extra); /* send the extra distance bits */ \n                }\n            } /* literal or match pair ? */ \n        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */ //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n        //       \"pendingBuf overflow\");\n        }while (lx < s.last_lit);\n    }\n    send_code(s, END_BLOCK, ltree);\n}\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */ function build_tree(s, desc) //    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n    var tree = desc.dyn_tree;\n    var stree = desc.stat_desc.static_tree;\n    var has_stree = desc.stat_desc.has_stree;\n    var elems = desc.stat_desc.elems;\n    var n, m; /* iterate over heap elements */ \n    var max_code = -1; /* largest code with non zero frequency */ \n    var node; /* new node being created */ \n    /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */ s.heap_len = 0;\n    s.heap_max = HEAP_SIZE;\n    for(n = 0; n < elems; n++){\n        if (tree[n * 2] !== 0) {\n            s.heap[++s.heap_len] = max_code = n;\n            s.depth[n] = 0;\n        } else {\n            tree[n * 2 + 1] = 0;\n        }\n    }\n    /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */ while(s.heap_len < 2){\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (has_stree) {\n            s.static_len -= stree[node * 2 + 1] /*.Len*/ ;\n        }\n    /* node is 0 or 1 so it does not have extra bits */ }\n    desc.max_code = max_code;\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */ for(n = s.heap_len >> 1 /*int /2*/ ; n >= 1; n--){\n        pqdownheap(s, tree, n);\n    }\n    /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */ node = elems; /* next internal node of the tree */ \n    do {\n        //pqremove(s, tree, n);  /* n = node of least frequency */\n        /*** pqremove ***/ n = s.heap[1 /*SMALLEST*/ ];\n        s.heap[1 /*SMALLEST*/ ] = s.heap[s.heap_len--];\n        pqdownheap(s, tree, 1 /*SMALLEST*/ );\n        /***/ m = s.heap[1 /*SMALLEST*/ ]; /* m = node of next least frequency */ \n        s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */ \n        s.heap[--s.heap_max] = m;\n        /* Create a new node father of n and m */ tree[node * 2] = tree[n * 2] + tree[m * 2] /*.Freq*/ ;\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n        /* and insert the new node in the heap */ s.heap[1 /*SMALLEST*/ ] = node++;\n        pqdownheap(s, tree, 1 /*SMALLEST*/ );\n    }while (s.heap_len >= 2);\n    s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/ ];\n    /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */ gen_bitlen(s, desc);\n    /* The field len is now set, we can generate the bit codes */ gen_codes(tree, max_code, s.bl_count);\n}\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */ function scan_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n    var n; /* iterates over all tree elements */ \n    var prevlen = -1; /* last emitted length */ \n    var curlen; /* length of current code */ \n    var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */ \n    var count = 0; /* repeat count of the current code */ \n    var max_count = 7; /* max repeat count */ \n    var min_count = 4; /* min repeat count */ \n    if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n    }\n    tree[(max_code + 1) * 2 + 1] = 0xffff; /* guard */ \n    for(n = 0; n <= max_code; n++){\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n        if (++count < max_count && curlen === nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s.bl_tree[curlen * 2] += count;\n        } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n                s.bl_tree[curlen * 2]++;\n            }\n            s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10) {\n            s.bl_tree[REPZ_3_10 * 2]++;\n        } else {\n            s.bl_tree[REPZ_11_138 * 2]++;\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n    }\n}\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */ function send_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n    var n; /* iterates over all tree elements */ \n    var prevlen = -1; /* last emitted length */ \n    var curlen; /* length of current code */ \n    var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */ \n    var count = 0; /* repeat count of the current code */ \n    var max_count = 7; /* max repeat count */ \n    var min_count = 4; /* min repeat count */ \n    /* tree[max_code+1].Len = -1; */ /* guard already set */ if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n    }\n    for(n = 0; n <= max_code; n++){\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n        if (++count < max_count && curlen === nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do {\n                send_code(s, curlen, s.bl_tree);\n            }while (--count !== 0);\n        } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n                send_code(s, curlen, s.bl_tree);\n                count--;\n            }\n            //Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s.bl_tree);\n            send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s.bl_tree);\n            send_bits(s, count - 3, 3);\n        } else {\n            send_code(s, REPZ_11_138, s.bl_tree);\n            send_bits(s, count - 11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n    }\n}\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */ function build_bl_tree(s) {\n    var max_blindex; /* index of last bit length code of non zero freq */ \n    /* Determine the bit length frequencies for literal and distance trees */ scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n    /* Build the bit length tree: */ build_tree(s, s.bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */ /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */ for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n            break;\n        }\n    }\n    /* Update opt_len to include the bit length tree and counts */ s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n    //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n    //        s->opt_len, s->static_len));\n    return max_blindex;\n}\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */ function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n    var rank; /* index in bl_order */ \n    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n    //        \"too many codes\");\n    //Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */ \n    send_bits(s, dcodes - 1, 5);\n    send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */ \n    for(rank = 0; rank < blcodes; rank++){\n        //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n    }\n    //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */ \n    //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */ \n//Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */ function detect_data_type(s) {\n    /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */ var black_mask = 0xf3ffc07f;\n    var n;\n    /* Check for non-textual (\"black-listed\") bytes. */ for(n = 0; n <= 31; n++, black_mask >>>= 1){\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n            return Z_BINARY;\n        }\n    }\n    /* Check for textual (\"white-listed\") bytes. */ if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n        return Z_TEXT;\n    }\n    for(n = 32; n < LITERALS; n++){\n        if (s.dyn_ltree[n * 2] !== 0) {\n            return Z_TEXT;\n        }\n    }\n    /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */ return Z_BINARY;\n}\nvar static_init_done = false;\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */ function _tr_init(s) {\n    if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n    }\n    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n    /* Initialize the first block of the first file: */ init_block(s);\n}\n/* ===========================================================================\n * Send a stored block\n */ function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */ \n    copy_block(s, buf, stored_len, true); /* with header */ \n}\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */ function _tr_align(s) {\n    send_bits(s, STATIC_TREES << 1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n    bi_flush(s);\n}\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */ function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n    var opt_lenb, static_lenb; /* opt_len and static_len in bytes */ \n    var max_blindex = 0; /* index of last bit length code of non zero freq */ \n    /* Build the Huffman trees unless a stored block is forced */ if (s.level > 0) {\n        /* Check if the file is binary or text */ if (s.strm.data_type === Z_UNKNOWN) {\n            s.strm.data_type = detect_data_type(s);\n        }\n        /* Construct the literal and distance trees */ build_tree(s, s.l_desc);\n        // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        build_tree(s, s.d_desc);\n        // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */ /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */ max_blindex = build_bl_tree(s);\n        /* Determine the best encoding. Compute the block lengths in bytes. */ opt_lenb = s.opt_len + 3 + 7 >>> 3;\n        static_lenb = s.static_len + 3 + 7 >>> 3;\n        // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n        if (static_lenb <= opt_lenb) {\n            opt_lenb = static_lenb;\n        }\n    } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */ \n    }\n    if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */ /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */ _tr_stored_block(s, buf, stored_len, last);\n    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n    } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n    }\n    // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */ init_block(s);\n    if (last) {\n        bi_windup(s);\n    }\n// Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n//       s->compressed_len-7*last));\n}\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */ function _tr_tally(s, dist, lc) //    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n    //var out_length, in_length, dcode;\n    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n    s.last_lit++;\n    if (dist === 0) {\n        /* lc is the unmatched char */ s.dyn_ltree[lc * 2]++;\n    } else {\n        s.matches++;\n        /* Here, lc is the match length - MIN_MATCH */ dist--; /* dist = match distance - 1 */ \n        //Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n        s.dyn_dtree[d_code(dist) * 2]++;\n    }\n    // (!) This block is disabled in zlib defaults,\n    // don't enable it for binary compatibility\n    //#ifdef TRUNCATE_BLOCK\n    //  /* Try to guess if it is profitable to stop the current block here */\n    //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n    //    /* Compute an upper bound for the compressed length */\n    //    out_length = s.last_lit*8;\n    //    in_length = s.strstart - s.block_start;\n    //\n    //    for (dcode = 0; dcode < D_CODES; dcode++) {\n    //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n    //    }\n    //    out_length >>>= 3;\n    //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n    //    //       s->last_lit, in_length, out_length,\n    //    //       100L - out_length*100L/in_length));\n    //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n    //      return true;\n    //    }\n    //  }\n    //#endif\n    return s.last_lit === s.lit_bufsize - 1;\n/* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */ }\nexports._tr_init = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLGtDQUFrQyxHQUVsQyxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQiw4RUFBOEUsR0FDOUUsOEVBQThFLEdBRzlFLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLElBQUlDLFVBQXdCO0FBQzVCLDhCQUE4QjtBQUU5QixpRUFBaUUsR0FDakUsSUFBSUMsV0FBd0I7QUFDNUIsSUFBSUMsU0FBd0I7QUFDNUIsMENBQTBDO0FBQzFDLElBQUlDLFlBQXdCO0FBRTVCLDhFQUE4RSxHQUc5RSxTQUFTQyxLQUFLQyxHQUFHO0lBQUksSUFBSUMsTUFBTUQsSUFBSUUsTUFBTTtJQUFFLE1BQU8sRUFBRUQsT0FBTyxFQUFHO1FBQUVELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO0lBQUc7QUFBRTtBQUVoRixlQUFlO0FBRWYsSUFBSUUsZUFBZTtBQUNuQixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLFlBQWU7QUFDbkIsaUNBQWlDLEdBRWpDLElBQUlDLFlBQWU7QUFDbkIsSUFBSUMsWUFBZTtBQUNuQix5Q0FBeUMsR0FFekMsaUJBQWlCO0FBQ2pCOztDQUVDLEdBRUQsSUFBSUMsZUFBZ0I7QUFDcEIsbUVBQW1FLEdBRW5FLElBQUlDLFdBQWdCO0FBQ3BCLGtDQUFrQyxHQUVsQyxJQUFJQyxV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d0JBQXdCO0lBQ3hCLGlFQUFpRTtJQUNqRSxrREFBa0Q7SUFDbEQsa0RBQWtEO0lBQ2xELDJGQUEyRjtJQUMzRixvQkFBb0I7SUFDcEIsT0FBTztJQUNQLEtBQUs7SUFDTCxRQUFRO0lBRU4sT0FBUUUsRUFBRXVDLFFBQVEsS0FBS3ZDLEVBQUVrRyxXQUFXLEdBQUc7QUFDdkM7OztHQUdDLEdBQ0g7QUFFQUMsZ0JBQWdCLEdBQUlkO0FBQ3BCYyx3QkFBd0IsR0FBR2I7QUFDM0JhLHVCQUF1QixHQUFJVDtBQUMzQlMsaUJBQWlCLEdBQUdGO0FBQ3BCRSxpQkFBaUIsR0FBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcz82OTZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS11bmFyeS1vcHMgKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIlpfRklYRUQiLCJaX0JJTkFSWSIsIlpfVEVYVCIsIlpfVU5LTk9XTiIsInplcm8iLCJidWYiLCJsZW4iLCJsZW5ndGgiLCJTVE9SRURfQkxPQ0siLCJTVEFUSUNfVFJFRVMiLCJEWU5fVFJFRVMiLCJNSU5fTUFUQ0giLCJNQVhfTUFUQ0giLCJMRU5HVEhfQ09ERVMiLCJMSVRFUkFMUyIsIkxfQ09ERVMiLCJEX0NPREVTIiwiQkxfQ09ERVMiLCJIRUFQX1NJWkUiLCJNQVhfQklUUyIsIkJ1Zl9zaXplIiwiTUFYX0JMX0JJVFMiLCJFTkRfQkxPQ0siLCJSRVBfM182IiwiUkVQWl8zXzEwIiwiUkVQWl8xMV8xMzgiLCJleHRyYV9sYml0cyIsImV4dHJhX2RiaXRzIiwiZXh0cmFfYmxiaXRzIiwiYmxfb3JkZXIiLCJESVNUX0NPREVfTEVOIiwic3RhdGljX2x0cmVlIiwiQXJyYXkiLCJzdGF0aWNfZHRyZWUiLCJfZGlzdF9jb2RlIiwiX2xlbmd0aF9jb2RlIiwiYmFzZV9sZW5ndGgiLCJiYXNlX2Rpc3QiLCJTdGF0aWNUcmVlRGVzYyIsInN0YXRpY190cmVlIiwiZXh0cmFfYml0cyIsImV4dHJhX2Jhc2UiLCJlbGVtcyIsIm1heF9sZW5ndGgiLCJoYXNfc3RyZWUiLCJzdGF0aWNfbF9kZXNjIiwic3RhdGljX2RfZGVzYyIsInN0YXRpY19ibF9kZXNjIiwiVHJlZURlc2MiLCJkeW5fdHJlZSIsInN0YXRfZGVzYyIsIm1heF9jb2RlIiwiZF9jb2RlIiwiZGlzdCIsInB1dF9zaG9ydCIsInMiLCJ3IiwicGVuZGluZ19idWYiLCJwZW5kaW5nIiwic2VuZF9iaXRzIiwidmFsdWUiLCJiaV92YWxpZCIsImJpX2J1ZiIsInNlbmRfY29kZSIsImMiLCJ0cmVlIiwiYmlfcmV2ZXJzZSIsImNvZGUiLCJyZXMiLCJiaV9mbHVzaCIsImdlbl9iaXRsZW4iLCJkZXNjIiwic3RyZWUiLCJleHRyYSIsImJhc2UiLCJoIiwibiIsIm0iLCJiaXRzIiwieGJpdHMiLCJmIiwib3ZlcmZsb3ciLCJibF9jb3VudCIsImhlYXAiLCJoZWFwX21heCIsIm9wdF9sZW4iLCJzdGF0aWNfbGVuIiwiZ2VuX2NvZGVzIiwibmV4dF9jb2RlIiwidHJfc3RhdGljX2luaXQiLCJpbml0X2Jsb2NrIiwiZHluX2x0cmVlIiwiZHluX2R0cmVlIiwiYmxfdHJlZSIsImxhc3RfbGl0IiwibWF0Y2hlcyIsImJpX3dpbmR1cCIsImNvcHlfYmxvY2siLCJoZWFkZXIiLCJhcnJheVNldCIsIndpbmRvdyIsInNtYWxsZXIiLCJkZXB0aCIsIl9uMiIsIl9tMiIsInBxZG93bmhlYXAiLCJrIiwidiIsImoiLCJoZWFwX2xlbiIsImNvbXByZXNzX2Jsb2NrIiwibHRyZWUiLCJkdHJlZSIsImxjIiwibHgiLCJkX2J1ZiIsImxfYnVmIiwiYnVpbGRfdHJlZSIsIm5vZGUiLCJzY2FuX3RyZWUiLCJwcmV2bGVuIiwiY3VybGVuIiwibmV4dGxlbiIsImNvdW50IiwibWF4X2NvdW50IiwibWluX2NvdW50Iiwic2VuZF90cmVlIiwiYnVpbGRfYmxfdHJlZSIsIm1heF9ibGluZGV4IiwibF9kZXNjIiwiZF9kZXNjIiwiYmxfZGVzYyIsInNlbmRfYWxsX3RyZWVzIiwibGNvZGVzIiwiZGNvZGVzIiwiYmxjb2RlcyIsInJhbmsiLCJkZXRlY3RfZGF0YV90eXBlIiwiYmxhY2tfbWFzayIsInN0YXRpY19pbml0X2RvbmUiLCJfdHJfaW5pdCIsIl90cl9zdG9yZWRfYmxvY2siLCJzdG9yZWRfbGVuIiwibGFzdCIsIl90cl9hbGlnbiIsIl90cl9mbHVzaF9ibG9jayIsIm9wdF9sZW5iIiwic3RhdGljX2xlbmIiLCJsZXZlbCIsInN0cm0iLCJkYXRhX3R5cGUiLCJzdHJhdGVneSIsIl90cl90YWxseSIsImxpdF9idWZzaXplIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/trees.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction ZStream() {\n    /* next input byte */ this.input = null; // JS specific, because we have no pointers\n    this.next_in = 0;\n    /* number of bytes available at input */ this.avail_in = 0;\n    /* total number of input bytes read so far */ this.total_in = 0;\n    /* next output byte should be put there */ this.output = null; // JS specific, because we have no pointers\n    this.next_out = 0;\n    /* remaining free space at output */ this.avail_out = 0;\n    /* total number of bytes output so far */ this.total_out = 0;\n    /* last error message, NULL if no error */ this.msg = \"\" /*Z_NULL*/ ;\n    /* not visible by applications */ this.state = null;\n    /* best guess about the data type: binary or text */ this.data_type = 2 /*Z_UNKNOWN*/ ;\n    /* adler32 value of the uncompressed data */ this.adler = 0;\n}\nmodule.exports = ZStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsU0FBU0E7SUFDUCxtQkFBbUIsR0FDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsTUFBTSwyQ0FBMkM7SUFDOUQsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDZixzQ0FBc0MsR0FDdEMsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsMkNBQTJDLEdBQzNDLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLHdDQUF3QyxHQUN4QyxJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFNLDJDQUEyQztJQUMvRCxJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixrQ0FBa0MsR0FDbEMsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsdUNBQXVDLEdBQ3ZDLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLHdDQUF3QyxHQUN4QyxJQUFJLENBQUNDLEdBQUcsR0FBRyxHQUFFLFFBQVE7SUFDckIsK0JBQStCLEdBQy9CLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2Isa0RBQWtELEdBQ2xELElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUMsV0FBVztJQUM3QiwwQ0FBMEMsR0FDMUMsSUFBSSxDQUFDQyxLQUFLLEdBQUc7QUFDZjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcz84YjMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iXSwibmFtZXMiOlsiWlN0cmVhbSIsImlucHV0IiwibmV4dF9pbiIsImF2YWlsX2luIiwidG90YWxfaW4iLCJvdXRwdXQiLCJuZXh0X291dCIsImF2YWlsX291dCIsInRvdGFsX291dCIsIm1zZyIsInN0YXRlIiwiZGF0YV90eXBlIiwiYWRsZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Courier-Bold.compressed.json":
/*!******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Courier-Bold.compressed.json ***!
  \******************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Courier-BoldOblique.compressed.json":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Courier-BoldOblique.compressed.json ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Courier-Oblique.compressed.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Courier-Oblique.compressed.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Courier.compressed.json":
/*!*************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Courier.compressed.json ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Bold.compressed.json":
/*!********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Bold.compressed.json ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-BoldOblique.compressed.json":
/*!***************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Helvetica-BoldOblique.compressed.json ***!
  \***************************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Oblique.compressed.json":
/*!***********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Oblique.compressed.json ***!
  \***********************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica.compressed.json":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Helvetica.compressed.json ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Symbol.compressed.json":
/*!************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Symbol.compressed.json ***!
  \************************************************************************/
/***/ ((module) => {

module.exports = "eJx9WFlv2zgQ/iuGnnYBt5DkS85bmk13g27SoEkPbNEHWqIlIhSpklSuov99R7JIkSLtFyGZjxzN8c0h/4oueF1jpqKz6Mt1K1GJZ4s4S+PZYrvdbqJ59J4zdYNqDAfuXuodp52spdSToZrQl6n0KyZl1Sm/xgVpa5BcKURJfs5KCgdj+F++J8+4uCUqr6IzJVo8jy4qJFCusLjD3d27BucE0cGYd+/4c3T2/U2SxfM36XYxT+JtDI8k/jGPPrMCC0oYvuWSKMJZdPYmiWMLuK9I/sCwlNHZCuRfsJD9sSiOk7dxnMFbbrgieefGBW9eROfA7I/8z1myzVbz7rnpn9vuCW/unpvZecF3eHb3IhWu5eyK5Vw0XCCFi7ezc0pnvRo5E1hi8QhCeM0lHCoIK+/yCvdR67zrfd2THPA7VfzzNTrbpv2fX+BPeH8fm2usBMnBg++/oq/forO08+QGNMgGgeG/5wfxYrE4iPFzTlFt5JtkkLeMPIL/EFoNreJBE2vrXReako3YcqvVEXCTKWJdzPS7Gizyjk/mZZvsAKC66d7FCgMtF4NC2eaVqpDyLW+QwIzi/TGoD6tvPQL7BJEPNVKVb39DW2mkJnY5FALyD9eEhU6DL4SPrqTaS0mRrHyDXrHgvpQz7AvVU+CkqgQOnN3zVgSkkFVfKslzQIgfMfPFOBxWRiyDjcs5p5wFIoFr4kImprQrP59WP1ubiVpcCgxlNLq5XC4PwM8Wy77EvSs5ZyU0EpuFaXqAzmlTjVlerzcH8TuskH/4oiLj0WQQ/oWpdXadJAfxZSOJ7exmPfD01lYSD8K/kU0288JLS7Mh+hW337dINCPA5MRX8QE1jXU8Wx/E/6J6V4zyLBtCdd36Km4Cso+QTOG4N6T5dvRusxxsu6/scK5Wgw2fKovZ20HxHSnrQDjv0WjEejvw7/MkxmMD6ZQkvnEfa1xayperg/ibZfN2kN1K4lvxHw4lZAfD6QErpy1lOt2QF4H3XATa8HDP7VnrVWY6SoNZQfKWokBRt90Ak7mt2GACwTVE8bNPE+Tw3VTIzkmQqRuLqsvtUGaFw3cTcjzJxSod3tjYSnQgS4fvpgyc8KaDZuLwXR8FtYlv8YPD9rHBuGxfbQYG1q1vL2v9+3zC9nF0EF+BqoLBFBbbjRfSYbsJprLYboxtpx1Fj23esXoMhqlx7rB9uR2OPxP/aCMDmX61/Vhm8cha7HA91bzbWUR1z0/m8tLUKSyJ1qWNHqeXrTUf16lb76Or6XIzTmWFA4mHyeLOkUS3+H23UpJQPAnbE0bUS2CSUi6IdWM13Mhpu/OlBUE1t/YbA1QYCeWLYVsrRh+SeDm0RCQEf9pxa3Xpds4RcpJhqNVDbXPkzqTpOJcK/mT1VO17gUtn57C3J3cpMlUucW77Px3hRwZ83VJFGvriJ6YRHJboLmnWPUNXWAC7FbQg+/0IrjUL4RMFBxhYkEdSBLxiXB0xD8TkEZorywPXoP0I/jxhXGzWKEoJUFgeiTvs3srq2eO9Hq2Aeq92S9eDIgeYwIeawKoVY+KyVOumuBmpY0r+CgrgQVn7ohl9n6aIoc4TJjB0lEDWvmaGa05ETrGfPRd3lm1jI64b9SKtBJlbhAFTgEhuqWoUvlhCFdwRBW613cNWqnGYyDAdj+OQfdnugpBWHUa14jAKbbN2tlDrfR6mXUT9p7F3peyGvHNBb0UCl933GHgmyN6Hc/0R6+KZxiG7Ba6ReJjg6RiAos0DpTRsHWNz1s284Mr58DI+UF52N8B7vyIGzP4+nGJcWLXiNMtiR0/0S0BPtExAj3ZNwE42zh11e6duTZS/YlZaK6DebfrkOsb4aURMnsqiA+viHpPowDrwsoX1y6moRTZ20cMXtmpOgFYf8sGd8kFrRw4ptuCQagu2lJvwmpXEUu2DNSlOoEf12vY4aXOZkG6WY8OC4hzrwHRcjVhWepjd4KdYKK7jrx5H89WjRxPWoycydlS3jZ/I2VS/G9yp9gB6PG1T1aY4YAp3LfPHPPqABbtFRHS/jf34/T82FAfb";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Times-Bold.compressed.json":
/*!****************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Times-Bold.compressed.json ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Times-BoldItalic.compressed.json":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Times-BoldItalic.compressed.json ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Times-Italic.compressed.json":
/*!******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Times-Italic.compressed.json ***!
  \******************************************************************************/
/***/ ((module) => {

module.exports = "eJyNnV1320aWtf+KF6/mXcvpsWTJsnPnTtLdsdNx7ESGMb36gpZgmSNKcEhRCjNr/vsLgqhz9tlnFz03XsaziwDqVNWuDxSg/5l919/cdLd3s29n7/+5Wc+vukcnZ2fHZ49On5+dHs8ez/7W3979PL/phgS/LW669Tc/3s2Xi4udslkuUXnkyvxmsdyiNsCmW1x93l3nn93lYnMzkH36l7dXyyHdN0enfzkd2Ppviz+6y18WdxefZ9/erTbd49l3n+er+cVdt/q12/3+hz/uutvL7vJdfzO/ne7wr3/t/5h9+69vjp69ePzN8dHZ46MnR08eP3/+9N+PZ+dD4tVycdv90q8Xd4v+dnexJ09A+O3z4uL6tluvZ9+eDvx9t1qPyWZPnhz/5cmTJ8NFfu7vFhe77HzXf9mudjl59B8X/+/R0Yvnp493/56N/77Y/fviyfjv0/Hfs0cvL/uP3aNft+u77maI0e1Fv/rSr+Z33eVfHj16uVw+erc72/rRu27dre4Hug/mYv1o/uhuNb/sbuar60f9p0c/LW77u+2X7pt/dMOvXv790fz28j/71aPF8OP15uN6cbmYrxbd+i/D7f4wXOZycXv168XnbiyF8S5+vRt+Ml9dFnVI+N38yz+mgnl2+vTx7EM5Ojk5ejx7ub7YhXo1iM8H8fvOjscgz369u/xHM/v26fH43/fDf8+e7cvrn93danExBPRf/zNrPsy+Pd4F9ufhRtZf5kMc//fxHj99+nSPuz8ulvMb4yfHU/LfN/0QqY9LU06fTMrt5ubjrqCubrN22S+X85Xx5+UqX7rVxa6yF+Hs7PlemN8M0nqITr6z8Q7GEs/al/mqu112n2pS/Jnd3ny9O+P62pRnZ6fTr5abtVGL2cXQRuf5Ep+3Xz53tzn5kJVF7zk5LplcL+frz/lu/uxWfab9bZfh3YNIefd51Ym0n/rNStDFvUi7XvwhYHffibLtdExvF7eiWl30y/4243V3s4iSlcByZwOJdr9v5suMr1bd0JBFNn/fdOvRaoryolToud/7s6OjPXuZ0V8dPTvbo++82h4f79H3+Yc/ZPS3/MO/Z/SPHKYfvT2enOzRq3xfrz37p8/26Kfc9P6Zf/hzvok3+e5/yane5lTvchn8mu/rt3yu83yu9/num5zqQz59m9F/eVSH3mFEH4fO7Lq7C7ZhbfTjoMV2yr+LnnJS8jFfXywWF4vVxeYmh2KzM+310POIJjL6W7gZ96mMPuYqcSH8N6fqcl4/5R9eZfQ5/3CR0X/nK17nVMtc/iJawnSE7X0RrT4X2iqjdb4vEftNztB9bkIPOdUfGW3zTfzpqaxoh/rVUa08LbVyVUlPPdzJEdTGu8XyssuX3nf1l/2DiHPonb0nuBvHaV45jkr+P+0Ghuiz9put6js+LfvVQvB1VznLxWY1dOMXHsDjoxNoNuvFOHhNrb6MWnSzutosBuWmv9Mjh508nvgrcmVw8Wmh8i360WEoqIYDl/OrK9Wl7TkOxWjAsSu7btV52z899rHQ/Go1/wKmVn76cZhEdCKXHt6P8/WBCB9WKyGyAoj6c6uhy+Xiy3rhDXWYLnhW7z73mzBUTL1+qNtecKv5vfDf+cXmTo1cRiv/tOz+yBo1rIJv5hcrNdr5uOrUhS/7u/lFaHAuLYaCxACYssJm6Dc7TOmGEbcYom5ur+arzc1yvhGX6a+GUea1ON0c8+HFchNqrPGXPuY5PptqQL+6/DQM8sKo0IcnsYf10UfkL4p/vvELPD16Yhe4GVxus8QrmC/PRXd3uWvw67XovJaVkXkfuZ29F0PooW0O0+GhzotC+zGVp3fLsfp51x8rjXdLskT9dLHofGSU7sDG0JeL+8WlKKQ23pkPlkXL8NuOP/JRnviRd4/UBK2jHudd1EYgq/mUfr3QThynMPidU2Pw31RKaEM/8BlAuojPFwaDgAlInGBSRs+emTiteIhLkeX4mJDqgeUyxMVnAuoGvHnU6mh0VB/lq7P5NKp2tuiqEM7sk15DQjaBkyH60DVe/eRsusqy/7O7vRKXfxcv4TM4lUmvHAcbiRC9eXEvYiPZeCNQ1JRXn/vkyNllfvvcr0Su3tDVPQyVUvuVeLmry0rYzukCHrHYs4XFjfVmHOGsxP3GKuhRrPFoq2aCN5vl3eLLcivuizLolTwWR+n4hrHW3WK+vFx8+pTLaptt2JpgvI5X2EOV5YeD1exAr1OXLioFfVuzQa4x7ilzORr6kfoVXHobBgy4/mbTn1V/3d3iJMjMcdVdLdZx2OtNtDLw+lG0C5uJbIZWHeYiHmwaQFrDrESm56pu7bJSpf6LTPvkRRm4jqtccQ3McvnDnRihfFc1wKXyLW9uFZPpqr1jrRd8WRs+HKiVlQD/WWsatZt6UyuRWtdT89x17cr1Lv7NwWEJ21IZF3TLO7HYcxdM2gvpoT/giPUhzs1G5IT6cAuVHGd6W6DQ+yw1jnDOTtHHhwq8GiqyuLVf0wymKMtYI33VU/a/NsOIBffiebmN8kBHeWJ9PvZjZe74Y627/Im6vxKGIWif50tYeCttfDcziQ3ci+KQyd/GUZPXtK+UHw2DLAi17vkqeilmaCpVVah6EPqrHO5aBdYzHKtgg0uoxx09NS13Qn0Tm5j+5LRMsIdu80L57PeVsebq4Gj351g+fruV0e67w9VaXsustXLOl1WP1rOkN5WFwz8PjCd/qPX2dG1fHZZZsfFYGAj42Q42hXgLvrh78ErL/mpX3re9GMX3dS/dZKk05eFUlZZ8dXDO0N2Jhw5/Vqrv7cFufAh56iHc8mtt/IfN7kHkvx/PXner21/mi9Xu8fG/Zi93j6lnj795+uTfj6ejvXsEtL/PiCZPR/j33dGpHe1dJSDMGApvhqMTO8+bcguAoHIEbkUV6L79BxScJyhTyALbLw4FtG84iN6Go992OTqzI4sZoJh7E86Ho1M7z3nJPaCQe+CQe6Al94Ao96BY7oFN7Tqw0U6QvB+Ojp5YETbD4Qs7andJ/ciy5Ahv3SjsB8AAbYajY7vwppwNUAgQcLgK0BIgQBQgUCxAwCxAwKYAObkPWXsIR9t4lOOzzfGZEmF7NUSN1ji1XOfcfIsCbdgQNWTjsjUXFZq0IWrXxlXjNjG3cJOomRvXbd1kbvAmUKs3Tk2/8LcZgQkYIidwruygqOAJhsgYjCt3MDFbhEnkE8a1WZjMjmEC24YJ0TsKRgMpDFykoDa3APYT4/VGo5ylaGAvhshjjCujMTG7jUlkOca175jM5mMCO5AJ0YYKvs8RechoK1Al1MKfJptAfzJE/mSc/Mk5+1NRwJ8MkT8Zl/5UVPAnQ+RPxpU/mZj9ySTyJ+Pan0xmfzKB/Mk4+VPhbzMCfzJE/uRc+VNRwZ8MkT8ZV/5kYvYnk8ifjGt/Mpn9yQT2JxOiPxWM/lQY+FNBbW4B7E/G641G+VPRwJ8MkT8ZV/5kYvYnk8ifjGt/Mpn9yQT2JxOiPxV8nyPykNFWoEqohT9haNCkIieniiLZFYnsWUEG44qc3CuK0sJCEvCxyMnMoqgcLabIthZ18rYoaoOLadjlokpWF0XyuyC+rXBwvsjJ/khUHhiSgBFGTm4YRWWJMUX2xaiTOUZRO2RMwzYZVfbKqEbDDBq6ZhDAOgNvKy2UTTSKX2neyk5DAvDUyMlYo6jcNabIFht18tkoarONadhxo8q2G9XovUG7rwTyocK3NX6o1IQpO0FLRkqGjBLZcZDYjEEEK0ZKRoyStGFIACaMlCwYJWXAqGf7RZXMFyVtvZiCjRc1sl2UyHRBeispGC5SstsgKbOFBGC1SMloUVI2i3o2WVTJYlHSBosp2F5RY3NFLVorKGisgMFWgbayhbGlonSwaSo7BRnMFClZKUrKSFHPNooqmShK2kIxBRsoamyfqEXzBOVehuxB0q2m9XIRljnlHv3SEJmlcXJK52yTRQGPNEQGaVy6Y1HBGg2RLxpXpmhidkSTyA6Nay80mY3QBHJB42SBhb/NCMzPEDmfc2V7RQXPM0SGZ1y5nYnZ6kwinzOuTc5kdjgT2N5MiN5WMBpbYeBqBbW5BbCfGa83GuVkRQMbM0QeZlwZmInZvUwi6zKufctkNi0T2LFMiHZV8H2OyENGW4EqoRb+VO4VDcoZOZQLZFEgsEeZBCbljFzKBWlTJoNPOSOjckE5lavZqlwjr3JBm5Xr7FaukF25QH5lwlvBwLGckWWBoDzLZDAtZ+RaLijbcjX7lmtkXC5o53KdrcsV9i5XonkZR/cyCPZlrBUthA3MhQPNSlmYieBhzsjEXFAu5mq2MdfIx1zQRuY6O5krbGWuRC8zfi+C8yDYVrFa5IWhlRtDQ3NGhuYCGRoIbGgmgaE5I0NzQRqayWBozsjQXFCG5mo2NNfI0FzQhuY6G5orZGgukKGZ8FYwMDRnZGggKEMzGQzNGRmaC8rQXM2G5hoZmgva0FxnQ3OFDc2VaGjG0dAMgqEZa0ULYUNz4UCzUoZmIhiaMzI0F5ShuZoNzTUyNBe0obnOhuYKG5or0dCM34vgPAi2VawWeWFoq+n7JO5AhZCZFUxWZpiNbBLAxgohEytYWtgkgoEVQvZVsDKvomXrKgoZV8HatorKplU4WVbBZFgTfpsImFUhZFWGlVFNIthUIWRSBSuLKlo2qKKQPRWszamobE2FszEVHm1pomhKEwJLmkibajjbUcHVJqGsaJLAiAohGypYmVDRsgUVhQyoYG0/RWXzKZytp/BoPBO9T2F4SGSbiY6tsJupEaDfGCLDMU6O45wtpyjgOYbIdIxL1ykq2I4h8h3jynhMzM5jElmPce09JrP5mEDuY5zsp/C3GYEBGSIHcq4sqKjgQYbIhIwrFzIx25BJ5EPGtRGZzE5kAluRCdGLCkYzKgzcqKA2twD2I+P1RqMcqWhgSYbIk4wrUzIxu5JJZEvGtS+ZzMZkAjuTCdGaCr7PEXnIaCtQJdTZn/460Je7K/uRBdFR8RJAMaTOMZpOLZCOPEjOPD7OSmiclIbt6HyslHZUcgAo3C5wuF2g5XYBUZGDYhkBZhkBNmVkT76f4r733+8x7oCih3+f4g4cMgK0ZASQ3S4wu11g0+0CKXF39N689PvJBvyojUexF/me2v1EJ9PFyBii8BinGBlXgTIxR8skCplxjpsJHDwTYgQNUxgLf5/D0GTUCkShNS7iO77DGONbEMe3cI5v4TK+RRTxLRLHt/AU3yKk+BaB4lswx3fi73MYmoxagTi+haf4/m0K7dHRqR2aFwErIUUWDQoEdCjAZlHA3IkAuhUBLF4EqIQN2G6keeZHJSuASk4AhYwAh3wALdkAZLkAZpkANuUBSMmCo/0HLodMPTUUE3Q5U10Z+iHSmepkpuCF24BzXjuR107kdbGrYn5kFdJRHIw7xzrq1Ibgjnx47czuxFnvw7/x0LtaZ9TXuhA6W8fe2zpL3a1L0N86LJMAZFajnU1fMA0VYmWDofEoDp1GVCoEojAN2Auvpua/N4NX2PoBlSYDSMykXlHTBxrnT69CwwfmhedsajJA4iTp1dTon1p+5rFbeIWNHpDoDF5Rowcau4BXodEDI+N/BY0eSLT7V9Doj4108SiOcF9hm0eUR7ivqM0jhTYPOA58X4U2D4wGvq+mlgZH+Z77yg328gb7fCfcyEAR92hNDFAcib/CBuZoEwpnkyvUplJ7NrL2bHLt4fkYKKJebUS92oR69Xq2XwnZT33HoziLH5GYwI88zd1HGqftI5Iz9lGhyfrISvgBlfA76kIeuhjr11jREeXwv6aKjhQqOuBYKq9DRQdGsX89VfQTy0EfLfN1qujAkz++xooOSC4tvQ4VHVhcUHqNFd3RJh7lu95U7noj73qT75prNSjirjfk96+hVjvZxqN819t8d6Grw3ZBAjURUlVroSS54VACakOk6uZEibhlkUyNjFRqb1GFyk8CtUJSqUGyKtomJcnNlBPkFkspqPGSyu2YZG7SUe5rFYkbOqmq9VCSr1VVdgJSdfOiRNzSSCarIJVcI6qbqnAwMNJWKMnXAsNmQ+r/JTDJgkhmNyI5GlMUt1XhYGCyc/002y/tH/uRDfMAhZG8C7v1gv24fnfUhKM2pGzjsvOI0qLyjorl7J+mDD+1RJZLQNjE9xTfuT8mRJmsvHNPKmQX30cn1OYfcu7V++gkqTjga9iUR46Ieg17kmKVgOCQQCFiVQUqpoFwRaGpCW3tVBxAUnMYYwIVzNygZHw4sPUGNSWY7A4Da4hC6lwFs6gQxoKajNr8Qw6a8RyuIqlAFW2b88jBMZ7C8vNseoZyZkd2d47sGYqjOIFzjnlwahM4Rz5Nc+ZTSWflGYoTm7ntUWlSLwWivBinDBlXuTIxZ80kyp9xzqQJnFMTYnYNU57xYQMjynN62MBc5Vk9bGCJ8pwfNrDAeeaHDYw5z6GFv6wKnP+ochSiKmMRk4iIxAQcl6im6EQ5xSjKFKkoUrzKg9OXAlGMjFN0jKu4mJgjYhLFwjhHwQTOvwkx54Zjnt9M2d178BvMKaCSSUBxhuc8PXN+g7kC5HMzZ747wVnZmODEJmaGfrNR4BvsnBCFfsmFsUuyoyYcfQgp26D59gZHaUb7Bo12uttktMwp1tpoWcxRT0bLnOOfjZaFWBLJaIlDmaSxauKqdMJYNaImow/5h21OxcWmhq+TFF7nhgKMnEoxilSUUVTlGVPkQo06lWwUuXijymUc1VjQUaPSTh+eOBHR43I/9OEJleR9pVSaCv9QOU9bSc+1ov79hb0OL61CxUBK1QIlqhQoqSqBeq4QqFJ1QIkrA2pcFVCLFQEVqgb0MvxJihNXgfrL8DnBexn5RtIP8gytTMvFXntHfK+W1wChxA1RcRunsjauCtrEXMomUREb5/I1gQvXhFiyhqlY8R3fkxgGLtDKO76kvs/xbDL6kH/Y5lRcfPKV2L0U17iwCFmhkmSZCpRlVa6cJhcvp6BSZpkLm3Uuc9Zj0bNKNYBkqAisUH1IsqoWlOh9tcSaqvKhera2+huuOSznCmTvzEHVcUaVxgWqLi6oiuJqriKuUeVwgauFK1whXIlVwTlVgvDm7AlFhAu+9uYsy+9FdBvBPojftiIdF6p+wXSvldUdKE1DVJjGqSyNq6I0MZekSVSQxrkcTeBiNCGWomEqRFzNO4lh4CKsrOaR+j7Hs8noQ/5hm1Nx4akFvknCSfqUtTRJZ05lpyfpLOayS5N05lx2eZLOQiy7NEknDmWXXl1IXJUd7uuneDYZfcg/bHMqLju503+UfpmK7YUfld8CKoUFKJQTcLgC0FI6gKxggFmZAJuKA0gpCUe7zUbP/ajkAFDJAaCQA+CQA6AlB4AsB8AsB8CmHAApOXBE+yR3KCbocqbsyTUinalOZio8mAac89qJvHYir308yvfcV26wlzfY5zvhp8agiHu058OAcvB5U+LbGb7RMB7FNxpGJN5oGHl6o2Gk8Y2GEck3GkaF3mgYGb3RMLLwRsO7Gb4+Nh7F57UjEk+vR54e3o40PqcekXw4PSr0RHpk8fn8iOJD+XdTrOEo3/V55a7P5V2f57vmWIMi7vqcHp6/g1g7GV/Eel6OmnDUxiOrPY6wluxpWfiCMjREITGu4mJiDo5JFCHjOkwmc6xMoGI2TmVd+LlAlSzKojexnkWuBMYPZzFVBxO4TpgQKwYukVLBNhm1AlFlUeuhk1QeMkGNMUThNK7CaWIOp0kUTuM6nCZzOE2gGmOcakzh5wJVsihrjIn1LHKNMX44i6nGmMA1xoRYY/D9IyrYJqNWIKox6v2jIqWthOUm9FZCrcoAV7cS6gQc7INbCXWiFHi9lVCrXM+Cel4VDgZG17yY5GuBSbUwqv+XwOQaGeVUL6NMtTPtupFVqakJbVXgWlvddbNPMEy09hPMJ3YUZzkjsmmlI7HxdeRpLjTSuMV1RLRldWT00vbIwvvaI4n7VX+bmpzn502MwW+pcQGXAbFmBIiHla74sNKZvbfjyF7bMbSbmbw4tiObITqyGaKjOEN0jjNEpzZDdOQzRGc+Q3RWZohObIZo6KJfwirAnuxnXGcnhcRfdDmXNuFCFGqXc6xdQGHCBSexSufIK50zkfnP2y+fu9uQjUXIpr2rBoiWPnasD2ftc977SnH2sjj7XJw8cQNFFLRN3ADlUrWJm+d+FbK1yrmnl8n2SLxMthPW3c2i1JxnRjchzSZfYiMWsUae1q9GGpeuRsRb6V2h9ayRifLchFWsHXkIYdrGo5IHQLjLbk9xv9bkaGm/FnPyY71fi8XszGm/FnP26Lxfi4Xo1mm/FnHw7TTEZq4cXA2xWSIvrw2xWWZXT0Ns5uTvhYPJGyIfME52b1yZhInZKUwiuzDOzmACW6EJsTMwTN5ROHULjkPfULA4AfcSxqmrcC76CxNzp+FS7jlMo+7DOPchJtSix71J4YscIu5XjLMZFaHPl+NuxvihaiQ6HJMq1ajS9Zhcq2XcCRmv1Cbujgpf5Whwx2SceifnqosqquinirTJqbnHMq66LRNz32USdWDGdS9mMndlJtSqEHVqBT/kiG8Foj7OuOjo0ibd0hvoTbpa5a7vwCZdnUR0g3qTrlZTl1jZpKtl6h71Jl2pYlepVxW0KrvN6qqCTsBd6MFVBZ0odad6VUGr3LUGFTvYKLAPRpU726hKr4xJhGPGBOybUU32GOXUmUSZOuQospEGlTtnEmMXnV4FladM3bV+FbSiqq67+ipoJYHoxvWroPr3qUuvvAoqz52696AuaqFOXX1Uk1vHdzBrN5M6/6h+vVqrgUBMcLBa1wYFMdHhup8GCFE9WLvTYCGoq1o808Ahqjx8IFUOIkIaNZSIr47WfpmGFVGVg4uYRAwxYgIeaES1MtyIidKgI8qHKzMPQIL4UCvLbVXgIUn99b8xwfk0GtkvzZ7jEARQ/L7NeRpsAE+L0ec4rABEK8rnYQABLKwdn+NQwVFx7v0HSs5n6ZslZZEd85re0WBOudbvaLCY85/e0WDOkcjvaLAQY5Le0SBO0SmYQ5RehZhOo1+FkCJF7MCrEDJFjp1+FUKKHMXKqxBSjfHUr0IokSIbNA4vvU4wnU69TiAkCmz1dQKh56Cq1wmExAGVrxMILQZTvU6QJQokKBxG3KA/nSdt0GdO0dMb9FnMcUsb9JlzxPIGfRZirNIGfeIUpYI5RGIf/HSi2j74ikxxO7gPvpImR7G2D74ic0yr++AreoxwbR+8linepHLYw+7x6YR593gSKMiV3eNJzYHNu8eTwMEUu8eTEgOYd4+zQEEzzuGyv+cA4XJG4XKBwuWCCperOVyuUbhc4HC5wuFyJYbLOYXLBAqXcQ7X9DV6CFYhFKqCKVAFqzAVLQepKBSigjlAhXN4Co/BKZRCM2EKzEQpLO+nkDx7YkclHIBKKACFMACHEAAt2QdkWQdm2QY2ZRlIya6j3fLWUz8qOQAUPxnlPH23YqT26SdH/DU9V/xLUM7KHBSQfZLR0Li3+OjIDm0pDph/FdcZfRXXBVyKA+xfxXUGX8V1CF/FdWhfxXXkX8U1Fqen76H6HR2/KIh+04kM23JPYJUMhy/NAoX1HExtn5p15J+adaaiYKs0p5a/3dLMfo44HsVp44hinXOe5pAjtTrnyGuWM/8QrrE+3msvwtrXQtjrOtOLOpM+PwuSqk7++Vlgour4Tm+vKbji4RndxKMc8rigARwrilOrEI4oj6B4VXEmCqMsR+xJE+y1yfbaZHttKvbaSHttsr02wl4bYa9Nstcm22sz2eu+u2jQXgGJr642ZK9A41dXG2GvoNBXVxu0V0Dxq6vNDJf2m1laz29maRG/Sd4KPK1rNrO0Rt/M8sJ8M8ur8c2Ml+CbWVp3b5KpNmCqnib+osu5pAX0Jhkq8LRU3rCfQuK4KN7M8kp4M8vL3w266f6DU80MF7qbWVrdbmZ5SbuZ4Tp2M0uL102yPeCyOPtcnHpBupnlVehmlpaem1lab27Q7xzlBd5mhqu6zSwt5TbJ7oCnRdtmllZqG2F3oNCabDPLC7HNjFdfd2RcWTXr8OVUR2jGI21n+ES3RZcEFJ/dtsklgaentC26JCB6HtsGlwQWnry26JKOxmesp3ZkvbCj2Ak7xz7YqXXBjrgHdsU7YGfW/zqy7teQu0mbXbLNLtlWXLKVLtlml2yFS7bCJdvkkm12yTa5ZJtcsg0u2WaXbLNLthWXbKVLttol2+ySrXDJVrhkO0tPBtsZjjnbWRpzjkiMOUeexpwjjWPOEdGYs53lMWcbrLfN1ttWrLeV1ttm622r1tsK622z9bbZettsva203nayXk+zydnbVLK3kdnb5Oyx9YIisrcR9WMTGwc+oJlMKT2gYU6Wqh/QsJjNNT2gYc42mx/QsBANNz2gIQ7Wm17PY65MWL2exxLZce31PJbZmNPreczJoguf55JmszZOjm1c1VkTc8U1iWqvca6oJnBtNUFXWTZ1f+4W2iU/jqPU4gRs9MbJ7Z0fiJDwfZey+ZtGPYBx7gZMqEWPO4TCFwJR12Bc9Q8m5k7CJOopjHN3YQL3GUXoc7649zB+qDREP2JSpb5WehSTa9WZ+xbjlWrLvUzhoqsp0ian5k7H+KGoiO7HpEpUKh2RybWopC7JhNjI+StwTxKl3kl+BS5Lqo+qfQUuq9RT6a/AZY37K/UVuKxQrwUSdFxIqe9CSXVfqOceDFXqxFDS/Rim4K4MNerNUKIODaS5rCXcraFEPRtKqlmgnlsGqtQ4UOIGgBq3AdSqzYC7u/AYP9iDeMCff6PPxF0fStT7BelwFEUfGNTcDaJMPSFK3BmidiDI3CWCtNCUOkaUVN+Ieu4eUaUeEiXuJFHjfhK0XmaZe0uUvlJ6os9Etd4GKj0npjjQSrj/RKneFLgXBUl0pKBu5G+4O0XpK2ETnSqq9bBVulZMcSBsqYNFLZjL4Asz/+bMeGTPDR3FjaaTUDrtK4HoHMbliabEeCJDdCLj8kRhD9hVjdMpoyjPC9G70pTOiZI8Y9k+dCUQncu4PJFt8bhSjE7lgjyX7X+4UozO5YI817Rl4CoTOk/B8izlQ2dXAtF5jKsTfURTODHkf/L8IzZzQPHhlHN8OOXUHk45kn/Z/GNovsDo75l/hOa6Jxe7jssGRLuj66Bdx9xPgs0C/ZcFXedU+hz2TqGfo6DrnKpyjmEMsFzO6SwGr1VKfab9iGb/J0guPy7LXyE5OskyabgKcGTEd8aEugUo3oYL/gj6tKD7cPQQjrwe7Y78z6SMR3HzyYjSJpMyOONMoBufEKLsVNyYVM5Y4fcZPWQE+Sxom/PAOTaes83v8h5FDNk2RNk2LrOdXvqcMlT4fUYPGUG28d1FygNnW767OElqy/OR0DAAsruTog6F3EpdcorifYU/VDiGB/m2kuEUqCDmaIlJz1FSIFKqCxeSjJIab055Bule0gdJITpAtzJ7HBmURFx8cpUCAxJGBjGHBjUdG0iRggPavcYPGmN8AG91PlOEUMsh4n3eRxFDaNJAjbkMSdowPmWw8PuMHjKCEBS0zXngrBvP2U5bh4+IQ8bzuDIJMut5G/KUKxPuBXsQDLJvbCsywwFwIUcg7QY+Ig4RyKPhJMgI5J3FU85MuBfsQTCIgLGtyAxHwIUUgU8p7zsyNJdlt17vlkKeGfw0K+9C744Wdi/jEQ1eP+XsfqIx2X4KepWuvyNdPLJlTUe23RNQ/obryHFlEyhu9nQcP+06IvqA68joA65xtiNmOtVZzlUOVPkpx6XgTiCKkHEKk3MRKxNzwFzKUTONQmec42cCBzEvBVxVlgKuDi4FmMqB1W+dTz/Kb51rgUJdeeu8ooqw1986ryTIRVB561yrXBy1t86lfFUVqIBIlcVUeYd6X1jXoRCuc+Svc7ivKzG+loG91tG8ziG8FnG7FsHasT4e5XvuKzfYyxvs852k/dSuiHv03dSO7MmKoW08yne9zXdXazAs0MkONpikilh9rcGkBLmIDzYYVjmohxsMyX1VOBgWWUnqn0zQCQ5mq1KLap9M0DLVrconE6S6rQoHA5PrYRlC7kdbt7hSMSGcxRcUTgpCWUl01Afb67PX9TWD68vQbn+Ul8z7tEjDXJ42LMbsUWXxuz+0+N1/ffG7zxP+PZeL4r2aUQtJXomnzXual8r7ylJ5f3CpvA8zrT2it0qv6gpdiWV5QUoE1xWr9n1t1b4/vGrfx0nUnpU/7nIlEJ3duDx5UeHceU2+r6zJ9wfX5HtsZ3tU+v/aum7USRzZsvt0V/T9/8vrQviTmb/EGPEQyfmd1uIlxTlX+nf2gRellZ5PanHdO6dYmz9FXC6otHJBqZU1d62KeW1M8WV+0VVis/vJ0/yTu3hSkcLrxhDe/VuPp3YUt7qMyCqgI7HrZeRpt8tI4y6XEdHelZF5j++svO3oJG5f2aGLWXlzZTyySbqjUkKIrGAAlpnLPtqrqVJ7AqvLjuKVunzxLl88Dr+A4zICUBhoAbYNDo58Y4Mzi6qzq3hUyhcQ1SETbH/HsdWf3UjsxMrChl+A4hvaziG3QO3NbEf8QXdX/H1tZ/ZNe0f2QrYhnxV5Wf8esuojoRUaAKA4xF7F5o5QGHVxMGx+aR8xc2qIeh8xi7lJpn3EzLlx5n3ELMRmmvYRE4cGa4gajnFqPc65/aZHeFPBFn6Zk3Jzxp3LjCr3x61b71xmMbdzuXOZNWrxeecyC9z2cajMiFygMlQmlf0AdxWfxEJnZ9C7ilnMHpF2FTPXbpF3FbNAvpF2FRNPDlKE33OYwEsMkaEYJ1dxztbiivIX/GL11PzSF6uZk7/oL1azmP0lfbGaOftL/mI1C9Ff0heriYO/GKL2a5zar3P2l/SsfCr2wi9zUvYX/EY2o8r9sb/ob2SzmP1FfiObNfKX/I1sFthfcOMAI/KXysYBUtlf8EPZJ7HQ2V/0h7JZzP6SPpTNXPtL/lA2C+Qv6UPZxJO/FOH3HCbwF0PkL8bJX5yzv7gi/SWs9KDLRIG9JqrsOFGVvhOTCPeJCdiDopqcKMrJj6JMrhRF9qb4jATKMArsA1FlNyA1eZZ+MFMqVFAvaz9LLpbWp7VwMCfJ1w6sT+skwuPq69M6BftdZX1ay8n70gMdLbAPHnqgI9MkT0wL4yeqyiV/PLAwrpMIr9QL41qt+GZlYVzL7KF6YVyq2U+D/Hst3OitUWCHjSr7LKnJbUkXnjstBo2vbe03DBixW4nY7DVi8RV509BQoxK/G2+YvgVv3L0z8mKakcaPwhf8WyYWVsIxXkHc/UG2/R+tLWT3l9hOQkx3f4LtLKSxv71GGAK0V+7BWvcvjdxjddujh5ToISfaQqL9Bzy2mGhCPNElzMnF9r2s4I/+/b//H63X5Vs=";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/Times-Roman.compressed.json":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Times-Roman.compressed.json ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/ZapfDingbats.compressed.json":
/*!******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/ZapfDingbats.compressed.json ***!
  \******************************************************************************/
/***/ ((module) => {

module.exports = "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w==";

/***/ }),

/***/ "(ssr)/./node_modules/@pdf-lib/standard-fonts/es/all-encodings.compressed.json":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/all-encodings.compressed.json ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ })

};
;